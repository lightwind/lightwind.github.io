{"meta":{"title":"Tyler的博客","subtitle":null,"description":"人生是一场难得的修行，不要轻易交白卷","author":"Tyler Liu","url":"https://tylerLiu.top","root":"/"},"pages":[{"title":"分类","date":"2019-07-31T03:21:47.000Z","updated":"2019-07-31T05:39:03.830Z","comments":false,"path":"categories/index.html","permalink":"https://tylerLiu.top/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-07-31T03:22:41.000Z","updated":"2019-07-31T05:38:27.183Z","comments":false,"path":"tags/index.html","permalink":"https://tylerLiu.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"（拉钩）Android工程师进阶34讲-14：Android Touch事件分发时序","slug":"（拉钩）Android工程师进阶34讲-14：Android-Touch事件分发时序","date":"2020-08-01T07:22:04.000Z","updated":"2020-08-02T08:41:04.813Z","comments":true,"path":"2020/08/01/（拉钩）Android工程师进阶34讲-14：Android-Touch事件分发时序/","link":"","permalink":"https://tylerLiu.top/2020/08/01/（拉钩）Android工程师进阶34讲-14：Android-Touch事件分发时序/","excerpt":"","text":"0. 前言Android Touch事件的分发是Android工程师必备的技能之一。关于事件分发主要有几个方向可以展开分析： 1、touch 事件是如何从驱动层传递给Framework层的InputManagerService。 2、WMS 是如何通过ViewRootImpl将事件传递到目标窗口。 3、touch 事件达到DecorView后，是如何一步步传递到内部的子View中。 本文是基于Android-28的源码分析的。 1. 思路梳理2个概念。 1.1 ViewGroupViewGroup是一组View的组合，在其内部有可能包含多个子View，当手指触摸屏幕时，手指所在的区域既能在ViewGroup显示范围内，也可能在其内部View控件上。 因此它内部的事件分发的重心是处理当前Group和子View之间的逻辑关系： 1、当前Group是否需要拦截touch事件。 2、是否需要将touch事件继续分发给子View。 3、如何将touch事件分发给子View。 1.2 ViewView是一个单纯的控件，不能再被细分，内部也并不会存在子View，所以它的事件分发的重点在于当前View如何处理touch事件，并根据相应的手势逻辑进行一系列的效果展示（比如滑动，放大，点击，长按等）。 1、是否存在TouchListener； 2、是否自己接收处理touch事件（主要逻辑在onTouchEvent方法中）。 2. 事件分发核心dispatchTouchEvent（ViewGroup）整个View之间的事件分发，实质上就是一个大的递归函数，而这个递归函数就是dispatchTouchEvent方法。在这个递归的过程中会适时调用onInterceptTouchEvent来拦截事件，或者调用onTouchEvent方法来处理事件。 先从宏观角度，纵览整个dispatch的源码如下： 1234567891011121314public boolean dispatchTouchEvent()&#123; /** * 步骤1：检查当前ViewGroup是否需要拦截事件 */ ... /** * 步骤2：将事件分发给子View */ ... /** * 步骤3：根据mFirstTouchTarget，再次分发事件 */ ...&#125; 如代码中的注释，dispatch主要分为三个步骤： 步骤1：判断当前ViewGroup是否需要拦截此touch事件，如果拦截则此次touch事件不再会传递给子View（或者以CENCEL的方式通知子View）。 步骤2：如果没有拦截，则将事件分发给子View继续处理，如果子View将此事件拦截，则将mFirstTouchTarget赋值给捕获touch事件的View。 步骤3：根据mFirstTouchTarget重新分发事件。 下面分析每个步骤： 2.1 步骤1具体代码如下1234567891011121314151617/** * 1、检查当前ViewGroup是否需要拦截事件 */final boolean intercepted;if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125;&#125; else &#123; // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true;&#125; actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null判断了是否需要拦截的条件： 如果事件为DOWN事件，则调用onInterceptTouchEvent()进行拦截判断。 或者mFirstTouchTarget不为null，代表已经有子View捕获了这个事件，子View的dispatchTouchEvent返回true表示捕获touch事件。 如果在步骤1中，当前ViewGroup并没有对事件进行拦截，则进行步骤2。 2.2 步骤2具体代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * 2、将事件分发给子View */if (!canceled &amp;&amp; !intercepted) &#123; View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null; if (actionMasked == MotionEvent.ACTION_DOWN // 1 || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; final int actionIndex = ev.getActionIndex(); final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; removePointersFromTouchTargets(idBitsToAssign); final int childrenCount = mChildrenCount; if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123; final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList(); final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; // 2 final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); if (childWithAccessibilityFocus != null) &#123; if (childWithAccessibilityFocus != child) &#123; continue; &#125; childWithAccessibilityFocus = null; i = childrenCount - 1; &#125; // 3 if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) &#123; ev.setTargetAccessibilityFocus(false); continue; &#125; newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) &#123; newTouchTarget.pointerIdBits |= idBitsToAssign; break; &#125; resetCancelNextUpFlag(child); // 4 if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; ... newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; &#125; ev.setTargetAccessibilityFocus(false); &#125; if (preorderedList != null) preorderedList.clear(); &#125; ... &#125;&#125; 说明： 1、表明事件主动分发的前提是事件为DOWN事件； 2、遍历所有子View； 3、判断事件坐标是否在子View坐标范围内，并且子View并没有处在动画状态； 4、调用dispatchTransformedTouchEvent方法将事件分发给子View，如果子View捕获事件成功，则将mFirstTouchTarget赋值给子View。 2.3 步骤3具体代码如下123456789101112131415161718192021222324252627282930/** * 3、根据mFirstTouchTarget，再次分发事件 */if (mFirstTouchTarget == null) &#123; // 1 // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, // 传入child为null TouchTarget.ALL_POINTER_IDS);&#125; else &#123; // Dispatch to touch targets, excluding the new touch target if we already // dispatched to it. Cancel touch targets if necessary. TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) &#123; final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123; handled = true; &#125; else &#123; final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; // 2 if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123; handled = true; &#125; ... &#125; predecessor = target; target = next; &#125;&#125; 步骤3有两个分支判断： 分支1：如果此时mFirstTouchTarget为null，说明在上述的事件分发中并没有子View对事件进行捕获操作。这种情况下，直接调用dispatchTransformedTouchEvent方法，并传入child为null，最终会调用dispatchTransformedTouchEvent方法，并传入chiild为null，最终会调用super.dispatchTouchEvent方法。实际上最终会调用自身的onTouchEvent方法，进行处理touch事件。也就是说：如果没有子View捕获处理touch事件，ViewGroup会通过自身的onTouchEvent方法进行处理。 分支2：mFirstTouchTarget不为null，说明在上面步骤2中有子View对touch事件进行了捕获，则直接将当前以及后续的事件交给mFirstTouchTarget指向的View进行处理。 3. 事件分发流程代码演示布局文件： 12345678910111213&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;com.ly.lgdemoandroid.DownInterceptedGroup xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"@color/colorPrimary\"&gt; &lt;com.ly.lgdemoandroid.CaptureTouchView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:background=\"@color/colorAccent\"/&gt;&lt;/com.ly.lgdemoandroid.DownInterceptedGroup&gt; DownInterceptedGroup和CaptureTouchView是两个自定义View，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class DownInterceptedGroup extends FrameLayout &#123; private static final String TAG = DownInterceptedGroup.class.getSimpleName(); public DownInterceptedGroup(@NonNull Context context) &#123; super(context); &#125; public DownInterceptedGroup(@NonNull Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); &#125; public DownInterceptedGroup(@NonNull Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; @Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; Log.i(TAG, \"dispatchTouchEvent: \" + ev); return super.dispatchTouchEvent(ev); &#125; @Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; Log.i(TAG, \"onInterceptTouchEvent: \" + ev); return super.onInterceptTouchEvent(ev); &#125;&#125;public class CaptureTouchView extends View &#123; private static final String TAG = CaptureTouchView.class.getSimpleName(); public CaptureTouchView(Context context) &#123; super(context); &#125; public CaptureTouchView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); &#125; public CaptureTouchView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; @Override public boolean dispatchTouchEvent(MotionEvent event) &#123; Log.i(TAG, \"dispatchTouchEvent: \" + event); boolean result = super.dispatchTouchEvent(event); Log.i(TAG, \"dispatchTouchEvent result is \" + result); return result; &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; Log.i(TAG, \"onTouchEvent: \" + event); return true; &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(500, 300); &#125;&#125; 用手触摸CaptureTouchView并滑动一段距离后抬起，打印日志如下： 12345678910111213141516com.ly.lgdemoandroid I/DownInterceptedGroup: dispatchTouchEvent: MotionEvent &#123; action=ACTION_DOWNcom.ly.lgdemoandroid I/DownInterceptedGroup: onInterceptTouchEvent: MotionEvent &#123; action=ACTION_DOWNcom.ly.lgdemoandroid I/CaptureTouchView: dispatchTouchEvent: MotionEvent &#123; action=ACTION_DOWNcom.ly.lgdemoandroid I/CaptureTouchView: onTouchEvent: MotionEvent &#123; action=ACTION_DOWNcom.ly.lgdemoandroid I/CaptureTouchView: dispatchTouchEvent result is truecom.ly.lgdemoandroid I/DownInterceptedGroup: dispatchTouchEvent: MotionEvent &#123; action=ACTION_MOVEcom.ly.lgdemoandroid I/DownInterceptedGroup: onInterceptTouchEvent: MotionEvent &#123; action=ACTION_MOVEcom.ly.lgdemoandroid I/CaptureTouchView: dispatchTouchEvent: MotionEvent &#123; action=ACTION_MOVEcom.ly.lgdemoandroid I/CaptureTouchView: onTouchEvent: MotionEvent &#123; action=ACTION_MOVEcom.ly.lgdemoandroid I/CaptureTouchView: dispatchTouchEvent result is true......com.ly.lgdemoandroid I/DownInterceptedGroup: dispatchTouchEvent: MotionEvent &#123; action=ACTION_UPcom.ly.lgdemoandroid I/DownInterceptedGroup: onInterceptTouchEvent: MotionEvent &#123; action=ACTION_UPcom.ly.lgdemoandroid I/CaptureTouchView: dispatchTouchEvent: MotionEvent &#123; action=ACTION_UPcom.ly.lgdemoandroid I/CaptureTouchView: onTouchEvent: MotionEvent &#123; action=ACTION_UPcom.ly.lgdemoandroid I/CaptureTouchView: dispatchTouchEvent result is true 上图中在DOWN事件中，DownInterceptGroup的onInterceptTouchEvent被触发一次；然后在子View CaptureTouchEvent的dispatchTouchEvent中返回true，代表它捕获消费了这个DOWN事件。这种情况下CaptureTouchEvent会被添加到父视图（DownInterceptGroup）中的mFirstTouchTarget中。因此后续的MOVE和UP事件都会经过DownInterceptGroup的onInterceptTouchEvent进行拦截判断。 3.1 为什么DOWN事件特殊所有touch事件都会从DOWN事件开始的，这是DOWN事件比较特殊的原因之一。另一个原因是DOWN事件的处理结果会直接影响后续MOVE、UP事件的逻辑。 在步骤2中，只有DOWN事件会传递给子View进行捕获判断，一旦子View捕获成功，后续的MOVE和UP事件是通过遍历mFirstTouchTarget链表，查找之前接受ACTION_DOWN的子View，并将触摸事件分配给这些子View。也就是说后续的MOVE、UP等事件的分发交给谁，取决于它们的起始事件DOWN是由谁捕获的。 3.2 mFirstTouchTarget有什么作用123456789101112131415private TouchTarget mFirstTouchTarget;private static final class TouchTarget &#123; ... public static final int ALL_POINTER_IDS = -1; // all ones // The touched child view. public View child; // The combined bit mask of pointer ids for all pointers captured by the target. public int pointerIdBits; // The next target in the target list. public TouchTarget next; private TouchTarget() &#123; &#125; ...&#125; 可以看出mFirstTouchTarget是一个TouchTarget类型的链表结构。而这个TouchTarget的作用就是用来记录捕获了DOWN事件的View，具体保存在上图中的child变量。为什么要用链表类型的结构呢？因为Android设备是支持多指操作的，每一个手指的DOWN事件都可以当做一个TouchTarget保存起来。在步骤3中判断如果mFirstTouchTarget不为null，则再次将事件分发给相应的TouchTarget。 3.3 容易被遗漏的CANCEL事件在上面的步骤3中，继续向子View分发事件的代码中，有一段逻辑： 12345678910111213141516171819202122232425while (target != null) &#123; // 1 final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123; handled = true; &#125; else &#123; final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; // 2 if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123; handled = true; &#125; if (cancelChild) &#123; if (predecessor == null) &#123; mFirstTouchTarget = next; &#125; else &#123; predecessor.next = next; &#125; target.recycle(); target = next; continue; &#125; &#125; predecessor = target; target = next;&#125; 1处的target != null表明已经有子View捕获了touch事件，但是2处的intercepted boolean变量又是true。这种情况下，事件主导权或重新回到父视图ViewGroup中，并传递给子View的分发事件中传入一个cancelChild == true。 dispatchTransformedTouchEvent方法部分源码： 12345678910111213141516171819private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) &#123; ... final int oldAction = event.getAction(); if (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123; // 1 event.setAction(MotionEvent.ACTION_CANCEL); if (child == null) &#123; handled = super.dispatchTouchEvent(event); &#125; else &#123; handled = child.dispatchTouchEvent(event); &#125; event.setAction(oldAction); return handled; &#125; ...&#125; 1处因为之前传入的cancel为true，并且child不为null，最终这个事件会被包装成一个ACTIOON_CANCEL事件传递给child。 3.3.1 什么情况下会触发这段代码？当父视图的onInterceptTouchEvent先返回false，然后在子View的dispatchTouchEvent中返回true（表示子View捕获事件），关键步骤就是接下来的MOVE的过程，父视图的onInterceptTouchEvent又返回true，intercepted被重新置为true，此时上述逻辑就会被触发，子控件就会收到ACTION_CANCEL的touch事件。 3.3.2 经典案例演示上述情况当在ScrollView中添加自定义View时，ScrollView默认在DOWN事件中并不会进行拦截，事件会被传递给ScrollView内的子控件。只有当手指进行滑动并到达一定距离之后，onInterceptTouchEvent方法返回true，并触发ScrollView的滚动效果。当ScrollView进行滚动的瞬间，内部的子View会接收到一个CANCEL事件，并丢失touch焦点。 如下代码： 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;ScrollView xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"@color/colorPrimaryDark\" tools:context=\".MainActivity\"&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\"&gt; &lt;com.ly.lgdemoandroid.CaptureTouchView android:layout_width=\"300dp\" android:layout_height=\"300dp\" android:layout_marginTop=\"10dp\" android:layout_marginBottom=\"10dp\" android:background=\"@color/colorAccent\"/&gt; &lt;!-- 重复上面的CaptureTouchView --&gt; &lt;/LinearLayout&gt;&lt;/ScrollView&gt; CaptureTouchView中onTouchEvent返回true，表示它会将接收到的touch事件进行捕获消费。 上述代码执行后，当手指点击屏幕时DOWN事件会被传递给CaptureTouchView，手指滑动屏幕将ScrollView向下滚动，刚开始MOVE事件还是由CaptureTouchView来消费处理，但是当ScrollView开始滚动时，CaptureTouchView会接收一个CANCEL事件，并不在接收后续的touch事件。日志如下： 123456789CaptureTouchView: dispatchTouchEvent: MotionEvent &#123; action=ACTION_DOWNCaptureTouchView: onTouchEvent: MotionEvent &#123; action=ACTION_DOWNCaptureTouchView: dispatchTouchEvent result is trueCaptureTouchView: dispatchTouchEvent: MotionEvent &#123; action=ACTION_MOVECaptureTouchView: onTouchEvent: MotionEvent &#123; action=ACTION_MOVECaptureTouchView: dispatchTouchEvent result is trueCaptureTouchView: dispatchTouchEvent: MotionEvent &#123; action=ACTION_CANCELCaptureTouchView: onTouchEvent: MotionEvent &#123; action=ACTION_CANCELCaptureTouchView: dispatchTouchEvent result is true 因此，平时自定义View时，尤其是有可能被ScrollView或者ViewPager嵌套使用的控件，不要遗漏对CANCEL事件的处理，否则有可能引起UI显示异常。 4. 总结dispatchTouchEvent事件的流程机制： 判断是否需要拦截 -&gt; 主要是根据onInterceptTouchEvent方法的返回值来决定是否拦截。 在DOWN事件中将touch事件分发给子View -&gt; 这一过程如果有子View捕获消费了touch事件，会对mFirstTouchTarget进行赋值。 最后一步，DOWN、MOVE、UP事件会根据mFirstTouchTarget是否为null，决定是自己处理touch事件，还是再次分发给子View。 事件分发的几个特殊点： DOWN事件的特殊之处：事件的起点；决定后续事件由谁来消费处理； mFirstTouchTarget的作用：记录捕获消费touch事件的View，是一个链表结构； CANCEL事件的触发场景：当父视图先不拦截，然后在MOVE事件中重新拦截，此时子View会接收到一个CANCEL事件。","categories":[{"name":"Android","slug":"Android","permalink":"https://tylerLiu.top/categories/Android/"},{"name":"进阶","slug":"Android/进阶","permalink":"https://tylerLiu.top/categories/Android/进阶/"}],"tags":[{"name":"Android核心技术","slug":"Android核心技术","permalink":"https://tylerLiu.top/tags/Android核心技术/"}]},{"title":"（拉钩）Android工程师进阶34讲-13：Android是如何通过Activity进行交互的？","slug":"（拉钩）Android工程师进阶34讲-13：Android是如何通过Activity进行交互的？","date":"2020-07-31T01:30:30.000Z","updated":"2020-08-01T07:19:02.950Z","comments":true,"path":"2020/07/31/（拉钩）Android工程师进阶34讲-13：Android是如何通过Activity进行交互的？/","link":"","permalink":"https://tylerLiu.top/2020/07/31/（拉钩）Android工程师进阶34讲-13：Android是如何通过Activity进行交互的？/","excerpt":"","text":"1. taskAffinityActiivty的启动模式。通过配置不同的启动模式可以实现调配不同的Task。但是taskAffinity在一定程度上也会影响任务栈的调配流程。 每一个Activity都有一个Affinity属性，如果不在清单文件中指定，默认为当前应用的包名。taskAffinity主要有以下几点需要注意： 1.1 taskAffinity会默认使Activity在新的栈中分配吗？可以通过一个例子验证一下，在一个Android项目LagouTaskAffinity中，创建两个Activity：First和Second，它们的具体配置如下： 除了Activity类名之外，其他都是默认配置。这种情况下，点击First中的Button，从First跳转到Second。 然后再执行以下命令： 1adb shell dumpsys activity activities 上述命令会将系统中所有存活中的Activity信息打印到控制台，具体结果如下： 上图中的TaskRecord代表一个任务栈，在这个栈中存在两个Activity实例：First和Second，并且Second处于栈顶。 接下来将Second的taskAffinity修改如下： 将Second的taskAffinity修改成lagou.affinity，使它和First的taskAffinity不同。重新运行代码，并再次查看任务栈中的情况，如下： 可以看到，虽然First和Second的taskAffinity不同，但是它们都被创建在一个任务栈中。 但如果再将Second的launchMode改为singleTask，再次重新运行，则会发现两个Activity会被分配到不同的任务栈中，如下图： 结论：单独使用taskAffinity不能导致Activity被创建在新的任务栈中，需要配合singleTask或者singleInstance。 1.2 taskAffinity + allowTaskReparentingallowTaskReparenting赋予Activity在各个task中间转移的特性。一个后台任务栈中的Activity A，当有其他任务进入前台，并且taskAffinity和A相同，则会自动将A添加到当前启动的任务栈中。举例： 1、在某外卖app中下好订单后，跳转到支付平台支付。当在支付平台支付成功之后，页面停留在支付平台支付成功页面。 2、按Home键，在主页面重新打开支付平台App，页面上显示的并不是支付平台主页面，而是之前支付成功页面。 3、再次进入外卖App，发现支付平台支付成功页面已经消失。 造成上述现象的原因就是allowTaskReparenting属性，代码演示。 分别创建两个Android工程：First和TaskAffinityReparent： 在First中有三个Activity：FirstA、FirstB、FirstC。打开顺序依次是FirstA -&gt; FirstB -&gt; ``FirstC。其中FirstC的taskAffinity为“lagou.affinity”，且allowTaskReparenting属性设置为true。FirstA和FirstB`为默认值； TaskAffinityReparent中只有一个Activity——ReparentActivity，并且其TaskAffinity也等于&quot;lagou.affinity&quot;。 将这个两个项目分别安装到手机上后，打开First App，并从FirstA开始跳转到FirstB，再进入FirstC页面。然后按Home键，使其进入后天任务。此时系统中的Activity信息如下： 接下来，打开TaskAffinityReparent项目，屏幕上本应显示显示ReoarentActivity的页面内容，但是实际上显示的却是FirstC中的页面内容，并且系统中Activity信息如下： 可以看出，FirstC被移动到与ReparentActivity处在一个任务栈中。此时FIrstC位于栈顶位置，再次点击返回键，才会显示ReparentActivity页面。 2. 通过Binder传递数据的限制2.1 Binder传递数据限制Activity界面跳转时，使用Intent传递数据是最常用的操作。但是Intent传值偶尔也会导致程序崩溃，如下代码： 在startFirstB()方法中，跳转FirstB页面，并通过Itent传递Bean类中的数据。但是执行上述代码会报如下错误： 上面log日志的意思是Intent传递数据过大，最终原因是Andorid系统对使用Binder传数据进行了限制。通常情况为1M，但是根据不同版本、不同厂商，这个值会有区别。 2.2 解决办法 1、减少通过Binder传递数据，将非必须字段使用transient关键字修饰。 比如上述Bean类中，假如byte[] data并非必须使用的数据，则需要避免将其序列化，如下所示： 添加transient修饰之后，再次运行代码，就不会报错。 2、将对象转化为JSON字符串，减少数据体积。 因为JVM加载类通常会伴随额外空间来保存类相关信息，将类中数据转化为JSON字符串可以减少数据大小。 有时将类转化为JSON字符串，还是会超出Binder的限制，说明实际需要传递的数据很大。这时，需要考虑使用本地持久化来实现数据共享，或者使用EventBus来实现数据传递。 关于Binder机制的原理分析。可以参考以下文章： Android系统进程间通信（IPC）机制Binder中的Server启动过程源代码分析 听说你 Binder 机制学的不错，来面试下这几个问题 2.3 process造成多个Application一直以来，都会在Application中做一些初始化操作。比如App分包、推送初始化、图片加载库的全局配置等，如下图： 但实际上，Activity可以在不同的进程中启动，而每一个不同的进程都会创建出一个Application，因此可能造成Application的onCreate方法被执行多次。比如以下代码： RemoteActivity的process为&quot;lagou.process&quot;，这将导致它会在新的进程中创建。当在MainActivity中跳转到RemoteActivity时，LagouApplication会被再次创建，代码如下： 最终打印日志如下： 可以看出LagouApplication的onCreate方法被创建了2次，因此各种初始化的操作也会被执行2遍。 针对这个问题，目前有两种比较好的处理方式： onCreate方法中判断进程名称，只有在符合要求的进程里，才执行初始化操作； 抽象出一个与Application生命周期同步的类，并根据不同的进程创建相应的Application实例。 可以参考：解决Android多进程导致Application重复创建问题 3. 后台启动Activity失效正在打开某个App，此时手机后台正在下载另一个App。当App下载完成后，突然弹出安装界面，中断了前一个App的界面交互，这种情况会影响用户体验，而最终用户会抱怨Android手机或者Android系统本身。 为了避免这种情况的发生，从Android 10（API 29）开始，Android系统对后台进程启动Activity做了一定的限制，官网介绍如下： 主要目的就是为了避免当前前台用户的交互被打断，保证当前屏幕上显示的内容不受影响。 但是这也造成了很多实际问题，在项目中有Force Update功能，当用户选择升级之后后台进行新的安装包下载任务。正常情况下，下载成功需要弹出apk安装界面，但是在某一版升级时，突然有很多用户反馈无法弹出下载界面。经过查看抓取的Log信息，最终发现有个特点就是发生在Andorid 10 版本，因此怀疑是版本兼容性问题，最终也确定是此问题。 解决办法： Android官方建议使用通知来替代直接启动Activity操作： 也就是当后台任务执行完毕之后，并不会直接调用startActivity来启动新的界面，而是通过NotificationManager来发送Notification到状态栏。这样既不会影响的当前使用的交互操作，用户也能及时获取后台任务的进展情况，后续的操作由用户自己决定。 4. 总结使用startActivity()时可能遇到的问题： taskAffinity实现任务栈的调配； 通过Binder传递数据的限制； 多进程可能造成的问题； 后台启动Activity的限制。","categories":[{"name":"Android","slug":"Android","permalink":"https://tylerLiu.top/categories/Android/"},{"name":"进阶","slug":"Android/进阶","permalink":"https://tylerLiu.top/categories/Android/进阶/"}],"tags":[{"name":"Android核心技术","slug":"Android核心技术","permalink":"https://tylerLiu.top/tags/Android核心技术/"}]},{"title":"（拉钩）Android工程师进阶34讲-12：DVM以及ART是如何对JVM进行优化的？","slug":"（拉钩）Android工程师进阶34讲-12：DVM以及ART是如何对JVM进行优化的？","date":"2020-07-30T02:39:50.000Z","updated":"2020-07-31T01:27:22.131Z","comments":true,"path":"2020/07/30/（拉钩）Android工程师进阶34讲-12：DVM以及ART是如何对JVM进行优化的？/","link":"","permalink":"https://tylerLiu.top/2020/07/30/（拉钩）Android工程师进阶34讲-12：DVM以及ART是如何对JVM进行优化的？/","excerpt":"","text":"1. 什么是DalvikDalvik是谷歌自己设计用于Android平台的Java虚拟机，Android工程师编写的Java或Kotlin代码最终都在这台虚拟机中执行。在Android 5.0之前叫DVM，5.0以后改叫ART(Android Runtime)。 在整个Android操作系统体系中，ART位于以下位置： 其实成DMV/ART为Android版的Java虚拟机是不准确的。虚拟机必须符合Java虚拟机规范，即通过JCM(Java Compliance Kit)的测试并获得授权，但是DVM/ART并没有得到授权。 DVM大多数实现与传统的JVM相同，但是因为Android最初是被设计用于手机端的，对内存空间要求比较高，并且起初Dalvik目标只是运行ARM架构的CPU上。针对这几种情况，Android DVM有了自己独有的优化措施。 2. Dex文件传统class文件是由一个Java文件编译成的.class文件，而Android是把所有class文件进行合并优化，然后生成一个最终的class.dex文件。dex文件中去除了class文件中的冗余信息（如重复字符常量），并且结构更加紧凑，因此在dex文件解析阶段，可以减少I/O操作，提高类的查找速度。 比如在course12目录下，分别创建Dex1.java和Dex2.java，如下： 12345678910111213141516public class Dex1 &#123; private int num = 1; public int add(int i, int j) &#123; return i + j; &#125;&#125;public class Dex2 &#123; private int count = 0; private int num = 2; public int add(int i) &#123; return num + i; &#125;&#125; 分别对它们进行编译： 12javac Dex1.java -&gt; Dex1.classjavac Dex2.java -&gt; Dex2.class 然后使用jar cvf AllDex.jar Dex1.class Dex2.class将Dex1.class和Dex2.class打包到一个jar文件中。 这时会生成一个名为AllDex.jar的文件。 最后使用dx命令对AllDex.jar进行优化，生成AllDex.dex文件。 1dx --dex --output AllDex.dex AllDex.jars 正常情况下，无法通过反编译工具查看其源码，可以通过Android SDK中的工具dexdump查看其字节码。 1dexdump -d -l plain AllDex.dex 上述命令将Dex1和Dex2优化后的字节码显示到控制台，内容较多，部分结果如下： 可以看出Dex1和Dex2的信息都在此.dex文件中。 实际上，dex文件在App安装过程中还会被进一步优化为odex(optimized dex)，此过程还会在后面介绍安装过程再次提到。 注意：这里的优化也伴随着一些副作用，最经典的就是Android 65535问题。出现这个问题的根本原因是在DVM源码中的MemberIdsSection.java类中，有如下一段代码： 如果items个数超过DexFormat.MAX_MEMBER_IDX，则会报错，DexFormat.MAX_MEMBER_IDX的值为65535，items代表dex文件中方法的个数、属性个数、以及类的个数。也就是说理论上不止方法数，在java文件中声明的变量，或者创建的类超过65535个，同样会编译失败，Android提供了MultiDex来解决这个问题。 3. 架构基于寄存器&amp;基于栈堆结构前面已经介绍过，JVM的指令集是基于栈结构来执行的；而Android字节码和Java字节码完全不同，Androdid的字节码(smali)更多的是二地址指令和三地址指令，具体Dalvik指令可以参考Dalvik 字节码。 具体看一下Dalvik和JVM字节码的区别，在上文中提到的Dex1.java，在Dex1中有add()方法。 经过编译为Dex1.class之后，查看其字节码如下： add()方法会使用4行指令来完成。而通过dx将其优化为.dex之后，再次查看它的Dalvik字节码如下： 说明： add_int指令需要三个寄存器参数：v0、v2、v3。这个指令会将v2和v3进行相加运算，然后将结果保存到寄存器v0中。 return指令将结果返回。 可以看出，Dalvik字节码只需要2行指令。基于寄存器的指令明显会比基于栈的指令少，虽然增加了指令长度但却缩减了指令的数量，执行也更迅速。 用一张表来对比基于栈和基于寄存器的实现方式： 栈式VS寄存器式 对比 指令条数 栈式 &gt; 寄存器式 指令长度 栈式 &lt; 寄存器式 移植性 栈式由于寄存器式 指令优化 栈式更不易优化 解释器执行速度 栈式解释器速度稍慢 代码生成难度 栈式简单 4. 内存管理与回收DVM与JVM另一个比较显著的不同是内存结构的区别，主要体现在对“堆”内存的管理。Dalvik虚拟机中的堆被划分为两个部分：Active Heap和Zygote Heap。如下如： 图中的Card Table以及两个Heap Bitmap主要用来记录垃圾收集过程中对象的引用情况，以便实现Concurrent GC。 5. 为什么要分Zygote和Active两个部分？Android系统中的第一个Dalvik虚拟机是由Zygote进程创建的，而应用程序进程是由Zygote进程fork出来的。 Zygote进程是系统启动时产生的，它会完成虚拟机的初始化，库的加载，预置类的加载以及初始化等操作，而在系统需要一个新的虚拟机实例时，Zygote通过复制自身，最快速的提供一个进程；另外，对于一些只读的系统库，所有虚拟机实例都和Zygote共享一块内存区域，大大节省内存开销。如下图： 说明： 当启动一个应用时，Android操作系统需要为应用程序创建新的进程，而这一步操作是通过一种写时拷贝技术(COW)直接复制Zygote进程而来。这意味着在开始的时候，应用程序进程和Zygote进程共享了同一个用来分配对象的堆。然而，当Zygote进程或者应用程序进程对该堆进行写操作时，内核就会执行真正额拷贝操作，使得Zygote进程和应用程序进程分别拥有自己的一份拷贝。拷贝是一件费时费力额的事情。因此，为了尽量避免拷贝，Dalvik虚拟机将自己的堆栈划分为两部分。 事实上，Dalvik虚拟机的堆最初只有一个，也就是Zygote进程在启动过程创建Dalvik虚拟机时，只有一个堆。但是当Zygote进程在fork第一个应用程序进程之前，会将已经使用的那部分堆内存划分为一部分，把还没有使用的堆内部内划分为另外一部分。前者称为Zygote堆，后者称为 Active堆。以后无论Zygote进程，还是应用程序进程，当它们需要分配对象时，都在Active上进行。这样就可以使得Zygote堆尽可能少地被执行写操作，因为就可以减少执行写时拷贝的操作时间。 6. Dalvik虚拟机堆在Dalvik虚拟机中，堆实际上就是一块匿名共享内存。Dalvik虚拟机并不是直接管理这块匿名共享内存，而是将它封装成一个mspace，交给C库来管理，为什么呢？因为内存碎片问题实际是一个通用的问题，不只是Dalvik虚拟机在Java堆为对象分配内存时会遇到，C库的malloc函数在分配内存时也会遇到。 Android系统使用的C库bionic使用了Doug Lea写的dlmalloc内存分配器，也就是说，调用函数malloc时，使用的是dlmalloc内存分配器来分配的内存。这是一个成熟的内存分配器，可以很好的解决内存碎片问题。 关于dlmalloc内存分配器的设计，可以参考：A Memory Allocator 7. 拓展阅读 dalvik.system Dalvik虚拟机字节码与指令集对照表 Dalvik虚拟机Java堆创建过程分析","categories":[{"name":"Android","slug":"Android","permalink":"https://tylerLiu.top/categories/Android/"},{"name":"进阶","slug":"Android/进阶","permalink":"https://tylerLiu.top/categories/Android/进阶/"}],"tags":[{"name":"JVM与DVM必知必会","slug":"JVM与DVM必知必会","permalink":"https://tylerLiu.top/tags/JVM与DVM必知必会/"}]},{"title":"（拉钩）Android工程师进阶34讲-11：线程池之刨根问底","slug":"（拉钩）Android工程师进阶34讲-11：线程池之刨根问底","date":"2020-07-27T10:31:17.000Z","updated":"2020-07-30T02:29:05.013Z","comments":true,"path":"2020/07/27/（拉钩）Android工程师进阶34讲-11：线程池之刨根问底/","link":"","permalink":"https://tylerLiu.top/2020/07/27/（拉钩）Android工程师进阶34讲-11：线程池之刨根问底/","excerpt":"","text":"0. 前言在介绍synchronized原理时，已经了解了Java中线程的创建以及上下切换是比较消耗性能的，因此引入了偏向锁、轻量级锁等优化技术，目的就是减少用户态和核心态之间的切换频率。但是在这些优化基础之上，还有另外一个角度值得思考：创建和销毁线程非常损耗性能，那有没有可能复用一些已经被创建的好的线程呢？那就是线程池。 另外，线程的创建需要开辟虚拟机栈、本地方法栈、程序计数器等线程私有的空间，在线程销毁时需要回收这些系统资源，频繁的创建销毁线程会浪费大量资源，而通过复用已有线程可以更好地管理和协调线程的工作。 线程池主要解决两个问题： 1、当执行大量异步任务时，线程池能提供更好的性能。 2、线程池提供了一种资源限制和管理的手段，比如可以限制线程的个数，动态新增线程等。 1. 线程池体系线程池体系如下图： 说明： Executor：线程池最顶层的接口，在Executor中只有一个execute()方法，用于执行任务。至于线程创建、调度等细节由子类实现。 ExecutorService：继承并扩展了Executor，在ExecutorService内部提供了更全面的任务提交机制以及线程池关闭的方法。 ThreadPoolExecutor：是ExecutorService的默认实现，所谓的线程池机制也大多封装在此类当中，因此它是分析的重点。 ScheduledExecutorService继承自ExecutorService，增加了定时任务相关方法。 ScheduledThreadPoolExecutor继承自ThreadPoolExecutor，并实现了ScheduledExecutorService接口。 ForkJoinPool是一种支持任务分解的线程池，一般要配合可分解任务接口ForkJoinTask来使用。 2. 创建线程池JDK提供了一个线程池的工厂类——Executors。在Executors中定义了多个静态方法，用来创建不同配置的线程池。常用有以下几种。 2.1 newSingleThreadExecutor创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按先进先出的顺序执行。 123456789101112131415161718public class CreateSingleThreadPool &#123; public static void main(String[] args) throws InterruptedException &#123; // 创建单线程池 ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor(); for (int i = 0; i &lt;= 5; i++) &#123; final int taskId = i; // 向线程池中提交任务 singleThreadExecutor.submit(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"线程：\" + Thread.currentThread().getName() + \" 正在执行 task：\" + taskId); &#125; &#125;); Thread.sleep(1000); &#125; &#125;&#125; 执行上述代码，结果如下，可以看出所有的task始终是在同一个线程中执行的。 123456线程：pool-1-thread-1 正在执行 task：0线程：pool-1-thread-1 正在执行 task：1线程：pool-1-thread-1 正在执行 task：2线程：pool-1-thread-1 正在执行 task：3线程：pool-1-thread-1 正在执行 task：4线程：pool-1-thread-1 正在执行 task：5 2.2 newCachedThreadPool创建一个可缓存线程，如果线程池长度超过处理需要，可灵活回收空线程，若无可回收，则新建线程。 123456789101112131415161718192021public class CreateCacheThreadPool &#123; public static void main(String[] args) &#123; ExecutorService cacheThreadPool = Executors.newCachedThreadPool(); for (int i = 0; i &lt;= 5; i++) &#123; final int taskId = i; cacheThreadPool.execute(new Runnable() &#123; @Override public void run() &#123; try &#123; System.out.println(\"线程：\" + Thread.currentThread().getName() + \" 正在执行 task：\" + taskId); Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; cacheThreadPool.shutdown(); &#125;&#125; 执行效果如下： 123456线程：pool-1-thread-1 正在执行 task：0线程：pool-1-thread-2 正在执行 task：1线程：pool-1-thread-3 正在执行 task：2线程：pool-1-thread-4 正在执行 task：3线程：pool-1-thread-5 正在执行 task：4线程：pool-1-thread-6 正在执行 task：5 从日志可以看出，缓存线程池会创建新的线程来执行任务。但是如果将代码修改一下，在提交任务之前休眠1秒，修改如下： 123456789101112131415161718192021222324public class CreateCacheThreadPool &#123; public static void main(String[] args) throws InterruptedException &#123; ExecutorService cacheThreadPool = Executors.newCachedThreadPool(); for (int i = 0; i &lt;= 5; i++) &#123; final int taskId = i; // 每次执行任务前休眠1秒 Thread.sleep(1000); cacheThreadPool.execute(new Runnable() &#123; @Override public void run() &#123; try &#123; System.out.println(\"线程：\" + Thread.currentThread().getName() + \" 正在执行 task：\" + taskId); Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; cacheThreadPool.shutdown(); &#125;&#125; 打印如下： 123456线程：pool-1-thread-1 正在执行 task：0线程：pool-1-thread-1 正在执行 task：1线程：pool-1-thread-1 正在执行 task：2线程：pool-1-thread-1 正在执行 task：3线程：pool-1-thread-1 正在执行 task：4线程：pool-1-thread-1 正在执行 task：5 2.3 newFixedThreadPool创建一个固定数目的、可重用的线程池。 1234567891011121314151617public class CreateFixedThreadPool &#123; public static void main(String[] args) &#123; // 创建线程数量为3的线程池 ExecutorService singleThreadThreadExecutor = Executors.newFixedThreadPool(3); // 提交10个任务交给线程池执行 for (int i = 0; i &lt;= 10; i++) &#123; final int taskId = i; singleThreadThreadExecutor.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"线程：\" + Thread.currentThread().getName() + \" 正在执行 task：\" + taskId); &#125; &#125;); &#125; &#125;&#125; 打印： 1234567891011线程：pool-1-thread-2 正在执行 task：1线程：pool-1-thread-1 正在执行 task：0线程：pool-1-thread-3 正在执行 task：2线程：pool-1-thread-1 正在执行 task：4线程：pool-1-thread-2 正在执行 task：3线程：pool-1-thread-1 正在执行 task：6线程：pool-1-thread-3 正在执行 task：5线程：pool-1-thread-1 正在执行 task：8线程：pool-1-thread-2 正在执行 task：7线程：pool-1-thread-1 正在执行 task：10线程：pool-1-thread-3 正在执行 task：9 2.4 newScheduledThreadPool创建一个定时线程池，支持定时及周期性任务执行。 1234567891011121314151617public class CreateScheduledThreadPool &#123; public static void main(String[] args) throws InterruptedException &#123; // 指定线程数量为2的定时任务线程池 ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(2); scheduledThreadPool.scheduleAtFixedRate(new Runnable() &#123; @Override public void run() &#123; Date now = new Date(); System.out.println(\"线程：\" + Thread.currentThread().getName() + \" 报时：\" + now); &#125; &#125;, 500, 500, TimeUnit.MILLISECONDS); Thread.sleep(5000); // 关闭定时任务 scheduledThreadPool.shutdown(); &#125;&#125; 上面代码创建了一个线程数量为2的定时任务线程池，通过scheduleAtFixedRate()方法，指定每隔500毫秒执行一次任务，并且在5秒之后通过shutdown()关闭定时任务。执行效果如下： 123456789线程：pool-1-thread-1 报时：Tue Jul 28 14:25:04 CST 2020线程：pool-1-thread-1 报时：Tue Jul 28 14:25:04 CST 2020线程：pool-1-thread-2 报时：Tue Jul 28 14:25:05 CST 2020线程：pool-1-thread-1 报时：Tue Jul 28 14:25:05 CST 2020线程：pool-1-thread-2 报时：Tue Jul 28 14:25:06 CST 2020线程：pool-1-thread-1 报时：Tue Jul 28 14:25:06 CST 2020线程：pool-1-thread-2 报时：Tue Jul 28 14:25:07 CST 2020线程：pool-1-thread-2 报时：Tue Jul 28 14:25:07 CST 2020线程：pool-1-thread-1 报时：Tue Jul 28 14:25:08 CST 2020 上面是常用的几种线程池的使用方式，但是《阿里Java开发手册》中已经严禁使用Executors来创建线程池了，为什么呢？下面先看看线程池的工作原理。 3. 线程池工作原理分析3.1 案例某工艺品加工厂有三台机器用来生产订单所需的产品，正常情况下，三天机器能保证所有订单按时按需生产完毕，如下图： 如果订单突然大幅增加，三台机器已经处于满负荷状态，一时间无法完成新增的订单任务，怎么办呢？如果接下了新的订单，会将新来的订单暂时存放在仓库中，当有加工机器空闲时，再用来生产仓库中的订单，如下图： 如果订单持续快速增长，导致仓库也存储满了？又该如何？正常情况下加工厂肯定会通过购买新的加工机器来满足订单需求，如下图： 有了仓库和新买的机器，加工厂业务还能正常流转。但是当某些极端情况发生时，比如节假日之后的爆单。这时新增的订单连仓库以及所有的加工机器都不能满足，说明工厂已经不能接新的订单了，只能拒绝新的订单。 线程池的工作流程和上面描述的加工厂完成订单任务类似，并且在线程池的构造器中，通过传入的参数可以设置默认有多少台加工机器、仓库的大小、可以购买新的加工机器的最大数量等等。 3.2 线程池结构 从上图可以看出，线程池内部主要包含以下几个部分： work集合：保存所有的核心线程和非核心线程，其本质是一个HashSet。 等待任务队列：当核心线程的个数达到corePiilSize时，提交新的任务会被先保存在等待队列中，其本质是一个阻塞队列BlockingQueue。 ctl：是一个AtomicInteger类型，二进制高3位用来标识线程池的状态，低29位用来记录线程池中线程的数量。 获取线程池状态、工作线程数量、修改ctl的方法分别如下： 12345678910111213141516private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));// 计算当前运行状态private static int runStateOf(int c)&#123; return c &amp; -CAPACITY;&#125;// 计算当前线程数量private static int workerCountOf(int c)&#123; return c &amp; CAPACITY;&#125; // 通过状态和线程数量生成ctlprivate static int ctlOf(int rs, int wc)&#123; return rs | wc;&#125; 线程池主要有几下几种运行状态： RUNNING：默认状态，接收新任务并处理排队任务； SHUTDOWN:不接受新任务，但处理排队任务，调用shutDown()会处于该状态； STOP：不接受新任务，也不处理排队任务，并中断正在运行的任务，调用shutDownNow()会处于该状态； TIDYING：所有任务都已终止，workCount为0时，线程会转换到TIDYING状态，并将运行terminate()方法。 TERMINATED：terminate()运行完成后，线程池转为此状态。 3.3 参数分析123456789101112131415161718192021222324public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.acc = System.getSecurityManager() == null ? null : AccessController.getContext(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; 参数说明： corePoolSIze：表示核心线程数量。 maximumPoolSize：表示线程池最大能容纳同时执行的线程数，必须 &gt;= 1。如果和corePoolSize相等即是固定大小线程池。 keepAliveTime：表示线程池中的空闲时间，当空闲时间达到此值时，线程会被销毁直到剩下corePoolSize个线程。 unit：用来指定KeepAliveTime的时间单位，有MILLISECONDS、SECONDS、MINUTES、HOURS等。 workQueue：等待队列，BlockingQueue类型。当请求任务数大于corePoolSize时，任务将被缓存到此BlockingQueue中。 threadFactory：线程工厂，线程池中使用它来创建线程，如果传入的是null，则使用默认工厂类DefaultThreadFactory。 handler：执行拒绝策略的对象。当workQueue满了之后并且活动线程数大于maximumPoolSize时，线程池通过该策略处理请求。 注意：当ThreadPoolExecutor的allowCoreThreadTimeOut设置为true时，核心线程超时后也会被销毁。 3.4 流程解析当调用execute或者submit，将一个任务交给线程池，线程池接收这个任务请求后，有以下几种处理情况： 1、当前线程池中运行的线程数量还没有达到corePoolSize大小时，线程池会创建一个新线程执行提交的任务，无论之前创建的线程是否处于空闲状态。例如：12345678910111213141516171819202122232425public class LessThanCoreCount &#123; public static void main(String[] args) throws InterruptedException &#123; ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3); for (int i = 1; i &lt;= 5; i++) &#123; final int taskId = i; fixedThreadPool.execute(new Runnable() &#123; @Override public void run() &#123; try &#123; System.out.println(\"线程：\" + Thread.currentThread().getName() + \" 正在执行 task：\" + taskId); // 任务耗时100毫秒 Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); // 延时2s向线程池中提交任务 Thread.sleep(2000); &#125; fixedThreadPool.shutdown(); &#125;&#125; 上面代码创建了3个固定数量的线程池，每次提交的任务耗时100毫秒。每次提交任务之前都会延迟2秒，保证线程池中的工作线程已经执行完毕的，但是执行效果如下： 12345线程：pool-1-thread-1 正在执行 task：1线程：pool-1-thread-2 正在执行 task：2线程：pool-1-thread-3 正在执行 task：3线程：pool-1-thread-1 正在执行 task：4线程：pool-1-thread-2 正在执行 task：5 虽然线程1和线程2都已经执行完毕，并处于空闲状态，但是线程池还是会尝试创建新的线程去执行新提交的任务，知道线程数量达到corePoolSize。 2、当前线程池中运行的线程数量已经达到corePoolSize时，线程池会把任务加到等待队列中，直到某一个线程空闲了，线程池会根据设置的等待队列规则，从队列中取出一个新的任务执行。例如：1234567891011121314151617181920212223242526public class MoreThanCoreCount &#123; public static void main(String[] args) throws InterruptedException &#123; ThreadPoolExecutor fixedThreadPool = (ThreadPoolExecutor) Executors.newFixedThreadPool(2); for (int i = 1; i &lt;= 5; i++) &#123; final int taskId = i; fixedThreadPool.execute(new Runnable() &#123; @Override public void run() &#123; try &#123; System.out.println(\"线程：\" + Thread.currentThread().getName() + \" 正在执行 task：\" + taskId); // 任务耗时4秒 Thread.sleep(4000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); System.out.println(\"此时等待队列中有 \" + fixedThreadPool.getQueue().size() + \" 个元素。\"); // 延时500毫秒向线程池中提交任务 Thread.sleep(500); &#125; fixedThreadPool.shutdown(); &#125;&#125; 代码中，任务耗时4秒。此时新的任务提交给线程时，任务会缓存到等待队列中，如下： 12345678910111213// 1此时等待队列中有 0 个元素。线程：pool-1-thread-1 正在执行 task：1此时等待队列中有 0 个元素。线程：pool-1-thread-2 正在执行 task：2// 2此时等待队列中有 1 个元素。此时等待队列中有 2 个元素。此时等待队列中有 3 个元素。线程：pool-1-thread-1 正在执行 task：3线程：pool-1-thread-2 正在执行 task：4线程：pool-1-thread-1 正在执行 task：5 1中通过两个核心线程直接执行提交的任务，因此等待队列中的数量为0；2中表明，此时核心线程都已经被占用，新提交的任务都被放入等待队列中。 3、如果线程数大于corePoolSize，但是还没达到最大线程池数maximumPoolSize，并且等待队列已满，则线程池会创建新的线程来执行任务。12345678910111213141516171819202122232425262728public class NonCoreThread &#123; public static void main(String[] args) throws InterruptedException &#123; // 核心线程为2，最大线程数为10，等待队列长度为2 ThreadPoolExecutor threadPool = new ThreadPoolExecutor(2, 10, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingDeque&lt;&gt;(2)); for (int i = 1; i &lt;= 5; i++) &#123; final int taskId = i; threadPool.execute(new Runnable() &#123; @Override public void run() &#123; try &#123; System.out.println(\"线程：\" + Thread.currentThread().getName() + \" 正在执行 task：\" + taskId); // 任务耗时4秒 Thread.sleep(4000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); System.out.println(\"此时等待队列中有 \" + threadPool.getQueue().size() + \" 个元素。\"); // 延时500毫秒向线程池中提交任务 Thread.sleep(500); &#125; threadPool.shutdown(); &#125;&#125; 执行效果如下： 1234567891011121314// 1此时等待队列中有 0 个元素。线程：pool-1-thread-1 正在执行 task：1此时等待队列中有 0 个元素。线程：pool-1-thread-2 正在执行 task：2// 2此时等待队列中有 1 个元素。此时等待队列中有 2 个元素。此时等待队列中有 2 个元素。线程：pool-1-thread-3 正在执行 task：5 // 3线程：pool-1-thread-1 正在执行 task：3线程：pool-1-thread-2 正在执行 task：4 说明： 1处表示线程数量已经达到corePoolSize。 2处表示等待队列已满。 3处创建新的线程执行任务。 4、最后如果提交的任务，无法被核心线程直接执行，又无法加入等待队列，又无法创建“非核心线程”直接执行，线程池将根据拒绝处理器定义的策略处理这个任务。比如在ThreadPoolExecutor中，如果没有为线程池设置RejectedExecutionHandler。这时线程池会抛出RejectedExecutionException，即线程池拒绝接受这个任务。如下： 12345678910111213141516171819202122232425public class ThreadPoolRejectHandle &#123; public static void main(String[] args) throws InterruptedException &#123; // 核心线程为2，最大线程数为3，等待队列长度为2 ThreadPoolExecutor threadPool = new ThreadPoolExecutor(2, 3, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingDeque&lt;&gt;(2)); for (int i = 1; i &lt;= 5; i++) &#123; // 提交6次任务 final int taskId = i; threadPool.execute(new Runnable() &#123; @Override public void run() &#123; try &#123; System.out.println(\"线程：\" + Thread.currentThread().getName() + \" 正在执行 task：\" + taskId); // 任务耗时5秒 Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); System.out.println(\"此时等待队列中有 \" + threadPool.getQueue().size() + \" 个元素。\"); &#125; &#125;&#125; 执行效果如下： 123456789101112131415此时等待队列中有 0 个元素。此时等待队列中有 0 个元素。此时等待队列中有 1 个元素。此时等待队列中有 2 个元素。此时等待队列中有 2 个元素。线程：pool-1-thread-1 正在执行 task：1线程：pool-1-thread-2 正在执行 task：2线程：pool-1-thread-3 正在执行 task：5Exception in thread &quot;main&quot; java.util.concurrent.RejectedExecutionException: Task ThreadPoolRejectHandle$1@d716361 rejected from java.util.concurrent.ThreadPoolExecutor@6ff3c5b5[Running, pool size = 3, active threads = 3, queued tasks = 2, completed tasks = 0] at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2063) at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:830) at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1379) at ThreadPoolRejectHandle.main(ThreadPoolRejectHandle.java:14)线程：pool-1-thread-1 正在执行 task：3线程：pool-1-thread-2 正在执行 task：4 程序报了RejectedExecutionException，拒绝策略是线程池的一种保护机制，目的就是当这种无节制的线程资源申请发生时，拒绝新的任务保护线程池。默认拒绝策略会直接报异常，但是JDK中一共提供了4中保护策略，如下： 名称 描述 ThreadPoolExecutor.AbortPolicy 丢弃任务并抛出RejectedExecutionException。这时线程池默认的拒绝策略，在任务不能再提交时，抛出异常，及时反馈程序运行状态。如果是比较关键的业务，推荐使用此策略，这样在系统不能承载更大的并发量的时候，能及时通过异常发现。 ThreadPoolExecutor.DiscardPolicy 丢弃任务，但是不抛出异常。使用此策略，可能会无法发现系统的异常状态。建议一些不重要的业务采用此策略。 ThreadPoolExecutor.DiscardOldestPolicy 丢弃队列最前面的任务，然后重新提交被拒绝的任务。是否要采用此种拒绝策略，要根据实际业务是否允许丢弃老任务来衡量。 ThreadPoolExecutor.CallerRunsPolicy 由调用线程（提交任务的线程）处理该任务。这种情况是需要让所有任务都执行完毕，那么就适合大量计算的任务类型去执行，多线程仅仅是增大吞吐量的手段，最终必须要让每个任务都执行完毕。 实际上拒绝策略都是实现接口RejectedExecutionException，也可以自定义类实现接口，定义自己的拒绝策略。 整个流程的动画演示：漫画Java线程池的工作机制 4. 为何禁止使用Executors再来看看对于禁止使用Executors，特别是newFixedThreadPool和newCachedThreadPool两个方法。 比如如下使用newFixedThreadPool方法创建线程池： 123456789101112131415161718192021222324public class FixedThreadPoolOOM &#123; public static void main(String[] args) &#123; ThreadPoolExecutor fixedThreadPool = (ThreadPoolExecutor) Executors.newFixedThreadPool(2); // 提交10个任务交给线程池执行 for (int i = 0; i &lt;= 1000000; i++) &#123; final int taskId = i; System.out.println(\"execute task:\" + taskId); fixedThreadPool.execute(new Runnable() &#123; @Override public void run() &#123; try &#123; System.out.println(\"线程：\" + Thread.currentThread().getName() + \" 正在执行 task：\" + taskId); // 任务耗时10秒 Thread.sleep(10000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; fixedThreadPool.shutdown(); &#125;&#125; 上述代码创建一个固定线程数量为2的线程池，并通过for循环向线程池中提交100W个任务。 通过java -Xms4m -Xmx4m FixedThreadPoolOOM执行上述代码： 可以看到当任务执行到7W多个时候，程序发生OOM。为什么呢？看一下newSingleThreadExecutor()和newFixedThreadPool()的具体实现，如下： 123456789public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125;public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; 可以看到传入的是一个无界的阻塞队列，理论上可以无限添加任务到线程池。当核心线程执行时间很长，则新提交的任务在不断插入到阻塞队列中，最终造成OOM。 再看一下newCachedThreadPool()有什么问题： 123456789101112131415161718192021222324public class CacheThreadPoolOOM &#123; public static void main(String[] args) &#123; ThreadPoolExecutor fixedThreadPool = (ThreadPoolExecutor) Executors.newCachedThreadPool(); // 提交10个任务交给线程池执行 for (int i = 0; i &lt;= 1000000; i++) &#123; final int taskId = i; System.out.println(\"execute task:\" + taskId); fixedThreadPool.execute(new Runnable() &#123; @Override public void run() &#123; try &#123; System.out.println(\"线程：\" + Thread.currentThread().getName() + \" 正在执行 task：\" + taskId); // 任务耗时10秒 Thread.sleep(10000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; fixedThreadPool.shutdown(); &#125;&#125; 上述代码同样会报OOM，只是错误的log信息有点区别：无法创建新的线程。 看一下newCachedThreadPool()的实现： 1234public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; 可以看到，缓存线程池的最大线程数为Integer最大值。当核心线程耗时很久，线程池会尝试创建新的线程来执行提交任务，当内部不足时就会报无法创建线程的错误。","categories":[{"name":"Android","slug":"Android","permalink":"https://tylerLiu.top/categories/Android/"},{"name":"进阶","slug":"Android/进阶","permalink":"https://tylerLiu.top/categories/Android/进阶/"}],"tags":[{"name":"JVM与DVM必知必会","slug":"JVM与DVM必知必会","permalink":"https://tylerLiu.top/tags/JVM与DVM必知必会/"}]},{"title":"（拉钩）Android工程师进阶34讲-10：深入理解AQS和CAS原理","slug":"（拉钩）Android工程师进阶34讲-10：深入理解AQS和CAS原理","date":"2020-07-24T01:37:59.000Z","updated":"2020-07-27T10:27:53.726Z","comments":true,"path":"2020/07/24/（拉钩）Android工程师进阶34讲-10：深入理解AQS和CAS原理/","link":"","permalink":"https://tylerLiu.top/2020/07/24/（拉钩）Android工程师进阶34讲-10：深入理解AQS和CAS原理/","excerpt":"","text":"0. 前言AQS 全称 Abstract Queued Synchronized，一般翻译为同步器。它是一套实现多线程同步功能的框架，由 Doug Lea 操刀设计并开发实现的。AQS 在源码中被广泛使用，尤其是在JUC(Java Util Concurrent)中，比如ReentrantLock、Semaphore、CountDownLatch、ThreadPoolExecutor。理解 AQS 对理解 JUC 以及其他组件很有帮助，并且在实际开发中也可以通过自定义 AQS 来实现各种需求场景。 注意：理解 AQS 需要一定额数据结构基础，尤其是双端队列，并对Unsafe有一定了解。 1. ReentrantLock 和 AQS 的关系这里主要通过ReentrantLock来理解 AQS 内部的工作机制。首先从ReentrantLock的lock()方法开始： 1234567891011121314151617/** * Acquires the lock. * * &lt;p&gt;Acquires the lock if it is not held by another thread and returns * immediately, setting the lock hold count to one. * * &lt;p&gt;If the current thread already holds the lock then the hold * count is incremented by one and the method returns immediately. * * &lt;p&gt;If the lock is held by another thread then the * current thread becomes disabled for thread scheduling * purposes and lies dormant until the lock has been acquired, * at which time the lock hold count is set to one. */public void lock() &#123; sync.lock();&#125; 在里面只调用了Sync的lock()方法，这个Sync是什么呢？ 12345678public class ReentrantLock implements Lock, java.io.Serializable &#123; private static final long serialVersionUID = 7373984872572414699L; /** Synchronizer providing all implementation mechanics */ private final Sync sync; ......&#125; Sync是ReentrantLock的一个内部类。ReentrantLock并没有直接继承 AQS，而是通过内部Sync来扩展AQS的功能，然后ReentrantLock中存有Sync的全局变量引用。 Sync在ReentrantLock有两种实现：NonfairSync和FairSync，分别对应非公平锁和公平锁。以非公平锁为例，实现源码如下： 123456789101112131415161718192021/** * Sync object for non-fair locks */static final class NonfairSync extends Sync &#123; private static final long serialVersionUID = 7316153563782823691L; /** * Performs lock. Try immediate barge, backing up to normal * acquire on failure. */ final void lock() &#123; if (compareAndSetState(0, 1)) // 通过cas操作来修改state状态，表示争抢锁的操作 setExclusiveOwnerThread(Thread.currentThread()); // 设置当前获得锁状态的线程 else acquire(1); // 修改状态失败，尝试获取锁 &#125; protected final boolean tryAcquire(int acquires) &#123; return nonfairTryAcquire(acquires); &#125;&#125; 可以看出，在非公平锁的lock()方法中，主要做了如下操作： 如果通过CAS设置变量state（同步状态）成功，表示当前线程获取锁成功，则将当前线程设置为独占线程。 如果通过CAS设置变量state（同步状态）失败，表示当前做正在被其他线程持有，则进入Acquire方法进行后续处理。 acquire()方法定义在AQS中，具体如下： 1234567891011121314151617/** * Acquires in exclusive mode, ignoring interrupts. Implemented * by invoking at least once &#123;@link #tryAcquire&#125;, * returning on success. Otherwise the thread is queued, possibly * repeatedly blocking and unblocking, invoking &#123;@link * #tryAcquire&#125; until success. This method can be used * to implement method &#123;@link Lock#lock&#125;. * * @param arg the acquire argument. This value is conveyed to * &#123;@link #tryAcquire&#125; but is otherwise uninterpreted and * can represent anything you like. */public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; acquire()主要做了三件事： 1、tryAcquire()：尝试获取锁； 2、addWaiter()：如果tryAcquire()尝试获取锁失败，则调用addWaiter()将当前线程添加到一个等待队列中； 3、acquireQueued()：处理加入到队列中的节点，通过自旋去尝试获取锁，根据情况将线程挂起或取消。 以上三个方法都被定义在AQS中，其中tryAcquire()有点特殊，其实现如下： 123protected boolean tryAcquire(int arg) &#123; throw new UnsupportedOperationException();&#125; 默认情况下，直接抛出异常，因此它需要在子类中重写，真正的获取锁的逻辑由子类同步器自己实现。 ReentrantLock中tryAcquire()的实现（非公平锁）如下： 123456789101112131415161718192021222324252627282930protected final boolean tryAcquire(int acquires) &#123; return nonfairTryAcquire(acquires);&#125;/** * Performs non-fair tryLock. tryAcquire is implemented in * subclasses, but both need nonfair try for trylock method. */final boolean nonfairTryAcquire(int acquires) &#123; // 获取当前执行的线程 final Thread current = Thread.currentThread(); int c = getState(); // 获取 state 值 if (c == 0) &#123; // c == 0，说明当前是无锁状态 // 通过cas操作来替换state的值为1 if (compareAndSetState(0, acquires)) &#123; // 设置当前线程持有独占锁 setExclusiveOwnerThread(current); return true; &#125; &#125; // 如果是同一个线程来获得锁，则直接增加重入次数 else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; // 增加重入次数 if (nextc &lt; 0) // overflow throw new Error(\"Maximum lock count exceeded\"); setState(nextc); return true; &#125; return false;&#125; 说明： 获得当前线程，判断当前的锁的状态。 如果state == 0，表示当前是无锁状态，通过cas更新state状态的值，返回true。 如果当前线程属于重入，则增加重入次数，返回true。 上述情况都不满足，则获取锁失败，返回false。 一张图表示ReentrantLock.lock()过程： 图中可以看出，在ReentrantLock执行lock()过程中，大部分同步机制的核心逻辑都已经在AQS中实现，ReentrantLock自身只要实现某些特定步骤下的方法即可，这种设计模式叫模板模式。比如Android中，Activity的生命周期的执行流程都已经在framework中定义好了，子类Activity只要在相应的onCreate()、onPause()等生命周期方法中提供相应的实现即可。 注意：不止ReentrantLock，JUC包中的其他组件如CountDownLatch、Semaphor等都是通过一个内部类Sync来继承AQS，然后在内部中通过操作Sync来实现同步。这种做法的好处是将线程控制的逻辑控制在Sync内部，而对外面向用户提供的接口是自定义锁，这种聚合关系能够很好的解耦两者所关注的逻辑。 2. AQS核心功能原理分析首先看看AQS中几个关键的属性： 123456789static final class Node&#123; ...&#125;private transient volatile Node head;private transient volatile Node tail;private volatile int state; 代码中展示了AQS中两个比较重要的属性Node和state。 2.1 state锁状态state表示当前锁状态。当state = 0时表示无锁状态；当state &gt; 0时，表示已经有线程获得锁，也就是state = 1，如果同一个线程多次获得同步锁时，state会递增，比如重入5次，那么state = 5。而在释放锁时，同样需要释放5次直到state = 0，其他线程才有资格获得锁。 state还有一个功能是实现锁的独占模式或共享模式。 独占模式：只有一个线程能够持有同步锁。 在独占模式下，可以把state的初始值设置成0，当某个线程申请锁对象时，需要判断state的值是不是0，如果不是0，表示其他线程已经持有该锁，则本线程需要阻塞等待。 共享模式：可以有多个线程持有同步锁。 共享模式下，比如某项操作允许10个线程同时进行，超过这个数量的线程就需要阻塞等待。那么只需要在线程申请对象时判断state的值是否小于10。如果小于10，就将state加1后继续同步语句的执行；如果等于10，说明已经有10个线程同时执行该操作，本线程需要阻塞等待。 2.2 Node双端队列节点Node是一个先进先出的双端队列，并且是等待队列，当多线程争用资源被阻塞时会进入此队列。这个队列是AQS实现多线程同步的核心。 从之前ReentrantLock图中可以看出，在AQS中有两个Node的指针，分别指向队列的head和tail。 Node的主要结构如下： 12345678910111213141516171819static final class Node &#123; // 该等待同步的节点处于共享模式 static final Node SHARED = new Node(); // 该等待同步的节点处于独占模式 static final Node EXCLUSIVE = null; static final int CANCELLED = 1; static final int SIGNAL = -1; static final int CONDITION = -2; static final int PROPAGATE = -3; // Node中的线程状态，这个和state是不一样的：有1，0，-1，-2，-3五个值 volatile int waitStatus; volatile Node prev; // 前驱节点 volatile Node next; // 后继节点 volatile Thread thread; // 等待锁的线程 ...&#125; 默认情况下，AQS中的链表结构如下图所示： 2.3 获取锁失败后续流程分析锁的意义就是使竞争到锁对象的线程执行同步代码，多个线程竞争锁时，竞争失败的线程需要被阻塞等待后续唤醒。那么ReentrantLock是如何实现让线程等待并唤醒的呢？ 前面提到在ReentrantLock.lock()阶段，在acquire()方法中会先调用tryAcquire、addWaiter、acquireQueued这三个方法来处理。tryAcquire在ReentrantLock中被复写并实现，如果返回true，说明成功获取锁，就继续执行同步代码语句。可是如果tryAcquire返回false，也就是当前锁对象被其他线程所持有，那么当前线程会被AQS如何处理呢？ 2.3.1 addWaiter首先当前获取锁失败的线程会被添加到一个等待队列的末端，具体源码如下： 12345678910111213141516171819202122232425262728293031323334353637/** * 将线程以Node的方式添加到队列中 */private Node addWaiter(Node mode) &#123; // 把当前线程封装到一个新的Node Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure Node pred = tail; if (pred != null) &#123; // 将node插入到队列 node.prev = pred; if (compareAndSetTail(pred, node)) &#123; // CAS替换当前尾部，成功则返回 pred.next = node; return node; &#125; &#125; enq(node); // 插入队列失败，进入enq自旋重试入队 return node;&#125;/** * 插入节点到队列中，如果队列未初始化则初始化，然后再插入 */private Node enq(final Node node) &#123; for (;;) &#123; Node t = tail; if (t == null) &#123; // 如果队列从未被初始化，需要初始化一个空的Node if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125;&#125; 有两种情况会致使插入队列失败： 1、tail为空：说明队列从未初始化，因此需要调用enq()方法在队列中插入一个空的Node。 2、compareAndSetTail()失败：说明插入过程中有线程修改了此队列，因此需要说明enq()将当前node重新插入到队列末端。 经过addWaiter方法之后，此时线程以Node的方式被加入到队列的末端，但是线程还没有被执行阻塞操作，真正的阻塞操作是在下面的acquireQueued()方法中判断执行。 2.3.2 acquireQueued在acquireQueued()方法中不会立即挂起该节点中的线程，因此在插入节点的过程中，之前持有锁的线程可能已经执行完毕并释放锁，所以这里使用自旋再次去尝试获取锁（不放过任何优化细节）。如果自旋操作还没没有获取到锁，那么就将该线程挂起（阻塞），该方法源码如下： 123456789101112131415161718192021222324252627282930/** * 在队列中的节点通过此方法获取锁 */final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); // 检测当前节点前驱是否head，这是试获取锁的资格。 // 如果是，则调用tryAcquire尝试获取锁， // 成功，则将head置为当前节点。 if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; // 如果未成功获取锁则根据前驱节点判断是否需要阻塞。 // 如果阻塞过程中被中断，则置interrupted标志位为true。 // shouldParkAfterFailedAcquire方法在前驱状态不为SINGAL的情况下都会循环重试获取锁。 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 可以看出在shouldParkAfterFailedAcquire()方法中会判断当前线程是否应该被挂起，代码如下： 1234567891011121314151617181920212223242526/** * 根据前驱节点中的waitStatus来判断是否需要阻塞当前线程。 */private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123; // 获取前驱节点的状态 int ws = pred.waitStatus; if (ws == Node.SIGNAL) // 如果是SINGAL状态，返回true，将当前线程挂起 return true; if (ws &gt; 0) &#123; /* * 前驱节点状态为取消，向前遍历，更新当前节点的前驱为往前一个非取消节点。 * 当前线程之后会再次回到循环并尝试获取锁。 */ do &#123; node.prev = pred = pred.prev; &#125; while (pred.waitStatus &gt; 0); pred.next = node; &#125; else &#123; /* * 等待状态为0或PROPAGATE(-3)，设置前驱的等待状态为SINGAL， * 并且之后会回到循环再次重试获取锁。 */ compareAndSetWaitStatus(pred, ws, Node.SIGNAL); &#125; return false;&#125; 首先获取前驱节点的waitStatus值，Node中的waitStatus一共有5种取值，分别代表的意义如下：|waitStatus值|意义||:-:|:–||CANCELLED(1)|当前线程因为超时或者中断被取消。这是一个终结状态，也就是状态到此为止||SIGNAL(-1)|当前线程的后继线程被阻塞或者即将被阻塞，当前线程释放锁或者取消后需要唤醒后继线程。这个状态一般都是后继线程来设置前驱节点的||CONDITION(-2)|当前线程在condition队列中||PROPAGATE(-3)|用于将唤醒后继线程继续传递下去，这个状态的引入是为了完善和增强共享锁的唤醒机制。在一个节点成为头节点之前，是不会跃迁为此状态的||0|表示无锁状态| 接下来根据waitStatus不同的值进行不同的操作，主要有以下几种情况： 如果waitStatus = SIGNAL，返回true，将当前线程挂起，等待后续唤醒操作即可。 如果waitStatus = CANCELLED，会将此前驱节点从队列中删除，并在循环中逐步寻找下一个不是CANCELLED状态的节点作为当前节点的前驱节点。 如果waitStatus既不是SIGNAL，也不是CANCELLED，则将当前节点的前驱节点状态设置为SIGNAL，这样做的好处是下一次执行shouldParkAfterFaildAcquire()时可以直接返回true，挂起线程。 代码再回到acquireQueued()中，如果shouldParkAfterFaileAcquire()返回true，表示线程需要被挂起，那么会继续调用parkAndCheckInterrupt()方法执行真正的阻塞线程代码，具体如下： 1234567891011private final boolean parkAndCheckInterrupt() &#123; LockSupport.park(this); return Thread.interrupted();&#125;public static void park(Object blocker) &#123; Thread t = Thread.currentThread(); setBlocker(t, blocker); UNSAFE.park(false, 0L); setBlocker(t, null);&#125; 在里面调用了LockSupport.park()。在LockSupport.park()中，调用了Unsafe API来执行底层native方法将线程挂起，代码到这里已经到了操作系统的层面。 至此，获取锁的大体流程已经分析完毕，总结： AQS的模板方法acquire()通过调用子类自定义实现的tryAcquire()获取锁； 如果获取锁失败，通过addWaiter()方法将线程构造成Node节点插入到同步队列队尾； 在acquireQueued()方法中以自旋的方式尝试获取锁，如果失败则判断是否需要将当前线程阻塞，如果需要阻塞则最终执行LockSupport(Unsafe)中的native API来实现阻塞线程。 2.4 释放锁流程分析在上面加锁阶段被阻塞的线程需要被唤醒之后才能重新执行。那具体AQS是何时尝试唤醒等待队列中被阻塞的线程呢？ 和加锁过程一样，释放锁需要从ReentrantLock.unlock()方法开始： 12345678910111213public void unlock() &#123; sync.release(1);&#125;public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; &#125; return false;&#125; 首先调用tryRelease()来尝试释放锁，如果成功，最终会调用AQS中的unparkSuccessor()方法来实现释放锁的操作。具体代码如下： 12345678910111213141516171819private void unparkSuccessor(Node node) &#123; // 获取头节点waitStatus int ws = node.waitStatus; if (ws &lt; 0) compareAndSetWaitStatus(node, ws, 0); // 获取当前节点（实际是head节点）的下一个节点 Node s = node.next; // 如果下一个节点是null或者下个节点是CANCEL状态，就找到队列最开始的非CALCEL的节点 if (s == null || s.waitStatus &gt; 0) &#123; s = null; // 从尾部节点开始找，到队首，找到队列第一个waitStatus &lt; 0的节点 for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; &#125; // 如果当前节点的下个节点不为空，而且状态 &lt;= 0，那就把当前节点unpark if (s != null) LockSupport.unpark(s.thread);&#125; 解释说明： 首先获取当前节点（实际上传入的是head节点）的状态，如果head节点的下一个节点是null，或者下一个节点的状态为CANCEL，则从等待队列的尾部开始遍历，直到寻找到第一个waitStatus &lt; 0的节点。 如果最终遍历的节点不为空，再调用LockSupport.unpark()方法，调用底层方法唤醒线程。至此，线程被唤醒的时机分析完毕。 2.5 不得不说的CAS不管在加锁还是释放锁阶段，都提到了通用的操作：compareAndSetXXX。这种操作最终会调用Unsafe中的API进行CAS操作。 CAS全称Compare And Swap，译为比较和替换，是一种通过硬件实现并发安全的常用技术，底层通过利用CPU的CAS指令对缓存加锁或总线加锁的方式实现多处理器之间的原子操作。 它的实现过程主要有3个操作数：内存值V、旧的预期值E、要修改的新值U，当且仅当预期值E和内存值V相同时，才将内存值V修改为U，否则什么都不做。 3. 自定义AQS通过自定义AQS来实现同步机制。 123456789101112131415161718192021222324252627282930public class MyLock &#123; private Sync sync = new Sync(); /** * 加锁 */ public void lock() &#123; sync.acquire(1); &#125; /** * 释放锁 */ public void unlock() &#123; sync.release(1); &#125; static class Sync extends AbstractQueuedSynchronizer &#123; @Override protected boolean tryAcquire(int arg) &#123; return compareAndSetState(0, 1); &#125; @Override protected boolean tryRelease(int arg) &#123; setState(0); return true; &#125; &#125;&#125; MyLock就是一个最简单的独占锁，通过使用MyLock也能实现同synchronized和ReentrantLock相同的功能。比如下面代码： 12345678910111213141516171819202122232425262728293031public class Test &#123; static int count = 0; static MyLock myLock = new MyLock(); public static void main(String[] args) throws InterruptedException &#123; testMyLock(); &#125; public static void testMyLock() throws InterruptedException &#123; Runnable runnable = () -&gt; &#123; try &#123; myLock.lock(); for (int i = 0; i &lt; 10000; i++) &#123; count++; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; myLock.unlock(); &#125; &#125;; Thread thread1 = new Thread(runnable); Thread thread2 = new Thread(runnable); thread1.start(); thread2.start(); thread1.join(); thread2.join(); System.out.println(count); &#125;&#125; 最终打印的count值为20000，说明两个线程之间是线程安全的同步操作。 4. 总结AQS是一套框架，在框架内部已经封装好了大部分同步需要的逻辑，在AQS内部维护了一个状态指示器state和一个等待队列Node，通过state的操作分为两种模式：独占模式和共享模式。导致AQS有两种不同的实现：独占锁(ReentrantLock等)和分享锁(CountDownLatch、读写锁等)。这里主要从独占锁的角度分析了AQS的加锁和释放锁的流程。 理解AQS的原理对理解JUC包中其他组件实现的基础有帮助，并且理解其原理才能更好的扩展其功能。上层开发人员可以基于此框架基础上进行扩展实现适合不同场景、不同功能的锁。其中几个有可能需要子类同步器实现的方法如下。 lock()。 tryAcquire()：独占方式。尝试获取资源，成功则返回true，失败则返回false。 tryRelease()：独占方式。尝试释放资源，成功则返回true，失败则返回false。 tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。 tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待节点返回true，否则返回false。","categories":[{"name":"Android","slug":"Android","permalink":"https://tylerLiu.top/categories/Android/"},{"name":"进阶","slug":"Android/进阶","permalink":"https://tylerLiu.top/categories/Android/进阶/"}],"tags":[{"name":"JVM与DVM必知必会","slug":"JVM与DVM必知必会","permalink":"https://tylerLiu.top/tags/JVM与DVM必知必会/"}]},{"title":"（拉钩）Android工程师进阶34讲-09：Java线程优化之偏向锁，轻量级所锁、重量级锁","slug":"（拉钩）Android工程师进阶34讲-09：Java线程优化之偏向锁，轻量级所锁、重量级锁","date":"2020-07-17T02:51:48.000Z","updated":"2020-07-23T02:45:43.662Z","comments":true,"path":"2020/07/17/（拉钩）Android工程师进阶34讲-09：Java线程优化之偏向锁，轻量级所锁、重量级锁/","link":"","permalink":"https://tylerLiu.top/2020/07/17/（拉钩）Android工程师进阶34讲-09：Java线程优化之偏向锁，轻量级所锁、重量级锁/","excerpt":"","text":"0. 前言Java的线程是映射到操作系统原生线程之上的，如果要阻塞或唤醒一个线程就需要操作系统的帮忙，这就要从用户态转换到核心态，而状态转换需要花费很多处理器的时间。 比如下面代码： 12345678private Object lock = new Object();private int value;public void setValue()&#123; synchronized(lock)&#123; value++; &#125;&#125; value++因为被关键字synchronized修饰，所以会在各个线程之间同步执行。但是value++消耗的时间很有可能比线程状态转换消耗的时间还要短，所以说synchronized是Java语言的重量级操作。 1. Synchronized实现原理先了解两个基础概念：对象头和Monitor。 1.1 对象头在《大话Java对象在虚拟机中是什么样子？》中提到了Java对象在内存中的布局分为三部分：对象头、实例数据、对齐填充。当在Java代码中，使用new创建一个对象时，JVM会在堆中创建一个instanceOopDesc对象，这个对象中包含了对象头以及实例数据。 instanceOopDesc的基类是oopDesc。结构如下： 123456789class oopDesc&#123; friend class VMStructs; private: volatile markOop _mark; union _metadata&#123; wideKlassOop _klass; narrowOop _compressed_klass; &#125; _metadata;&#125; 其中_mark和_meatdata一起组成对象头。_metadata主要保存了类元数据，不需要做过多介绍。这里重点看一下_mark属性，_mark是markOop类型数据，一般称它为标记字段(Mark Word)，其中主要存储了对象的hashCode、分代年龄、锁标志位、是否偏向锁等。 用一张图来表示32位Java虚拟机的Mark Word的默认存储结构如下： 默认情况下，没有线程进行加锁操作，所以锁对象中的Mark Word处于无锁状态。但是考虑到JVM的空间效率，Mark Word被设计成一个非固定的数据结构，以便存储更多的有效数据，它会根据对象本身的状态复用自己的存储空间，如32位JVM下，除了上述列出的Mark Word默认存储结构外，还有如下可能变化的结构： 从图中可以看出，根据“锁标志位”以及“是否为偏向锁”，Java中的锁可以分为以下几种状态： 是否为偏向锁 锁标志位 锁状态 0 01 无锁 1 01 偏向锁 0 00 轻量级锁 0 10 重量级锁 0 11 GC标记 Java6之前，并没有轻量级锁和偏向锁，只有重量级锁，也就是通常所说的synchronized的对象锁，锁标记位为10。从图中的描述可以看出：当锁是重量级锁时，对象头中Mark Word会用30 bit来指向一个“互斥量”，而这个互斥量就是Monitor。 1.2 Monitor可以把它理解成是一个同步工具，也可以描述为一种同步机制。实际上，它是一个保存在对象头中的一个对象。在markOop中有如下代码： 123456789bool has_monitor() const&#123; return ((value() &amp; monitor_value) != 0);&#125;ObjectMonitor* monitor() const&#123; assert(has_monitor(), &quot;check&quot;); // Use xor instead of &amp;~ to provide one extra tag-bit check. return (ObjectMonitor*) (value() ^ monitor_value);&#125; 通过monitor()创建一个ObjectMonitor对象，而ObjectMonitor就是Java虚拟机中的Monitor的具体实现。因此Java中每个对象都会有一个对应的ObjectMonitor对象，这也是Java中所有Object都可以作为锁对象的原因。 ObjectMonitor是如何实现同步机制的？ 首先看ObjectMonitor的结构： 其中几个比较关键的属性： _owner：指向持有ObjectMonitor对象的线程。 _WaitSet：存放处于wait状态的线程队列。 _EntryList：存放处于等待锁block状态的线程队列。 _recursions：锁的重入次数。 _count：用来记录该线程获取锁的次数。 当多个线程访问同一段同步代码时，首先会进入_EntryList队列中，当某个线程通过竞争获取到对象的monitor后，monitor会把_owner变量设置为当前线程，同时monitor中的计数器_count加1，即获得对象锁。 若持有monitor的线程调用wait()方法，将释放当前持有的monitor，_owner变量恢复为null，_count减1，同时该线程进入_WaitSet集合中等待被唤醒。若当前线程执行完毕也将释放monitor（锁）并复位变量的值，以便其他线程进入获取monitor（锁）。 1.3 实例演示比如以下代码通过三个线程分别执行以下同步代码块： 1234567private Object lock = new Object();public void syncMethod()&#123; synchronized(lock)&#123; // do something &#125;&#125; 锁对象是lock对象，在JVM中会有一个ObjectMonitor对象与之呼应。如下图： 分别使用三个线程来执行以上同步代码块。默认情况下，三个线程都会进入ObjectMonitor中的EntrySet队列中，如下： 假设线程2首先通过竞争获取到锁对象，则ObjectMonitor中的Owner指向线程2，并将count加1。结果如下： 上图中Owner指向线程2表示它已经成功获取到锁(Monitor)对象，其他线程只能处于阻塞(blocking)状态。如果线程2在执行过程中调用wait()操作，则线程2会释放(Monitor)对象，以便其他线程进入获取锁(Monitor)对象，Owner变量恢复为null，count做减1操作，同时线程2会添加到WaitSet集合，进入等待(waiting)状态并等待被唤醒。结果如下： 然后线程1和线程3再次通过竞争获取到锁(Monitor)对象，则重新将Owner指向成功获取到锁的线程。假设线程1获取到锁，如下： 如果在线程1执行过程中调用notify操作将线程1唤醒，则当前处于WaitSet中的线程2会被重新添加到EntrySet集合中，并尝试重新回去竞争锁(Monitor)对象。但是notify操作并不会是线程1释放锁(Monitor)对象。结果如下： 当线程1中的代码执行完毕以后，同样会自动释放锁，以便其他线程再次获取锁对象。 实际上，ObjectMonitor的同步机制是JVM对操作系统级别的 Mutex Lock（互斥锁）的管理过程，其间都会转入操作系统内核态。也就是说synchronized实现锁，在“重量级锁”状态下，当多个线程之间切换上下文时，还是一个比较重量级的操作。 2. Java虚拟机对synchronized的优化从Java 6开始，虚拟机对synchronized关键字做了多方面的优化，主要目的是，避免ObjectMonitor的访问，减少“重量级锁”的使用次数，并最终减少线程上下文切换的频率。其中主要做了以下几个优化：锁自旋、轻量级锁、偏向锁。 2.1 锁自旋线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，会给系统的并发性能带来很大的压力，所以Java引入了自旋锁的操作。实际上自旋锁在Java 1.4就被引入了，默认关闭，但是可以使用参数-XX:UseSpinning将其开启。但是从Java 6以后，默认开启。 所谓自旋，就是让该线程等待一段时间，不会被立即乖挂起，看当前持有锁的线程是否很快释放锁。而所谓的等待就是执行一段无意义的循环即可（自旋）。 自旋锁的缺陷：自旋锁要占用CPU，如果锁竞争的时间比较长，那么自旋通常不能获得锁，浪费自旋占用的CPU时间。这通常发生在锁持有时间长，且竞争激烈的场景，此时应主动禁用自旋锁。 2.2 轻量级锁有时Java虚拟机会出现这种情形：对于一块同步代码块，虽然有多个不同线程去执行，但是这些线程是在不同额时间段交替请求这把锁对象，也就是不存在竞争锁的现象。这时，锁会保持轻量级所得状态，避免重量级锁的阻塞和唤醒操作。 要了解轻量级锁的工作流程，需要再次看下对象头中的Mark Work。上文中已经提到，锁的标志位包含几种情况：00代表轻量级锁、01代表无锁（或偏向锁）、10代表重量锁、11是跟垃圾回收算法的标记有关。 当线程执行某段同步代码时，Java虚拟机会在当前线程的栈帧中开辟一块空间(Lock Record)作为该锁的记录，如下图所示： 然后Java虚拟机会尝试使用CAS(Compare And Swap)操作，将锁对象的Mark Word拷贝到这块空间中，并且将锁记录中的owner指向Mark Word。结果如下： 当线程再次执行此同步代码块时，判断当前对象的Mark Word是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象的锁，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占，这时轻量级锁需要膨胀为重量级锁。 轻量级锁适应的场景是线程交替执行同步快的场合，如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁。 2.3 偏向锁轻量级锁是在没有锁竞争情况的锁状态，但是有时锁不仅存在多线程的竞争，而且总有由同一个线程获得。因此为了让线程获得锁的代价更低，引入了偏向锁。偏向锁的意思是如果一个线程获得了一个偏向锁，如果在接下来的一段时间中没有其他线程来竞争锁，那么持有偏向锁的线程再次进入或退出同一个同步代码块，不需要再次进行抢占和释放锁的操作。偏向锁可以通过-XX:UseBiasedLocking开始或关闭。 偏向锁的具体实现就是在锁对象的对象头中有个ThreadId字段，默认情况下这个字段是空的，当第一次获取锁的时候，就将自身的ThreadId写入锁对象的Mark Word中的ThreadId字段内，将是否偏向锁的状态置位为01。这样下次获取锁的时候，直接检查ThreadId是否和自身线程Id一致，如果一致，则认为当前线程已经获取了锁，因此不需要再获取锁，略过轻量级锁和重量级锁的加锁阶段，提高效率。 其实偏向锁并不适合所有应用场景，因为一旦锁竞争，偏向锁会被撤销，并膨胀为重量级锁，而撤销锁操作(revoke)是比较重的行为，只有当存在较多不会真正竞争的synchronized块时，才能体现出明显改善；因此实践中，还需要考虑具体业务场景，并测试后，在决定是否开启偏向锁。 对于锁的几种状态转换的源码分析，可以参考：源码分析Java虚拟机中锁膨胀的过程。 3. 总结本节主要介绍Java中锁的几种状态，其中偏向锁和轻量级锁都是通过自旋等技术避免真正的加锁，而重量级锁才是获取锁和释放锁，重量级锁通过对象内部的监听器(ObjectMonitor)实现，其本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，成本很高。实际上Java对锁的优化还是“锁消除”，但“锁消除”是基于Java对象逃逸分析的，可以查看Java逃逸分析。","categories":[{"name":"Android","slug":"Android","permalink":"https://tylerLiu.top/categories/Android/"},{"name":"进阶","slug":"Android/进阶","permalink":"https://tylerLiu.top/categories/Android/进阶/"}],"tags":[{"name":"JVM与DVM必知必会","slug":"JVM与DVM必知必会","permalink":"https://tylerLiu.top/tags/JVM与DVM必知必会/"}]},{"title":"（拉钩）Android工程师进阶34讲-08：Synchronized与ReentrantLock","slug":"（拉钩）Android工程师进阶34讲-08：Synchronized与ReentrantLock","date":"2020-07-14T03:26:12.000Z","updated":"2020-07-17T02:48:32.400Z","comments":true,"path":"2020/07/14/（拉钩）Android工程师进阶34讲-08：Synchronized与ReentrantLock/","link":"","permalink":"https://tylerLiu.top/2020/07/14/（拉钩）Android工程师进阶34讲-08：Synchronized与ReentrantLock/","excerpt":"","text":"1. SynchronizedSynchronized可以用来修饰以下三个层面： 修饰实例方法； 修饰静态类方法； 修饰代码块。 1.1 Synchronized修饰实例方法1234567public class LagouSynchronizedMethods &#123; private int sum = 0; public synchronized void calculate() &#123; sum = sum + 1; &#125;&#125; 这种情况下锁的对象是当前实例对象，因此只有同一个实例对象调用此方法才会产生效果，不同实例对象之间不会有互斥效果。如下代码： 1234567891011121314151617181920212223public class LagouSynchronizedMethods &#123; public static void main(String[] args) &#123; LagouSynchronizedMethods l1 = new LagouSynchronizedMethods(); LagouSynchronizedMethods l2 = new LagouSynchronizedMethods(); Thread t1 = new Thread(l1::printLog); Thread t2 = new Thread(l2::printLog); t1.start(); t2.start(); &#125; public synchronized void printLog() &#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(Thread.currentThread().getName() + \" is printing \" + i); Thread.sleep(300); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 上述代码，在不同线程中调用的是不同对象的printLog方法，因此彼此之间不会排斥。运行结果如下： 12345678910Thread-1 is printing 0Thread-0 is printing 0Thread-0 is printing 1Thread-1 is printing 1Thread-1 is printing 2Thread-0 is printing 2Thread-1 is printing 3Thread-0 is printing 3Thread-0 is printing 4Thread-1 is printing 4 可以看到，两个线程是交互执行的。 如果将代码修改如下，两个线程调用一个对象的printLog方法： 12345678910111213141516171819202122public class LagouSynchronizedMethods &#123; public static void main(String[] args) &#123; LagouSynchronizedMethods l1 = new LagouSynchronizedMethods(); Thread t1 = new Thread(l1::printLog); Thread t2 = new Thread(l1::printLog); t1.start(); t2.start(); &#125; public synchronized void printLog() &#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(Thread.currentThread().getName() + \" is printing \" + i); Thread.sleep(300); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 打印如下： 12345678910Thread-0 is printing 0Thread-0 is printing 1Thread-0 is printing 2Thread-0 is printing 3Thread-0 is printing 4Thread-1 is printing 0Thread-1 is printing 1Thread-1 is printing 2Thread-1 is printing 3Thread-1 is printing 4 可以看出，只有当一个线程中的代码执行完毕后，才会调用另一个线程中的代码。此时两个线程间是互斥的。 1.2 Synchronized修饰静态类方法如果synchronized修饰的是静态方法，则锁对象是当前类的Class对象，因此即使在不同线程间调用不同实例对象，也会有互斥效果。代码如下： 1234567891011121314151617181920212223public class LagouSynchronizedMethods &#123; public static void main(String[] args) &#123; LagouSynchronizedMethods l1 = new LagouSynchronizedMethods(); LagouSynchronizedMethods l2 = new LagouSynchronizedMethods(); Thread t1 = new Thread(() -&gt; l1.printLog()); Thread t2 = new Thread(() -&gt; l2.printLog()); t1.start(); t2.start(); &#125; public static synchronized void printLog() &#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(Thread.currentThread().getName() + \" is printing \" + i); Thread.sleep(300); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 打印如下： 12345678910Thread-0 is printing 0Thread-0 is printing 1Thread-0 is printing 2Thread-0 is printing 3Thread-0 is printing 4Thread-1 is printing 0Thread-1 is printing 1Thread-1 is printing 2Thread-1 is printing 3Thread-1 is printing 4 两个线程是依次执行的。 1.3 Synchronized修饰代码块代码如下： 12345678910111213141516171819202122public class LagouSynchronizedMethods &#123; private Object lock = new Object(); public static void main(String[] args) &#123; LagouSynchronizedMethods l1 = new LagouSynchronizedMethods(); Thread t1 = new Thread(l1::printLog); Thread t2 = new Thread(l1::printLog); t1.start(); t2.start(); &#125; public void printLog() &#123; synchronized (lock) &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(Thread.currentThread().getName() + \" is printing \" + i); &#125; &#125; &#125;&#125; synchronized作用于代码块，锁对象就是紧跟在后面括号中的对象。上图可以看出任何Object对象都可以当做锁对象。 1.4 实现细节synchronized既可以作用于方法，也可以作用于某一代码块。但在实现上是有区别的。比如以下代码，使用synchronized作用于代码块： 123456789public class Foo &#123; private int number; public void test1() &#123; int i = 0; synchronized (this) &#123; number = i + 1; &#125; &#125;&#125; 使用javap查看test1方法的字节码，可以看出，编译而成的字节码中会包含monitorenter和monitorexit这两个字节码指令。如下： 12345678910111213141516171819202122232425public void test1(); descriptor: ()V flags: ACC_PUBLIC Code: stack=3, locals=4, args_size=1 0: iconst_0 1: istore_1 2: aload_0 3: dup 4: astore_2 5: monitorenter 6: aload_0 7: iload_1 8: iconst_1 9: iadd 10: putfield #2 // Field number:I 13: aload_2 14: monitorexit 15: goto 23 18: astore_3 19: aload_2 20: monitorexit 21: aload_3 22: athrow 23: return 上面字节码中有1个monitorenter和2个monitorexit。这是因为虚拟机需要保证当异常发生时也能释放锁。因此2个monitorexit，一个是代码正常执行结束后释放锁，一个是代码执行异常时释放锁。 再来看看synchronized修饰方法有哪些区别： 123456public class Foo &#123; public synchronized void test1() &#123; int i = 0; i = i + 1; &#125;&#125; 以上代码经过编译之后，字节码如下： 123456789101112public synchronized void test1(); descriptor: ()V flags: ACC_PUBLIC, ACC_SYNCHRONIZED Code: stack=2, locals=2, args_size=1 0: iconst_0 1: istore_1 2: iload_1 3: iconst_1 4: iadd 5: istore_1 6: return 可以看出，被synchronized修饰的方法在被编译成字节码后，在方法的flags属性中会被标记为ACC_SYNCHRONIZED。当虚拟机访问一个被标记为ACC_SYNCHRONIZED的方法时，会自动在方法的开始和结束（或异常）位置添加monitorenter和monitorexit指令。 关于monitorenter和monitorexit，可以理解为一把具体的锁。在这个锁中保存着两个比较重要的属性：计数器和指针。 计数器：表示当前线程一共访问几次这把锁。 指针：指向持有这把锁的线程。 锁计数器默认为0，当执行monitorenter指令时，如锁计数器为0，说明这把锁没有被其他线程持有。那么线程会将计数器加1，并将锁中的指针指向自己。当执行monitorexit指令时，会将计数器减1。 2. ReentrantLock2.1 ReentrantLock基本使用ReentrantLock的用法和synchronized有点不同，它的加锁和解锁操作都需要手动完成，如下： 12345678910111213141516171819202122232425262728import java.util.concurrent.locks.ReentrantLock;public class LagouReentrantLockTest &#123; ReentrantLock lock = new ReentrantLock(); public static void main(String[] args) &#123; LagouReentrantLockTest l1 = new LagouReentrantLockTest(); Thread t1 = new Thread(l1::printLog); Thread t2 = new Thread(l1::printLog); t1.start(); t2.start(); &#125; public void printLog() &#123; try &#123; lock.lock(); for (int i = 0; i &lt; 5; i++) &#123; System.out.println(Thread.currentThread().getName() + \" is printing \" + i); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 运行效果如下： 12345678910Thread-0 is printing 0Thread-0 is printing 1Thread-0 is printing 2Thread-0 is printing 3Thread-0 is printing 4Thread-1 is printing 0Thread-1 is printing 1Thread-1 is printing 2Thread-1 is printing 3Thread-1 is printing 4 2.2 公平锁实现ReentrantLock有一个带参的构造器： 123456789/** * Creates an instance of &#123;@code ReentrantLock&#125; with the * given fairness policy. * * @param fair &#123;@code true&#125; if this lock should use a fair ordering policy */public ReentrantLock(boolean fair) &#123; sync = fair ? new FairSync() : new NonfairSync();&#125; 默认情况下，synchronized和ReentrantLock都是非公平锁。但是ReentrantLock可以通过传入true来创建一个公平锁。所谓公平锁就是通过同步队列来实现多个线程按照申请锁的顺序获取锁。 公平锁实例： 12345678910111213141516171819202122232425262728293031import java.util.concurrent.locks.ReentrantLock;public class LagouFairLockTest implements Runnable &#123; private int shareNumber = 0; // 创建公平锁 private static ReentrantLock lock = new ReentrantLock(true); @Override public void run() &#123; while (shareNumber &lt; 20) &#123; lock.lock(); try &#123; shareNumber++; System.out.println(Thread.currentThread().getName() + \" 获得锁，shareNumber is \" + shareNumber); &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; public static void main(String[] args) &#123; LagouFairLockTest lft = new LagouFairLockTest(); Thread t1 = new Thread(lft); Thread t2 = new Thread(lft); Thread t3 = new Thread(lft); t1.start(); t2.start(); t3.start(); &#125;&#125; 打印如下： 12345678910111213141516171819202122Thread-0 获得锁，shareNumber is 1Thread-1 获得锁，shareNumber is 2Thread-0 获得锁，shareNumber is 3Thread-1 获得锁，shareNumber is 4Thread-0 获得锁，shareNumber is 5Thread-1 获得锁，shareNumber is 6Thread-2 获得锁，shareNumber is 7Thread-0 获得锁，shareNumber is 8Thread-1 获得锁，shareNumber is 9Thread-2 获得锁，shareNumber is 10Thread-0 获得锁，shareNumber is 11Thread-1 获得锁，shareNumber is 12Thread-2 获得锁，shareNumber is 13Thread-0 获得锁，shareNumber is 14Thread-1 获得锁，shareNumber is 15Thread-2 获得锁，shareNumber is 16Thread-0 获得锁，shareNumber is 17Thread-1 获得锁，shareNumber is 18Thread-2 获得锁，shareNumber is 19Thread-0 获得锁，shareNumber is 20Thread-1 获得锁，shareNumber is 21Thread-2 获得锁，shareNumber is 22 可以看出，创建的3个线程按照顺序去修改shareNumber的值。 2.2 读写锁(ReentrantReadWriteLock)开发中，经常定义一个线程间共享的用作缓存的数据结构，比如一个较大的Map。缓存中保存了全部的城市id和城市name对应关系。这个大Map绝大部分时间提供读服务（根据城市id查询城市名称等）。而写操作占有的时间很少，通常是在服务启动时初始化，然后可以每隔一段时间再刷新缓存的数据。但是写操作开始到结束之间，不能再有其他读操作进来，并且写操作完成之后的更新数据需要对后续的读操作可见。 在没有读写锁支持的时候，如果想要实现上面的功能，需要使用Java的等待通知机制，就是当写操作开始时，所有晚于写操作的读操作都会进入等待状态，只有写操作完成并进行通知之后，所有等待的读操作才能继续执行。这样做的目的是使读操作能读取到正确的数据。 但是如果使用concurrent包中的读写锁(ReentrantReadWriteLock)实现上面的功能，就只需要在读操作时获取读锁，写操作时获取写锁即可。当写锁被获取到时，后续的读写锁都会被阻塞，写锁释放之后，所有操作继续执行，这种编程方式相对于使用等待通知机制而言，更加简明。 下面，看看读写锁(ReentrantReedWriteLock)如何使用： 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.concurrent.locks.ReentrantReadWriteLock;public class LagouReentrantReadWriteLockTest &#123; // 创建读写锁对象 private static final ReentrantReadWriteLock lock = new ReentrantReadWriteLock(true); private static String number = \"0\"; public static void main(String[] args) &#123; Thread t1 = new Thread(new Reader(), \"读线程 1\"); Thread t2 = new Thread(new Reader(), \"读线程 2\"); Thread t3 = new Thread(new Writer(), \"写线程\"); t1.start(); t2.start(); t3.start(); &#125; static class Reader implements Runnable &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; // 使用读锁对读操作加锁 lock.readLock().lock(); System.out.println(Thread.currentThread().getName() + \" ---&gt; Number is \" + number); lock.readLock().unlock(); &#125; &#125; &#125; static class Writer implements Runnable &#123; @Override public void run() &#123; for (int i = 1; i &lt;= 7; i += 2) &#123; try &#123; // 使用写锁对写操作加锁 lock.writeLock().lock(); System.out.println(Thread.currentThread().getName() + \" is writing \" + i); number = number.concat(\"\" + i); &#125; finally &#123; lock.writeLock().unlock(); &#125; &#125; &#125; &#125;&#125; 打印如下： 123456789101112131415161718192021222324读线程 1 ---&gt; Number is 0读线程 2 ---&gt; Number is 0读线程 1 ---&gt; Number is 0写线程 is writing 1读线程 2 ---&gt; Number is 01读线程 1 ---&gt; Number is 01写线程 is writing 3读线程 2 ---&gt; Number is 013读线程 1 ---&gt; Number is 013写线程 is writing 5读线程 2 ---&gt; Number is 0135读线程 1 ---&gt; Number is 0135写线程 is writing 7读线程 2 ---&gt; Number is 01357读线程 1 ---&gt; Number is 01357读线程 1 ---&gt; Number is 01357读线程 2 ---&gt; Number is 01357读线程 1 ---&gt; Number is 01357读线程 1 ---&gt; Number is 01357读线程 1 ---&gt; Number is 01357读线程 2 ---&gt; Number is 01357读线程 2 ---&gt; Number is 01357读线程 2 ---&gt; Number is 01357读线程 2 ---&gt; Number is 01357 3. 总结Java同步实现的两个方式： synchronized：使用简单，加锁和释放锁都是由虚拟机自动完成。 ReentrantLock：需要开发者手动加锁和释放锁。但使用场景更多，公平锁还可以通过读写锁(ReentrantReadWriteLock)来实现。","categories":[{"name":"Android","slug":"Android","permalink":"https://tylerLiu.top/categories/Android/"},{"name":"进阶","slug":"Android/进阶","permalink":"https://tylerLiu.top/categories/Android/进阶/"}],"tags":[{"name":"JVM与DVM必知必会","slug":"JVM与DVM必知必会","permalink":"https://tylerLiu.top/tags/JVM与DVM必知必会/"}]},{"title":"（拉钩）Android工程师进阶34讲-07：Java内存模型与线程","slug":"（拉钩）Android工程师进阶34讲-07：Java内存模型与线程","date":"2020-07-09T06:44:24.000Z","updated":"2020-07-14T03:22:59.814Z","comments":true,"path":"2020/07/09/（拉钩）Android工程师进阶34讲-07：Java内存模型与线程/","link":"","permalink":"https://tylerLiu.top/2020/07/09/（拉钩）Android工程师进阶34讲-07：Java内存模型与线程/","excerpt":"","text":"0. 前言Java内存模型翻译自Java Memory Model，简称JMM，它所描述的是多线程并发、CPU缓存等方面的内容。 1. 为什么有Java内存模型很多介绍JMM时，会借用《深入理解Java虚拟机》中的一张图。 上图描述的意思是，在每一个线程中，都会有一块内部的工作内存（working memory）。这块工作内存保存了主内存共享数据的拷贝副本。第一节中，了解到JVM内存结构中有一块线程独享的内存空间——虚拟机栈，这里自然而然就会将线程工作内存理解成虚拟机栈。 但是，这是不准确的！虚拟机栈和线程的工作内存并不是一个概念。在Java线程中并不存在所谓的工作内存，它只是对CPU寄存器和高速缓存的抽象描述。 1.1 CPU普及线程是CPU调度的最小单位，线程中的字节码指令最终都是在CPU中执行的。CPU在执行的时候，免不了要和各种数据打交道，而Java中所有数据都存放在主内存(RAM)中的，这一过程可以参考下图： 随着CPU技术的发展，CPU的执行速度越来越快，但内存的技术并没有太大变化，所以在内存中读取和写入数据的过程和CPU的执行速度比起来差距会越来越大。CPU对主内存的访问需要等待较长时间，这样就体现不出CPU超强的运算能力的优势了。 为了“压榨”处理性能，达到“高并发”的效果，在CPU中添加高速缓存(cache)来作为缓冲。 在执行任务时，CPU会先将运算所需要使用到的数据复制到高速缓存中，让运算能快速进行，当运算完成之后，再将缓存中的结果刷回(flush back)主内存，这样CPU就不用等待主内存的读写操作了。 但是这样也有问题。每个处理器都有自己的高速缓存，同时又共同操作同一块主内存，当多个处理器同时操作主内存时，可能导致数据不一致，这就是缓存一致性问题。 1.2 缓存一致性问题现在市面上手机通常有两个或多个CPU，一些CPU还有多核。每个CPU在某一时刻都能运行一个线程，这意味着，如果Java程序是多线程的，那么就有可能存在多个线程在同一时刻被不同CPU执行的情况。 如下代码： 123456789101112131415161718192021public int x = 0;public int y = 0;Thread t1 = new Thread() &#123; @Override public void run() &#123; int r1 = x; y = 1; &#125;&#125;;Thread t2 = new Thread() &#123; @Override public void run() &#123; int r2 = y; x = 2; &#125;&#125;;t1.start();t2.start(); 定义两个变量x和y，初始值都为0。 在线程t1中，将x赋值给r1，然后将y设置为1。 在线程t2中，将y赋值给r2，然后将x设置为2。 假设一台设备上有2个CPU，分别为C1和C2，将上面这段代码在这台设备上执行，最后打印r1和r2的值分别为多少？答案是不确定。 情况1： 假设t1现在C1中执行完毕，并成功刷回主内存中，此时r1 = 0，x = 0，y = 1。 然后t2在C2中执行，从主内存中加载y = 1并赋值给r2，此时r2 = 1，x = 2，y = 1。 情况2： 假设t2现在C1中执行完毕，并成功刷回主内存中，此时r2 = 0，x = 2，y = 0。 然后t1在C2中执行，从主内存中加载y = 1并赋值给r2，此时r1 = 2，x = 2，y = 1。 情况3： x和y的值分别缓存在C1和C2的缓存中。 首先t1在C1中执行完毕，但是没有将结果刷回主内存中，此时主内存中x = 0，y = 0。 然后t2在C2中执行，缓存中的y = 0，并将其赋值给r2，此时r2 = 0，x = 2，y = 1。 如下图： 可以看出，虽然在C1和C2的缓存中，分别修改了x和y的值，但是并未将它刷回主内存中，这就是缓存一致性问题。 1.3 指令重排除了缓存一致性问题，还有另外一个硬件问题：为了使CPU内部的运算单元能尽量被充分利用，处理器可能会对输入的字节码指令进行重排序处理，也就是处理器优化。除了CPU之外，很多编程语言的编译器也会有类似的优化，比如Java虚拟机的即使编译(JIT)也会做指令重排。 以下面代码为例： 编译之后的字节码指令如下： 可以看出，在上述指令中，有两处指令表达的是同样的语义，并且指令7并不依赖指令2和指令3。在这种情况下，CPU会对指令的顺序做优化，如下： 从Java是语言的角度看这层优化就是： 也就是说在CPU层面，有时代码并不会严格按照Java文件中的顺序执行。再看一下之前r1/r2的实例，刚才分析了会有三种情况发生，其实在极端情况下，还会出现第4种情况： r1 = 2，r2 = 1 线程t2中的代码经过CPU优化之后，会被重排为： 经过优化之后，t2线程将x赋值为2，这时CPU将时间片段分配给线程t1，线程t1在执行过程中，将r1赋值为x，此时x = 2，所以r1 = 2。然后将y赋值为1，此时CPU再将时间片段重新分配给t2。 代码回到t2中，将y赋值给r2，此时y = 1，所以r2 = 1，整个过程如下图： 上面两小部分的内容表明，如果任由CPU优化或编译器指令重排，那编写的Java代码最终执行效果可能会出现偏差。为了解决这个问题，让Java在不同硬件、不同操作系统中，输出的结果达到一致，Java虚拟机规范了一套机制——Java内存模型。 2. 什么是内存模型内存模型是一套共享内存中多线程读写操作行为的规范，这套规范屏蔽了底层各种硬件和操作系统的内存访问差异，解决了CPU多级缓存、CPU优化、指令重排等导致的内存访问问题，从而保证Java程序（尤其是多线程程序）在各种平台下对内存的访问效果一致。 在Java内存模型中，统一用工作内存(working memory)来当做CPU中寄存器或高速缓存的抽象。线程之间的共享变量存储在主内存(main memory)中，每个线程都有一个私有的工作内存（类比CPU中的寄存器或高速缓存），本地工作内存中存储了该线程读/写共享变量的副本。 这套规范中有一个非常重要的规则——happens-before。 happens-before 先行发生原则happens-before用于描述两个操作的内存可见性，通过保证可见性的机制可以让应用程序免于数据竞争干扰。它的定义如下： 如果一个操作A happens-before 另一个操作B，那么操作A的执行结果将对操作B可见。 上述定义也可以反过来理解：如果操作A的结果需要对另一个操作B可见，那么操作A必须happens-before 操作B。 用以下代码举例： 123456789private int value = 0;public void setValue(int value) &#123; value = 1;&#125;public int getValue() &#123; return value;&#125; 假设setValue就是操作A，getValue就是操作B。如果先后在两个线程中调用A和B，那最后在B操作中返回的value值是多少呢？有以下两种情况： 如果 A happens-before B不成立 也就是说当线程调用操作B(getValue)时，即使操作A(setValue)已经在其他线程中被调用过，并且value也被成功设置为1，但这个修改对于操作B(getValue)仍然是不可见的。根据之前介绍的CPU缓存，value值有可能返回0，也可能返回1。 如果 A happens-before 成立 根据 happens-before 的定义，先行发生动作的结果，对后续发生动作是可见的。也就是说如果先在一个线程中调用操作A(setValue)，那个这个修改的结果对后续的操作B(getValue)始终可见。因此先调用setValue为value赋值1之后，后续在其他线程中调用getValue的值一定是1。 那么Java中两个操作如何就算符合 happens-before 规则呢？JMM中定义了以下几种情况实时自动符合 happens-before 规则的： 程序次序规则在单线程内部，如果一段代码的字节码顺序也隐式符合 happens-before 原则，那么逻辑顺序靠前的字节码执行结果一定对后续逻辑字节码可见，只是后续逻辑中不一定用到而已。比如下面代码： 12int a = 10; // 1b = b + 1; // 2 当代码执行到2时，a = 10这个结果已经可见，至于用没用到a这个结果，则不一定。比如上面的代码就没用到，说明b对a的结果没有依赖，这样就有可能发生指令重排。 但如果将代码修改如下，就不会发生指令重排优化： 12int a = 10; // 1b = b + a; // 2 锁定规则无论在单线程环境还是多线程环境，一个锁如果处于被锁状态，那么必须先执行unlock操作后才能进行lock操作。 变量规则volatile保证了线程可见性。通俗讲就是如果一个线程先写了一个volatile变量，然后另外一个线程去读这个变量，那么这个写操作一定是 happens-before 读操作的。 线程启动规则Thread对象的start()方法先行发生于此线程的每个动作。假定线程A执行过程中，通过执行ThreadB.start()来启动线程B，那么线程A对共享变量的修改在线程B开始执行后确保对线程B可见。 线程中断规则对线程interrupt()方法的调用先行发生于被中断线程的代码检测，直到中断事件的发生。 线程终结规则线程中所有的操作都发生在线程的终止检测之前，可以通过Thread.join()方法结束、Thread.isAlive()的返回值等方法检测线程是否终止执行。假定线程A在执行过程中，通过调用Thread.join()等待线程B终止，那么线程B在终止之前对共享变量的修改在线程A等待返回后可见。 对象终结规则一个对象的初始化完成发生在它的finalize()方法开始之前。 此外，happens-before 原则还具有传递性L如果操作 A happens-before 操作B，而操作 B happens-before 操作 C，则操作 A happens-before 操作 C。 3. Java内存模型的应用上面介绍的 happens-before 原则很重要，它是判断数据是否存在竞争、线程是否安全的主要依据，根据这个原则，可以解决在并发环境下操作之间是否可能存在冲突的问题。在此基础上，可以通过Java提供的一系列关键字，实现多线程操作 “happens-before化”。 3.1 使用volatile修饰value123456789private volatile int value = 0;public void setValue(int value) &#123; value = 1;&#125;public int getValue() &#123; return value;&#125; 3.2 使用synchronized关键字12345678910111213private int value = 0;public void setValue(int value) &#123; synchronized (this) &#123; value = 1; &#125;&#125;public int getValue() &#123; synchronized (this) &#123; return value; &#125;&#125; 通过以上两种方式，都可以使setValue和getValue符合 happens-before 原则——当在某一线程中调用setValue后，再在其他线程中调用getValue获取的值一定是1。 4. 总结 Java内存模型的来源：主要是因为CPU缓存和指令重排等优化导致多线程程序结果不可控。 Java内存模型是什么：本质上它是一套规范，在这套规范中有一条最重要的 happens-before 原则。 Java内存模型的使用，介绍了两种方式：volatile和synchronized。除了这两种方法，Java还提供了很多关键字来实现 happens-before 原则，会在后面介绍。","categories":[{"name":"Android","slug":"Android","permalink":"https://tylerLiu.top/categories/Android/"},{"name":"进阶","slug":"Android/进阶","permalink":"https://tylerLiu.top/categories/Android/进阶/"}],"tags":[{"name":"JVM与DVM必知必会","slug":"JVM与DVM必知必会","permalink":"https://tylerLiu.top/tags/JVM与DVM必知必会/"}]},{"title":"（拉钩）Android工程师进阶34讲-06：Class对象在执行引擎中的初始化过程","slug":"（拉钩）Android工程师进阶34讲-06：Class对象在执行引擎中的初始化过程","date":"2020-07-07T09:01:51.000Z","updated":"2020-07-09T06:41:10.715Z","comments":true,"path":"2020/07/07/（拉钩）Android工程师进阶34讲-06：Class对象在执行引擎中的初始化过程/","link":"","permalink":"https://tylerLiu.top/2020/07/07/（拉钩）Android工程师进阶34讲-06：Class对象在执行引擎中的初始化过程/","excerpt":"","text":"0. 前言前面介绍了ClassLoader的使用，包括它的主要作用就是用来将class字节码加载到内存中。那么，JVM加载class文件的具体过程是怎么样的呢？ 一个class文件被加载到内存分为三步：装载、链接、初始化。其中链接可细分为：验证、准备、解析。 1. 装载1.1 什么是装载装载是指将Java虚拟机查找.class文件并生成字节流，然后根据字节流创建java.lang.Class对象的过程。 这一过程主要完成三件事： 1、ClassLoader通过一个类的全限定名（包名 + 类名）来查找.class文件，并生成二进制字节流：其中class字节码文件的来源不一定是.class文件，也可以是jar包、zip包，甚至是网络的字节流。 2、把.class文件各个部分分别解析(parse)为JVM内部特定的数据结构，并存放在方法区。这点和JSON解析过程有点类似。 3、在内存中创建一个java.lang.Class类型的对象：后面程序在运行过程中所有对该类的访问都通过这个对象，即这个Class类型的对象是提供给外界访问该类的接口。 1.2 加载时机一个项目编译之后，往往会生成大量的.class文件。当程序运行时，JVM并不会一次性将这些.class文件全部加载到内存中。那JVM什么时候加载某个.class文件？对此，Java虚拟机规范中没有做严格的规定，不同的虚拟机会有不同实现。以下两种情况一般会对class进行装载操作。 隐式装载：在程序运行时，当碰到通过new等方式生成的对象时，系统会隐式调用ClassLoader去装载对应的class到内存中。 显示装载：在编写源代码时，主动调用Class.forName()等方法也会进行class装载操作。 2. 链接链接分为三步：验证、准备、解析。 2.1 验证目的是为了确保.class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危及虚拟机本身的安全。主要包含以下几个方面的检验。 1、文件格式检验：检验字节流是否符合class文件格式的规范，并且能被当前版本的虚拟机处理。 2、元数据检验：对字节码描述的信息进行语义分析，以保证其描述的内容符合Java语言规范的要求。 3、字节码检验：通过数据流和控制流分析，确定程序语义是合法、符合逻辑的。 4、符号引用检验：符号引用检验可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验。 实例分析： 下面使用Foo.java来分析验证阶段的几个情况： 123456789101112131415161718public class Foo &#123; public static void main(String[] args) &#123; new Foo().print(); &#125; public void print() &#123; int superCode = super.hashCode(); System.out.println(\"superCode is \" + superCode); int thisCode = hashCode(); System.out.println(\"thisCode is \" + thisCode); &#125; public int hashCode() &#123; return 111; &#125;&#125; 使用javac将Foo.java编译成Foo.class，然后使用16进制编辑器打开.class文件，部分如下： 123456CA FE BA BE 00 00 00 34 00 36 0A 00 10 00 1C 0700 1D 0A 00 02 00 1C 0A 00 02 00 1E 0A 00 10 001F 09 00 20 00 21 07 00 22 0A 00 07 00 1C 08 0023 0A 00 07 00 24 0A 00 07 00 25 0A 00 07 00 260A 00 27 00 28 0A 00 02 00 1F 08 00 29 07 00 2A01 00 06 3C 69 6E 69 74 3E 01 00 03 28 29 56 01 正常执行Foo.java，打印如下： 12superCode is 460141958thisCode is 111 使用16进制编辑器，修改class魔数，将CAFE BABE改成CAFE BABB，重新运行： 12345678910111213141516E:\\Project\\MyStudyDemo\\LGDemo\\src&gt;java FooError: A JNI error has occurred, please check your installation and try againException in thread &quot;main&quot; java.lang.ClassFormatError: Incompatible magic value 3405691579 in class file Foo at java.lang.ClassLoader.defineClass1(Native Method) at java.lang.ClassLoader.defineClass(Unknown Source) at java.security.SecureClassLoader.defineClass(Unknown Source) at java.net.URLClassLoader.defineClass(Unknown Source) at java.net.URLClassLoader.access$100(Unknown Source) at java.net.URLClassLoader$1.run(Unknown Source) at java.net.URLClassLoader$1.run(Unknown Source) at java.security.AccessController.doPrivileged(Native Method) at java.net.URLClassLoader.findClass(Unknown Source) at java.lang.ClassLoader.loadClass(Unknown Source) at sun.misc.Launcher$AppClassLoader.loadClass(Unknown Source) at java.lang.ClassLoader.loadClass(Unknown Source) at sun.launcher.LauncherHelper.checkAndLoadMain(Unknown Source) 魔数后面的&quot;0034&quot;为版本号，如果改成&quot;0035&quot;： 1CA FE BA BE 00 00 00 35 00 36 0A 00 10 00 1C 07 运行结果： 1234567891011121314151617E:\\Project\\MyStudyDemo\\LGDemo\\src&gt;java FooError: A JNI error has occurred, please check your installation and try againException in thread &quot;main&quot; java.lang.UnsupportedClassVersionError: Foo has been compiled by a more recent version of the Java Runtime (class file version 53.0), this version of the Java Runtime only recognizes class file versions up to 52.0 at java.lang.ClassLoader.defineClass1(Native Method) at java.lang.ClassLoader.defineClass(Unknown Source) at java.security.SecureClassLoader.defineClass(Unknown Source) at java.net.URLClassLoader.defineClass(Unknown Source) at java.net.URLClassLoader.access$100(Unknown Source) at java.net.URLClassLoader$1.run(Unknown Source) at java.net.URLClassLoader$1.run(Unknown Source) at java.security.AccessController.doPrivileged(Native Method) at java.net.URLClassLoader.findClass(Unknown Source) at java.lang.ClassLoader.loadClass(Unknown Source) at sun.misc.Launcher$AppClassLoader.loadClass(Unknown Source) at java.lang.ClassLoader.loadClass(Unknown Source) at sun.launcher.LauncherHelper.checkAndLoadMain(Unknown Source) 版本号&quot;0034&quot;之后的&quot;0036&quot;是常量计数器，表示常量池中有54个常量。这个修改成&quot;0032&quot;： 1CA FE BA BE 00 00 00 35 00 32 0A 00 10 00 1C 07 运行结果： 12345678910111213141516E:\\Project\\MyStudyDemo\\LGDemo\\src&gt;java FooError: A JNI error has occurred, please check your installation and try againException in thread &quot;main&quot; java.lang.ClassFormatError: Invalid constant pool index 50 in class file Foo at java.lang.ClassLoader.defineClass1(Native Method) at java.lang.ClassLoader.defineClass(Unknown Source) at java.security.SecureClassLoader.defineClass(Unknown Source) at java.net.URLClassLoader.defineClass(Unknown Source) at java.net.URLClassLoader.access$100(Unknown Source) at java.net.URLClassLoader$1.run(Unknown Source) at java.net.URLClassLoader$1.run(Unknown Source) at java.security.AccessController.doPrivileged(Native Method) at java.net.URLClassLoader.findClass(Unknown Source) at java.lang.ClassLoader.loadClass(Unknown Source) at sun.misc.Launcher$AppClassLoader.loadClass(Unknown Source) at java.lang.ClassLoader.loadClass(Unknown Source) at sun.launcher.LauncherHelper.checkAndLoadMain(Unknown Source) 虽然JVM会检查各种对class字节码文件的篡改行为，但是依然无法保证class文件的安全性。比如在Foo.java中的print()方法中，分别打印出父类的自身类的hashCode值，分别是460141958和111。我们可以在class字节码的基础上篡改，将父类的hashCode返回111。 通过javap -v Foo查看Foo.class中常量池的具体信息（部分）： 1234567891011121314151617Constant pool: #1 = Methodref #16.#28 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = Class #29 // Foo #3 = Methodref #2.#28 // Foo.&quot;&lt;init&gt;&quot;:()V #4 = Methodref #2.#30 // Foo.print:()V #5 = Methodref #16.#31 // java/lang/Object.hashCode:()I #6 = Fieldref #32.#33 // java/lang/System.out:Ljava/io/PrintStream; #7 = Class #34 // java/lang/StringBuilder #8 = Methodref #7.#28 // java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V #9 = String #35 // superCode is #10 = Methodref #7.#36 // java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; #11 = Methodref #7.#37 // java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder; #12 = Methodref #7.#38 // java/lang/StringBuilder.toString:()Ljava/lang/String; #13 = Methodref #39.#40 // java/io/PrintStream.println:(Ljava/lang/String;)V #14 = Methodref #2.#31 // Foo.hashCode:()I #15 = String #41 // thisCode is #16 = Class #42 // java/lang/Object #5处指向了父类Object的hashCode方法，#14处指向了Foo的hashCode方法。第03节中，已经了解到CONSTANT_Methodref_info结构如下： 12345CONSTANT_Methodref_info&#123; u1 tag = 10; u2 class_index; // 指向此方法的所属类 u2 name_type_index; // 指向此方法名称和类型&#125; 其中class_index就是指向方法的所属类，示例中为16，转化为16进制为0X10，因此只需要使用16进制编辑器将指向Object的class_index改为执行Foo的class_index即可。具体修改如下： 将&quot;0X10&quot;改成&quot;0X02&quot;，重新运行： 123E:\\Project\\MyStudyDemo\\LGDemo\\src&gt;java FoosuperCode is 111thisCode is 111 可以看出，虽然在Java源文件中调用了super.hashCode()方法，但是经过篡改之后，Foo.class文件成功通过了JVM校验，并成功执行最终打印。 注意，上面的实例说明，即使没有Java源文件，某种程度上，也可以对编译之后的class字节码进行篡改。这也是为什么在项目中使用混淆，甚至使用一些第三方加固软件，来保证编写的代码的安全性。 2.2 准备目的是为类中的静态变量分配内存，并为其设置“0值”。比如： 1public static int value = 100; 在准备阶段，JVM会为value分配内存，并将其设置为0。而真正的值100是在初始化阶段设置的。并且此阶段进行内存分配的仅包括类变量，而不包括实例变量（实例变量将会在对象初始化时随对象一起分配在Java堆中）。 有一种情况比较特殊——静态常量，比如： 1public static final int value = 100; 以上代码会在准备阶段为value分配内存，并设置为100。 Java中基本类型的默认“0值”如下： 基本类型的默认值为0； 引用类型的默认值为null。 2.3 解析这一阶段的任务是把常量池中的符号引用转换为直接引用，也就是具体的内存地址。在这一阶段，JVM会将常量池中的类、接口名、字段名、方法名等转换为具体的内存地址。 比如上面Foo.java中编译之后main方法的字节码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879Constant pool: #1 = Methodref #16.#28 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = Class #29 // Foo #3 = Methodref #2.#28 // Foo.&quot;&lt;init&gt;&quot;:()V #4 = Methodref #2.#30 // Foo.print:()V #5 = Methodref #2.#31 // Foo.hashCode:()I #6 = Fieldref #32.#33 // java/lang/System.out:Ljava/io/PrintStream; #7 = Class #34 // java/lang/StringBuilder #8 = Methodref #7.#28 // java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V #9 = String #35 // superCode is #10 = Methodref #7.#36 // java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; #11 = Methodref #7.#37 // java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder; #12 = Methodref #7.#38 // java/lang/StringBuilder.toString:()Ljava/lang/String; #13 = Methodref #39.#40 // java/io/PrintStream.println:(Ljava/lang/String;)V #14 = Methodref #2.#31 // Foo.hashCode:()I #15 = String #41 // thisCode is #16 = Class #42 // java/lang/Object #17 = Utf8 &lt;init&gt; #18 = Utf8 ()V #19 = Utf8 Code #20 = Utf8 LineNumberTable #21 = Utf8 main #22 = Utf8 ([Ljava/lang/String;)V #23 = Utf8 print #24 = Utf8 hashCode #25 = Utf8 ()I #26 = Utf8 SourceFile #27 = Utf8 Foo.java #28 = NameAndType #17:#18 // &quot;&lt;init&gt;&quot;:()V #29 = Utf8 Foo #30 = NameAndType #23:#18 // print:()V #31 = NameAndType #24:#25 // hashCode:()I #32 = Class #43 // java/lang/System #33 = NameAndType #44:#45 // out:Ljava/io/PrintStream; #34 = Utf8 java/lang/StringBuilder #35 = Utf8 superCode is #36 = NameAndType #46:#47 // append:(Ljava/lang/String;)Ljava/lang/StringBuilder; #37 = NameAndType #46:#48 // append:(I)Ljava/lang/StringBuilder; #38 = NameAndType #49:#50 // toString:()Ljava/lang/String; #39 = Class #51 // java/io/PrintStream #40 = NameAndType #52:#53 // println:(Ljava/lang/String;)V #41 = Utf8 thisCode is #42 = Utf8 java/lang/Object #43 = Utf8 java/lang/System #44 = Utf8 out #45 = Utf8 Ljava/io/PrintStream; #46 = Utf8 append #47 = Utf8 (Ljava/lang/String;)Ljava/lang/StringBuilder; #48 = Utf8 (I)Ljava/lang/StringBuilder; #49 = Utf8 toString #50 = Utf8 ()Ljava/lang/String; #51 = Utf8 java/io/PrintStream #52 = Utf8 println #53 = Utf8 (Ljava/lang/String;)V&#123; public Foo(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 1: 0 public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=1, args_size=1 0: new #2 // class Foo 3: dup 4: invokespecial #3 // Method &quot;&lt;init&gt;&quot;:()V 7: invokevirtual #4 // Method print:()V 10: return LineNumberTable: line 4: 0 line 5: 10 在main方法中通过invokespecial指令调用print方法，Foo.print:()V就是一个符号引用，当main方法执行到此处时，会将符号引用 Foo.print:()V解析成直接引用，可以将直接引用理解为方法真正的内存地址。 对于符号引用和直接引用，可以与微信聊天类比，在微信好友列表中，保存的是好友的名称或别名（就是符号引用），当真正给某个好友发送消息时，计算机（JVM）会根据好友的名称找到对象计算机的IP地址（直接引用）并将消息发送给这一地址。 3. 初始化这一阶段执行类构造器&lt;clinit&gt;方法的过程，并真正初始化类变量。比如： 1public static int value = 100; 在准备阶段value被分配内存，并设置为0，在初始化阶段value就会被设置为100。 3.1 初始化的时机对于装载阶段，JVM并没有规范何时具体执行。但是对于初始化，JVM规范中严格规定了class初始化的时机，主要有以下几种情况会触发class的初始化： 1、虚拟机启动时，初始化包含main方法的主类； 2、遇到new指令创建对象实例时，如果目标对象类没有被初始化则进行初始化操作； 3、遇到访问静态方法或静态字段的指令时，如果目标对象类没有被初始化则进行初始化操作； 4、子类的初始化过程如果发现其父类没有进行初始化，则需要先触发其父类的初始化； 5、使用反射API进行反射调用时，如果类没有进行初始化则需要先触发其初始化； 6、第一次调用java.lang.invoke.MethodHandle实例时，需要初始化MethodHandle指向方法所在的类。 3.2 初始化类变量在初始化阶段，只会初始化与类相关的静态赋值语句和静态语句，也就是有static关键字修饰的信息，而没有static修饰的语句块在实例化对象的时候才进行初始化。 如下代码： 12345678910111213public class ClassInit &#123; public static int value = 1; // 静态语句块在初始化阶段执行 static &#123; System.out.println(\"ClassInit static block!\"); &#125; // 非静态语句块只在创建对象实例时被执行 &#123; System.out.println(\"ClassInit non-static block!\"); &#125;&#125; 然后在ClassInitTest.java中访问ClassInit的value值： 12345public class ClassInitTest &#123; public static void main(String[] args) &#123; ClassInit.value = 2; &#125;&#125; 执行代码，打印： 1ClassInit static block! 可以看出，非静态代码块没有被执行。如果将ClassInitTest.java修改成： 123456public class ClassInitTest &#123; public static void main(String[] args) &#123; ClassInit.value = 2; ClassInit ci = new ClassInit(); &#125;&#125; 再次执行，就会执行非静态代码块，打印： 12ClassInit static block!ClassInit non-static block! 3.3 被动引用上述的6种情况在JVM中被称为主动引用，除此6种情况之外所有引用类的方式都被称为被动引用。被动引用并不会触发class的初始化。 最典型的就是子类调用父类的静态变量，比如： 12345678910111213class Parent &#123; public static int value = 1; static &#123; System.out.println(\"this is Parent!\"); &#125;&#125;class Child extends Parent &#123; static &#123; System.out.println(\"this is Child!\"); &#125;&#125; Child继承了Parent，如果直接使用Child来访问Parent的value值，则不会初始化Child类，如下： 12345class NonInitTest &#123; public static void main(String[] args) &#123; Child.value = 2; &#125;&#125; 打印： 1this is Parent! 可以看出，Child中的静态代码没有执行。也就是说JVM没有对Child进行初始化操作。 对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过子类Child来引用父类Parent中定义的静态字段，只会触发Parent额初始化。至于是否要触发子类的加载和验证，在虚拟机规范中没有明确规定，可以通过XX:-TraceClassLoading参数来查看，比如使用如下命令再次执行NonInitTest：（先javac NonInitTest.java编译） 1java XX:-TraceClassLoading NonInitTest 打印（部分）： 123[Loaded Parent from file:/E:/Project/MyStudyDemo/LGDemo/src/][Loaded Child from file:/E:/Project/MyStudyDemo/LGDemo/src/]this is Parent! 可以看到，虽然只有Parent被初始化，但是Parent和Child都经过了装载和验证阶段，并被加载到了内存中。 3.4 class初始化和对象的创建顺序关于class的初始化还有一点经常被提及，就是对象的初始化顺序。当在代码中使用new创建一个类的实例对象时，类中的静态代码块、费静态代码块、构造函数之间的执行顺序是怎样的： 如下代码： 1234567891011121314151617181920212223242526272829303132333435public class InitOrder &#123; public static void main(String[] args) &#123; Parent p = new Child(); System.out.println(\"-----------------------\"); p = new Child(); &#125; static class Child extends Parent &#123; static &#123; System.out.println(\"Child static block!\"); &#125; &#123; System.out.println(\"Child non-static block!\"); &#125; public Child() &#123; System.out.println(\"Child constructor!\"); &#125; &#125; static class Parent &#123; static &#123; System.out.println(\"Parent static block!\"); &#125; &#123; System.out.println(\"Parent non-static block!\"); &#125; public Parent() &#123; System.out.println(\"Parent constructor!\"); &#125; &#125;&#125; 打印： 1234567891011Parent static block!Child static block!Parent non-static block!Parent constructor!Child non-static block!Child constructor!-----------------------Parent non-static block!Parent constructor!Child non-static block!Child constructor! 对象初始化顺序：静态变量/静态代码块 -&gt; 普通代码块 -&gt; 构造函数 1、父类静态变量和静态代码块； 2、子类静态变量和静态代码块； 3、父类普通成员变量和普通代码块； 4、父类构造函数； 5、子类普通成员变量和普通代码块； 6、子类构造函数； 更多参考链接： JVM符号引用转换直接引用的过程? JVM里的符号引用如何存储？ 大话Java对象在虚拟机中是什么样子？ JVM源码分析之Java类的加载过程 4. 总结 1、装载：查找字节流，并根据此字节流创建类的过程。装载过程成功的标志就是在方法区中成功创建类所对应的Class对象。 2、链接：验证创建的类，并将其解析到JVM中使之能被JVM执行。 3、初始化：将标记为static的字段进行赋值，并且执行static标记的代码语句。","categories":[{"name":"Android","slug":"Android","permalink":"https://tylerLiu.top/categories/Android/"},{"name":"进阶","slug":"Android/进阶","permalink":"https://tylerLiu.top/categories/Android/进阶/"}],"tags":[{"name":"JVM与DVM必知必会","slug":"JVM与DVM必知必会","permalink":"https://tylerLiu.top/tags/JVM与DVM必知必会/"}]},{"title":"（拉钩）Android工程师进阶34讲-05：深入理解ClassLoader的加载机制","slug":"（拉钩）Android工程师进阶34讲-05：深入理解ClassLoader的加载机制","date":"2020-06-30T02:20:12.000Z","updated":"2020-07-07T08:56:31.781Z","comments":true,"path":"2020/06/30/（拉钩）Android工程师进阶34讲-05：深入理解ClassLoader的加载机制/","link":"","permalink":"https://tylerLiu.top/2020/06/30/（拉钩）Android工程师进阶34讲-05：深入理解ClassLoader的加载机制/","excerpt":"","text":"0. 前言第3节介绍了Java字节码文件(.class)的格式。一个完整的Java程序是由多个.class文件组成的，在程序运行过程中，需要将这些.class文件加载到JVM中才可以使用。而负责加载这些.class文件的就是类加载器(ClassLoader)。 1. Java中的类何时被加载器加载在Java程序启动的时候，并不会一次性加载程序中的所有.class文件，而是在程序的运行过程中，动态地加载相应的类到内存中。 通常情况下，Java程序中的.class文件会在以下2种情况下被ClassLoader主动加载到内存中： 1、调用类构造器 2、调用类中的静态(static)变量或静态方法 2. Java中的ClassLoaderJVM中自带3个类加载器： 1、启动类加载器BootstrapClassLoader 2、扩展类加载器ExtClassLoader（JDK 1.9之后，改名为PlatformClassLoader） 3、系统加载器AppClassLoader 以上三者在JVM中各有分工，但是又相互依赖。 2.1 AppClassLoader系统类加载器部分源码： 12345678910111213141516static class AppClassLoader extends URLClassLoader &#123; final URLClassPath ucp = SharedSecrets.getJavaNetAccess().getURLClassPath(this); public static ClassLoader getAppClassLoader(final ClassLoader var0) throws IOException &#123; final String var1 = System.getProperty(\"java.class.path\"); final File[] var2 = var1 == null ? new File[0] : Launcher.getClassPath(var1); return (ClassLoader)AccessController.doPrivileged(new PrivilegedAction&lt;Launcher.AppClassLoader&gt;() &#123; public Launcher.AppClassLoader run() &#123; URL[] var1x = var1 == null ? new URL[0] : Launcher.pathToURLs(var2); return new Launcher.AppClassLoader(var1x, var0); &#125; &#125;); ......&#125; 可以看出，AppClassLoader主要加载系统属性&quot;java.class.path&quot;配置下的文件，也就是环境变量CLASS_PATH配置的路径。因此AppClassLoader是面向用户的类加载器，编写的代码以及使用的第三方jar包通常都是由它来加载的。 2.2 ExtClassLoader扩展类加载器部分源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344static class ExtClassLoader extends URLClassLoader &#123; private static volatile Launcher.ExtClassLoader instance; public static Launcher.ExtClassLoader getExtClassLoader() throws IOException &#123; if (instance == null) &#123; Class var0 = Launcher.ExtClassLoader.class; synchronized(Launcher.ExtClassLoader.class) &#123; if (instance == null) &#123; instance = createExtClassLoader(); &#125; &#125; &#125; return instance; &#125; ...... public ExtClassLoader(File[] var1) throws IOException &#123; super(getExtURLs(var1), (ClassLoader)null, Launcher.factory); SharedSecrets.getJavaNetAccess().getURLClassPath(this).initLookupCache(this); &#125; private static File[] getExtDirs() &#123; String var0 = System.getProperty(\"java.ext.dirs\"); File[] var1; if (var0 != null) &#123; StringTokenizer var2 = new StringTokenizer(var0, File.pathSeparator); int var3 = var2.countTokens(); var1 = new File[var3]; for(int var4 = 0; var4 &lt; var3; ++var4) &#123; var1[var4] = new File(var2.nextToken()); &#125; &#125; else &#123; var1 = new File[0]; &#125; return var1; &#125; ......&#125; ExtClassLoader加载系统属性&quot;java.ext.dirs&quot;配置下类文件，可以打印出这个属性查看具体有哪些文件： 1System.out.println(System.getPreperty(\"java/ext.dirs\")); 结果如下： 1/Library/Java/JavaVirtualMachines/jdk1.8.0_1051.jdk/Contents/Home/jre/lib/ext 2.3 BootstrapClassLoader启动类加载器BootstrapClassLoader和上面两种ClassLoader不一样。 首先，它并不是使用Java实现的， 而是由C/C++编写的，它本身属于虚拟机的一部分。因此无法在Java代码中直接获取它的引用。如果在Java层获取BootstrapClassLoader的引用，系统会返回null。 BootstrapClassLoader加载系统属性&quot;sun.boot.class.path&quot;配置下的类文件，可以打印出这个属性来查看具体有哪些文件： 1System.out.println(System.getPreperty(\"sun.boot.class.path\")); 结果如下： 可以看到，这些全是JRE目录下的jar包或.class文件。 3. 双亲委派模式(Parents Delegation Model)JVM中已经有了三种ClassLoader，那么JVM又是如何知道该使用哪一种类加载器去加载相应的类呢？是双亲委派模式。 3.1 双亲委派模式双亲委派模式就是当类加载器接收加载类或资源的请求时，通常都是先委托给父加载器加载，只有当父加载器找不到指定类或资源时，自身才会执行实际的类加载过程。 其具体实现代码就是在ClassLoader.java中的loadClass()方法中，如下：java/lang/ClassLoader.java 1234567891011121314151617181920212223protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException&#123; // First, check if the class has already been loaded Class&lt;?&gt; c = findLoadedClass(name); // 1 if (c == null) &#123; try &#123; if (parent != null) &#123; c = parent.loadClass(name, false); // 2 &#125; else &#123; c = findBootstrapClassOrNull(name); // 3 &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; // If still not found, then invoke findClass in order // to find the class. c = findClass(name); // 4 &#125; &#125; return c;&#125; 说明： 1、判断该Class是否已加载，如果已经加载，则直接将该Class返回。 2、如果该Class没有被加载过，则判断parent是否为空，如果不为空，则将加载任务委托给parent。 3、如果parent = null，则直接调用BootstrapClassLoader加载该类。 4、如果parent和BootstrapClassLoader都没有加载成功，则调用当前ClassLoader的findClass()方法继续尝试加载。 这个parent是什么呢？可以看ClassLoader的构造器： 123protected ClassLoader(ClassLoader parent) &#123; this(checkCreateClassLoader(), parent);&#125; 可以看到，在每一个ClassLoader中都有一个ClassLoader类型的parent引用，并且在构造器中传入值。如果继续看源码，可以看到AppClassLoader传入的parent就是ExtClassLoader，而ExtClassLoader并没有传入任何parent，也就是null。 3.2 举例比如执行下面代码： 1Test test = new Test(); 默认情况下，JVM首先使用AppClassLoader去加载Test类。 1、AppClassLoader将加载的任务委派给它的父类加载器——ExtClassLoader。 2、ExtClassLoader的parent为null，所以直接将加载任务委派给BootstrapClassLoader。 3、BootstrapClassLoader在jdk/lib目录下无法找到Test类，因此返回的Class为null。 4、因为parent和BootstrapClassLoader都没有成功加载Test类，所以AppClassLoader会调用findClass()来加载Test。 最终Test就是被AppClassLoader加载到内存中，可以通过如下代码验证此结果： 123456789101112public class Test &#123; public static void main(String[] args) &#123; ClassLoader cl = Test.class.getClassLoader(); System.out.println(\"cl is \" + cl); ClassLoader parent = cl.getParent(); System.out.println(\"parent is \" + parent); ClassLoader boot_strap = parent.getParent(); System.out.println(\"boot_strap is \" + boot_strap); &#125;&#125; 打印结果为： 123cl is sun.misc.Launcher$AppClassLoader@18b4aac2parent is sun.misc.Launcher$ExtClassLoader@1b6d3586boot_strap is null 注意：“双亲委派模式”只是Java推荐的模式，并不是强制的。我们可以继承ClassLoader，实现自己的类加载器。如果想保持双亲委派模式，应该重写findClass(name)方法；如果想破坏双亲委派模式，可以重写loadClass(name)方法。 4. 自定义ClassLoaderJVM中预置了三种ClassLoader，只能加载特定目录下的.class文件，如果想加载其他特殊位置下的jar包或类时（比如，要加载网络或磁盘上的一个.class文件），默认的ClassLoader就不能满足需求，所以需要自定义ClassLoader来加载特定目录下的.class文件。 4.1 自定义ClassLoader步骤 1、自定义一个类继承抽象类ClassLoader。 2、重写findClass()方法。 3、在findClass()中，调用defineClass()方法将字节码转换成Class对象，并返回。 伪代码： 12345678public class 自定义ClassLoader extends ClassLoader &#123; @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; // 寻找字节码 byte[] code = findCodeFromSomeWhere(name); return this.defineClass(name, code); &#125;&#125; 4.2 自定义ClassLoader示例首先创建测试类Secret.java： 12345public class Secret &#123; public void printSecret() &#123; System.out.println(\"打印了 printSecret\"); &#125;&#125; 测试类所在的磁盘路径如下： 1/Project/MyStudyDemo/LGDemo/src/Secret.java 下面创建DiskClassLoader继承ClassLoader，重写findClass()方法，并在其中调用defineClass()创建Class： 1234567891011121314151617181920212223public class DiskClassLoader extends ClassLoader &#123; private String filePath; public DiskClassLoader(String path) &#123; this.filePath = path; &#125; // 重写findClass @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; String newPath = filePath + name + \".class\"; byte[] classBytes = null; Path path = null; try &#123; path = Paths.get(new URI(newPath)); classBytes = Files.readAllBytes(path); &#125; catch (URISyntaxException | IOException e) &#123; e.printStackTrace(); &#125; // 调用defineClass，创建Class并返回 return defineClass(name, classBytes, 0, classBytes.length); &#125;&#125; 最后，写一个测试自定义DiskClassLoader的测试类，验证自定义的DiskClassLoader是否正常工作。 123456789101112131415161718192021class DiskClassLoaderTest &#123; public static void main(String[] args) &#123; testClassLoader(); &#125; public static void testClassLoader() &#123; // 创建自定义ClassLoader对象 DiskClassLoader diskClassLoader = new DiskClassLoader(\"file:///Project/MyStudyDemo/LGDemo/src/\"); // 1 try &#123; Class c = diskClassLoader.loadClass(\"Secret\"); // 2 if (c != null) &#123; Object obj = c.newInstance(); // 通过反射调用Secret的printSecret方法 Method method = c.getDeclaredMethod(\"printSecret\", null); // 3 method.invoke(obj, null); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 说明： 1、代表需要动态加载的class路径。 2、代表需要动态加载的类名。 3、代表需要动态调用的方法名称。 最后执行，并打印如下结果，表示自定义的ClassLoader可以正常工作。 1234D:\\Java\\jdk1.8.0_212\\bin\\java.exe &quot;-javaagent:D:\\Program Files\\JetBrains\\IntelliJ IDEA 2020.1.2\\lib\\idea_rt.jar=55145:D:\\Program Files\\JetBrains\\IntelliJ IDEA 2020.1.2\\bin&quot; -Dfile.encoding=UTF-8 -classpath D:\\Java\\jdk1.8.0_212\\jre\\lib\\charsets.jar;D:\\Java\\jdk1.8.0_212\\jre\\lib\\deploy.jar;D:\\Java\\jdk1.8.0_212\\jre\\lib\\ext\\access-bridge-64.jar;D:\\Java\\jdk1.8.0_212\\jre\\lib\\ext\\cldrdata.jar;D:\\Java\\jdk1.8.0_212\\jre\\lib\\ext\\dnsns.jar;D:\\Java\\jdk1.8.0_212\\jre\\lib\\ext\\jaccess.jar;D:\\Java\\jdk1.8.0_212\\jre\\lib\\ext\\jfxrt.jar;D:\\Java\\jdk1.8.0_212\\jre\\lib\\ext\\localedata.jar;D:\\Java\\jdk1.8.0_212\\jre\\lib\\ext\\nashorn.jar;D:\\Java\\jdk1.8.0_212\\jre\\lib\\ext\\sunec.jar;D:\\Java\\jdk1.8.0_212\\jre\\lib\\ext\\sunjce_provider.jar;D:\\Java\\jdk1.8.0_212\\jre\\lib\\ext\\sunmscapi.jar;D:\\Java\\jdk1.8.0_212\\jre\\lib\\ext\\sunpkcs11.jar;D:\\Java\\jdk1.8.0_212\\jre\\lib\\ext\\zipfs.jar;D:\\Java\\jdk1.8.0_212\\jre\\lib\\javaws.jar;D:\\Java\\jdk1.8.0_212\\jre\\lib\\jce.jar;D:\\Java\\jdk1.8.0_212\\jre\\lib\\jfr.jar;D:\\Java\\jdk1.8.0_212\\jre\\lib\\jfxswt.jar;D:\\Java\\jdk1.8.0_212\\jre\\lib\\jsse.jar;D:\\Java\\jdk1.8.0_212\\jre\\lib\\management-agent.jar;D:\\Java\\jdk1.8.0_212\\jre\\lib\\plugin.jar;D:\\Java\\jdk1.8.0_212\\jre\\lib\\resources.jar;D:\\Java\\jdk1.8.0_212\\jre\\lib\\rt.jar;E:\\Project\\MyStudyDemo\\LGDemo\\out\\production\\LGDemo DiskClassLoaderTest打印了 printSecretProcess finished with exit code 0 注意：上述动态加载.class文件的思路，经常被用作热修复和插件化开发的框架中，包括QQ空间热修复方案、微信Tink等原理都是由此而来。客户端只要从服务端下载一个加密的.class文件，然后在本地通过事先定义好的加密方式进行解密，最后再使用自定义ClassLoader动态加载解密后的.class文件，并动态调用相应的方法。 5. Android中的ClassLoader本质上，Andorid系统和JVM是一样的，也需要通过ClassLoader将目标类加载到内存，类加载器之间也符合双亲委派模式。但是在Android中，ClassLoader的加载细节有略微的差别。 在Android虚拟机中是无法直接运行.class文件的，Android会将所有的.class文件转换成一个.dex文件，并且Android将加载.dex文件的实现封装在BaseDexClassLoader中，一般只是用它的两个子类：PathClassLoader和DexClassLoader。 5.1 PathClassLoaderPathClassLoader用来加载系统apk和被安装到手机中的apk内的dex文件。它的2个构造函数如下： 1234567891011public class PathClassLoader extends BaseDexClassLoader &#123; public PathClassLoader(String dexPath, ClassLoader parent) &#123; super((String)null, (File)null, (String)null, (ClassLoader)null); throw new RuntimeException(\"Stub!\"); &#125; public PathClassLoader(String dexPath, String librarySearchPath, ClassLoader parent) &#123; super((String)null, (File)null, (String)null, (ClassLoader)null); throw new RuntimeException(\"Stub!\"); &#125;&#125; 参数说明： dexPath：dex文件路径，或者包含dex文件的jar包路径； librarySearchPath：C/C++ native库的路径。 PathClassLoader里面除了这2个构造方法以外就没有其他方法了，具体的实现都是在BaseDexClassLoader里面，其dexPath比较受限制，一般是已经安装应用的apk文件路径。 当一个App被安装手机后，apk里面的class.dex中的class均通过PathClassLoader来加载的，可以通过如下代码验证： 12345678910public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ClassLoader loader = MainActivity.class.getClassLoader(); Log.i(\"TAG\", loader.toString()); &#125;&#125; 打印如下： 12System.out: dalvik.system.PathClassLoader[DexPathList[[zip file &quot;/data/app/com.ly.lgdemoandroid-1/base.apk&quot;],nativeLibraryDirectories=[/data/app/com.ly.lgdemoandroid-1/lib/x86, /system/lib, /vendor/lib]]] 5.2 DexClassLoader官方描述： A class loader that loads classes from .jar and .apk filescontaining a classes.dex entry. This can be used to execute code notinstalled as part of an application. 对比PathClassLoader只能加载已经安装应用的dex或apk文件，DexClassLoader则没有此限制，可以从SD卡上加载包含class.dex的.jar和.apk文件，这也是插件化和热修复的基础，在不需要安装应用的情况下，完成需要使用的dex的加载。 DexClassLoader的源码只有一个构造方法，如下： 123456public class DexClassLoader extends BaseDexClassLoader &#123; public DexClassLoader(String dexPath, String optimizedDirectory, String librarySearchPath, ClassLoader parent) &#123; super((String)null, (File)null, (String)null, (ClassLoader)null); throw new RuntimeException(\"Stub!\"); &#125;&#125; 参数说明： dexPath：包含class.dex的apk、jar文件路径，多个路径用文件分隔符（默认是“:”）分隔。 optimizedDirectory：用来缓存优化的dex文件的路径，即从apk或jar文件中提取出来的dex文件。该路径不可为空，且应该是应用私有的，有读写权限的路径。 5.2.1 使用DexClassLoader实现热修复创建Android项目DexClassLoaderHotFix项目结构： ISay是一个接口，内部定义了一个方法： 123public interface ISay &#123; String saySomething();&#125; SayException实现了ISay接口，但是在saySomething()方法中，打印&quot;something wrong here&quot;来模拟线上的bug。 123456public class SayException implements ISay &#123; @Override public String saySomething() &#123; return \"something wrong here\"; &#125;&#125; 最后在MainActivity中，当点击按钮时，将saySomething返回的内容通过Toast显示出来。 1234567891011121314151617181920public class MainActivity extends AppCompatActivity &#123; private ISay say; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); say = new SayException(); Button btnSay = findViewById(R.id.btn_say); btnSay.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Log.e(\"TAG\", \"say_hotfix.jar not exists\"); Toast.makeText(MainActivity.this, say.saySomething(), Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125;&#125; 点击按钮： 创建HotFix patch包新建Java项目，并分别创建两个文件ISay.java和SayHotFix.java。 12345package com.ly.dexclassloaderhotfix;public interface ISay &#123; String saySomething();&#125; 12345678package com.ly.dexclassloaderhotfix;public class SayHotFix implements ISay &#123; @Override public String saySomething() &#123; return \"Everything is right!\"; &#125;&#125; ISay接口的包名和类名必须和Android项目中的一样。SayHotFix实现ISay接口，并在saySomething()中返回新的结果，用来模拟修复bug。 将ISay和SayHotFix打包成say_something.jar，然后通过dx工具将生成的say_something.jar包中的class文件优化为dex文件。 dx –dex –output=say_something_hotfix.jar say_something.jar 上述say_something.jar就是最终需要用作hotfix的jar包。 将HotFix patch 包拷贝到SD卡主目录中，并使用DexClassLoader加载SD卡中的ISay接口。 首先将HotFix patch保存到本地目录下。一般在真实项目中，可以通过向后端发送请求的方式，将最新的HoFix patch下载到本地中。这里为了演示，直接使用adb命令将say_something.jar包push到SD卡目录下： adb push say_something_hotfix.jar /storage/self/primary/ 下面，修改MainActivity中的逻辑，使用DexClassLoader加载HotFix patch中的SayHotFix类，如下： 6. 总结 ClassLoader就是用来加载class文件的，不管是jar中还是dex中的class。 Java中的ClassLoader通过双亲委托模式来加载各自指定路径下的class文件。 可以自定义ClassLoader，一般覆盖findClass()方法，不建议重写loadClass()方法。 Andorid中常用的两种ClassLoader分别为：PathClassLoader和DexClassLoader。","categories":[{"name":"Android","slug":"Android","permalink":"https://tylerLiu.top/categories/Android/"},{"name":"进阶","slug":"Android/进阶","permalink":"https://tylerLiu.top/categories/Android/进阶/"}],"tags":[{"name":"JVM与DVM必知必会","slug":"JVM与DVM必知必会","permalink":"https://tylerLiu.top/tags/JVM与DVM必知必会/"}]},{"title":"（拉钩）Android工程师进阶34讲-04：编译插桩操纵字节码，实现不可能完成的任务","slug":"（拉钩）Android工程师进阶34讲-04：编译插桩操纵字节码，实现不可能完成的任务","date":"2020-06-25T06:39:50.000Z","updated":"2020-06-30T02:15:37.123Z","comments":true,"path":"2020/06/25/（拉钩）Android工程师进阶34讲-04：编译插桩操纵字节码，实现不可能完成的任务/","link":"","permalink":"https://tylerLiu.top/2020/06/25/（拉钩）Android工程师进阶34讲-04：编译插桩操纵字节码，实现不可能完成的任务/","excerpt":"","text":"0. 前言前面介绍了Java字节码文件的格式，并通过一个Demo手动模拟了JVM解析class文件的过程。 本节看看，对于class文件还有其他什么玩法。 需求： 记录每个页面的打开和关闭事件，并通过各种Data Tracking的框架上传到服务器，用来日后做数据分析。 面对这样的需求，一般人会想到在每个Activity的onCreate和onDestory方法中，分别添加页面打开和关闭的逻辑。常见的做法有以下两种： 1、修改项目中现有的每一个Activity，这样做，如果项目以后需要添加新的页面，这套逻辑需要多次拷贝，容易遗漏。 2、将项目中所有的Activity继承BaseActivity，将页面打开和关闭的逻辑添加在BaseActivity，这样做比1要好一些。但是这种方法对于第三方依赖库中的界面就无法添加。 这时有一种更加优雅的处理方式：编译插桩。 1. 编译插桩是什么编译插桩就是在代码编译期间修改已有的代码或者生成新的代码。实际上，项目中用到的Dagger、ButterKnife甚至是Kotlin语言，都用到了编译插桩技术。 Android项目中.java文件的编译过程： 从上图可以看出，在1、2两处对代码进行改造。 1、在.java文件编译成.class文件时，ART、AndroidAnnotation等就是在此处触发代码生成。 2、在.class文件进一步优化成.dex文件时，也就是直接操作字节码文件，也是本节的内容。这种方式功能更加强大，应用场景也更多。但是门槛比较高，需要对字节码有一定理解。 本节主要介绍第2种实现方式，用一张图描述如下过程，其中红色虚框包含了本节的所有内容。 一般情况下，经常会使用编译插桩实现如下几种功能： 日志埋点； 性能监控； 动态权限控制； 业务逻辑跳转时，校验是否已经登录； 甚至是代码调试等。 2. 插桩工具介绍目前主要流行两种实现编译插桩的方式： AspectJ：AspectJ是老牌的AOP(Aspect-Oriented Programming)框架，如果做过J2EE可能会对这个框架更熟悉，经常拿这个框架和Spring AOP进行比较。其主要优势是成熟稳定，使用者也不需要对字节码有深入的理解。 ASM：通过ASM可以修改现有的字节码文件，也可以动态生成字节码文件，并且它是一款完全以字节码层面来操纵字节码并分析字节码的框架。 举例，在Java中实现两个数相加操作，可以如下实现： 如果直接使用ASM直接编写字节码指令，则有可能是如下几个字节码指令： 有工具可以帮助实现这些字节码指令。 本节就是使用ASM来实现简单的编译插桩效果，通过插桩实现最开始提出的需求，在每个Activity打开时输出相应的log日志。 3. 实现思路主要包含两步： 1、遍历项目中所有的.class文件：如何找到项目中编译生成的所有.class文件，是需要解决的第一个问题。众所周知，Android Studio使用Gradle编译项目中的.java文件，并且从Gradle 1.5.0之后，可以自定义Transform，来获取所有.class文件引用。但是Transform的使用需要依赖Gradle Plugin。因此第一步需要创建一个单独的Gradle Plugin，并在Gradle Plugin中使用自定义Transform找出所有的.class文件。 2、遍历到目标.class文件(Activity)之后，通过ASM动态注入需要被插桩的字节码：第一步找到所有的.class文件，接下来就是过滤出目标Activity文件，并在目标Activity文件的onCreate方法中，通过ASM插入相应的log日志字节码。 4. 具体实现4.1 创建ASMLifeCycleDemo项目创建ASMLifeCycleDemo项目： 4.2 创建自定义Gradle插件首先在ASMLifeCycleDemo项目中创建一个新的module，并选择Android Library类型，命名为asm_lifecyle_plugin。 并将asm_lifecyle_plugin中除了build.gradle和main文件夹之外的所有内容都删除。然后在main目录下分别创建groovy和java目录。 因为Gradle插件是使用Groovy编写的，所以需要创建一个groovy目录，用来存放插件相关的.groovy类。但是ASM是java层面的框架，所以在java目录里存放ASM相关的类。 然后，在groovy中创建目录tyler.liu.plugin，并在此目录中创建类LifeCyclePlugin.groovy文件。在LifeCyclePlugin中重写apply方法，实现插件逻辑，这里只是简单打印。 可以看出LifeCyclePlugin实现了gradle api中的Plugin接口。当在build.gradle文件中使用此插件时，其LifeCyclePlugin的apply方法将会被自动调用。 下面将asm_lifecycle_plugin中的build.gradle的内容全部删掉，换成如下内容： 1234567891011121314151617181920212223apply plugin: 'groovy'apply plugin: 'maven'dependencies &#123; implementation fileTree(dir: 'libs', includes: ['*.jar']) implementation gradleApi() implementation localGroovy() implementation 'com.android.tools.build:gradle:3.4.2'&#125;group = 'tyler.lifecycle.plugin'version = '1.0.0'uploadArchives &#123; repositories &#123; mavenDeployer &#123; // 本地的Maven地址配置 repository(url: uri('../asm_lifecycle_repo')) &#125; &#125;&#125; group和version都需要在app mudule引用此插件时使用。 所有的插件都需要被部署到maven库中，可以选择部署到远程或本地。这里只是演示，所以只是将插件部署到本地目录中。具体地址通过repository属性设置，这里将其配置在项目根目录下的asm_lifecycle_repo目录下。 最后一步，创建properties文件。 在plugin/src/main目录下新建目录resources/META-INF/gradle-plugins，然后在此目录下新建文件：tyler.asm.lifecycle.properties，其中文件名tyler.asm.lifecycle就是自定义插件的名称，后面在app module中会使用到。 在.properties文件中，需要指定自定义的插件类名LifeCyclePlugin，如下： 至此，自定义Gradle插件就已经写完，现在在Android Studio右栏找到Gradle中点击uploadArchives，执行plugin的部署任务。 构建成功后，在Project的根目录下将会出现一个repo目录，里面存放的就是插件目标文件。 4.3 测试asm_lifecycle_plugin在app module的build.gradle引用此插件。 1、在自定义Gradle插件中properties的文件名(tyler.asm.lifecycle)。 2、dependencies中的classpath是group值 + module名 + version。 然后在执行命令行中使用gradlew执行构建命令，如果打印出插件里的log，说明自定义插件可以使用： 也有比较成熟的第三方Gradle插件，如hiBever。 4.4 自定义Transform，实现遍历.class文件自定义Gradle插件已经写好，接下来就需要实现遍历所有.class的逻辑。这部分主要依赖Transform API。 4.4.1 什么是Transform？Transform可以被看做是Gradle在编译项目时的一个task，在.class文件转换成.dex的流程中会执行这些Task，对所有.class文件（可包含第三方库的.class）进行转换，转换的逻辑定义在Transform的transform方法中。实际上平时在build.gradle中常用的功能都是通过Transform实现的，比如混淆(proguard)、分包(multi-dex)、jar包合并(jarMerge)。 4.4.2 自定义Transform在tyler.liu.plugin目录中，新建LifeCycleTransform.groovy，继承Transform类，并需要实现里面的方法。 12345678910111213141516171819202122232425262728293031package tyler.liu.pluginimport com.android.build.api.transform.QualifiedContentimport com.android.build.api.transform.Transformpublic class LifeCycleTransform extends Transform &#123; @Override String getName() &#123; return null &#125; @Override Set&lt;QualifiedContent.ContentType&gt; getInputTypes() &#123; return null &#125; @Override Set&lt;? super QualifiedContent.Scope&gt; getScopes() &#123; return null &#125; @Override boolean isIncremental() &#123; return false &#125; @Override void transform(TransformInvocation transformInvocation) throws TransformException, InterruptedException, IOException &#123; super.transform(transformInvocation) &#125;&#125; Transform的主要作用是检索项目编译过程中的所有文件。通过这几个方法，可以对自定义Transform设置一些遍历规则，具体如下： getName()：设置自定义的Transform对应的Task名称。Gradle在编译的时候，会将这个名称显示在控制台上。比如：app:transformClassesWithXXXForDebug。 getInputTypes()：在项目中会有各种各样格式的文件，通过getInputType()可以设置LifeCycleTransform接收的文件类型，此方法的返回值类型是Set&lt;QualifiedContent.ContentType&gt;。 ContentType有以下两种取值： 123456789101112131415161718192021222324/** * The type of of the content. */enum DefaultContentType implements ContentType &#123; /** * The content is compiled Java code. This can be in a Jar file or in a folder. If * in a folder, it is expected to in sub-folders matching package names. */ CLASSES(0x01), /** The content is standard Java resources. */ RESOURCES(0x02); private final int value; DefaultContentType(int value) &#123; this.value = value; &#125; @Override public int getValue() &#123; return value; &#125;&#125; CLASSES：表示只检索.class文件。 RESOURCES：表示检索java标准资源文件。 getScopes()：这个方法规定自定义Transform检索的范围。 有以下取值： 1234567PROJECT // 只有项目内容SUB_PROJECTS // 只有子项目EXTERNAL_LIBRARIES // 只有外部库TESTED_CODE // 由当前变量（包括依赖项）测试的代码PROVIDED_ONLY // 只提供本地或远程依赖项PROJECT_LOCAL_DEPS // 只有项目的本地依赖（本地jar）SUB_PROJECTS_LOCAL_DEPS // 只有子项目的本地依赖项（本地jar） isIncremental：表示当前Transform是否支持增量编译，不需要增量编译，就直接返回false。 transform()：在自定义Transform中最重要的方法。在这个方法中可以获取两个数据的流向。 inputs：inputs中传过来的输入流，其中有两种格式，一种是jar包格式，一种是directory（目录格式）。 outputProvider：outputProvider获取到输出目录，最后将修改的文件复制到输出目录，这一步必须做，否则编译报错。 下面实现了一个简单的LifeCycleTransform，功能是打印出所有.class文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package tyler.liu.pluginimport com.android.build.api.transform.DirectoryInputimport com.android.build.api.transform.QualifiedContentimport com.android.build.api.transform.Transformimport com.android.build.api.transform.TransformExceptionimport com.android.build.api.transform.TransformInputimport com.android.build.api.transform.TransformInvocationimport com.android.build.gradle.internal.pipeline.TransformManagerimport groovy.io.FileTypepublic class LifeCycleTransform extends Transform &#123; // 1 @Override String getName() &#123; return \"LifeCycleTransform\"; &#125; // 2 @Override Set&lt;QualifiedContent.ContentType&gt; getInputTypes() &#123; return TransformManager.CONTENT_CLASS &#125; // 3 @Override Set&lt;? super QualifiedContent.Scope&gt; getScopes() &#123; return TransformManager.PROJECT_ONLY &#125; @Override boolean isIncremental() &#123; return false &#125; // 4 @Override void transform(TransformInvocation transformInvocation) throws TransformException, InterruptedException, IOException &#123; // 拿到所有的class文件 Collection&lt;TransformInput&gt; transformInputs = transformInvocation.inputs transformInputs.each &#123; TransformInput transformInput -&gt; // directoryInputs代表以源码方式参与项目编译的所有目录结构及其目录下的源码文件 // 比如手写的类以及R.class、BuildConfig.class以及MainActivity.class等 transformInput.directoryInputs.each &#123; DirectoryInput directoryInput -&gt; File dir = directoryInput.file if (dir) &#123; dir.traverse(type: FileType.FILES, nameFilter: ~/.*\\.class/) &#123; File file -&gt; System.out.println(\"find class: \" + file.name) &#125; &#125; &#125; &#125; &#125;&#125; 1、自定义的Transform的名称为LifeCycleTransform。 2、检索项目中的.class类型的目录或者文件。 3、设置当前Transform检索范围为当前项目。 4、设置过滤文件为.class文件（去除文件夹类型），并打印文件名称。 4.4.2 将自定义的LifeCycleTransform注册到Gradle插件中在LifeCyclePlugin中添加如下代码： 12345678910public class LifeCyclePlugin implements Plugin&lt;Project&gt; &#123; void apply(Project project) &#123; System.out.println(\"==LifeCyclePlugin gradle plugin==\") def android = project.extensions.getByType(AppExtension) println '------------- registering AutoTrackTransform -------------' LifeCycleTransform transform = new LifeCycleTransform() android.registerTransform(transform) &#125;&#125; 再次执行build，可以看到LifeCycleTransform检索出的所有.class文件。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455Executing tasks: [clean, :app:assembleDebug] in project E:\\Project\\MyStudyDemo\\ASMLifeCycleDemo&gt; Configure project :app==LifeCyclePlugin gradle plugin==------------- registering AutoTrackTransform -------------&gt; Task :clean&gt; Task :app:clean UP-TO-DATE&gt; Task :asm_lifecycle_plugin:clean UP-TO-DATE&gt; Task :app:preBuild UP-TO-DATE&gt; Task :app:preDebugBuild UP-TO-DATE&gt; Task :app:generateDebugBuildConfig&gt; Task :app:compileDebugAidl NO-SOURCE&gt; Task :app:compileDebugRenderscript NO-SOURCE&gt; Task :app:javaPreCompileDebug&gt; Task :app:generateDebugResValues&gt; Task :app:generateDebugResources&gt; Task :app:createDebugCompatibleScreenManifests&gt; Task :app:extractDeepLinksDebug&gt; Task :app:processDebugManifest&gt; Task :app:mergeDebugResources&gt; Task :app:processDebugResources&gt; Task :app:compileDebugJavaWithJavac&gt; Task :app:compileDebugSources&gt; Task :app:mergeDebugShaders&gt; Task :app:compileDebugShaders NO-SOURCE&gt; Task :app:generateDebugAssets UP-TO-DATE&gt; Task :app:mergeDebugAssets&gt; Task :app:processDebugJavaRes NO-SOURCE&gt; Task :app:transformClassesWithLifeCycleTransformForDebugfind class: BuildConfig.classfind class: MainActivity.class&gt; Task :app:checkDebugDuplicateClasses&gt; Task :app:dexBuilderDebug&gt; Task :app:mergeDebugJavaResource&gt; Task :app:mergeDebugJniLibFolders&gt; Task :app:validateSigningDebug&gt; Task :app:mergeExtDexDebug&gt; Task :app:mergeDebugNativeLibs&gt; Task :app:stripDebugDebugSymbols NO-SOURCE&gt; Task :app:mergeDexDebug&gt; Task :app:packageDebug&gt; Task :app:assembleDebugDeprecated Gradle features were used in this build, making it incompatible with Gradle 7.0.Use &apos;--warning-mode all&apos; to show the individual deprecation warnings.See https://docs.gradle.org/6.1.1/userguide/command_line_interface.html#sec:command_line_warningsBUILD SUCCESSFUL in 5s24 actionable tasks: 22 executed, 2 up-to-dateBuild Analyzer results available 可以看到，Gradle编译时，多了一个自定义的LifeCycleTransform类型的任务，并且将所有.class文件打印出来，其中包含目标文件MainActivity.class。 4.5 使用ASM，插入字节码到Activity中ASM是一套开源框架，其中几个常见的API如下： ClassReader：负责解析.class文件中的字节码，并将所有字节码传递给ClassWriter。 ClassVisitor：负责访问.class文件中的各个元素，ClassVisitor就是用来解析上节说到的.class文件结构，当解析到某些特定结构时（比如类变量、方法），它会自动调用内部相应的FieldVisitor和MethodVisitor的方法，进一步解析或修改.class文件内容。 ClassWriter：继承自ClassVisitor，它是生成字节码的工具类，负责将修改后的字节码输出为byte数组。 4.5.1 添加ASM依赖在asm_lifecycle_pligun的build.gradle中，添加ASM的依赖： 123456dependencies &#123; ... // ASM依赖 implementation &quot;org.ow2.asm:asm:7.1&quot; implementation &quot;org.ow2.asm:asm-commons:7.1&quot;&#125; 4.5.2 创建自定义ASM Visitor类在asm_lifecycle_plugin中的src/main/java目录下创建包tyler.liu.asm，并分别创建LifeCycleClassVisitor.java和LifeCycleMethodVisitor.java。 LifeCycleClassVisitor.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344package tyler.liu.asm;import org.objectweb.asm.ClassVisitor;import org.objectweb.asm.MethodVisitor;import org.objectweb.asm.Opcodes;/** * @author Liuyang * @date 2020/6/29 */public class LifecycleClassVisitor extends ClassVisitor &#123; private String className; private String superName; public LifecycleClassVisitor(ClassVisitor classVisitor) &#123; super(Opcodes.ASM5, classVisitor); &#125; @Override public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) &#123; super.visit(version, access, name, signature, superName, interfaces); this.className = className; this.superName = superName; &#125; @Override public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) &#123; System.out.println(\"ClassVisitor visitMethod name -----\" + name + \", superName is\" + superName); MethodVisitor mv = cv.visitMethod(access, name, descriptor, signature, exceptions); if (\"android/support/v7/app/AppCompatActivity\".equals(superName)) &#123; if (name.startsWith(\"onCreate\")) &#123; // 处理onCreate方法 return new LifeCycleMethodVisitor(mv, className, name); &#125; &#125; return mv; &#125; @Override public void visitEnd() &#123; super.visitEnd(); &#125;&#125; &quot;android/support/v7/app/AppCompatActivity&quot;.equals(superName)，用来过滤出继承AppCompatActivity的文件，并在LifeCycleMethodVisitor.java中对onCreate进行改造。 LifeCycleMethodVisitor.java 123456789101112131415161718192021222324252627282930313233package tyler.liu.asm;import org.objectweb.asm.MethodVisitor;import org.objectweb.asm.Opcodes;/** * @author Liuyang * @date 2020/6/29 */public class LifeCycleMethodVisitor extends MethodVisitor &#123; private String className; private String methodName; public LifeCycleMethodVisitor(MethodVisitor methodVisitor, String className, String methodName) &#123; super(Opcodes.ASM5, methodVisitor); this.className = className; this.methodName = methodName; &#125; /** * 方法执行前插入 */ @Override public void visitCode() &#123; super.visitCode(); System.out.println(\"MethodVisitor visitCode ----------------\"); mv.visitLdcInsn(\"TAG\"); mv.visitLdcInsn(className + \"-----&gt;\" + methodName); mv.visitMethodInsn(Opcodes.INVOKESTATIC, \"android/util/Log\", \"i\", \"(Ljava/lang/String;Ljava/lang/String;)I\", false); mv.visitInsn(Opcodes.POP); &#125;&#125; 在visitCode()中，是真正执行插入字节码的逻辑。可以看出ASM都是直接以字节码指令的方式进行操作的，所以如果想使用ASM，需要对字节码由一定了解。如果对字节码不是很了解，也可以使用第三方工具ASM ByteCode Outline来生成想要的字节码。 4.5.3 修改LifeCycleTransform的tranform方法，使用ASM各种Visitor定义好之后，就可以修改LifeCycleTransform的transform方法，并将需要插桩的字节码插入到MainActivity.class文件中： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package tyler.liu.pluginimport com.android.build.api.transform.*import com.android.build.gradle.internal.pipeline.TransformManagerimport com.android.utils.FileUtilsimport groovy.io.FileTypeimport org.objectweb.asm.ClassReaderimport org.objectweb.asm.ClassVisitorimport org.objectweb.asm.ClassWriterimport tyler.liu.asm.LifecycleClassVisitorpublic class LifeCycleTransform extends Transform &#123; // 1 @Override String getName() &#123; return \"LifeCycleTransform\"; &#125; // 2 @Override Set&lt;QualifiedContent.ContentType&gt; getInputTypes() &#123; return TransformManager.CONTENT_CLASS &#125; // 3 @Override Set&lt;? super QualifiedContent.Scope&gt; getScopes() &#123; return TransformManager.PROJECT_ONLY &#125; @Override boolean isIncremental() &#123; return false &#125; // 4 @Override void transform(TransformInvocation transformInvocation) throws TransformException, InterruptedException, IOException &#123; // 拿到所有的class文件 Collection&lt;TransformInput&gt; transformInputs = transformInvocation.inputs TransformOutputProvider outputProvider = transformInvocation.outputProvider transformInputs.each &#123; TransformInput transformInput -&gt; // directoryInputs代表以源码方式参与项目编译的所有目录结构及其目录下的源码文件 // 比如手写的类以及R.class、BuildConfig.class以及MainActivity.class等 transformInput.directoryInputs.each &#123; DirectoryInput directoryInput -&gt; File dir = directoryInput.file if (dir) &#123; dir.traverse(type: FileType.FILES, nameFilter: ~/.*\\.class/) &#123; File file -&gt; System.out.println(\"find class: \" + file.name) // 对class文件进行读取和解析 ClassReader classReader = new ClassReader(file.bytes) // 对class文件的写入 ClassWriter classWriter = new ClassWriter(classReader, ClassWriter.COMPUTE_MAXS) // 访问class文件相应的内容，解析到某一个结构就会通知到ClassVisitor的相应方法 ClassVisitor classVisitor = new LifecycleClassVisitor(classWriter) // 依次调用ClassVisitor接口的各个方法 classReader.accept(classVisitor, ClassReader.EXPAND_FRAMES) // toByteArray方法会将最终修改的字节码以byte数组形式返回 byte[] bytes = classWriter.toByteArray() // 通过文件流写入方式覆盖掉原先的内容，实现class文件的改写 FileOutputStream outputStream = new FileOutputStream(file.path) outputStream.write(byte) outputStream.close() &#125; &#125; // 处理完传输文件后，把输出传给下一个文件 def dest = outputProvider.getContentLocation(directoryInput.name, directoryInput.contentTypes, directoryInput.scopes, Format.DIRECTORY) FileUtils.copyDirectory(directoryInput.file, dest) &#125; &#125; &#125;&#125; 4.5.4 重新部署自定义Gradle插件，并运行主项目重新点击uploadAtchives重新部署LifeCyclePlugin。 部署成功后，重新运行APP主项目，当MainActivity被打开时，会在logcat看到如下日志： 12020-06-30 10:00:10.333 5421-5421/com.ly.asmlifecycledemo I/TAG: com/ly/asmlifecycledemo/MainActivity----&gt;onCreate 如果后续有新的Activity，如BActivity.java： 1234567891011121314151617package com.ly.asmlifecycledemo;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;/** * @author Liuyang * @date 2020/6/30 */public class BActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_b); &#125;&#125; 并在MainActivity中实现点击按钮跳转到BActivity： 12345678910111213141516public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button btn = findViewById(R.id.btn); btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; startActivity(new Intent(MainActivity.this, BActivity.class)); &#125; &#125;); &#125;&#125; 打印日志如下： 122020-06-30 10:13:21.105 5647-5647/com.ly.asmlifecycledemo I/TAG: com/ly/asmlifecycledemo/MainActivity----&gt;onCreate2020-06-30 10:13:31.546 5647-5647/com.ly.asmlifecycledemo I/TAG: com/ly/asmlifecycledemo/BActivity----&gt;onCreate 如果在项目中打开混淆，注入的字节码还能正常工作吗？混淆其实也是一个Transform，叫做ProguardTransform，它是在自定义的Transform之后执行。","categories":[{"name":"Android","slug":"Android","permalink":"https://tylerLiu.top/categories/Android/"},{"name":"进阶","slug":"Android/进阶","permalink":"https://tylerLiu.top/categories/Android/进阶/"}],"tags":[{"name":"JVM与DVM必知必会","slug":"JVM与DVM必知必会","permalink":"https://tylerLiu.top/tags/JVM与DVM必知必会/"}]},{"title":"（拉钩）Android工程师进阶34讲-03：字节码层面分析class类文件结构","slug":"（拉钩）Android工程师进阶34讲-03：字节码层面分析class类文件结构","date":"2020-06-21T01:47:24.000Z","updated":"2020-06-25T06:35:14.989Z","comments":true,"path":"2020/06/21/（拉钩）Android工程师进阶34讲-03：字节码层面分析class类文件结构/","link":"","permalink":"https://tylerLiu.top/2020/06/21/（拉钩）Android工程师进阶34讲-03：字节码层面分析class类文件结构/","excerpt":"","text":"0. 前言 面试题：Java中String字符串的长度有限制吗？ 平时开发中，经常会用到String来声明字符串，比如String str = &quot;abc&quot;;，但是有没有想过等于号后面的字符串常量有没有长度限制。要想知道这个，就需要先学习class文件。 1. class的来龙去脉Java能实现“一次编译，到处运行”，这其中class文件占大部分功劳。为了让Java语言有良好的跨平台能力，Java提供了一种可以在所有平台上都能使用的一种中间代码——字节码类文件（.class文件）。有了字节码，无论哪种平台（如：Mac、Windows、Linux等），只要安装了虚拟机都可以直接运行代码。 并且，有了字节码，也解除了Java虚拟机和Java语言之间的耦合。 Java虚拟机当初被设计出来目的不单单只是运行Java一种语言。目前Java虚拟机可以支持很多除Java语言之外的其他语言了，如Groovy、JRuby、Jython、Scala等。之所以可以支持其他语言，是因为这些语言经过编译之后能够被JVM解析并执行的字节码文件。而虚拟机并不关心字节码是由哪种语言编译而来的。如下图： 2. 上帝视角看class文件如果从纵观的角度来看class文件，class文件里只有两种数据结构：无符号数和表。 无符号数：属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用，、数量值或者字符串（UTF-8编码）。 表：表是由多个无符号数或者其他表作为数据项构成的复合数据类型，class文件中所有的表都以“_info”结尾。其实，整个class文件本质上就是一张表。 这二者之间的关系可以用下面这张图表示： 可以看出，在一张表中可以包含其他无符号数和其他表格。伪代码可以如下： 1234567891011121314151617// 无符号数u1 = byte[1];u2 = byte[2];u4 = byte[4];u8 = byte[8];// 表class_table &#123; // 表中可以引用各种无符号数， u1 tag; u2 index2; ... // 表中也可以引用其它表 method_table mt; ...&#125; 3. class文件结构刚才说了class文件只存在无符号数和表这两种数据结构。而这些无符号数和表就组成了class中的各个结构。这些结构按照预先规定好的顺序紧密的从前向后排列，相邻的项之间没有任何缝隙。如下图： 当JVM加载某个class文件时，JVM就是根据上图中的结构去解析class文件的，加载class文件到内存中，并在内存中分配相应的空间。具体某一种结构需要占用多大空间，如下图： 到这里可能有点概念混淆，分不清无符号数、表格以及上面的结构是什么关系。举个例子：人体由H、O、C、N等元素组成的。但这些元素又是按照一定的规律组成人体的各个器官。class文件中的无符号数和表格就相当于人体的H、O、C、N等元素，而class结构图中的各项结构就相当于人体的各个器官，并且这些器官的组织顺序是有严格顺序要求的。 4. 实例分析理清这些概念之后，下面通过一个Java代码实例，来看一下上面这几个结构的详细情况。首先编写一个Java代码Text.java，如下： 1234567891011import java.io.Serializable;public class Test implements Serializable, Cloneable &#123; private int num = 1; public int add(int i) &#123; int j = 10; num = num + i; return num; &#125;&#125; 通过javac将其编译，生成Test.class字节码文件。使用16进制编辑器打开class文件，显示内容如下： 上图中都是一些16进制数字，每两个字符表示一个字节。乍一看各个字符之间毫无规律，但是在JVM的视角里，这些16进制字符是按照严格的规律排列的。接下来就一步一步看看JVN是如何解析它们的。 4.1 魔数(magic number) 如上图所示，在class文件开头的四个字节是class文件的魔数，它是一个固定的值–0XCAFEBABE。魔数是class文件的标志，也就是说它是判断一个文件是不是class格式文件的标准。如果开头的四个字节不是0XCAFEBABE，那么说明它不是class文件，不能被JVM识别或加载。 4.2 版本号 紧跟在魔数后面的四个字节代表当前class文件的版本号。前两个字节 0000 代表次版本号(minor_version)，后两个字节 0034 是主版本号(major_version)，对应的十进制值为52，也就是说当前class文件的主版本号为52，次版本号为0。所以综合版本号为52.0，也就是 jdk1.8.0。 4.3 常量池（重点）紧跟在版本号之后的是一个叫做常量池的表(cp_info)。在常量池中保存了类的各种相关信息，比如类的名称、父类的名称、类中的方法名、参数名称、参数类型等，这些信息都是以各种表的形式保存在常量池中。 常量池中的每一项都是一个表，其项目类型共有14种，如下表所示： 可以看出，常量池中的每一项都会有一个u1大小的tag值。tag值是表的标识，JVM解析class文件时，通过这个值来判断当前数据结构是哪一种表。以上14种表都有自己的结构，这里不再一一介绍，就以CONSTANT_Class_info和CONSTANT_utf8_info这两张表举例说明，因为其他表也基本类似。 首先，CONSTANT_Class_info表的具体结构如下： 1234table CONSTANT_Class_info &#123; u1 tag = 7; u2 name_index;&#125; 说明： tag：占用一个字节大小。比如值为7，说明是CONSTANT_Class_info类型表。 name_index：是一个索引值，可以将它理解为一个指针，指向常量池中索引为name_index的常量表。比如name_index=2，则它指向常量池中第二个常量。 再来看看CONSTANT_utf8_info表具体结构如下： 12345table CONSTANT_utf8_info &#123; u1 tag; u2 length; u1[] bytes;&#125; 说明： tag：值为1，表示是CONSTANT_utf8_info类型表。 length：表示u1[]的长度，比如length=5，表示接下来的数据是5个连续的u1类型数据。 bytes：u1类型数组，长度为上面第二个参数length的值。 而在Java代码中声明的String字符串最终在class文件的存储格式就是CONSTANT_utf8_info。因此字符串最大长度也就是u2所能代表的最大值65536个，但是需要使用2个字节来保存null值，因此字符串的最大长度为65536 - 2 = 65534。 不难看出，在常量池内部的表也有相互之间的引用。用一张图来理解CONSTANT_Class_info和CONSTANT_utf8_info表格之间的关系，如下图： 理解了常量池内部的数据结构之后，接下来就看一下实例代码的解析过程。因为开发者平时定义的Java类各式各样，类中的方法与参数也不尽相同。所以常量池的元素数量也就无法固定，因此class文件在常量池的前面使用2个字节的容量计数器，来表示当前类中常量池的大小。如下图： 001d 转化成十进制就是29，也就是说常量池计数器的值为29.其中下标为0的常量被JVM留作特殊用途。因此Test.class中实际的常量池大小28个。 第一个常量，如下： 0a 转化成十进制为10，通常查看常量池14种表格图中，可以查到tag=10的表类型为CONSTANT_Methodref_info，因此常量池中的第一个常量类型为方法引用表。其结构如下： 12345CONSTANT_Methodref_info &#123; u1 tag = 10; u2 class_index; // 指向此方法的所属类 u2 name_type_index; // 指向此方法的名称和类型&#125; 也就是说在 0a 之后的两个字节指向这个方法是属于哪个类，紧接的两个字节指向这个方法的名称和类型。它们的值分别为： 0006：十进制为6，表示指向常量池中的第6个常量。 0015：十进制为21，表示指向常量池中的第21个常量。 至此，第一个常量解读完毕。紧接着就是第二个常量，如图： tag = 9表示字段引用表CONSTANT_Fieldref_info，其结构如下： 12345CONSTANT_Fieldref_info&#123; u1 tag; u2 class_index; // 指向此字段的所属类 u2 name_type_index; // 指向此字段的名称和类型&#125; 0005：指向常量池中第5个常量。 0016：指向常量池中第22个常量。 这里已经解析了两个常量，剩下的21个常量的解析过程也是大同小异。 实际上可以借助javap命令帮助查看class常量池中的内容： 1javap -v Test.class 执行上述命令之后，显示结果如下： 和刚才的分析一样，常量池中的第一个常量是Methodref类型，指向下标6和下标21的常量。其中下标21的常量类型为NameAndType，它对应的数据结构如下： 12345CONSTANT_NameAndType_info&#123; u1 tag; u2 name_index; // 指向某字段或方法的名称字符串 u2 type_index; // 指向某字段或方法的类型字符串&#125; 而下标在21的NameAndType的name_index和type_index分别指向了13和14，也就是&lt;int&gt;和()V。因此最终解析下来常量池的第一个常量的解析过程以及最终值如下图： 仔细解析层层引用，最后可以看出，Test.clsss文件中常量池的第一个常量保存的是Object中的默认构造方法。 4.4 访问标志(access_flags)紧跟在常量池后面的常量是访问标志，占用两个字节。 访问标志代表类或者接口的访问信息，比如：该class文件是类还是接口，是否被定义成public，是否是abstract，如果是类，是否被声明成final等。各种访问标志如下： 前面定义的Test.java是一个普通类，不是接口、枚举或者注解。并且被public修饰但是没有被声明为final和abstract，因此它所对应的access_falgs为 0021 （0X0001 和 0X0020 相结合）。 4.5 类索引、父类索引和接口索引计数器在访问标志后的2个字节就是类索引，类索引后的2个字节就是父类索引，父类索引后的2个字节是接口索引计数器。如下如： 可以看出类索引指向常量池的第5个常量，父类索引指向常量池中的第6个常量，并且实现的接口个数为2个。再回顾一下常量池中的数据： 从图中可以看出，第5个常量和第6个常量均为“CONSTANT_Class_info”表类型，并且代表的类分别是”Test”和”Object”。再看接口计数器，因为接口计数器的值为2，代表这个类实现了2个接口。查看接口索引计数器之后的4个字节分别是： 0007：指向常量池的第7个常量，从图中可以看出第7个常量值为”Serializable”。 0008：指向常量池的第8个常量，从图中可以看出第8个常量值为”Cloneable”。 综上所述，可以得出如下结论：当前类为Test继承自Object类，并实现了Serializable和Cloneable两个接口。 4.6 字段表紧跟在接口索引集合后面的就是字段表，字段表的主要功能是用来描述类或者接口中声明的变量。这里的字段包含了类级别变量以及实例变量，但是不包括方法内部声明的局部变量。 同样，一个类中的变量个数是不固定的，因此在字段表集合之前还是使用一个计数器来表示变量的个数，如下入： 0002：表示类中声明了两个变量，字段计数器之后紧跟着2个字段表的数据结构。 字段表的数据结构如下： 1234567CONSTANT_Fieldref_info&#123; u2 access_flags // 字段的访问标志 u2 name_index // 字段的名称索引(也就是变量名) u2 descriptor_index // 字段的描述索引(也就是变量的类型) u2 attributes_count // 属性计数器 attribute_info&#125; 继续解析Test.class中的字段表，其结构如下： 4.7 字段访问标志对于Java类中的变量，也可以使用public、private、final、static等标识符进行标识。因此解析字段时，需要先判断它的访问标志，字段的访问标志如下所示： 字段表结构图中的访问标志的值为0002，代表它是private类型。变量名索引指向常量池中的第9个常量，变量名类型索引指向常量池中的第10个常量。第9和10个常量分别是num和I，如下所示： 因此可以得知类中有一个名为num，类型为int类型的变量。对于第二个变量的解析过程也是一样。 注意事项 ： 1、字段表集合中不会列出从父类或者父接口中继承而来的字段。 2、内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。 4.8 方法表字段表之后紧跟着的就是方法表常量。方法表常量也是以一个计数器开始的，因为一个类中的方法数是不固定的，如图： 上图表示Test.class中有了两个方法，但是只在Test.java中声明了一个add()方法，这是为什么呢？这是因为默认构造器方法也被包含在方法表常量中。 方法表的结构如下： 1234567CONSTANT_Methodref_info&#123; u2 access_flags; // 方法的访问标志 u2 name_index; // 指向方法名的索引 u2 descriptor_index; // 指向方法类型的索引 u2 attributes_count; // 方法属性计数器 attribute_info attributes;&#125; 方法也有自己的访问标志，具体如下： 主要看add()方法，具体如下： 1、access_flags = 0001：访问权限为public。 2、bame_index = 0011：指向常量池中的第17个常量，也就是add。 3、type_index = 0012：指向常量池中的第18个常量，也就是(I)。这个方法接收int类型参数，并返回int类型参数。 4.9 属性表在之前解析字段和方法时，在它们的具体结构中可以看到一个叫做attributes_info的表，这就是属性表。 属性表没有固定的结构，各个不同的属性满足以下结构即可： 12345CONSTANT_Attribute_info&#123; u2 name_index; u2 attribute_length length; u1[] info;&#125; JVM中预定义了很多属性表，这里重点看一下Code属性表。 接着上面解析方法表，向下分析： 可以看到，在方法类型索引之后跟着的就是add方法的属性。 0001：是属性计数器，代表只有一个属性。 000f：属性表类型索引，通过查看常量池可以看出，它是一个Code属性，如下所示： Code属性表中，最重要的就是一系列的字节码。通过javap -v Test.class之后，可以看到方法的字节码，如下显示了add方法的字节码指令： JVM 执行add方法时，就是通过这一系列的指令来完成相应的操作的。","categories":[{"name":"Android","slug":"Android","permalink":"https://tylerLiu.top/categories/Android/"},{"name":"进阶","slug":"Android/进阶","permalink":"https://tylerLiu.top/categories/Android/进阶/"}],"tags":[{"name":"JVM与DVM必知必会","slug":"JVM与DVM必知必会","permalink":"https://tylerLiu.top/tags/JVM与DVM必知必会/"}]},{"title":"（拉钩）Android工程师进阶34讲-02：GC回收机制与分代回收策略","slug":"（拉钩）Android工程师进阶34讲-02：GC回收机制与分代回收策略","date":"2020-06-18T00:43:12.000Z","updated":"2020-06-20T09:30:36.010Z","comments":true,"path":"2020/06/18/（拉钩）Android工程师进阶34讲-02：GC回收机制与分代回收策略/","link":"","permalink":"https://tylerLiu.top/2020/06/18/（拉钩）Android工程师进阶34讲-02：GC回收机制与分代回收策略/","excerpt":"","text":"0. 前言垃圾回收(Garbage Collection)，简称GC。Java语言比C语言好的地方在于，不需要手动释放对象的内存，JVM中的垃圾回收器(Garbage Collector)会自动回收。但是：一旦这种自动化机制出错，就需要去深入理解GC回收机制，甚至需要对这些“自动化”的技术实施必要的监控和调节。 上一节介绍了Java内存运行时区域的各个部分，其中程序计数器、虚拟机栈、本地方法栈三个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊的执行入栈和出栈操作，这几个区域内不需要过多考虑回收问题。 而堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的就是这部分内存。 1. 什么是垃圾所谓垃圾就是内存中已经没有用的对象。既然是“垃圾回收”，就必须知道哪些对象是垃圾。Java虚拟机中使用一种叫做 “可达性分析” 的算法来决定对象是否可被回收。 1.1 可达性分析可达性分析算法是从离散数学中的图论引入的，JVM把内存中所有的对象之间的引用关系看作一张图，通过一组名为“GC Root”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，最后通过判断对象的引用链是否可达来决定对象是否可以被回收。如下图： 上图，对象A/B/C/D/E与GC Root之间都存在一条直接或间接的引用链，这也代表它们与GC Root之间是可达的，因此它们是不能被GC回收掉的。而对象M和K虽然被对象J引用到，但是并不存在一条引用链连接它们与GC Root，所以当GC进行垃圾回收时，只要遍历到J/K/M这三个对象，就会将它们回收。 注意：上图中圆形图标虽然标记的是对象，但实际上代表的是此对象在内存中的引用。包括GC Root也是一组引用而非对象。 1.2 GC Root对象在Java中，有以下几种对象可以作为GC Root： 1、Java虚拟机栈（局部变量表）中的引用的对象。 2、方法区静态引用指向的对象。 3、仍处于活跃状态中的线程对象。 4、Native方法中JVM引用的对象。 2. 什么时候回收不同的虚拟机实现有着不同的GC实现机制，一般情况下每种GC实现都会在以下两种情况下触发垃圾回收。 1、Allocation Failure：在堆内存中分配时，如果因为可用剩余空间不足导致对象内存分配失败，这时系统触发一次GC。 2、System.gc()：在应用层，可以主动调用API来进行一次GC。 3. 代码验证GC Root的几种情况现在了解了Java中的GC Root，以及何时触发GC，下面通过几个案例来验证GC Root的情况。在看具体代码前，先了解一个执行Java命令时的参数。 -Xms 初始分配Java运行时的内存大小，如果不指定，默认为物理内存的 1/64。 比如运行如下命令执行HelloWorld程序，从物理内存中分配出200M空间给JVM内存。 1java -Xms200m HelloWorld 3.1 验证虚拟机栈（栈帧中的局部变量）中引用的对象作为GC Root代码如下： 12345678910111213141516171819202122232425public class GCRootLocalVariable &#123; private int _10MB = 10 * 1024 * 1024; private byte[] memory = new byte[8 * _10MB]; public static void main(String[] args) &#123; System.out.println(\"开始时：\"); printMemory(); method(); System.gc(); System.out.println(\"第二次GC完成：\"); printMemory(); &#125; public static void method() &#123; GCRootLocalVariable g = new GCRootLocalVariable(); System.gc(); System.out.println(\"第一次GC完成：\"); printMemory(); &#125; public static void printMemory() &#123; System.out.print(\"free is \" + Runtime.getRuntime().freeMemory() / 1024 / 1024 + \" M, \"); System.out.println(\"total is \" + Runtime.getRuntime().totalMemory() / 1024 / 1024 + \" M.\"); &#125;&#125; 打印日志： 123456开始时：free is 242 M, total is 243 M.第一次GC完成：free is 161 M, total is 243 M.第二次GC完成：free is 241 M, total is 243 M. 可以看出： 当第一次GC时，g作为局部变量，引用了new出的对象（80M），并且它作为了GC Root，在GC后不会被GC回收。 第二次GC时，method()方法执行完毕后，局部变量g跟随方法消失，不再有引用类型指向该80M对象，所以第二次GC此后80M也会被回收。 3.2 验证方法区中的静态变量引用的对象作为GC Root代码如下： 1234567891011121314151617181920212223242526public class GCRootStaticVariable &#123; private static int _10MB = 10 * 1024 * 1024; private byte[] memory; private static GCRootStaticVariable staticVariable; public GCRootStaticVariable(int size) &#123; memory = new byte[size]; &#125; public static void main(String[] args) &#123; System.out.println(\"程序开始：\"); printMemory(); GCRootStaticVariable g = new GCRootStaticVariable(4 * _10MB); g.staticVariable = new GCRootStaticVariable(8 * _10MB); // 将g设置为 null，调用GC时可以回收此对象内存 g = null; System.gc(); System.out.println(\"GC完成：\"); printMemory(); &#125; public static void printMemory() &#123; System.out.print(\"free is \" + Runtime.getRuntime().freeMemory() / 1024 / 1024 + \" M, \"); System.out.println(\"total is \" + Runtime.getRuntime().totalMemory() / 1024 / 1024 + \" M.\"); &#125;&#125; 打印日志： 1234程序开始：free is 242 M, total is 243 M.GC完成：free is 161 M, total is 243 M. 可以看到： 程序刚开始运行时，内存为242M，并分别创建了g对象（40M），同时也初始化g对象内部的静态变量staticVariable对象（80M）。当调用GC时，只有g对象的40M被GC回收掉，而静态变量staticVariable作为GC Root，它引用的80M不会被回收。 3.3 验证活跃线程作为GC Root代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class GCRootThread &#123; private int _10MB = 10 * 1024 * 1024; private byte[] memory = new byte[8 * _10MB]; public static void main(String[] args) throws InterruptedException &#123; System.out.println(\"开始前内存情况：\"); printMemory(); AsyncTask at = new AsyncTask(new GCRootThread()); Thread thread = new Thread(at); thread.start(); System.gc(); System.out.println(\"main方法执行完毕，完成GC：\"); printMemory(); thread.join(); at = null; System.gc(); System.out.println(\"线程代码执行完毕，完成GC：\"); printMemory(); &#125; public static void printMemory() &#123; System.out.print(\"free is \" + Runtime.getRuntime().freeMemory() / 1024 / 1024 + \" M, \"); System.out.println(\"total is \" + Runtime.getRuntime().totalMemory() / 1024 / 1024 + \" M.\"); &#125; private static class AsyncTask implements Runnable &#123; private GCRootThread gcRootThread; public AsyncTask(GCRootThread gcRootThread) &#123; this.gcRootThread = gcRootThread; &#125; @Override public void run() &#123; try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 打印日志： 123456开始前内存情况：free is 242 M, total is 243 M.main方法执行完毕，完成GC：free is 161 M, total is 243 M.线程代码执行完毕，完成GC：free is 241 M, total is 243 M. 可以看到： 程序刚开始是242M内存，当调用第一次GC时线程没有执行结束，并且它作为GC Root，所以它所引用的80M内存不会被GC回收掉。thread.join()保证线程结束再调用后续代码，所以当调用第二次GC时，线程已经执行完毕并被设置为null，此时线程已经被销毁，所以之前它所引用的80M此时会被GC回收掉。 3.4 测试成员变量是否可作为GC Root代码如下： 12345678910111213141516171819202122232425public class GCRootClassVariable &#123; private static int _10MB = 10 * 1024 * 102; private byte[] memory; private GCRootClassVariable classVariable; public GCRootClassVariable(int size) &#123; memory = new byte[size]; &#125; public static void main(String[] args) &#123; System.out.println(\"程序开始：\"); printMemory(); GCRootClassVariable g = new GCRootClassVariable(4 * _10MB); g.classVariable = new GCRootClassVariable(8 * _10MB); g = null; System.gc(); System.out.println(\"GC完成：\"); printMemory(); &#125; public static void printMemory() &#123; System.out.print(\"free is \" + Runtime.getRuntime().freeMemory() / 1024 / 1024 + \" M,\"); System.out.println(\"total is \" + Runtime.getRuntime().totalMemory() / 1024 / 1024 + \" M.\"); &#125;&#125; 打印日志： 1234程序开始：free is 238 M,total is 243 M.GC完成：free is 241 M,total is 243 M. 从日志可以看出，当调用GC时，因为g已经设置为null，因此g中的全局变量classVariable此时也不会被GC Root所引用。所以最后g(40M)和classVariable(80M)都会被回收掉。这也表明全局变量和静态变量不同，它不会被作为GC Root。 上面演示的几种情况往往也是内存泄露发生的场景，设想一下将各个Test类换成Android中的Activity的话将导致Activity无法被系统回收，而一个Activity中的数据往往比较大，因此内存泄露导致Activity无法回收还是比较致命的。 4. 如何回收垃圾由于垃圾收集算法的实现涉及大量的程序细节，各家虚拟机厂商对其实现细节也各不相同，因此这里不过多讨论算法的实现，只是介绍几种算法的思想及优缺点。 4.1 标记清除算法(Mark and Sweep GC)从“GC Root”集合开始，将内存整个遍历一次，保留所有可以被GC Root直接或间接引用到的对象，而剩下的对象都当做垃圾回收，过程分为两步。 1、Mark 标记阶段：找到内存中的所有GC Root对象，只要是和GC Root对象直接或间接相连则标记为灰色（即存活对象），否则标记为黑色（即垃圾对象）。 2、Sweep 清除阶段：当遍历完所有的GC Root之后，则将标记为垃圾的对象直接清除。 如下图： 优点：实现简单，不需要将对象进行移动。 缺点：这个算法需要中断进程内其他组件的执行(stop the world)，并且可能产生内存碎片，提高了垃圾回收的频率。 4.2 复制算法(Copying)将现有的内存空间分为两块，每次只是用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中。之后，清除正在使用的内存块中所有的对象，交换两个内存的角色，完成垃圾回收。 1、复制算法之前，内存分为A/B两块，并且当前只使用内存A，内存状况如下图： 2、标记完成之后，所有可达对象都被按次序复制到内存B中，并设置B为当前使用中的内存。内存状况如下图： 4.3 标记-压缩算法(Mark-Compact)需要先从根节点开始对所有可达对象做一次标记，之后，它并不是简单的清理未标记的对象，而是将所有的存活对象压缩到内存的一端。最后，清理边界外所有的空间。因此标记-压缩算法也分为两步： 1、Mark 标记阶段：找到内存中的所有GC Root对象，只要是和GC Root对象直接或间接相连则标记为灰色（即存活对象），否则标记为黑色（即垃圾对象）。 2、Compact 压缩阶段：将剩余存活对象按顺序压缩到内存的某一端。 优点：这种方法避免了碎片的产生，又不需要两块相同的内存空间，因此，性价比高。 缺点：所谓压缩操作，仍需要进行局部对象移动，所以一定程度上降低了效率。 5. JVM分代回收策略Java虚拟机根据对象存活的周期不同，把堆内存划分为几块，一般分为新生代、老年代，这就是JVM的内存分代策略。 注意，在HotSpot中除了新生代和老年代，还有永久代。 分代回收的中心思想就是：对于新创建的对象会在新生代中分配内存，此区域的对象生命周期一般较短。如果经历几次回收仍然存活下来，则将它们转移到老年代中。 5.1 新生代(Young Generation)新生代的对象存放在新生代中，新生代对象朝生夕死，存活率很低。在新生代中，常规应用进行一次垃圾收集，一般可以回收70%~95%的空间，回收效率很高。 新生代又可以细分为三个部分：Eden、Survivor0（简称S0）、Survivor1（简称S1）。这三个部分按照8：1：1的比例来划分新生代。这三个区域的分配过程如下： 绝大多数刚刚被创建的对象会存放在Eden区。如图： 当Eden区第一次存满时，会进行垃圾回收。首先将Eden区的垃圾对象回收清除，并将存活对象复制到S0，此时S1是空的。如图： 下一次Eden区满时，在执行一次垃圾回收。此次会将Eden和S0区所有的垃圾对象清除，并将存活的对象复制到S1，此时S0变为空。如图： 如此反复在S0和S1之间切换几次（默认是15次）之后，如果还有存活对象。说明这些对象的生命周期较长，则将它们转入到老年代。如图： 5.2 老年代(Old Generation)一个对象如果在新生代存活了足够长时间而没有被清理掉，则会被复制到老年代。老年代的内存大小一般比新生代大，能存放更多的对象。如果对象比较大（比如长字符串或大数组），并且新生代的剩余空间不足，则这个大对象会直接被分配到老年代上。 可以使用-XX:PretenureSizeThreshold来控制直接升入老年代的对象的大小，大小这个值的对象会直接分配在老年代上。老年代因为对象的生命周期较长，不需要过多的复制操作，所以一般采用标记-压缩到的回收算法。 注意：对于老年代可能存在这么一种情况，老年代中的对象有时候会引用到新生代对象。这时如果要执行新生代GC，则可能需要查询整个老年代上可能引用新生代的情况，这显然是低效的。所以，老年代中维护了一个512 byte 的card table，所有老年代对象引用新生代对象的信息都记录在这里。每当新生代发生GC时，只需要检查这个 card table即可，大大提高性能。 6. GC Log分析为了让上层开发人员更加方便的调试Java程序，JVM提供了相应的GC日志。在GC执行垃圾回收事件过程中，会有各种相应的log被打印出来。其中新生代和老年代所打印的日志是有区别的： 新生代GC：这一区域的GC叫做Minor GC。因为Java对象大多数都具备朝生夕死的特性，所以Minor GC非常频繁，一般回收速度也比较快。 老年代GC：这一区域的GC叫做Major GC或Full GC。当出现Major GC，经常会伴随至少一次Minor GC。 注意，在有些虚拟机实现中，Major GC和Full GC还有一些区别。Major GC只是代表回收老年代中的内存，而Full GC则代表回收整个堆中的内存，也就是新生代 + 老年代。 接下来通过几个案例分析如何查看GC Log，分析这些GC Log的过程加深对JVM分代策略的理解。 Java命令参数： 命令参数 功能描述 -verbose:gc 显示GC的操作内容 -Xms20M 初始化堆大小为20M -Xmx20M 设置堆最大分配内存为20M -Xmn10M 设置新生代的内存大小为10M -XX:+printGCDetails 打印GC的详细log日志 -XX:SurvivorRatio=8 新生代中Eden区域与Survivor区域的大小比值为8:1:1 使用如下代码，在内存中创建4个byte类型数组来演示内存分配和GC的详细过程。代码如下： 12345678910111213141516171819/** * VM agrs: -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails * -XX:SurvivorRatio=8 */public class MinorGCTest &#123; private static final int _1MB = 1024 * 1024; public static void testAllocation() &#123; byte[] a1, a2, a3, z4; a1 = new byte[2 * _1MB]; a2 = new byte[2 * _1MB]; a3 = new byte[2 * _1MB]; a4 = new byte[1 * _1MB]; &#125; public static void main(String[] agrs) &#123; testAllocation(); &#125;&#125; 通过上面的参数，可以看出堆内存总大小为20M，其中新生代占10M，剩下的10M会自动分配给老年代。执行上述代码日志如下： 123456789HeapPSYoungGen total 9216K, used 8003K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000) eden space 8192K, 97% used [0x00000007bf600000,0x00000007bfdd0ed8,0x00000007bfe00000) from space 1024K, 0% used [0x00000007bff00000,0x00000007bff00000,0x00000007c0000000) to space 1024K, 0% used [0x00000007bfe00000,0x00000007bfe00000,0x00000007bff00000)ParOldGen total 10240K, used 0K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000) object space 10240K, 0% used [0x00000007bec00000,0x00000007bec00000,0x00000007bf600000)Metaspace used 2631K, capacity 4486K, committed 4864K, reserved 1056768K class space used 286K, capacity 386K, committed 512K, reserved 1048576K 日志中的各字段代表意义如下： 字段 代表含义 PSYoungGen 新生代 eden 新生代中的Eden1区 from 新生代中的S0区 to 新生代中的S1区 ParOldGen 老年代 从日志可以看出：程序执行完之后，a1、a2、a3、a4四个对象都被分配在新生代的Eden区。 如果将测试代码中的a4初始化改为a4 = new byte[2 * _1MB];，则打印日志如下： 12345678910[GC (Allocation Failure) [PSYoungGen: 6815K-&gt;480K(9216K)] 6815K-&gt;6632K(19456K), 0.0067344 secs] [Times: user=0.04 sys=0.00, real=0.01 secs]HeapPSYoungGen total 9216K, used 2130K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000) eden space 8192K, 26% used [0x00000007bf600000,0x00000007bf814930,0x00000007bfe00000) from space 1024K, 0% used [0x00000007bfe00000,0x00000007bfe00000,0x00000007bff00000) to space 1024K, 0% used [0x00000007bff00000,0x00000007bff00000,0x00000007c0000000)ParOldGen total 10240K, used 6420K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000) object space 10240K, 62% used [0x00000007bec00000,0x00000007bf2450d0,0x00000007bf600000)Metaspace used 2632K, capacity 4486K, committed 4864K, reserved 1056768K class space used 286K, capacity 386K, committed 512K, reserved 1048576K 这时因为在给a4分配内存之前，Eden区已经被占用了6M，已经无法再分配出2M来存储a4对象。因此会执行一次Minor GC。并尝试将存活的a1、a2、a3复制到S1区。但是S1区只有1M空间，所以无法存储a1、a2、a3中的任意一个对象。这时，a1、a2、a3就会被转移到老年代，最后将a4保存在Eden区。所以最终结果是：Eden区占用2M(a4)，老年代占用6M(a1、a2、a3)。 通过这个测试案例，也间接验证了JVM的内存分配和分代回收策略。 6.1 再谈引用上文介绍了，判断对象是否存活是用过GC Root的引用可达性来判断的。但是JVM中的引用关系不止一种。根据引用强度可分为：强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)、虚引用(Phantom Reference)。 引用 GC回收时机 使用示例 强引用 如果一个对象具有强引用，那垃圾回收器绝对不会回收 Object obj = new Object(); 软引用 在内存实在不足时，会对软引用进行回收 SoftReference&lt;Object&gt; softObj = new SoftReference(); 弱引用 第一次GC回收时，如果垃圾回收器遍历到了此弱引用，就将其回收 WeakReference&lt;Object&gt; weakObj = new WeakReference(); 虚引用 一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获取一个对象的实例 不会使用 平时项目中，特别是Android项目，因为有大量的图像(Bitmap)对象，使用软引用的场景比较多。所以重点看一下软引用的使用，不当的使用软引用会导致系统异常。 6.2 软引用常规使用常规使用代码如下： 12345678910111213141516171819public class SoftReferenceNormal &#123; static class SoftObject &#123; // 120M byte[] data = new byte[120 * 1024 * 1024]; &#125; public static void main(String[] args) &#123; // 将缓存数据用软引用持有 SoftReference&lt;SoftObject&gt; cacheRef = new SoftReference&lt;&gt;(new SoftObject()); System.out.println(\"第一次GC前 软引用：\" + cacheRef.get()); // 进行一次GC回收后，查看对象的回收情况 System.out.println(\"第一次GC后 软引用：\" + cacheRef.get()); // 再分配一个120M的对象，看看缓存对象的回收情况 SoftObject newSo = new SoftObject(); System.out.println(\"再次分配120M强引用对象之后 软引用：\" + cacheRef.get()); &#125;&#125; 执行上述代码，打印日志如下： 首先通过-Xmx200M将堆最大内存设置为200M。从日志可以看出，当第一次GC时，内存中还有剩余可用内存，所以软引用不会被GC回收。但是再次创建一个120M的强引用时，JVM可用内存已经不够，所以会尝试将软引用回收。 6.3 软引用隐藏问题需要注意，被软引用对象关联的对象会自动被垃圾回收器回收，但是软引用对象本身也是一个对象，这些创建的软引用并不会自动被垃圾回收器回收掉。如下代码： 1234567891011121314151617181920212223public class SoftReferenceTest &#123; public static class SoftObject &#123; // 1KB byte[] data = new byte[1024]; // 100M public static int CACHE_INITIAL_CAPACITY = 100 * 1024; // 静态集合保存软引用，会导致这些软引用对象本身无法被垃圾回收器回收 public static Set&lt;SoftReference&lt;SoftObject&gt;&gt; cache = new HashSet&lt;&gt;(CACHE_INITIAL_CAPACITY); public static ReferenceQueue&lt;SoftObject&gt; referenceQueue = new ReferenceQueue&lt;&gt;(); public static void main(String[] args) &#123; for (int i = 0; i &lt; CACHE_INITIAL_CAPACITY; i++) &#123; SoftObject obj = new SoftObject(); cache.add(new SoftReference&lt;&gt;(obj, referenceQueue)); if (i % 10000 == 0) &#123; System.out.println(\"size of cache:\" + cache.size()); &#125; &#125; System.out.println(\"End!\"); &#125; &#125;&#125; 上述代码，虽然每个SoftObject都被一个软引用所引用，在内存紧张时，GC会将SoftObject所占用的1KB回收。但是每个SoftReference又被Set所引用（强引用）。执行上述代码结果如下： 限制堆内存大小为4M，最终程序崩溃，但是异常的原因并不是普通的堆内存溢出，而是“GC overhead”。之所以抛出这个错误，是由于虚拟机一会不断回收软引用，回收进行的速度过快，占用的CPU 过大（超过98%），并且每次回收掉的内存过小（小于2%），导致最终抛出这个错误。 这里需要做优化，合理的处理方式是注册一个引用队列，每次循环之后将引用队列中出现的软引用对象从cache中移除。如下： 1234567891011121314151617181920212223242526272829303132333435public class SoftReferenceTest &#123; public static class SoftObject &#123; // 1KB byte[] data = new byte[1024]; &#125; public static int removeSoftRefs = 0; // 100M public static int CACHE_INITIAL_CAPACITY = 100 * 1024; // 静态集合保存软引用，会导致这些软引用对象本身无法被垃圾回收器回收 public static Set&lt;SoftReference&lt;SoftObject&gt;&gt; cache = new HashSet&lt;&gt;(CACHE_INITIAL_CAPACITY); public static ReferenceQueue&lt;SoftObject&gt; referenceQueue = new ReferenceQueue&lt;&gt;(); public static void main(String[] args) &#123; for (int i = 0; i &lt; CACHE_INITIAL_CAPACITY; i++) &#123; SoftObject obj = new SoftObject(); cache.add(new SoftReference&lt;&gt;(obj, referenceQueue)); clearUselessReference(); if (i % 10000 == 0) &#123; System.out.println(\"size of cache:\" + cache.size()); &#125; &#125; System.out.println(\"End, removed soft reference = \" + removeSoftRefs); &#125; public static void clearUselessReference() &#123; Reference&lt;? extends SoftObject&gt; ref = referenceQueue.poll(); while (ref != null) &#123; if (cache.remove(ref)) &#123; removeSoftRefs++; &#125; ref = referenceQueue.poll(); &#125; &#125;&#125; 再次运行，结果如下： 可以看出优化后，程序可以正常执行完。并且在执行过程中会动态的将集合中的软引用删除。","categories":[{"name":"Android","slug":"Android","permalink":"https://tylerLiu.top/categories/Android/"},{"name":"进阶","slug":"Android/进阶","permalink":"https://tylerLiu.top/categories/Android/进阶/"}],"tags":[{"name":"JVM与DVM必知必会","slug":"JVM与DVM必知必会","permalink":"https://tylerLiu.top/tags/JVM与DVM必知必会/"}]},{"title":"大话设计模式-02：商场促销——策略模式","slug":"大话设计模式-02：商场促销——策略模式","date":"2020-06-14T06:05:18.000Z","updated":"2020-06-14T06:07:45.986Z","comments":true,"path":"2020/06/14/大话设计模式-02：商场促销——策略模式/","link":"","permalink":"https://tylerLiu.top/2020/06/14/大话设计模式-02：商场促销——策略模式/","excerpt":"","text":"","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://tylerLiu.top/categories/设计模式/"},{"name":"大话设计模式","slug":"设计模式/大话设计模式","permalink":"https://tylerLiu.top/categories/设计模式/大话设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://tylerLiu.top/tags/设计模式/"}]},{"title":"大话设计模式-01：代码无错就是优？——简单工厂模式","slug":"大话设计模式-01：代码无错就是优？——简单工厂模式","date":"2020-06-13T08:14:19.000Z","updated":"2020-06-14T06:00:27.420Z","comments":true,"path":"2020/06/13/大话设计模式-01：代码无错就是优？——简单工厂模式/","link":"","permalink":"https://tylerLiu.top/2020/06/13/大话设计模式-01：代码无错就是优？——简单工厂模式/","excerpt":"","text":"0. 前言要求实现一个计算器的代码： 123456789101112131415161718192021222324public class Program &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); System.out.println(\"请输入数字A：\"); String A = scanner.nextLine(); System.out.println(\"请选择运算符号（+、-、*、/）：\"); String B = scanner.nextLine(); System.out.println(\"请输入数字C：\"); String C = scanner.nextLine(); String D = \"\"; if (B.equals(\"+\")) D = String.valueOf(Double.valueOf(A) + Double.valueOf(C)); if (B.equals(\"-\")) D = String.valueOf(Double.valueOf(A) - Double.valueOf(C)); if (B.equals(\"*\")) D = String.valueOf(Double.valueOf(A) * Double.valueOf(C)); if (B.equals(\"/\")) D = String.valueOf(Double.valueOf(A) / Double.valueOf(C)); System.out.println(\"结果为：\" + D); &#125;&#125; 1. 代码规范问题： 1、命名不规范； 2、判断分支，用if写，意味着每个条件都要判断，每次都要做三次无用功 3、如果除数为0或者不是数字，而是其他的字符，如何处理？ 修改之后： 12345678910111213141516171819202122232425262728293031323334public class Program &#123; public static void main(String[] args) &#123; try &#123; Scanner scanner = new Scanner(System.in); System.out.println(\"请输入数字A：\"); String strNumberA = scanner.nextLine(); System.out.println(\"请选择运算符号（+、-、*、/）：\"); String strOperate = scanner.nextLine(); System.out.println(\"请输入数字B：\"); String strNumberB = scanner.nextLine(); String strResult = \"\"; switch (strOperate) &#123; case \"+\": strResult = String.valueOf(Double.valueOf(strNumberA) + Double.valueOf(strNumberB)); break; case \"-\": strResult = String.valueOf(Double.valueOf(strNumberA) - Double.valueOf(strNumberB)); break; case \"*\": strResult = String.valueOf(Double.valueOf(strNumberA) * Double.valueOf(strNumberB)); break; case \"/\": strResult = String.valueOf(Double.valueOf(strNumberA) / Double.valueOf(strNumberB)); break; &#125; System.out.println(\"结果为：\" + strResult); &#125; catch (Exception e) &#123; System.out.println(\"输入有误：\" + e); &#125; &#125;&#125; 2. 业务封装程序不单要实现需求，还需要易维护，易扩展，易复用。 面向对象的分析设计编程思想，考虑通过封装、继承、多态把程序的耦合度降低，使用设计模式使程序更加灵活，容易修改，并且易于复用。 让业务逻辑和界面逻辑分开，降低耦合，只有分离开，才能容易维护或扩展。 Operation运算类 12345678910111213141516171819202122public class Operation &#123; public static double getResult(double numberA, double numberB, String operation) &#123; double result = 0D; switch (operation) &#123; case \"+\": result = numberA + numberB; break; case \"-\": result = numberA - numberB; break; case \"*\": result = numberA * numberB; break; case \"/\": result = numberA / numberB; break; &#125; return result; &#125;&#125; 客户端代码 12345678910111213141516171819202122public class Program &#123; public static void main(String[] args) &#123; try &#123; Scanner scanner = new Scanner(System.in); System.out.println(\"请输入数字A：\"); String strNumberA = scanner.nextLine(); System.out.println(\"请选择运算符号（+、-、*、/）：\"); String strOperate = scanner.nextLine(); System.out.println(\"请输入数字B：\"); String strNumberB = scanner.nextLine(); String strResult = \"\"; strResult = String .valueOf(Operation.getResult(Double.valueOf(strNumberA), Double.valueOf(strNumberB), strOperate)); System.out.println(\"结果为：\" + strResult); &#125; catch (Exception e) &#123; System.out.println(\"输入有误：\" + e); &#125; &#125;&#125; 3. 紧耦合 &amp; 松耦合上面只用到了封装，继承和多态如何使用？ 思考：如上，如果需要增加一个新的运算，按照一般方法，就是在switch中新增加一个case，但是这样，为了增加一个新的运算，却要所有的运算都参与编译，另外，如果不小心修改了其他case里面的内容，就会造成程序错误。 所以应该把运算分离，修改其中一个，不会影响到另外几个，增加新的运算，也不会影响其他代码。 修改Operation运算类，接口 123public interface IOperation &#123; double getResult(double numberA, double numberB);&#125; 加减乘除类 123456789101112131415161718192021222324252627282930public class OperationAdd implements IOperation &#123; @Override public double getResult(double numberA, double numberB) &#123; return numberA + numberB; &#125;&#125;public class OperationSub implements IOperation &#123; @Override public double getResult(double numberA, double numberB) &#123; return numberA - numberB; &#125;&#125;public class OperationMul implements IOperation &#123; @Override public double getResult(double numberA, double numberB) &#123; return numberA * numberB; &#125;&#125;public class OperationDiv implements IOperation &#123; @Override public double getResult(double numberA, double numberB) &#123; if (numberB == 0) &#123; throw new IllegalArgumentException(\"除数不能为0\"); &#125; return numberA / numberB; &#125;&#125; 4. 简单工厂模式现在的问题就是如何去实例化对象的问题，可以使用简单工厂模式，即，到底要实例化谁，将来会不会增加实例化的对象，可以考虑使用一个单独的类来做这个创建实例的过程，这就是工厂。 简单运算工厂类 1234567891011121314151617181920public class OperationFactory &#123; public static Operation createOperation(String operation) &#123; Operation oper = null; switch (operation) &#123; case \"+\": oper = new OperationAdd(); break; case \"-\": oper = new OperationSub(); break; case \"*\": oper = new OperationMul(); break; case \"/\": oper = new OperationDiv(); break; &#125; return oper; &#125;&#125; 这样只需要输入运算符工厂类就会实例化对应的对象，通过多态，返回父类的方法实现计算的结果。 12IOperation operation = OperationFactory.createOperation(\"-\");operation.getResult(2, 1);","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://tylerLiu.top/categories/设计模式/"},{"name":"大话设计模式","slug":"设计模式/大话设计模式","permalink":"https://tylerLiu.top/categories/设计模式/大话设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://tylerLiu.top/tags/设计模式/"}]},{"title":"（拉钩）Android工程师进阶34讲-01：程序运行时，内存到底是如何进行分配的？","slug":"（拉钩）Android工程师进阶34讲-01：程序运行时，内存到底是如何进行分配的？","date":"2020-06-10T07:47:49.000Z","updated":"2020-06-17T09:00:27.522Z","comments":true,"path":"2020/06/10/（拉钩）Android工程师进阶34讲-01：程序运行时，内存到底是如何进行分配的？/","link":"","permalink":"https://tylerLiu.top/2020/06/10/（拉钩）Android工程师进阶34讲-01：程序运行时，内存到底是如何进行分配的？/","excerpt":"","text":"0. 前言将Java的内存分为堆内存(Heap)和栈内存(Stack)，这样划分体现了这两块区域时Java工程师最关注的内存区域。但是这样划分并不完全正确。 Java虚拟机在执行Java程序过程中，会把它所管理的内存划分成不同的数据区域。下面的图描述了一个HelloWorld.java文件被JVM加载到内存中的过程： 1、HelloWorld.java文件首先需要经过编译器编译，生成HelloWorld.class字节码文件。 2、Java程序访问HelloWorld这个类时，需要通过ClassLoader（类加载器）将HelloWorld.class加载到JVM的内存中。 3、JVM的内存可以划分为若干个不同的数据区域，主要分为：程序计数器、虚拟机栈、本地方法栈、堆、方法区。 1. 程序计数器(Program Counter Register)Java程序是多线程的，CPU可以在多个线程中分配执行时间片段。当某一个线程被CPU挂起时，需要记录代码已经执行到的位置，方便CPU重新执行此线程时，知道从哪行命名开始执行。这就是程序计数器的作用。 程序计数器是虚拟机中的一块较小的内存空间，主要用户记录当前线程执行的位置。 如下图所示：每个线程都会记录当前方法执行到的位置，当CPU切换到某一个线程时，则根据程序计数器记录的数字，继续向下执行指令。 实际上除了上图演示的恢复线程操作之外，其他一些我们熟悉的分支操作、循环操作、跳转、异常处理等也都需要依赖这个计数器来完成。 关于计数器还有几点需要格外注意： 1、在Java虚拟机规范中，对程序计数器这一区域没有规定任何OutOfMemoryError情况。 2、线程私有的，每条线程内部都有一个私有程序计数器。它的生命周期随着线程的创建而创建，随着线程的结束而死亡。 3、当一个线程正在执行一个Java方法的时候，这个计数器记录的是正在执行的虚拟字节码指令的地址。如果正在执行的是Native方法，这个计数器值为空(Undefined)。 2. 虚拟机栈虚拟机栈也是线程私有的，与线程的生命周期同步。在Java虚拟机规范中，对这个区域规定了两种异常情况： 1、StackOverflowError：当线程请求栈深度超过虚拟机栈所允许的深度时抛出。 2、OutOfMemoryError：当Java虚拟机动态扩展到无法申请足够的内存时抛出。 在学习Java虚拟机过程中，常会看到一句话： JVM是基于栈的解释器执行的， DVM是基于寄存器解释器执行的。 上面的“基于栈”指的就是虚拟机栈。虚拟机栈的初衷是用来描述Java方法执行的内存模型，每个方法被执行的时候，JVM都会在虚拟机中创建一个栈帧。 2.1 栈帧栈帧(Stack Frame)，是用于支持虚拟机进行方法调用和方法执行的数据结构，每一个线程在执行某个方法时，都会为这个方法创建一个栈帧。 可以这样理解：一个线程包含多个栈帧，而每个栈帧内部包含局部变量、操作数栈、动态链接、返回地址等。如下图： 2.2 局部变量表局部变量是变量值的存储空间，调用方法时传递的参数，以及在方法内部创建的局部变量都保存在局部变量表中。在Java编译成Class文件时，就会在方法的Code属性表中的max_locals数据项中，确定该方法需要分配的最大局部变量表的容量。如下代码： 12345public static int add(int k) &#123; int i = 1; int j = 2; return i + j + k;&#125; 使用javap-v反编译之后，得到如下字节码指令： 123456789101112131415public static int add(int); descriptor: (I)I flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=3, args_size=1 0: iconst_1 1: istore_1 2: iconst_2 3: istore_2 4: iload_1 5: iload_2 6: iadd 7: iload_0 8: iadd 9: ireturn 上面的locals=3就是代表局部变量表的长度，也就是说经过编译之后，局部变量表的长度已经确定是3，分别保存参数k和局部变量i、j。 注意：系统不会为局部变量赋予初始值（实例变量和类变量都会被赋予初始值），也就是说不存在类变量那样的准备阶段。这一点会在后续的Class初始化中详细介绍。 2.3 操作数栈操作数栈（Operand Stack），也称操作栈，它是一个后入先出栈。 和局部变量表一样，操作数栈的最大深度也在编译的时候写入方法的Code属性表中的max_stacks数据项中。栈中的元素可以是任意Java数据类型，包括long和double。 当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的。在方法执行的过程中，会有各种字节码指令被压入和弹出操作数栈（比如：iadd指令就是将操作数栈中栈顶的两个元素弹出，执行加法运算，并将结果重新压回到操作数栈中）。 2.4 动态链接动态链接的主要目的是为了支持方法调用过程中的动态链接(Dynamic Linking)。 在一个class文件中，一个方法要调用其他方法，需要将这些方法的符号引用转化为其所在内存地址中的直接引用，而符号引用存在于方法区中。 在Java虚拟机栈中，每个栈帧都包含一个指向运行时常量池中该栈所属方法的符号引用，持有这个引用的目的就是为了支持调用过程中的动态链接。具体过程会在后面字节码中讲解。 2.5 返回地址当一个方法执行后，只有两种方法可以退出这个方法： 正常退出：指方法中的代码正常完成，或者遇到任意一个方法返回的字节码指令(如return)并退出，没有抛出任何异常。 异常退出：指方法执行过程中遇到异常，并且这个异常在方法体内部没有得到处理，导致方法退出。 无论当前方法采用何种退出方式，在方法退出后都需要返回到方法被调用的位置，程序才能继续执行。而虚拟机栈中的“返回地址”就是用来帮助当前方法恢复到它的上层方法执行状态。 一般来说，方法正常退出时，调用者的PC计数值可以作为返回地址，栈帧中可能保存此计数值。而方法异常退出时，返回地址是通过异常处理器表确定的，栈帧中一一般不会保存此部分的信息。 2.6 实例讲解下面用一个add()方法来演示，代码如下： 123456public int add() &#123; int i = 1; int j = 2; int result = i + j; return result + 10;&#125; 使用javap命令来查看某个类的字节码指令，比如add()方法的代码，经过javap之后的字节码指令如下： 1234567891011120: iconst_1 （把常量 1 压入操作数栈栈顶）1: istore_1 （把操作数栈栈顶的出栈放入局部变量表索引为 1 的位置）2: iconst_2 （把常量 2 压入操作数栈栈顶）3: istore_2 （把操作数栈栈顶的出栈放入局部变量表索引为 2 的位置）4: iload_1 （把局部变量表索引为 1 的值放入操作数栈栈顶）5: iload_2 （把局部变量表索引为 2 的值放入操作数栈栈顶）6: iadd （将操作数栈栈顶的和栈顶下面的一个进行加法运算后放入栈顶）7: istore_3 （把操作数栈栈顶的出栈放入局部变量表索引为 3 的位置）8: iload_3 （把局部变量表索引为 3 的值放入操作数栈栈顶）9: bipush 10 （把常量 10 压入操作数栈栈顶）11: iadd （将操作数栈栈顶的和栈顶下面的一个进行加法运算后放入栈顶）12: ireturn （结束） 从上面的字节码指令可以看到，其实局部变量表和操作数栈在代码执行期间是协同合作来达到某一运算效果的。接下来通过图示来看以上代码在执行期间，虚拟机栈的实际情况。 各指令代表的意思： iconst和binpush：这两个指令都是将常量压入操作数栈顶，区别就是：当int取值-15采用iconst指令，取值-128127采用binpush指令。 istore：将操作数栈顶的元素放入局部变量表的某索引位置，比如istore_5表示将操作数栈顶的元素放到局部变量表下标为5的位置。 iload：将局部变量表中某下标上的值加载到操作数栈顶中，比如iload_2表示将局部变量表下标为2上的值压入到操作数栈顶。 iadd：表示加法运算，具体是将操作数栈顶最上方的两个元素进行相加操作，然后将结果重新压入栈顶。 首先在Add.java被编译成Add.class时，栈帧中需要多大的局部变量表，多深的操作数栈已经完全确定了，并且写入到了方法表的Code属性中。因此这会局部变量表的大小是确定的，add()方法中有三个局部变量，因此局部变量表的大小为3，但是操作数栈此时为空。 所以代码刚执行到add()方法时，局部变量表和操作数栈的情况如下： iconst_1 把常量1压入操作数栈顶，如下： istore_1 把操作数栈顶的元素出栈并放入局部变量表下标为1的位置，如下： 可以看到此时操作数栈重新变为空，并将出栈元素1保存到局部变量表中。 iconst_2 把常量2压入到操作数栈顶，如下： istore_2 把操作数栈顶的元素出栈并放入到局部变量表下标为2的位置，如下： 接下来是iload_1和iload_2。分别表示将局部变量表下标为1和2的元素重新压入操作数栈中，如下： 然后进行iadd操作，将栈顶最上方的两个元素进行加法操作，然后将结果重新压入到操作数栈顶，如下： istore_3 将操作数栈顶的元素出栈，保存到局部变量表下标为3的位置，如下： iload_3 将局部变量表下标为3的元素重新压入到操作数栈顶，如下： bipush 10 将常量10压入到操作数栈顶，如下： 再次执行iadd操作， 如下： 最后执行ireturn指令，将操作数栈顶的元素13返回给上层方法。至此add()方法执行完毕。局部变量表和操作数栈也会被销毁。 3. 本地方法栈本地方法栈和虚拟机栈基本相同，只不过是针对本地(native)方法。开发中，如果涉及JNI接触本地方法栈会多一些，在有些虚拟机的实现中已经将二者合二为一（比如HotSpot）。 4. 堆堆(Heap)，是JVM所管理的内存最大的一块，该区域的唯一目的就是存放对象实例，几乎所有的对象的实例都在堆里面分配，因此它也是Java垃圾收集器(GC)管理的主要区域，有时也叫做“GC堆”。同时它也是所有线程共享的内存区域，因此被分配在此区域的对象如果被多个线程访问的话，需要考虑线程安全问题。 按照对象存储时间的不同，堆中的内存可以划分为新生代(Young)和老年代(Old)，其中新生代又被划分为Eden和Survivor区。如图： 图中不同区域存放具有不同生命周期的对象，这样可以根据不同的区域使用不同的垃圾回收算法，从而更具有针对性，进而提高垃圾回收效率。 5. 方法区方法区(Method Area)，也是JVM规范中规定的一块运行时数据区。方法区主要是存储已经被JVM加载的类信息（版本、字段、方法、接口）、常量、静态变量、即时编译器编译之后的代码和数据。该区域和堆一样，也是被各个线程共享的内存区域。 注意：关于方法区，会跟“永久区”混淆。所以在这里对二者进行一下对比： 方法区是JVM规范中规定的一块区域，但是并不是实际实现，切忌将规范跟实际实现混淆，不同的JVM厂商可以有不同版本的“方法区”的实现。 HotSpot在JDK 1.7以前使用“永久区”（或者叫Perm区）来实现方法区，在JDK 1.8以后“永久区”就已经被移除了，取而代之的是“元空间(metaspace)”的实现方式。 总结一下： 方法区是规范层面的东西，规定了这一区域要存放哪些数据。 永久区或者是metaspace是对方法区的不同实现，是实现层面的东西。 6. 异常再现6.1 StackOverflowError 栈溢出异常递归调用是造成StackOverflowError的一个常见场景，如下： 1234567891011121314151617public class StackOver &#123; private int number; public static void main(String[] args) &#123; StackOver so = new StackOver(); try &#123; so.method(); &#125; catch (StackOverflowError e) &#123; System.out.println(\"栈容量已经溢出！\"); &#125; &#125; public void method() &#123; number++; method(); &#125;&#125; 在method()方法中，递归调用了自身，并且没有设置结束条件。运行上述代码时，则会产生StackOverflowError。 原因就是每调用一次method()方法时，都会在虚拟机栈中创建一个栈帧。因为是递归调用，method()方法并不会退出，也就不会销毁栈帧；所以必然会导致StackOverflowError。因此当使用递归时，要格外注意。 6.2 OutOfMemoryError 内存溢出异常理论上，虚拟机栈、堆、方法区都有可能发生OutOfMemoryError。但实际项目中，大多数发生在堆中。如下： 12345678public class HeapError &#123; public static void main(String[] args) &#123; ArrayList list = new ArrayList(); while (true) &#123; list.add(new HeapError()); &#125; &#125;&#125; 在一个无限循环中，动态向ArrayList中添加新的HeapError对象。这样不断的占用堆的内存，当堆内存不够时，必然产生OutOfMemoryError。 7. 总结对于JVM运行时内存布局，需要记住：上面介绍的5块内容都是在Java虚拟机规范中定义的规则，这些规则只是描述各个区域是负责做什么事情、存储什么样的数据、如何处理异常、是否允许线程间共享等。并不是虚拟机的“具体实现”，虚拟机的具体实现很多，比如Sun公司的HotSpot、JRocket、IBM J9，以及Android Dalvik和ART等。这些具体实现符合上面5中运行时数据区的前提下，各自会有不同的实现方式。 总的来说，JVM的运行时内存结构中一共有两个“栈”和一个“堆”，分别是：Java虚拟机栈和本地方法栈，以及“GC堆”和方法区。除此之外还有一个程序计数器。JVM内存中只有堆和方法区是线程共享的数据区域，其他区域都是线程私有的。并且程序计数器是唯一一个在Java虚拟机规范中没有任何OutOfMemoryError情况的区域。","categories":[{"name":"Android","slug":"Android","permalink":"https://tylerLiu.top/categories/Android/"},{"name":"进阶","slug":"Android/进阶","permalink":"https://tylerLiu.top/categories/Android/进阶/"}],"tags":[{"name":"JVM与DVM必知必会","slug":"JVM与DVM必知必会","permalink":"https://tylerLiu.top/tags/JVM与DVM必知必会/"}]},{"title":"Kotlin系列-01：DSL","slug":"Kotlin系列-01：DSL","date":"2020-06-04T05:20:54.000Z","updated":"2020-06-09T07:11:04.088Z","comments":true,"path":"2020/06/04/Kotlin系列-01：DSL/","link":"","permalink":"https://tylerLiu.top/2020/06/04/Kotlin系列-01：DSL/","excerpt":"","text":"原文地址：https://www.jianshu.com/p/0766ede7e917 1. 什么是DSL？DSL是Domin Specific Language，领域特定语言。指的是专注于某个应用程序领域的计算机语言，比如显示网页的HTML、用于数据库处理的SQL、用于检索或替换文本的正则表达式。与DSL相对的是GPL(General Purpose Language)，通用编程语言，如C、Java、Objective-C等。 DSL分为外部DSL和内部DSL。外部DSL是一种可以独立解析的语言，就像SQL，它专注于数据库的操作；内部DSL是通用语言暴露的用来执行特定任务的API，它利用语言本身的特性，将API以特殊的形式暴露出去，例如Android的Gradel和iOS的依赖管理组件CocosPods，Geadle是基于Groovy的，Groovy是一种通用语言，但是Gradle基于Groovy的语言，构建了自己的一套DSL，所以在配置Gradle时，必须遵循Groovy的语法，还要遵循Gradle的DSL标准。 Android的Gradle 1234567891011121314151617181920212223242526272829303132333435363738apply plugin: 'com.android.application'apply plugin: 'kotlin-android'apply plugin: 'kotlin-android-extensions'apply plugin: 'kotlin-kapt'android &#123; compileSdkVersion 28 defaultConfig &#123; applicationId \"com.tanjiajun.androidgenericframework\" minSdkVersion rootProject.minSdkVersion targetSdkVersion rootProject.targetSdkVersion versionCode 1 versionName \"1.0\" testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\" &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro' &#125; &#125; androidExtensions &#123; experimental = true &#125; dataBinding &#123; enabled = true &#125; packagingOptions &#123; pickFirst 'META-INF/kotlinx-io.kotlin_module' pickFirst 'META-INF/atomicfu.kotlin_module' pickFirst 'META-INF/kotlinx-coroutines-io.kotlin_module' &#125;&#125; iOS的Podfile文件 12345678910111213source &apos;https://github.com/CocoaPods/Specs.git&apos;platform :ios, &apos;10.0&apos;use_frameworks!target &apos;GenericFrameworkForiOS&apos; **do**​ pod &apos;SnapKit&apos;, &apos;~&gt; 4.0&apos;**end** 2. 实现原理本文主要讲Kotlin的DSL，先来了解一个概念和语法。 2.1 扩展函数声明一个扩展函数，需要用到一个接受者类型(receiver type)，也就是被扩展的类型作为前缀，如下： 1fun Activity.getViewModelFactory(): ViewModelFactory = ViewModelFactory((applicationContext as AndroidGenericFrameworkApplication).userRepository) 声明一个getViewModelFactory()函数，它是Activity的扩展函数。 2.2 Lambda表达式Java 8以下不支持Lambda表达式，Kotlin解决了与Java的互操作性，Kotlin的Lambda表达式以更加简洁的语法实现功能，使开发者从冗余的语法中解放出来。 2.3 Lambda表达式分类2.3.1 普通Lambda表达式不接受任何参数返回Uint的Lambda表达式 1() -&gt; Unit 接受一个可空的TabLayout.Tab参数，返回Unit的Lambda表达式 1(tab: TabLayout.Tab?) -&gt; Unit 2.3.2 带接收者的Lambda表达式带有OnTabSlectedListenerBuilder接收者对象，不接受任何参数返回的Unit的Lambda表达式。这种带接收者的在Kotlin的标准库函数中很常见，如下的作用域函数(Scope Functions)： appyl函数 12345678910111213/** * Calls the specified function [block] with `this` value as its receiver and returns `this` value. * * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#apply). */@kotlin.internal.InlineOnlypublic inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T &#123; contract &#123; callsInPlace(block, InvocationKind.EXACTLY_ONCE) &#125; block() return this&#125; let函数 123456789101112/** * Calls the specified function [block] with `this` value as its argument and returns its result. * * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#let). */@kotlin.internal.InlineOnlypublic inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R &#123; contract &#123; callsInPlace(block, InvocationKind.EXACTLY_ONCE) &#125; return block(this)&#125; 还可以给这些Lambda表达式起别称，叫做类别名(Type aliases)。 1private typealias OnTabCallback = (tab: TabLayout.Tab?) -&gt; Unit 这里给Lambda表达式起了别称，叫OnTabCallback。 Lambda表达式在Kotlin里的这些特性是实现DSL的必备语法糖。 2.4 函数类型实例调用Kotlin提供invoke函数，可以这样写：f.invoke(x)，相当于f(x)，例如： 1onTabReselectedCallback?.invoke(tab) ?: Unit 也可以写成这样： 1onTabReselectedCallback?.let&#123; it(tab) &#125; ?: Unit 2.5 中缀表示法标有infix关键字的函数可以使用中缀表示法（忽略该调用的点和圆括号）调用，中缀函数必须满足以下条件： 1、它们必须是成员函数和扩展函数。 2、它们必须只有一个参数。 3、其参数不得接受可变数量的参数，而且不能有默认值。 例子： 1234567infix fun Int.plus(x: Int): Int = this.plus(x)// 可以中缀表示法调用函数1 plus 2// 等同于1.plus(2) 常用的函数： until函数用法 123for(int 0 until 4)&#123; tlOrder.addTab(tlOrder.newTab().setText(\"订单$i\"))&#125; until函数源码 123456789/** * Returns a range from this value up to but excluding the specified [to] value. * * If the [to] value is less than or equal to `this` value, then the returned range is empty. */public infix fun Int.until(to: Int): IntRange&#123; if(to &lt;= Int.MIN_VALUE) return IntRange.EMPTY return this .. (to -1).toInt()&#125; to函数的用法 1mapOf&lt;String, Any&gt;(\"name\" to \"Tyler\", \"age\" to 30) to函数的源码 1234567/** * Creates a tuple of type [Pair] from this and [that]. * * This can be useful for creating [Map] literals with less noise, for example: * @sample samples.collections.Maps.Instantiation.mapFromPairs */public infix fun &lt;A, B&gt; A.to(that: B): Pair&lt;A, B&gt; = Pair(this, that) 3. 实践Kotlin DSL使代码更加简洁，更加优雅，而且还很有想象力。 3.1 回调处理3.1.1 Java中的回调实现实现步骤： 1、定义一个接口 2、在接口定义一些回调方法 3、定义一个设置回调接口的方法，这个方法的参数是回调接口的实例，一般以匿名对象的形式存在。 实现TextWatcher接口 1234567891011121314151617EditText etCommonCallbackContent = findViewById(R.id.et_common_callback_content);etCommonCallbackContent.addTextChangedListener(new TextWatcher() &#123; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123; // no implementation &#125; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123; // no implementation &#125; @Override public void afterTextChanged(Editable s) &#123; // no implementation &#125;&#125;); 实现TabLayout.OnTabSelectedListener接口 1234567891011121314151617TabLayout tlOrder = findViewById(R.id.tl_order);tlOrder.addOnTabSelectedListener(new TabLayout.OnTabSelectedListener() &#123; @Override public void onTabSelected(TabLayout.Tab tab) &#123; // no implementation &#125; @Override public void onTabUnselected(TabLayout.Tab tab) &#123; // no implementation &#125; @Override public void onTabReselected(TabLayout.Tab tab) &#123; // no implementation &#125;&#125;); 3.1.2 Kotlin中的回调实现实现TextWatcher接口 1234567891011121314findViewById&lt;EditText&gt;(R.id.et_common_callback_content).addTextChangedListener(object : TextWatcher &#123; override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) &#123; // no implementation &#125; override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) &#123; // no implementation &#125; override fun afterTextChanged(s: Editable?) &#123; tvCommonCallbackContent.text = s &#125;&#125;) 实现TabLayout.OnTabSelectedListener接口 12345678910111213tlOrder.addOnTabSelectedListener(object : TabLayout.OnTabSelectedListener&#123; override fun onTabReselected(tab: TabLayout.Tab?) &#123; // no implementation &#125; override fun onTabUnselected(tab: TabLayout.Tab?) &#123; // no implementation &#125; override fun onTabSelected(tab: TabLayout.Tab?) &#123; vpOrder.currentItem = tab?.position ?: 0 &#125;&#125;) 3.1.2 Kotlin DSLTextWatcherBuilder 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.tanjiajun.kotlindsldemoimport android.text.Editableimport android.text.TextWatcherprivate typealias BeforeTextChangedCallback = (s: CharSequence?, start: Int, count: Int, after: Int) -&gt; Unitprivate typealias OnTextChangedCallback = (s: CharSequence?, start: Int, before: Int, count: Int) -&gt; Unitprivate typealias AfterTextChangedCallback = (s: Editable?) -&gt; Unitclass TextWatcherBuilder : TextWatcher &#123; private var beforeTextChangedCallback: BeforeTextChangedCallback? = null private var onTextChangedCallback: OnTextChangedCallback? = null private var afterTextChangedCallback: AfterTextChangedCallback? = null override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) = beforeTextChangedCallback?.invoke(s, start, count, after) ?: Unit override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) = onTextChangedCallback?.invoke(s, start, before, count) ?: Unit override fun afterTextChanged(s: Editable?) = afterTextChangedCallback?.invoke(s) ?: Unit fun beforeTextChanged(callback: BeforeTextChangedCallback) &#123; beforeTextChangedCallback = callback &#125; fun onTextChanged(callback: OnTextChangedCallback) &#123; onTextChangedCallback = callback &#125; fun afterTextChanged(callback: AfterTextChangedCallback) &#123; afterTextChangedCallback = callback &#125;&#125;fun registerTextWatcher(function: TextWatcherBuilder.() -&gt; Unit) = TextWatcherBuilder().also(function) onTabSelectedListenerBuilder 12345678910111213141516171819202122232425262728293031323334353637package com.tanjiajun.androidgenericframework.utilsimport com.google.android.material.tabs.TabLayoutprivate typealias OnTabCallback = (tab: TabLayout.Tab?) -&gt; Unitclass OnTabSelectedListenerBuilder : TabLayout.OnTabSelectedListener &#123; private var onTabReselectedCallback: OnTabCallback? = null private var onTabUnselectedCallback: OnTabCallback? = null private var onTabSelectedCallback: OnTabCallback? = null override fun onTabReselected(tab: TabLayout.Tab?) = onTabReselectedCallback?.invoke(tab) ?: Unit override fun onTabUnselected(tab: TabLayout.Tab?) = onTabUnselectedCallback?.invoke(tab) ?: Unit override fun onTabSelected(tab: TabLayout.Tab?) = onTabSelectedCallback?.invoke(tab) ?: Unit fun onTabReselected(callback: OnTabCallback) &#123; onTabReselectedCallback = callback &#125; fun onTabUnselected(callback: OnTabCallback) &#123; onTabUnselectedCallback = callback &#125; fun onTabSelected(callback: OnTabCallback) &#123; onTabSelectedCallback = callback &#125;&#125;fun registerOnTabSelectedListener(function: OnTabSelectedListenerBuilder.() -&gt; Unit) = OnTabSelectedListenerBuilder().also(function) 一般步骤： 1、先定义一个类去实现回调接口，并实现它的回调方法 2、观察回调方法的参数，提取成一个函数模型（function type），并且按照需要使用类型别名给函数类型起一个别称，并且用私有修饰。 3、在类里面声明一些可空的函数类型的可变(var)私有成员变量，并且在回调函数中拿到对应的变量实现它的invoke()函数，传入对应的参数。 4、在类中定义定义一些和回调接口一样的名字，但是参数是对应的函数类型的函数，并且将函数类型赋值给当前类的对应的成员变量。 5、定义一个成员函数，参数是一个带有定义好的那个类的接受者对象并返回Unit的Lambda表达式，在函数里创建相应的对象，并且使用also函数把Lambda表达式传出去。 如何使用？如下：TextWatcher 1234findViewById&lt;EditText&gt;(R.id.et_dsl_callback_content).addTextChangedListener( registerTextWatcher &#123; afterTextChanged &#123; tvDSLCallbackContent.text = it &#125; &#125;) Tablayout.OnTabSelectedListener 123tlOrder.addOnTabSelectedListener(registerOnTabSelectedListener &#123; onTabSelected &#123; vpOrder.currentItem = it?.position ?: 0 &#125;&#125;) 简化之前代码如下： 12345findViewById&lt;EditText&gt;(R.id.et_dsl_callback_content).addTextChangedListener(registerTextWatcher(&#123; this.afterTextChanged(&#123; s: Editable? -&gt; tvDSLCallbackContent.text = s &#125;)&#125;)) Kotlin语法规定，如果函数最后一个参数是Lambda表达式的话，可以提到小括号外面，同时小括号也可以省略，然后Kotlin可以自己推导出参数的类型，并且使用默认参数it代替命名参数，然后因为这是个带接收者的Lambda表达式，所以可以用this拿到对象，并且调用它的afterTextChanged()函数，最后就得到简化后的代码。 3.1.3 object对象表达式回调和DSL回调对比 1、DSL写法比object写法会更加符合Kotlin风格。 2、object写法要实现所有方法，DSL写法可以按照需要实现想要的方法。 3、从性能上对比，DSL写法对每个回调函数都会创建Lambda表达式的实例对象，而object写法不管有多少个回调方法，都只生成一个匿名对象实例，所以object写法比DSL写法性能好。 这里拿TextWatcher举例，将它们反编译成Java代码，代码如下： object对象表达式回调 12345678910111213((EditText)this.findViewById(-1000084)).addTextChangedListener((TextWatcher)(new TextWatcher() &#123; public void beforeTextChanged(@Nullable CharSequence s, int start, int count, int after) &#123; &#125; public void onTextChanged(@Nullable CharSequence s, int start, int before, int count) &#123; &#125; public void afterTextChanged(@Nullable Editable s) &#123; TextView var10000 = tvCommonCallbackContent; Intrinsics.checkExpressionValueIsNotNull(var10000, \"tvCommonCallbackContent\"); var10000.setText((CharSequence)s); &#125;&#125;)); DSL回调 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354((EditText)this.findViewById(-1000121)).addTextChangedListener((TextWatcher)TextWatcherBuilderKt.registerTextWatcher((Function1)(new Function1() &#123; // $FF: synthetic method // $FF: bridge method public Object invoke(Object var1) &#123; this.invoke((TextWatcherBuilder)var1); return Unit.INSTANCE; &#125; public final void invoke(@NotNull TextWatcherBuilder $this$registerTextWatcher) &#123; Intrinsics.checkParameterIsNotNull($this$registerTextWatcher, \"$receiver\"); $this$registerTextWatcher.beforeTextChanged((Function4)(new Function4() &#123; // $FF: synthetic method // $FF: bridge method public Object invoke(Object var1, Object var2, Object var3, Object var4) &#123; this.invoke((CharSequence)var1, ((Number)var2).intValue(), ((Number)var3).intValue(), ((Number)var4).intValue()); return Unit.INSTANCE; &#125; public final void invoke(@Nullable CharSequence s, int start, int count, int after) &#123; TextView var10000 = tvDSLCallbackContent; Intrinsics.checkExpressionValueIsNotNull(var10000, \"tvDSLCallbackContent\"); var10000.setText(s); &#125; &#125;)); $this$registerTextWatcher.onTextChanged((Function4)(new Function4() &#123; // $FF: synthetic method // $FF: bridge method public Object invoke(Object var1, Object var2, Object var3, Object var4) &#123; this.invoke((CharSequence)var1, ((Number)var2).intValue(), ((Number)var3).intValue(), ((Number)var4).intValue()); return Unit.INSTANCE; &#125; public final void invoke(@Nullable CharSequence s, int start, int before, int count) &#123; TextView var10000 = tvDSLCallbackContent; Intrinsics.checkExpressionValueIsNotNull(var10000, \"tvDSLCallbackContent\"); var10000.setText(s); &#125; &#125;)); $this$registerTextWatcher.afterTextChanged((Function1)(new Function1() &#123; // $FF: synthetic method // $FF: bridge method public Object invoke(Object var1) &#123; this.invoke((Editable)var1); return Unit.INSTANCE; &#125; public final void invoke(@Nullable Editable it) &#123; TextView var10000 = tvDSLCallbackContent; Intrinsics.checkExpressionValueIsNotNull(var10000, \"tvDSLCallbackContent\"); var10000.setText((CharSequence)it); &#125; &#125;)); &#125;&#125;))); 可以看到object写法只生成一个匿名的TextWathcer对象实例，而DSL写法对每个回调函数都会创建Lambda表达式的实例对象(Function1、Founction4)，符合上述预期。 3.2 题外话Java8引入了default关键字，在接口中可以包含一些默认的方法实现。 123456789interface Handlers&#123; void onLoginClick(View view); default void onLogoutClick(View view)&#123; &#125; &#125; 用Kotlin实现的话，可以加上@JvmDefault注解，如下： 12345678910interface Handlers&#123; fun onLoginClick(view: View) @JvmDefault fun onLogoutClick(view: View)&#123; &#125;&#125; 可以反编译成Java代码，如下： 123456789101112131415@Metadata( mv = &#123;1, 1, 15&#125;, bv = &#123;1, 0, 3&#125;, k = 1, d1 = &#123;\"\\u0000\\u0018\\n\\u0002\\u0018\\u0002\\n\\u0002\\u0010\\u0000\\n\\u0000\\n\\u0002\\u0010\\u0002\\n\\u0000\\n\\u0002\\u0018\\u0002\\n\\u0002\\b\\u0002\\bf\\u0018\\u00002\\u00020\\u0001J\\u0010\\u0010\\u0002\\u001a\\u00020\\u00032\\u0006\\u0010\\u0004\\u001a\\u00020\\u0005H&amp;J\\u0010\\u0010\\u0006\\u001a\\u00020\\u00032\\u0006\\u0010\\u0004\\u001a\\u00020\\u0005H\\u0017ø\\u0001\\u0000\\u0082\\u0002\\u0007\\n\\u0005\\b\\u0091(0\\u0001¨\\u0006\\u0007\"&#125;, d2 = &#123;\"Lcom/tanjiajun/kotlindsldemo/MainActivity$Handlers;\", \"\", \"onLoginClick\", \"\", \"view\", \"Landroid/view/View;\", \"onLogoutClick\", \"app_debug\"&#125;)public interface Handlers &#123; void onLoginClick(@NotNull View var1); @JvmDefault default void onLogoutClick(@NotNull View view) &#123; Intrinsics.checkParameterIsNotNull(view, \"view\"); &#125;&#125; 在使用@JvmDefault时，需要注意： 因为default关键字是Java8才引入的，所以需要做一些特殊处理，从Kotlin官方文档可以看到：https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-jvm-default/ 1234567891011Specifies that a JVM default method should be generated for non-abstract Kotlin interface member.Usages of this annotation require an explicit compilation argument to be specified: either -Xjvm-default=enable or -Xjvm-default=compatibility.· with -Xjvm-default=enable, only default method in interface is generated for each @JvmDefault method. In this mode, annotating an existing method with @JvmDefault can break binary compatibility, because it will effectively remove the method from the DefaultImpls class.· with -Xjvm-default=compatibility, in addition to the default interface method, a compatibility accessor is generated in the DefaultImpls class, that calls the default interface method via a synthetic accessor. In this mode, annotating an existing method with @JvmDefault is binary compatible, but results in more methods in bytecode.Removing this annotation from an interface member is a binary incompatible change in both modes.Generation of default methods is only possible with JVM target bytecode version 1.8 (-jvm-target 1.8) or higher.@JvmDefault methods are excluded from interface delegation. 翻译： 1、只有使用JVM目标字节码1.8版本或者更高，才可以生成default方法。 2、使用这个注解还要指定一个显示的编译参数：-Xjvm-default=enable或-Xjvm-default=compatibility（兼容性），使用-Xjvm-default=enable的话对于每个@JvmDefault方法，仅仅是生成default方法，同时这样做可能会破坏二进制兼容性，因为它从DefaultImpls类中删除该方法；使用-Xjvm-default=compatibility的话，除了生成default方法之外，还将defaultImpls类中生成兼容性访问器，该访问器通过综合访问器调用default方法，在这种模式下，它是二进制兼容的，但是会导致字节码中有更多的方法。 在build.gradle文件中加入如下代码： 1234567891011121314allprojects &#123; repositories &#123; google() jcenter() &#125; tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).all &#123; kotlinOptions &#123; jvmTarget = '1.8' freeCompilerArgs += '-Xjvm-default=compatibility' &#125; &#125;&#125; 下面尝试上面的两种方法，看看是否符合预期，代码如下： 加上-Xjvm-default=enable后反编译的代码： 123456789101112131415@Metadata( mv = &#123;1, 1, 15&#125;, bv = &#123;1, 0, 3&#125;, k = 1, d1 = &#123;\"\\u0000\\u0018\\n\\u0002\\u0018\\u0002\\n\\u0002\\u0010\\u0000\\n\\u0000\\n\\u0002\\u0010\\u0002\\n\\u0000\\n\\u0002\\u0018\\u0002\\n\\u0002\\b\\u0002\\bf\\u0018\\u00002\\u00020\\u0001J\\u0010\\u0010\\u0002\\u001a\\u00020\\u00032\\u0006\\u0010\\u0004\\u001a\\u00020\\u0005H&amp;J\\u0010\\u0010\\u0006\\u001a\\u00020\\u00032\\u0006\\u0010\\u0004\\u001a\\u00020\\u0005H\\u0017ø\\u0001\\u0000\\u0082\\u0002\\u0007\\n\\u0005\\b\\u0091(0\\u0001¨\\u0006\\u0007\"&#125;, d2 = &#123;\"Lcom/tanjiajun/kotlindsldemo/MainActivity$Handlers;\", \"\", \"onLoginClick\", \"\", \"view\", \"Landroid/view/View;\", \"onLogoutClick\", \"app_debug\"&#125;)public interface Handlers &#123; void onLoginClick(@NotNull View var1); @JvmDefault default void onLogoutClick(@NotNull View view) &#123; Intrinsics.checkParameterIsNotNull(view, \"view\"); &#125;&#125; 加上-Xjvm-default=compatibility后反编译的代码： 123456789101112131415161718192021222324252627@Metadata( mv = &#123;1, 1, 15&#125;, bv = &#123;1, 0, 3&#125;, k = 1, d1 = &#123;\"\\u0000\\u0018\\n\\u0002\\u0018\\u0002\\n\\u0002\\u0010\\u0000\\n\\u0000\\n\\u0002\\u0010\\u0002\\n\\u0000\\n\\u0002\\u0018\\u0002\\n\\u0002\\b\\u0002\\bf\\u0018\\u00002\\u00020\\u0001J\\u0010\\u0010\\u0002\\u001a\\u00020\\u00032\\u0006\\u0010\\u0004\\u001a\\u00020\\u0005H&amp;J\\u0010\\u0010\\u0006\\u001a\\u00020\\u00032\\u0006\\u0010\\u0004\\u001a\\u00020\\u0005H\\u0017ø\\u0001\\u0000\\u0082\\u0002\\u0007\\n\\u0005\\b\\u0091(0\\u0001¨\\u0006\\u0007\"&#125;, d2 = &#123;\"Lcom/tanjiajun/kotlindsldemo/MainActivity$Handlers;\", \"\", \"onLoginClick\", \"\", \"view\", \"Landroid/view/View;\", \"onLogoutClick\", \"app_debug\"&#125;)public interface Handlers &#123; void onLoginClick(@NotNull View var1); @JvmDefault default void onLogoutClick(@NotNull View view) &#123; Intrinsics.checkParameterIsNotNull(view, \"view\"); &#125; @Metadata( mv = &#123;1, 1, 15&#125;, bv = &#123;1, 0, 3&#125;, k = 3 ) public static final class DefaultImpls &#123; @JvmDefault public static void onLogoutClick(MainActivity.Handlers $this, @NotNull View view) &#123; $this.onLogoutClick(view); &#125; &#125;&#125; 可以看到加上了-Xjvm-default=compatibility要比-Xjvm-default=enable多了一个DefaultImpls的静态final类，而且类中也有一个静态方法，其实-Xjvm-default=compatibility是为了兼容Java8之前的版本在接口中也可以实现方法。 Spek spek是一个为Kotlin打造的测试框架。 12345678910111213141516describe(\"Verify Check Email Valid\") &#123; it(\"Email Is Null\") &#123; presenter.checkEmailValid(\"\") verify &#123; viewRenderer.showEmailEmptyError() &#125; &#125; it(\"Email Is Not Null and Is Not Valid\") &#123; presenter.checkEmailValid(\"ktan\") verify &#123; viewRenderer.showEmailInvalidError() &#125; &#125; it(\"Email Is Not Null and Is Valid\") &#123; presenter.checkEmailValid(\"ktan@xogrp.com\") verify &#123; viewRenderer.hideEmailError() &#125; &#125;&#125; Github：Spek KxDate 一个日期处理库，可以写出类似于英语句子的代码： 12val twoMonthsLater = 2 months fromNowval yesterday = 1 days ago Github：KxDate Anko 一个专门针对Android开发的Kotlin库，可以这样写： 123456verticalLayout &#123; val name = editText() button(\"Say Hello\") &#123; onClick &#123; toast(\"Hello, $&#123;name.text&#125;!\") &#125; &#125;&#125; Github：Anko Demo地址","categories":[{"name":"Android","slug":"Android","permalink":"https://tylerLiu.top/categories/Android/"},{"name":"Kotlin","slug":"Android/Kotlin","permalink":"https://tylerLiu.top/categories/Android/Kotlin/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://tylerLiu.top/tags/Kotlin/"}]},{"title":"Android网络优化-02：网络基础（下）","slug":"Android网络优化-02：网络基础（下）","date":"2020-06-02T01:26:23.000Z","updated":"2020-06-03T09:31:01.776Z","comments":true,"path":"2020/06/02/Android网络优化-02：网络基础（下）/","link":"","permalink":"https://tylerLiu.top/2020/06/02/Android网络优化-02：网络基础（下）/","excerpt":"","text":"原文地址：https://juejin.im/post/5ebb3db16fb9a0438e2396af 8. 网络层8.1 网络层主要功能数据路由。 8.2 IP协议8.2.1 IP协议拆解虚拟互联网络 1、实际的计算机网络是错综复杂的。 2、物理设备通过使用IP协议，屏蔽了物理网络之间的差异。 3、当网络中的主机IP协议连接时，则无需关心网络细节， 计算机A与B之间的数据通信可以认为是通过一个虚拟的互联网络进行传输的。 IP协议的作用 1、IP协议使得复杂的实际网络变成一个虚拟的互联网络。 2、IP协议使得网络层可以屏蔽底层细节而专注网络层的数据转发。 3、IP协议解决了在虚拟网络中数据报传输路径的问题。 IP地址 每一个唯一的网络设备都有一个唯一的IP地址。不同于MAC地址是不可改变的，IP地址会根据当前设备所连接的网络环境的变化而变化。 特点 IP地址长度为32位，常分为4个8位。 IP地址常使用点分十进制来表示，即0255.0255.0~255。 IP地址最多有2 ^ 32 = 4294961296 =&gt; 42 亿 IP数据报 = IP首部 + IP数据报的数据，IP数据报的报文格式如下： 版本 占4位，指的是IP协议的版本，通信双方的版本必须一致，当前主流版本是4和6，即IPv4，也有IPv6。 首部位长度 占4位，最大数值为15，表示的是IP首部的长度，单位是32位字（4个字节）。所以IP首部的最大长度为 15 * 4 = 60 字节。 服务类型（TOS） 表示当前的数据包是高优先级的，还是低优先级的。数据包是按照TOS被分配到三个波段（band0、band1、band2）里面的。 总长度 占16位，最大数值为65535，表示的是IP数据报的总长度（IP首部 + IP数据）。 注意，数据在数据链路层中的传输受最大传输单元MTU的限制，而MTU一般为1500个字节，如果IP数据报的长度高于MTU，数据链路层会把IP数据报进行分片，即拆分成多个数据帧进行传输。 标识 协议内部自身使用，不需关注。 标志 占3位，目前只有两位有意思，标识是否进行分片。 片偏移 占13位，如果发生了分片，这里将会记录当前的数据帧保存的是第几个偏移的IP数据。 TTL 占8位，表名IP数据报文在网络中的寿命，每经过一个设备，TTL减1，当TTL = 0时，网络设备必须丢弃该报文。 当IP报文在网络中找不到终点的时候，避免IP数据在网络中无限进行传输，消耗带宽。 协议 占8位，表明IP数据所携带的具体数据是什么协议的。。如：TCP、UDP等。 协议 值 ICMP(Internet Control Message Protocol)Internet控制报文协议 1 IGMP(Internet Group Management Protocol)Internet组管理协议 2 IP(Internet Protocol)网络互连协议 4 TCP(Transmission Control Protocol)传输控制协议 6 UDP(User Datagram Protocol)用户数据报协议 17 OSPF(Open Shortest Path First)开放式最短路径优先，是一个内部网关协议(Interior Gateway Protocol) 89 首部校验和 占16位，校验IP首部是否有错，接收方在接收了IP数据报文之后会进行头部的校验，如果出错会进行丢弃。 源IP地址 发送IP数据报文的IP地址。 目的IP地址 数据报到达的IP的地址。 8.2.2 IP协议的转发流程逐跳(hop-by-hop) 数据是从目的设备传输到下一个网络1， 又从下一个网络1传输到路由器的，又从路由器跳到下一个网络2，所以是一跳一跳的，即hop-by-hop。 路由表 1、不同于MAC地址表是由一组一组的MAC地址与硬件接口组成的，路由表是由一组一组的目的IP地址与吓一跳的IP地址组成。 2、计算机或者路由器都拥有路由表。 转发流程 1、A发出的目的为C的IP数据报，查询路由表发现吓一跳为E。 2、A将IP数据报交给数据链路层，并告知目的MAC地址为E。 3、数据链路层填充源MAC地址A和目的MAC地址E。 4、数据链路层通过物理层将数据发送给E。 5、E的数据链路层接收到数据帧，把数据帧交给网络层。 6、E查询路由表，发现吓一跳为F。 7、E把数据报交给数据链路层，并告知目的MAC地址为F。 8、E的数据链路层封装数据帧并发送。 9、F的数据链路层收到数据帧，把数据帧交给网络层。 10、F查询路由表，发现吓一跳为C。 11、F把数据报交给路由链路层，并告知目的MAC地址为C。 12、F的数据链路层封装数据帧并发送。 MAC地址与IP地址的最大区别 1、数据帧每一跳的MAC地址都在变化，而IP数据报的每一跳的IP地址始终不变。 2、IP地址具有远程定位功能，而MAC地址更像是身份证号，它的唯一性是为了组网时可以不用担心不同的网卡在一个网络里会产生冲突，从硬件角度保证不同的网卡有不同的标识。 3、相比于IP地址，MAC地址的通信范围比较小，局限在一个子网内。如：从192.168.0.1/24访问192.168.0.9/24是可以用MAC地址的。 8.2.3 IP地址的子网划分为什么要对IP地址进行划分？ 因为规划和分配IP地址非常麻烦。 分类的IP地址 组成形式：网络号 + 主机号 通常有如下三种类型的IP地址： A类：首位为0，网络号为8位，主机号为24位。 B类：首位为10，网络号为16位，主机号为16位。 C类：首位为110，网络号为24位，主机号为8位。 特殊的网络号 A类地址网络段全0（00000000），表示特殊网络 A类地址网络后7位全1（01111111:127），表示回环地址 B类地址网络段（10000000.00000000:128.0），是不可使用的 C类地址网络段（192.0.0），是不可用的 特殊的主机号 主机号全0，表示当前网络段不可分配特定的主机。例如：1.0.0.0。 主机号全1，表示广播地址向当前网络段所有主机发消息。例如：0.1.11.111。 本地回环地址（Loopback Address）：127.0.0.1，不属于任何一个有类别地址类。它代表设备的本地虚拟接口，所有默认被看作是永久不会废弃的接口。在Windows操作系统中也有相似的定义，所有一般在安装网卡前就可以ping通这个本地回环地址。一般都会用来检查本地网络协议、基本数据接口等是否正常。 代码如下： 123456789101112C:\\Users\\AHXIUWU_RJ_LY&gt;ping 127.0.0.1正在 Ping 127.0.0.1 具有 32 字节的数据:来自 127.0.0.1 的回复: 字节=32 时间&lt;1ms TTL=128来自 127.0.0.1 的回复: 字节=32 时间&lt;1ms TTL=128来自 127.0.0.1 的回复: 字节=32 时间&lt;1ms TTL=128来自 127.0.0.1 的回复: 字节=32 时间&lt;1ms TTL=128127.0.0.1 的 Ping 统计信息: 数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，往返行程的估计时间(以毫秒为单位): 最短 = 0ms，最长 = 0ms，平均 = 0ms 分类地址的补充 D类地址：1110…… E类地址：1111…… 他们仅做特殊用途。 划分子网 1某公司有256台计算机，该申请哪种网路段？ 分配B类地址，但是一个B类地址所能容纳的主机数量为2^16-2，这会造成极大的浪费。为了解决这个问题，需要划分子网。 例如：将193.10.10.0这个IP划分为193.10.10.0193.10.10.127与193.10.10.128193.10.10.255。 子网掩码 1子网这么多，如何判断某个IP的网络号？ 快速的判断某个IP属于哪一个子网号，通过IP &amp; 子网掩码 = 该IP对应的子网号。子网掩码的组成特点如下： 与IP地址一样，都是32位。 由连续的1和连续的0组成。 某一个子网掩码具备网络号位数个连续的1。 例如，A、B、C类的子网掩码： A类：255.0.0.0 B类：255.255.0.0 B类：255.255.255.0 无分类编址CIDR（Classless Inter-Domain Routing，无类别域间路由） 1、CIDR中没有A、B、C类网络号和子网划分的概念 2、CIDR将网络前缀相同的IP地址称为一个CIDR地址块 3、网络前缀是任意位数的 4、相比原来子网划分更加灵活 CIDR使用了斜线记法，例如：193.10.10.129/25 表示网络号为25位，主机号为7位。一般家里都是使用 /24 的CIDR，此时整个网络里面的一个地址为192.168.0.1，往往就是私网的出口地址。例如：家里面的电脑连接WIFI，WIFI路由器的地址就是192.168.0.1，而192.168.0.255就是广播的地址。 1loopback是什么？ 回环接口，通常会被分配到127.0.0.1这个地址，它用于本机内部通信，经过内核处理后直接返回，不会再任何网络中出现。 1某公司有200台电脑，需要拆分成两个部分，每个部分使用一个小型网络，如何进行CIDR进行划分？ 可以使用一个 /24 作为一个中型网络（在CIDR中被称为超网），旗下有两个 /25 作为一个小型网络（在CIDR中被称为子网）。 8.3 ARP协议与RARP协议1在IP数据的转发过程中，A将IP数据报交给了数据链路层，并告知其目的MAC地址是E。这里A是如何知道目的MAC地址是E呢？ 8.3.1 ARP(Address Resolution Protocol)地址解析协议ARP协议将网络层IP 32位地址转换为数据链路层MAC 48位地址。 ARP缓存池 缓存了IP地址到硬件地址之间的映射关系。有缓存时直接从缓存中取出即可，没有缓存时则会和MAC地址表获取地址时使用的广播形式类似，即 1、E检查MAC地址表，发现没有C的信息。 2、E将广播A的数据包到除A以外的端口。 3、E将收到来自B、C的回应，并将地址记录。 ARP缓存时ARP协议和RARP协议运行的关键。此外，ARP缓存表中的记录并不是永久有效的，有一定的期限。 查看ARP缓存表 使用arp -a命令， 12345678910111213141516171819202122232425262728C:\\Users\\AHXIUWU_RJ_LY&gt;arp -a接口: 192.168.137.1 --- 0xa Internet 地址 物理地址 类型 192.168.137.255 ff-ff-ff-ff-ff-ff 静态 224.0.0.2 01-00-5e-00-00-02 静态 224.0.0.22 01-00-5e-00-00-16 静态 224.0.0.251 01-00-5e-00-00-fb 静态 224.0.0.252 01-00-5e-00-00-fc 静态 239.11.20.1 01-00-5e-0b-14-01 静态 239.255.255.250 01-00-5e-7f-ff-fa 静态 255.255.255.255 ff-ff-ff-ff-ff-ff 静态接口: 192.168.1.200 --- 0x12 Internet 地址 物理地址 类型 192.168.1.1 30-b4-9e-57-63-45 动态 192.168.1.202 48-3f-e9-66-03-09 动态 192.168.1.205 b4-c4-fc-43-b0-4f 动态 192.168.1.211 7c-67-a2-94-4d-82 动态 192.168.1.239 7c-67-a2-bd-96-e7 动态 192.168.1.255 ff-ff-ff-ff-ff-ff 静态 224.0.0.2 01-00-5e-00-00-02 静态 224.0.0.22 01-00-5e-00-00-16 静态 224.0.0.251 01-00-5e-00-00-fb 静态 224.0.0.252 01-00-5e-00-00-fc 静态 239.11.20.1 01-00-5e-0b-14-01 静态 239.255.255.250 01-00-5e-7f-ff-fa 静态 255.255.255.255 ff-ff-ff-ff-ff-ff 静态 ARP协议 ARP协议是被直接封装在了数据链路层中的数据帧里面。 1既然ARP协议是直接被封装在数据链路层中的数据帧里面，那么为什么它属于网络层的内容？ 主要是因为ARP协议使用到了网络层的IP地址。 ARP协议内容 8.3.2 RARP(Reverse Address Resolution Protocol)逆地址解析协议 将数据链路层MAC 48位地址转换为网络层IP 32位地址。 除了类型8035标识为RARP协议，其他内容与ARP协议类似。 8.3.3 小结 RARP协议与ARP协议是TCP/IP协议栈里面的基础协议，它们的操作对程序员是透明的。 理解它们有助于里面网络分层的细节。 它们是协调数据链路层和网络层配合工作的重要协议。 8.4 网络地址转换NAT(Network Address Translation)技术不改变IP地址的网关，称为转发网关；改变IP地址的网关，称为NAT网关。 1为什么要使用NAT？ 1、IPv4最多只有40+亿个IP地址。 2、早期IP地址的不合理规划导致IP号浪费。 8.4.1 内网地址特点 内部机构使用 避免与外网地址重复 三类内网地址 A类：10.0.0.0 ~ 10.255.255.255，支持千万数据量级设备 B类：172.16.0.0 ~ 172.31.255.255，支持百万数据量级设备 C类：192.168.0.0 ~ 193.168.255.255，支持万数据量级设备 对于公司，它可以在外部使用全球唯一的外网IP地址，通常在内部使用一个B类内网地址即可。 对于家庭，可以在外部使用全球唯一的外网IP地址，在内部使用一个C类内网地址即可。 1问题：内网的多个设备使用同一外网IP地址请求外网服务，外部是怎么知道时候哪一个内网设备请求的呢？ 使用NAT，它用于多个主机通过一个公有IP访问互联网的私有网络，并减缓了IP地址的消耗，但是增加了网络通信的复杂度。 8.4.2 外网地址 全球范围使用 全球公网唯一 8.4.3 端口映射如下两个NAT转换过程：发送数据时，A设备内网地址和端口号 =&gt; 外网地址与端口号：192.168.2.11:6666 =&gt; 173.21.59.10:16666，B设备内网地址和端口号 =&gt; 外网地址和端口号：192.168.2.10:7777 =&gt; 173.21.59.10:17777。 由于同时转换了Port，即进行了端口映射，NAT也可称为NA(P)T。","categories":[{"name":"Android","slug":"Android","permalink":"https://tylerLiu.top/categories/Android/"},{"name":"网络","slug":"Android/网络","permalink":"https://tylerLiu.top/categories/Android/网络/"}],"tags":[{"name":"网络","slug":"网络","permalink":"https://tylerLiu.top/tags/网络/"}]},{"title":"Android网络优化-01：网络基础（上）","slug":"Android网络优化-01：网络基础（上）","date":"2020-05-29T02:01:12.000Z","updated":"2020-06-02T01:23:53.254Z","comments":true,"path":"2020/05/29/Android网络优化-01：网络基础（上）/","link":"","permalink":"https://tylerLiu.top/2020/05/29/Android网络优化-01：网络基础（上）/","excerpt":"","text":"原文地址：https://juejin.im/post/5eba5a39e51d454de64e49b1 0. 大纲 1. 重识计算机网络1.1 计算机网络是什么？ 1、主要由通用、可编程的硬件互连而成。 2、通过这些硬件，可以传送不同类型的数据。 3、计算机网络不仅包含软件概念，还包含硬件设备。 4、计算机网络不仅包含信息通信，还可以支持广泛和日益增长的应用。 1.2 计算机网络的分类1.2.1 按作用范围 广域网（WAM）：几十KM ~ 几千 KM，跨省、跨国。 城域网（MAN）：5KM ~ 50KM，城市间、城市内。 局域网（LAN）：1KM内，地区内、家庭间、公司内。 1.2.2 按网络使用者 公用网络：所有可以通过付费方式就可以加入的网络。 专用网络：某些部队、组织或者某些人为了满足特殊业务需求而建立起来的特殊网络。如军队、铁路、银行都有自己的专用网络。 2. 网络历史演进2.1 世界历史互联网发展历史演进2.1.1 单个网络ARPANET，1969年美国国防部创建的一个网络，可以连接周围的计算机。计算机直接通过交换机就可以进行信息交换。 2.1.2 三级结构现代互联网的雏形，也称互联网络，可以把大学、实验室、研究所都连接起来。 从上至下，由主干网、地区网、校园网组成。 2.1.3 多层次ISPISP，Internet Service Provider：网路服务提供商，如中国电信、中国移动、中国联通等。从上之下，由主干ISP、地区ISP组成。 主干ISP：中国的主干ISP，包括中国电信、中国移动、中国联通，它们可以直接连接其他国家的在主干ISP。 地区ISP：例如移动网络，在北京叫“北京移动”，在上海叫“上海移动”。这些就属于地区ISP。地区ISP可以连接公司、学校、家庭的网络。 2.1.4 了解现代国际互联网的主要线路可以通过infrapedia查看。 2.2 中国互联网发展历史 1980年，中国铁道部开始互联网实验。 1989年，建立并运行第一个公共网络。 1994年，接入国际互联网。 至今，当今中国最大的五个公用计算机网络： 中国电信互联网(CHINANET) 中国联通互联网(UNINET) 中国移动互联网(CMNET) 中国教育与科研计算机网(CERNET) 中国科学技术网(CSTNET) 2.3 中国的互联网企业 1996年，张朝阳创建搜狐。 1997年，丁磊创建网易。 1998年，王志东创建新浪，马化腾、张志东创建腾讯。 1999年，马云创建阿里巴巴。 2000年，李彦宏创建百度。 3. 重识网络层次结构网络为什么要分层因为复杂的程序都要分层。这时一个架构设计的通用问题，不仅仅是网络协议的问题，只要涉及复杂的逻辑或软件需求需要经常变动的情况通常都会通过分层来解决。 思考：设计一个计算机网络需要解决哪些问题？ 1、传输数据时需要保证数据通路顺畅。 2、需要识别目的计算机。 3、需要了解目的计算机的状态。 4、数据是否错误。 因为计算机网络需要解决的问题繁多复杂，所以需要采用分层的设计分别去解决不同的问题，实现不同的功能。 3.1 层级结构设计的基本原则 相互独立：每一层仅仅实现一个相对独立的功能，并且需要确保层与层之间的耦合度非常低。 灵活性：每一层的设计需要具备很好的灵活性、扩展性，以适应未来的网络变化。 耦合度：各层之间是完全耦合的，层与层之间的变化互不影响。 3.2 OSI七层模型 OSI 功能 应用层 为计算机用户提供接口和服务 表示层 数据处理：编解码、加解密等等 会话层 管理（建立、维护、重连）通信会话 传输层 管理端到端的通信连接 网络层 数据路由：决定数据在网络中的路径 数据链路层 管理相邻节点之间的数据通信 物理层 数据通信的光电物理特性 3.2.1 OSI的故事 开始，OSI想要成为全球计算机都遵循的标准。 但是，OSI在市场化的过程中困难重重，因为TCP/IP已经在全球范围成功运行。 最终，OSI没有成为广为使用的标准模型。 3.2.2 OSI七层模型失败的原因 1、OSI没有充分将理论和实际结合。 2、OSI标准的制定周期长，按OSI标准生产的设备无法及时投入市场。 3、OSI模型设计不合理，某些功能在多层重复出现。 3.3 TCP/IP四层模型 需要理解数据通信过程中不同设备之间协议的转换。从下图可以看到路由器仅包括网络层和网络接口层。 从协议的数量来看，TCP/IP四层模型构成了中间窄，两端大的沙漏模型，下图： 4. 初始现代网络拓扑4.1 为什么要了解网络拓扑？有助于形成一个形象的计算机网络。 4.2 网络拓扑分类4.2.1 边缘部分 家庭：由终端机器、路由器、网关、地区ISP组成。 企业：不同于家庭的网络拓扑，其网关细分为内部网关和统一网关。 4.2.2 核心部分由地区ISP、主干ISP、路由器、海底电缆或跨地区电缆组成。其中通信设备（一般是华为）主要由移动、联通锁铺设的。 现代互联网的网络拓扑形成了一个树形结构。 4.2.3 C/S模式由客户端/服务端模式组成，并可以相互进行通信。 4.2.4 P2P模式不分客户端和服务端，它们之间对等地进行连接，优势在于可以使下载速度更快，如迅雷下载器中就是采用这种模式。 5. 网络性能指标5.1 速率即，bps &lt;==&gt; bit/s 网络数据传输的各种单位与之对应的常见设备 bit Byte KB MB GB TB PB EB 名字 比特位 字节 千字节 兆字节 吉字节 太字节 拍字节 艾字节 比例 - 8bits 1024B 1024KB 1024MB 1024GB 1024TB 1024PB 常见设备 门电路 - 寄存器 高速缓存 内存/硬盘 硬盘 云硬盘 数据仓库 为什么100M的电信光纤，测试峰值速度只有12M/s呢？ 网络常用的单位为Mbps，因此这里的100M指的是100Mbps。 12100 M/s = 100 Mbps = 100 Mbit/s100 Mbit/s = (100 / 8) MB/s = 12.5 MB/s 5.2 时延5.2.1 发送时延发送时延 = 数据长度(bit) / 发送速率(bit/s)。 数据长度有用户决定，发送速率有计算机网卡决定。 5.2.2 传输时延传输时延 = 传输路径距离 / 传播速率(bit/s)。 传输路径距离由用户决定，传播速率受限于传输介质。 5.2.3 排队时延数据包在网络设备中等待被处理的时间，例如路由器需要一个一个处理完前面的数据包才能处理后面的。 5.2.4 处理时延数据包达到设备或目的机器被处理所需的时间。 总时延 = 发送时延 + 传输时延 + 排队时延 + 处理时延。 5.3 往返时间RTT(Route-Trip Time) 评估网络质量的一项重要指标。 表示数据报文在端到端通信中来回一次的时间。 通常使用ping命令查看RRT 6. 应用层传输层与之下的层已经提供了完整的通信服务。而应用层是面向用于的一层。主要用来定义应用间通信的规则，例如应用进程的报文类型（请求报文、响应报文）、报文的语法、格式、应用进程发送数据的时机、规则等。 6.1 DNS（Domain Name System）域名系统服务域即对应的网络号，名即对应的主机名字。 6.1.1 功能通过把没有规则的点分十进制IP地址转换为可以理解的一些域名。 6.1.2 域名 使用域名可以帮助记忆。 域名通过DNS服务可以被转换成IP地址。 域名是由点、字母和数字组成。 点分割不同的域。 域名可以分为顶级域名、二级域、三级域…，如，www.taobao.com -&gt; 三级域.二级域.顶级域。 顶级域常见分类 国家 cn us uk ca 通用 com net gov org 二级域例如：qq、aliyun、taobao、google、facebook等。 顶级域、二级域、三级域组成了一个树状结构。且在顶级域名服务器上面还有一个根域名服务器。 6.1.3 域名服务器只要有一个外网的服务器就可以搭建一个域名的服务器。 6.2 DHCP(Dynamic Host Configuration Protocol)动态主机设置协议6.2.1 是什么？网络管理员只需配置一段共享的IP地址，每一台新接入的机器都可以通过DHCP来这个共享的IP地址里面申请IP地址，就可以自动配置。等用完之后还回去，其他机器也能使用。 特点如下： DHCP是一个局域网协议。 DHCP是应用UDP协议的应用层协议。 6.2.2 功能 即插即用联网。 在IP配置界面中自动获得IP地址、自动获得DNS服务器地址即可启用DHCP协议去获取一个临时IP（通常是一个内网地址）。 有一个租期，在租期过半时可以续租。 6.2.3 DHCP的过程 1、DHCP服务器监听默认端口：67 2、主机使用UDP协议广播DHCP发现报文 3、DHCP服务器发出DHCP提供报文 4、主机向DHCP服务器发出DHCP请求报文 5、DHCP服务器回应并提供IP地址 6.2.4 向DHCP租用的IP地址是有租期的，IP地址如何实现续租呢？客户端会在租期过去50%的时候，直接向为其提供IP地址的DHCP服务器发送DHCP request消息报。客户端接收到服务器回应的DHCP ACK消息报后，会根据消息报中提供的新的租期以及其他已经更新的TCP/IP参数更新自己的配置。 6.3 HTTP（HyperText Transfer Protocol）超文本传输协议6.3.1 是什么？HyperText即超文本、超链接，Http是指在电脑中显示的、含有可以指向其他文本的链接文本。 对于这些内容都有一个统一的路径，例如：http(s)://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;。 HTP协议底层是TCP协议，因此它是可靠的数据传输协议。 6.3.2 Web服务器分为硬件部分（计算机或云上的虚拟设备）和软件部分（Nginx、Apache）。 过程： 1、接受客户端连接 2、接受请求报文 3、处理请求 4、访问Web资源 5、构造应答 6、发送应答 6.3.3 HTTP请求方法 header1 header2 GET 获取指定的服务端资源 POST 提交数据到服务端 DELETE 删除指定的服务端资源（很少用） UPDATE 更新指定的服务端资源 PUT 修改数据 OPTIONS 列出可对资源实行的请求方法，用来跨域请求 CONNECT 建立连接隧道，用于代理服务器 HEAD 获取资源的元信息 TRACE 追踪请求-响应的传输路径 GET和POST的区别： 1、GET参数通过url传递，POST放在request body中。 2、GET请求在url中传递的参数是有长度限制的，而POST没有。 3、GET比POST更不安全，因为参数直接暴露在url中，所以不能用来传递敏感信息。 4、GET请求只能进行url编码，而POST支持多种编码方式。 5、GET请求浏览器会主动cache。 6、GET请求参数会被完整保留在浏览器历史记录中，而POST不会保留。 7、GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出了一些不同。 6.3.4 HTTP指定资源在地址中指定 1https://www.wanandroid.com/repo/100.html repo/100.html是指定的请求资源。 在请求数据中指定 1https://www.wanandroid.com/?sort=0&amp;unlearn=0&amp;page=2 ?后面用来指定请求参数。 6.3.5 HTTP请求报文HTTP的请求报文与响应报文都满足如下结构： 1起始行 + 头部 + 空行 + 实体 其中空行是用来区分开头部和实体的。 HTTP请求报文的格式如下： 例如： 12345POST https://www.wanandroid.com HTTP/1.1Accept-Encoding:gzipAccept-Language:zh-CN...&#123; 请求的 jsonString 内容&#125; 6.3.6 HTTP应答报文 6.3.7 HTTP应答状态码 header1 header2 100~199 协议处理的中间状态，还需要后续操作 200~299 成功 300~399 重定向 400~499 客户端错误 500~599 服务端错误 100~199 101：Switching Protocols，服务器同意将HTTP升级为WebSocket时发送。 200~299 200：在响应体中放有数据。 204：No Connect，响应头后没有body数据。 206：Partial Content，通常用于HTTP分块下载和断点续传，同时带上相应的响应头字段Content-Range。 300~399 301：Moved Permanently，永久重定向。 302：Found，临时重定向。 304：Not Modified，协商缓存命中时返回。 400~499 400：Bad Request，请求出错。 403：Forbidden，服务器禁止访问，原因有法律禁止、信息敏感等。 404：Not Found，资源未找到。 405：Method Not Allowed，请求方法不被允许。 406：Not Acceptable，资源无法满足条件。 408：Request Timeout，请求超时。 409：Confilict，多个请求发生冲突。 413：Request Entity Too Larget，请求体的数据过大。- 414：Request-URI Too Long，请求行里的URI太大。 429：Too Many Request，客户端发送的请求过多。 431：Request Header Fields Too Large，请求头的字段内容太大。 500~599 500：Internal Server Error，服务内部出错。 501：Not Implemented，请求的功能不支持。 502：Bad Gateway，服务器自身是正常的，只是数据通道有问题。 503：Service Unavailable，服务器很忙，无法响应服务。 6.3.8 HTTP工作结构Web缓存 通常遵循二八原则：一个网站的内容通常分为20%的热门内容，80%的冷门内容。因此可以优先缓存热门内容。 存储器层次结构 缓存（CPU高速缓存）/主存（内存）/辅存（磁盘） Web代理 正向代理：代理客户端去访问Server。 反向代理：代理Server把数据返回给客户端。例如Nginx、HAProxy就是一些著名的代理软件。 CDN（Content Delivery Network）内容分发网络 用于即将一些大的内容在临近的服务器留一个备份。 使用CDN可以进行多媒体内容的加速。 CDN的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应。 爬虫 用于在互联网上采集信息，例如百度、Google的本质就是一个爬虫，它们通过把整个网络的数据取下来，并且做一个索引，然后把这些内容提供给大家，在进行搜索时就会匹配这些内容并返回。 不好的爬虫的缺点： 增加网络拥塞 损耗服务器资源 6.4 HTTPS(Hyper Text Transfer Protocol over SecureSocket Layer)安全的HTTP协议1https://&lt;主机&gt;:&lt;443&gt;/&lt;路径&gt; HTTP是明文传输，但是有时需要在网络中传输账号密码、个人信息、账号金额、交易信息等敏感信息，HTTP会导致中间人非法截取信息，导致信息泄露。 6.4.1 加密模型 对称加密：加密与解密都是用同一个秘钥。 非对称加密：公钥加密，私钥解密，并且公钥与私钥是拥有一定数学关系的一组秘钥。 6.4.2 数字证书、签名校验数字证书是可信任组织颁发给特定对象的认证。而可信任组织即客户端与服务端都认为安全的组织。 数字证书格式： 证书格式、版本号 证书序列号 签名算法 有效期 对象名称 对象公开秘钥 6.4.3 SSL（Secure Sockets Layer）安全套接层SSL位于传输层与应用层之间，它是一个子层，作用主要有两点： 数据安全（保证数据不会被泄露）与数据完整（保证数据不会被篡改） 对数据进行加密后传输 HTTPS的通信过程 1、433端口的TCP连接。 2、SSL安全参数握手 3、客户端发送数据 4、服务端发送数据 SSL（Secure Sockets Layer）安全套接层握手过程 1、生成随机数1、2、3的过程 2、双端根据随机数1、2、3与相同的算法生成对称秘钥进行加密通信 HTTPS综合地运用了对称加密与非对称加密，在进行随机数校验的阶段使用了非对称加密来进行通信，然后等双方都确定了三个随机数之后，就可以使用相同的算法来生成对称秘钥进行加密通信。HTTPS的优势在于双端分别生成了秘钥，没有经过传输，减少了秘钥泄露的可能性。 6.5 HTTP2特点： 头部压缩 多路复用：多路复用允许同时通过单一的HTTP/2连接发送多重请求-响应信息。改善了在HTTP1.1中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制（连接数量），超过限制会被阻塞。 提升访问速度：相比HTTP1.1请求资源所需时间更少，访问速度更快 二进制分帧：HTTP2.0会将所有的传输信息分割成更小的信息或者帧，并对他们进行二进制编码。 设置请求优先级 服务端推送 6.6 CookieHTTP是一个无状态协议，因此Cookie的最大作用就是存储sessionId用来唯一标识用户。并且，Cookie本质上就是浏览器里面存储的一个很小的文本文件，内部以键值对的方式来存储。 6.6.1 生命周期通过Expries和Max-Age两个属性来设置： Expries：过期时间 Max-Age：表示一段时间间隔，单位是秒，从浏览器收到报文开始计算。 6.6.2 作用域可以使用Domain和path属性给Cookie绑定域名和路径。如果在发送请求之前，发现域名或路径和这两个属性不匹配，那么就不会带上Cookie。需要注意，路径中含有/，表示域名下的任意路径都允许使用Cookie。 6.6.3 安全 带上Secure：说明只能通过HTTPS传输Cookie。 带上HttpOnly：说明只能通过HTTP协议传输。 带上SameSite：预防CSRF攻击。 6.6.4 缺点 1、安全缺陷：Cookie容易被非法用户截获，然后进行一系列的篡改，最后在Cookie有效期内重新发送给服务器。 2、容量缺陷：体积上限只有4KB，只能用来存储少量的信息。 3、性能缺陷：Cookie紧跟域名，因此域名下的请求都会携带上完整的Cookie，这样随着请求数的增多，将会造成巨大的性能浪费，因此请求携带了很多不必要的内容。这里可以通过Domain和Path指定作用域去解决。 6.7 HTTP传输中常见的问题 跨域问题 数据传输 队头阻塞 7. 传输层当设备A和设备B相互通信时，可以认为它们就是通过一个虚拟的互联网络进行连接的。在虚拟的网络世界里面已经解决了网络拓扑、数据路由的走向等问题。在传输层重点解决的是两个设备它们是如何直接进行通信的。 7.1 传输层的主要功能7.1.1 进程与进程的通信不同于在单个操作系统中使用的进程间通信（Unix域套接字、共享内存），网络通信可以跨设备、跨网络进行通信。 7.1.2 端口的概念使用端口来标记不同的网络进程。 端口使用16比特位表示（0~65535）。 常见的协议端口有： 协议 端口 FTP 21 HTTP 80 HTTPS 443 DNS 53 TELNET 23 7.2 UDP（User Datagram Protocol）用户数据报协议 7.2.1 功能UDP协议不会对数据进行任何处理，即不合并，也不拆分数据。 7.2.2 特点 1、无连接：通信时并不需要提前建立连接。 2、不保证可靠的数据交付：想发就发，无法保证数据在网络传输过程中是否丢失。 3、面向报文传输：不对数据做任何处理，而是直接将应用层数据塞进报文里面。 4、没有拥塞控制：不管网络是否拥塞，它都会把数据给交付出去。 5、首部开销很小：首部仅占用8字节。 7.2.3 报文结构 UDP长度最小为8，即仅包括UDP首部。 校验和用来检测UDP的数据报在传输过程中是否出错。 7.2.4 基于UDP定制化的5个例子1、来自网页或者App的访问 目前，HTTP往往采用多个数据通道共享一个连接的策略，这样做本来是为了加快传输速度，但是TCP严格的顺序策略使得哪怕通道共享，前一个包不来，后面的包即使与前一个包没有关系，也要等着，这样就会使延时很大。 而QUIC（Quick UDP Internet Connection，快速UDP互联网连接）协议是Google提供基于UDP改进的通信协议，其目的是降低网络通信的延迟，提供更好的用户体验。 QUIP会在应用层上自己快速建立连接、减少重传延时、自适应拥塞控制，是应用层定制化的代表。 2、流媒体协议 直播通常都使用RTMP（Real Time Messaging Protocol，实时消息传输协议），基于TCP。但对于直播来说，实时性很重要，宁可丢包，也不要卡顿。 对于视频直播来说，有的包可以丢，有的包不能丢，因为在视频的连续帧里，有的帧重要，有的不重要，如果一定要丢包，隔几个丢一个，看视频的人不会感知，但是如果连续丢帧，就能感知，因此网络条件不好的情况下，应用一般会选择性的丢帧。 当网络不好的时候，TCP会主动降低发送速度，这对本来就卡的视频来说无疑是雪上加霜。TCP应该让应用层马上重传，而不是主动让步。因此，很多直播应用都是基于UDP实现了自己的视频传输协议。 3、实时游戏 维护TCP连接需要在内核维护一些数据结构，但是一台机器能够支撑的TCP连接数目有限。由于UDP是没有连接的，所以在异步I/O机制引入之前，UDP常常是应对海量客户端连接的策略。 在游戏对实时要求比较严格的情况下，可以采用自定义的可靠UDP来传输数据包，通过使用自定义重传策略，能够使丢包产生的延时降到最低，尽量减少网络问题对游戏造成的影响。 4、物联网Google旗下的Nest建立了Thread Group，推出物联网通信协议Thread，该协议就是基于UDP的。 5、移动通信领域在4G网络里，通过移动通信传输数据面对的协议GTP-U就是基于UDP的。关于移动网络的知识下一篇会详细讲解。 7.3 TCP（Transmission Control Protocol）传输控制协议 7.3.1 特点 1、面向连接：就像打电话时，需要先拨通电话。 2、点对点通信、 3、可靠的传输服务。 4、全双工通信：两个设备在连接时，它们可以同时发送数据与接收数据。 5、面向字节的协议：TCP处理的是一个一个的字节，所以TCP很可能会取出数据中某一段进行输出，而剩下的数据会把它放到第二段以及之后的TCP报文中进行传输。因此TCP协议可能会对用户的数据进行合并和拆分。 TCP的缺点在于传输效率慢，因为它需要建立连接、发送确认包等等。 7.3.2 报文首部字段 序号 表示范围为0 ~ 2^32 - 1。 因为TCP是面向字节流的，所以每一字节都有一个与之对应的序号。 TCP数据报的序号就是数据报中第一个字节的序号。 确认号 表示范围0 ~ 2^32 - 1。 表示期望收到的数据的首字节序号，如果确认号为S，则表示 S - 1序号的数据都已经收到了。 数据偏移 占4位：0 ~ 15，单位为：32位字。 =&gt; 首部范围为20~60字节。 TCP数据偏移首部的距离，因为TCP选项的大小是不确定的，所以需要此数据项。 TCP标记占6位，每位都有不同的含义。 标记 含义 URG(Urgent) 紧急位，URG = 1，表示紧急数据 ACK(Acknowledgement) 确认位，ACK = 1，确认号才生效 PSH(Push) 推送位，PSH = 1，表示需要尽快地把数据交付给应用层 RST(Rest) 重置位，RST = 1，表示重新建立连接 SYN(Synchronizeation) 同步位，SYN = 1，表示连接请求报文 FIN(Finish) 终止位，FIN = 1，表示释放连接 窗口 占位16位：0 ~ 2^16 - 1. 窗口指明允许对方发送的数据量。例如，确认号为201，窗口号为300，那么可以接收序号的范围是201~500。 校验和 与UDP类似，用来检测TCP的数据在传输过程中是否出错。 紧急指针 紧急数据（URG = 1） 指定紧急数据在报文中的位置 TCP选项 最多40字节 支持未来的扩展 7.4 可靠传输的基本原理7.4.1 停止等待协议当发送方发送一个消息时，接收方接收到了并将消息发给发送方，这个过程中发送方需要停止等待接收方的确认信息。 超时重传 当消息发送出去后，发送方没有在超时时间内接收到接收方的确认消息或者超时之后才接收到消息，此时会向发送方重新发送该消息。超时重传通常都会处理三种异常情况，如下： 发送的消息在路上丢失了 确认的消息在路上丢失了 确认的消息超时了才收到 超时定时器（超时重传定时器） 1、每发送一个消息，都需要设置一个超时定时器。 2、主要应用在TCP的可靠传输协议里面，它是为了控制可能发生丢失的报文而设计的定时器，当TCP协议发送端发送一个报文时，就会为该报文设置一个超时定时器。 3、如果超时定时器在结束之前收到了来自接收端对该报文段的确认，则撤销这个定时器。 4、如果在超时定时器结束之前仍然没有收到接收端的报文段的确认（超时），则认为这个报文可能已经丢弃，发送端会重新发送该报文，并设置一个超时定时器。 5、需要注意，发送端在超时定时器撤销之前，必须继续缓存已发送未确认的报文，直到发送端接收到来自接收端的确认。 特点 停止等待协议是最简单的可靠传输协议 对信道的利用率不高 7.4.2 连续ARQ(Automatic Repeat Request)自动重传请求协议前面说到单个发送和确认效率低，那么是否可以批量发送和确认？ ARQ是对停止等待协议的改进，可以大幅提高信道利用率的一个协议。 滑动窗口 1、窗口中的数据都可以发送。 2、通过移动窗口的方式来标识没有接收到确认的消息。 3、采用了累积确认的方式，并不需要对每一个消息都进行确认。 累积确认 只要收到第5个消息的确认，就表示1~5的消息接收方都收到了。 7.5 TCP协议的可靠传输TCP的可靠传输是基于ARQ协议。 1、滑动窗口 2、累积确认 3、选择重连 选择重传 1、选择重传需要制定需要重传的字节。 2、每一个字节都有唯一的32位序号（4字节）。 3、要重传的数据是存储在TCP选项中，其中最多只能存储10个序号，即5个范围段的信息。 4、选择重传的是一个信息边界，即一段字节流，例如：传送10001200，20003000这个范围内的信息。 7.6 TCP协议的流量控制流量控制是指让发送方效率不要太快，TCP使用了滑动窗口来实现流量控制。 7.6.1 滑动窗口rwnd = 300，表示窗口大小为300。 占16位，0 ~ 2 ^ 16 - 1 窗口指明允许对方发送的数据量。例如：确认号为201，窗口为300，那么可以接收序号的范围是201 ~ 500 接收方可以调整滑动窗口的大小来控制发送方发送数据的效率。 当接收方将rwnd从0调整为1000并将这个信息发送给发送方时，消息丢失了，这就会导致发送方和接收方都会等待，形成一个死锁局面。 1如何解决这种死锁局面？ 7.6.2 坚持定时器坚持定时器是使用了滑动窗口进行流量控制的时候设置的。 1、当接收到窗口为0的消息，则启动坚持定时器。 2、坚持定时器每隔一段时间发送一个窗口探测报文。 7.7 TCP协议的拥塞控制7.7.1 问题 一条数据链路经常经过非常多的设备。 数据链路中各个部分都有可能成为网络传输的瓶颈。 7.7.2 流量控制和拥塞控制的区别不同于流量控制的点对点的通信量的控制，拥塞控制考虑的是整个网络，是一个全局性的考虑。 1如何判断是否拥塞？ 简单的认为报文超时就发生了拥塞。 TCP的拥塞控制 1、慢启动算法 有小到大逐渐增加发送数据量（呈指数增长，例如，1、2、4、8、16） 每收到一个报文确认，就加1 超过慢启动阈值(ssthresh)，就不再增长 2、拥塞避免算法 维护一个拥塞窗口的变量 只要网络不拥塞，就试探着将拥塞窗口调大 TCP的拥塞控制在前期使用了慢启动算法对窗口大小进行指数增长，直到超过慢启动阈值（ssthresh）则不再增长，后续则启动拥塞避免算法对窗口进行线性增长。 7.8 TCP链接的建立-三次握手 为什么发送方要发出第三个确认报文呢？ 1、已经失效的链接请求报文传送到对方，引出错误：假设两次握手就可以，失效的链接请求报文就会被接收并建立了重复的连接。当使用第三次握手时，比较慢到达接收方的报文也会发送一次确认给发送方，但是发送方已经进行了第三次握手了，因此发送方会忽略掉第二的确认，不会进行任何操作。 2、因为信道不可靠，而TCP想在不可靠的信道上建立可靠的传输，那么三次通信是理论上的最小值。（而UDP则不需要建立可靠传输，因此UDP不需要三次握手）。 3、因为双方都需要确认对方收到了自己发送的序号，确认过程最少要进行三次通信。 7.9 TCP链接的释放-四次挥手 7.9.1 等待计时器 会等待2MSL时间 =&gt; 4分钟 时间等待定时器是由在四次挥手时由主动关闭TCP连接的一方设置的，它主要是为了保证主动关闭方在对最后一个FIN报文（第三次挥手）发送确认的报文可以到达接收方。 MSL（Max Segment Lifetime）：最长报文段寿命。MSL建议设置为2分钟。 7.9.2 为什么要等待2MSL？ 1、因为最后一个报文没有确认，需要确保发送方的ACK可以到达接收方，如果2MSL时间内没有收到，则接收方会重发。 2、2MSL时间可以保证当发送方没有收到确认时，接收方可以再次发送FIN报文，并且接收方可以再次收到并重新发送确认，所以2MSL的时间可以保证连接正常结束。 3、确保当前连接的所有报文都已经过期。 7.10 TCP与UDP的区别 1、 UD常用于多媒体信息分发，即视频、语音、实时信息等。而TCP常用于可靠的信息传输，如金融交易、可靠通信、MQ等。 2、TCP面向连接，UDP是无连接的。 3、TCP提供可靠的服务，即，通过TCP连接传送的数据，无差错、不丢失、不重复，且按序达到；UDP尽最大的努力交付，但不保证可靠交付。 4、TCP的逻辑通信信道是全双工的可靠信道；UDP则是不可靠信道。 5、每一条TCP连接只能是点到点的；UDP支持一对一，一对多，多对一，多对多的交互通信。 6、TCP面向字节流（可能出现黏包问题），实际上是TCP把数据看成一连串无结构的字节流；UDP是面向报文的（不会出现黏包问题）。 7、UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）。 8、TCP首部开销20字节；UDP的首部开销小，只有8字节。 7.11 套接字（Socket）可以使用端口（Port）来标记不同的网络进程，而端口使用了16比特表示（0~65535）。 7.11.1 Socket概念 套接字是一个抽象的概念，表示TCP连接的一端。 通过套接字可以进行数据的发送或接收。 TCP = {Socket1:Socket2} = {{IP:Port}{IP:Port}}，可以看到，TCP由两个套接字组成。 7.11.2 Socket编程服务端编程 1、创建Socket 2、绑定Socket 3、监听Socket 4、接收和处理消息 其代码如下： 1234567891011121314151617181920import socketdef server(): # 1、创建 Socket s = socket.socket() host = \"127.0.0.1\" port = 5678 # 2、绑定 Socket s.bind(host, port) # 3、监听 s.listen() # 4、发送数据 while True: c, addr = s.accept() print(\"connect addr\", addr) c.send(b'Socket Study.') c.close() 客户端编程 1、创建Socket 2、连接Socket 3、发送消息 其代码如下： 1234567891011121314151617import socketdef client(i): # 1、创建 Socket s = socket.socket() # 2、连接 Socket s.connect(('127.0.0.1', 5678)) # 3、接收消息 print(\"Received message:%s, client Id:%d\" % (s.recv(1024), i)) s.close()if __name__ == '__main__': for i in range(10): client(i) 单机通信更推荐使用域Socket，相比网络通信数据需要在整个协议栈走一轮，域Socket它的处理流程更加简单，系统消耗更小。此外，如果对Socket IO实现机制有兴趣的可以查看CS-Notes。 7.12 TCP协议细节之TCP协议的四个定时器 1、超时定时器 2、坚持定时器 3、时间等待定时器 4、保活定时器：服务端一般都会设置一个保活定时器，为了保活TCP连接而设计的，可以防止TCP连接的两端出现长时间的空闲，当一方出现变化或者故障时，另一方没有察觉的情况。当服务端每次收到对方的数据则重置这个定时器，如果定时器超时，则发送弹出报文段，以此探测客户端是否在线，如果没有收到响应的话，那么则认为客户端已经断开连接，因此服务端也会终止这个连接。如今，很多的分布式系统都会使用保活计时器来检测其他节点是否在线还是已经故障，或者其他节点也会每个一段时间向主节点上报心跳信息以证明在线。 7.13 TCP在三次握手的时候，IP层和MAC（Medium Access Control）层在做什么？TCP每发送一条消息，都会带着IP层和MAC层。因为TCP每发送一个消息，IP层和MAC层的所有机制都要运行一遍。 注意，只要是网络上跑的包，都是完整的。可以有下层没有上层，绝对不会有上层没有下层。所以，对TCP来说，无论是三次握手还是重试，只要想将网络包发送出去，就要有IP层和MAC层，不然发不出去。 参考链接 1、慕课网之《编程必备基础 计算机组成原理+操作系统+计算机网络》网络部分 9 - 13章 2、《趣谈网络协议》1 - 5章 3、《计算机网络 自顶向下方法》前 6 章 4、(建议精读)HTTP灵魂之问，巩固你的HTTP知识体系 5、(建议收藏)TCP协议灵魂之问，巩固你的网路底层基础 6、一位前端小姐姐的五万字面试宝典 7、面试带你飞：这是一份全面的计算机网络基础总结攻略 8、JavaGuide-网络 9、interview-网络 10、总结了17年初到18年初百场前端面试的面试经验(含答案) 11、CS-Notes-网络","categories":[{"name":"Android","slug":"Android","permalink":"https://tylerLiu.top/categories/Android/"},{"name":"网络","slug":"Android/网络","permalink":"https://tylerLiu.top/categories/Android/网络/"}],"tags":[{"name":"网络","slug":"网络","permalink":"https://tylerLiu.top/tags/网络/"}]},{"title":"Android蓝牙串口SPP开发","slug":"Android蓝牙串口SPP开发","date":"2020-05-28T00:41:11.000Z","updated":"2020-05-29T01:53:27.517Z","comments":true,"path":"2020/05/28/Android蓝牙串口SPP开发/","link":"","permalink":"https://tylerLiu.top/2020/05/28/Android蓝牙串口SPP开发/","excerpt":"","text":"原文地址：https://blog.gtf35.top/bluetooth_spp/ 【这里仅供学习】 0. 前言物联网形势下，经常需要用到蓝牙串口来和单片机通讯。问题： 蓝牙串口是什么？ 如何扫描蓝牙设备？ 如果连接蓝牙设备？ 如果收发串口数据？ 1. 蓝牙串口是什么？先介绍一下串口，串行接口简称串口，就是一种通信的方式，类似于USB，只是比USB低级多。但是手机等设备没有外设这个串口，解决方案就是用手机蓝牙模块连接一个小硬件，小硬件有个串口，可以和单片机连接，来达到手机和单片机的串口连接，这种方式就是蓝牙串口。 那个小硬件就是“蓝牙透传模块”，淘宝上有卖，有专用的上位机。 这里要做的就是打开电脑上蓝牙模块的上位机的串口界面，能正常收发数据即可： 2. 如何扫描蓝牙设备？为什么不直接连接，而是扫描呢？ 因为连接需要使用BluetoothDevice，这个东西要么搜索到，要么使用“MAC”地址构造。“MAC”地址是每台设备独一无二的，所以必须要扫描设备，获取周围所有的设备列表，拿到BluetoothDevice来连接。同时取出里面的“MAC”地址，保存，用于下次连接。 首先获取系统的蓝牙适配器，所有的搜索，连接，等操作都要靠它： 1BluetoothAdapter mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter(); 然后判断用户的蓝牙是否已开启： 123456/** * 获取用户是否打开了蓝牙 */boolean isBluetoothEnable() &#123; return mBluetoothAdapter.isEnabled();&#125; 开启蓝牙： 123456/** * 开启蓝牙 */void enableBluetooth() &#123; mBluetoothAdapter.enable();&#125; 蓝牙开启之后，就可以搜索设备列表： 1mBluetoothAdapter.startDiscovery(); 搜索前，还需要判断是不是已经在搜索了： 1mBluetoothAdapter.isDiscovering(); 如果正在搜索，就取消搜索： 1mBluetoothAdapter.cancelDiscovery(); 结合起来就是： 1234567/** * 开始搜索 */void startDiscovery() &#123; if (mBluetoothAdapter.isDiscovering()) mBluetoothAdapter.cancelDiscovery(); mBluetoothAdapter.startDiscovery();&#125; 那么，结果在哪获取？可以通过广播。 先定义一个广播接收器，获取搜索结果的Action是BluetoothDevice.ACTION_FOUND，然后在里面取出BluetoothDevice.EXTRA_DEVICE，就可以获得BluetoothDevice了。 自定义广播： 123456789101112/** * 搜索到新设备广播广播接收器 */private final BroadcastReceiver mReceiver = new BroadcastReceiver() &#123; public void onReceive(Context context, Intent intent) &#123; String action = intent.getAction(); if (BluetoothDevice.ACTION_FOUND.equals(action)) &#123; // 这就是可爱的 BluetoothDevice 了 BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE); &#125; &#125;&#125;; 注册广播： 12IntentFilter foundFilter = new IntentFilter(BluetoothDevice.ACTION_FOUND);mContext.registerReceiver(mReceiver, foundFilter); 添加权限： 123456&lt;!--管理蓝牙需要--&gt;&lt;uses-permission android:name=\"android.permission.BLUETOOTH\" /&gt;&lt;uses-permission android:name=\"android.permission.BLUETOOTH_ADMIN\" /&gt;&lt;!--搜索蓝牙需要，因为蓝牙可以被用来定位，所以需要定位权限--&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\"/&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\"/&gt; 这样在触发搜索逻辑之后，每次找到一个新设备就会收到一个广播，拿到BluetoothDevice之后，就可以获取“MAC“地址： 1bluetoothDevice.getAddress(); 保存下来，下次使用的时候就可以用它二次获取BluetoothDevice了: 1bluetoothDevice = bluetoothAdapter.getRemoteDevice(\"之前保存过的蓝牙MAC地址\"); 到这里，搜索部分结束。 3. 如何连接蓝牙设备前面说到，拿到BluetoothDevice就可以用来连接了，连接很简单，首先要知道每个蓝牙设备都有一个UUID来描述自己是什么设备，蓝牙串口设备到的缩写是SPP，它的UUID如下，其他的UUID详情，可以参考这里。 1UUID SPP_UUID = UUID.fromString(\"00001101-0000-1000-8000-00805F9B34FB\"); 然后用前面拿到的BluetoothDevice来打开指定UUID的连接即可获取到蓝牙的Socket，注意，只能和UUID类型对应的设备连接，比如这里设置的UUID是SPP的，和普通的手机就连不上： 1BluetoothSocket bluetoothSocket = bluetoothDevice.createRfcommSocketToServiceRecord(SPP_UUID); 调用BluetoothSocket的connect()方法建立和蓝牙模块的连接，如果之前没有配对过，会弹出系统窗口，要求输入配对密码，这里系统会自动处理。要注意connect()方法会阻塞线程，需要在子线程连接： 12// 等待连接，会阻塞线程bluetoothSocket.connect(); 然后通过BluetoothSocket即可拿到输入流和输出流： 1234// 用来收数据InputStream inputStream = bluetoothSocket.getInputStream();// 用来发数据OutputStream outputStream = bluetoothSocket.getOutputStream(); 4. 如何收发串口数据发数据就是传统的流操作，调用OutputStream的write(byte[])方法来写入流： 12345678910/** * 发送 * * @param msg 内容 */void send(byte[] msg) &#123; try &#123; bluetoothSocket.getOutputStream().write(msg); &#125; catch (Exception e)&#123;e.printStackTrace();&#125;&#125; 收数据需要注意，需要写一个死循环，反复读取，因为串口发来的一句话很可能是分成好几段发来的，和单片机的开发约定好一个停止位，没收到停止位之前，就一直累加，这里给出一个调试好的模板代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 记录标志位，开始运行boolean isRunning = true;// 约定好的停止位String stopString = \"\\r\\n\"; // 开始监听数据接收try &#123; InputStream inputStream = bluetoothSocket.getInputStream(); byte[] result = new byte[0]; while (isRunning) &#123; logD(\"looping\"); byte[] buffer = new byte[256]; // 等待有数据 while (inputStream.available() == 0 &amp;&amp; isRunning) &#123;if (System.currentTimeMillis() &lt; 0) break;&#125; while (isRunning) &#123; try &#123; int num = inputStream.read(buffer); byte[] temp = new byte[result.length + num]; System.arraycopy(result, 0, temp, 0, result.length); System.arraycopy(buffer, 0, temp, result.length, num); result = temp; if (inputStream.available() == 0) break; &#125; catch (Exception e) &#123; e.printStackTrace(); // todo:处理接收数据单次失败 break; &#125; &#125; try &#123; // 返回数据 logD(\"当前累计收到的数据=&gt;\" + byte2Hex(result)); byte[] stopFlag = stopString.getBytes(); int stopFlagSize = stopFlag.length; boolean shouldCallOnReceiveBytes = false; logD(\"标志位为：\" + byte2Hex(stopFlag)); for (int i = stopFlagSize - 1; i &gt;= 0; i--) &#123; int indexInResult = result.length - (stopFlagSize - i); if (indexInResult &gt;= result.length || indexInResult &lt; 0) &#123; shouldCallOnReceiveBytes = false; logD(\"收到的数据比停止字符串短\"); break; &#125; if (stopFlag[i] == result[indexInResult]) &#123; logD(\"发现\" + byte2Hex(stopFlag[i]) + \"等于\" + byte2Hex(result[indexInResult])); shouldCallOnReceiveBytes = true; &#125; else &#123; logD(\"发现\" + byte2Hex(stopFlag[i]) + \"不等于\" + byte2Hex(result[indexInResult])); shouldCallOnReceiveBytes = false; &#125; &#125; if (shouldCallOnReceiveBytes) &#123; // 到了这里，byte 数组 result 就是收到的数据了 // todo: 执行收到数据逻辑 // 清空之前的 result = new byte[0]; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); // todo:处理验证收到数据结束标志出错 &#125; &#125;&#125; catch (Exception e) &#123; e.printStackTrace(); // todo:处理接收数据失败&#125; 5. 总结主要流程基本结束，后面不要忘记关闭线程，关闭流，解除注册广播等。 源码地址：BluetoothLowEnergyDemo","categories":[{"name":"Android","slug":"Android","permalink":"https://tylerLiu.top/categories/Android/"},{"name":"蓝牙","slug":"Android/蓝牙","permalink":"https://tylerLiu.top/categories/Android/蓝牙/"}],"tags":[{"name":"蓝牙","slug":"蓝牙","permalink":"https://tylerLiu.top/tags/蓝牙/"}]},{"title":"慕课网《编程必备基础 计算机组成原理+操作系统+计算机网络》-01","slug":"慕课网《编程必备基础-计算机组成原理-操作系统-计算机网络》-01","date":"2020-05-22T02:03:00.000Z","updated":"2020-05-22T02:04:35.677Z","comments":true,"path":"2020/05/22/慕课网《编程必备基础-计算机组成原理-操作系统-计算机网络》-01/","link":"","permalink":"https://tylerLiu.top/2020/05/22/慕课网《编程必备基础-计算机组成原理-操作系统-计算机网络》-01/","excerpt":"","text":"","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://tylerLiu.top/categories/计算机基础/"},{"name":"计算机组成原理","slug":"计算机基础/计算机组成原理","permalink":"https://tylerLiu.top/categories/计算机基础/计算机组成原理/"}],"tags":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://tylerLiu.top/tags/计算机组成原理/"}]},{"title":"HashMap解析-02：手写HashMap（基于JDK1.7，只写数组+链表）","slug":"HashMap解析-02：手写HashMap","date":"2020-05-21T08:55:29.000Z","updated":"2020-05-22T01:17:07.059Z","comments":true,"path":"2020/05/21/HashMap解析-02：手写HashMap/","link":"","permalink":"https://tylerLiu.top/2020/05/21/HashMap解析-02：手写HashMap/","excerpt":"","text":"思考HashMap的存储结构为散列表，解决哈希冲突是用过链表法解决的，结构如下： 下面主要实现这个结构。 1、定义接口HashMap是实现了Map接口的，这里也需要定义个类似的接口，主要包括存取数据，以及存取数据结构的接口（包括取键和取值）。 12345678910111213141516171819202122232425262728293031323334353637public interface MyMap&lt;K, V&gt; &#123; /** * 取值 * * @param k 键 * @return 值 */ V get(K k); /** * 存值 * * @param k 键 * @param v 值 * @return 值 */ V put(K k, V v); /** * 内部接口 */ interface Entry&lt;K, V&gt; &#123; /** * 取值 * * @return 值 */ V getValue(); /** * 取键 * * @return 键 */ K getKey(); &#125;&#125; 2、自定义HashMap实现自定义的Map接口实现自定义的接口，并且定义默认的容量，默认加载因子（0.75），以及数组使用长度，存储的数组。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class MyHashMap&lt;K, V&gt; implements MyMap&lt;K, V&gt; &#123; /** * 默认容量 */ private int DEFAULT_LENGTH = 16; /** * 默认加载因子 */ private float LOADER = 0.75f; /** * Map使用数组长度 */ private int useSize = 0; /** * 数组 */ private Entry&lt;K, V&gt;[] table; public MyHashMap() &#123; this(16, 0.75f); &#125; public MyHashMap(int defaultLength, float loader) &#123; if (defaultLength &lt; 0) &#123; throw new IllegalArgumentException(\"数组异常\"); &#125; if (loader &lt;= 0 || Float.isNaN(loader)) &#123; throw new IllegalArgumentException(\"加载因子异常\"); &#125; this.DEFAULT_LENGTH = defaultLength; this.LOADER = loader; table = new Entry[DEFAULT_LENGTH]; &#125; @Override public V get(K k) &#123; return null; &#125; @Override public V put(K k, V v) &#123; return null; &#125;&#125; 3、HashMap存储结构下面实现内部接口，来自定义每个点的存储结构，需要有键，值，及指向下一节点的对象。 1234567891011121314151617181920212223242526272829303132333435/** * 存储结构 */class Entry&lt;K, V&gt; implements MyMap.Entry&lt;K, V&gt; &#123; /** * 键 */ private K key; /** * 值 */ private V value; /** * 链表指向下一个 */ private Entry&lt;K, V&gt; next; public Entry(K key, V value, Entry&lt;K, V&gt; next) &#123; this.key = key; this.value = value; this.next = next; &#125; @Override public V getValue() &#123; return value; &#125; @Override public K getKey() &#123; return key; &#125;&#125; 4、实现HashMap的HashCode来计算下标实现HashCode来自定义确定key所对应的下标。 1234567891011121314151617181920/** * 使用每个object的hashCode计算hashCode */private int hash(int hashCode) &#123; hashCode = hashCode ^ ((hashCode &gt;&gt;&gt; 20) ^ (hashCode &gt;&gt;&gt; 12)); return hashCode ^ ((hashCode &gt;&gt;&gt; 7) ^ hashCode &gt;&gt;&gt; 4);&#125;/** * 获取下标 * * @param k 键 * @param length 数组长度 * @return 下标 */private int getIndex(K k, int length) &#123; int m = length - 1; int index = hash(k.hashCode()) &amp; m; return index &gt;= 0 ? index : -index;&#125; 5、实现HashMap的put方法通过key确定对于数组的下标，再确定有没有哈希冲突，有则往后追加，没有则直接存放。 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 存 * * @param k 键 * @param v 值 * @return 值 */@Overridepublic V put(K k, V v) &#123; // 扩容 if (useSize &gt;= DEFAULT_LENGTH * LOADER) &#123; resize(); &#125; // 计算下标 int index = getIndex(k, table.length); Entry&lt;K, V&gt; entry = table[index]; Entry&lt;K, V&gt; newEntry = new Entry&lt;K, V&gt;(k, v, null); if (null == entry) &#123; // 直接插入第一个 table[index] = newEntry; useSize++; &#125; else &#123; Entry&lt;K, V&gt; t = entry; if (t.getKey() == k || (t.getKey() != null &amp;&amp; t.getKey().equals(k))) &#123; // 已经存在，替换 t.value = v; &#125; else &#123; while (t.next != null) &#123; if (t.getKey() == k || (t.getKey() != null &amp;&amp; t.getKey().equals(k))) &#123; // 已经存在，替换 t.value = v; break; &#125; else &#123; t = t.next; &#125; &#125; if (t.next == null) &#123; // 不存在，追加在链表后面 t.next = newEntry; &#125; &#125; &#125; return newEntry.getValue();&#125; 6、HashMap的扩容方法resize12345678910111213141516171819202122232425262728293031/** * 扩容 */private void resize() &#123; Entry&lt;K, V&gt;[] newTable = new Entry[DEFAULT_LENGTH * 2]; List&lt;Entry&lt;K, V&gt;&gt; list = new ArrayList&lt;&gt;(); // 循环遍历取出就数组的数据 for (Entry&lt;K, V&gt; kvEntry : table) &#123; if (null == kvEntry) &#123; continue; &#125; Entry&lt;K, V&gt; entry = kvEntry; while (null != entry) &#123; list.add(entry); entry = entry.next; &#125; &#125; // 重新放回数组 if (list.size() &gt; 0) &#123; useSize = 0; DEFAULT_LENGTH = DEFAULT_LENGTH * 2; table = newTable; for (Entry&lt;K, V&gt; entry : list) &#123; if (entry.next != null) &#123; entry.next = null; &#125; put(entry.getKey(), entry.getValue()); &#125; &#125;&#125; 7、实现HashMap的get方法12345678910111213141516171819202122@Overridepublic V get(K k) &#123; int index = getIndex(k, table.length); Entry&lt;K, V&gt; entry = table[index]; if (null != entry) &#123; while (entry.next != null) &#123; if (entry.getKey() == k || (entry.getKey() != null &amp;&amp; entry.getKey().equals(k))) &#123; return entry.getValue(); &#125; else &#123; entry = entry.next; &#125; &#125; if (entry.next == null) &#123; if (entry.getKey() == k || (entry.getKey() != null &amp;&amp; entry.getKey().equals(k))) &#123; return entry.getValue(); &#125; &#125; &#125; else &#123; throw new NullPointerException(); &#125; return null;&#125; 源码地址：HandWriteHashMap","categories":[{"name":"Java","slug":"Java","permalink":"https://tylerLiu.top/categories/Java/"},{"name":"源码","slug":"Java/源码","permalink":"https://tylerLiu.top/categories/Java/源码/"}],"tags":[{"name":"源码","slug":"源码","permalink":"https://tylerLiu.top/tags/源码/"}]},{"title":"HashMap解析-01：HashMap源码解析（基于JDK1.8）","slug":"HashMap解析-01：HashMap源码解析","date":"2020-05-16T05:58:48.000Z","updated":"2020-05-21T08:53:37.987Z","comments":true,"path":"2020/05/16/HashMap解析-01：HashMap源码解析/","link":"","permalink":"https://tylerLiu.top/2020/05/16/HashMap解析-01：HashMap源码解析/","excerpt":"","text":"相关概念时间复杂度时间复杂度O(1), O(n), O(logn), O(nlogn) 数组采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和元素，时间复杂度为O(n)，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n)。 线性列表对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理节点间的引用即可，时间复杂度为O(1)，而查找操作需要遍历链表逐一进行对比，复杂度为O(n)。 红黑树红黑树（Red Black Tree）是一种自平衡二叉查找树，其典型的用途是实现关联数组。除了二叉树强制的一般要求外，红黑树还需要： 1、节点是红色或黑色； 2、根节点是黑色； 3、每个叶节点（NIL节点，空节点）是黑色； 4、每个红色节点的两个子节点都是黑色。（从每个叶子到根的所有路径上不能有两个连续的红色节点） 5、从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。 哈希表散列表（Hash Table，也成哈希表），是根据关键码值（key value）而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中的一个位置来访问记录，以加快查找速度。这个映射函数叫做散列函数，存放记录的数组叫散列表。 给定表M，存在函数f(key)，对任意给定的关键字key，带入函数后如果能包含该关键字的记录在表中的地址，则成表M为哈希（Hash）表，函数f(key)为哈希（Hash）函数。 哈希冲突如果两个不同的元素，通过哈希函数得出的实际存储地址相同怎么办？也就是说，当对某个元素进行哈希运算，得到一个存储地址，然后要进行插入时，发现已经被其他元素占用了，这就是哈希冲突，也叫哈希碰撞。前面提到，哈希函数的设计至关重要，好的哈希函数会尽可能保证计算简单和散列地址分布均匀，但是，需要清楚的是，数组是一块连续的固定长度的内存空间，再好的哈希函数也不能保证得到的存储地址绝不发生冲突。那么哈希冲突如何解决呢？哈希冲突的解决方案有多种：开放定址法（发生冲突，继续寻找下一块未被占用的存储地址）、再散列函数法、链地址法，HashMap采用的是再散列函数法，即数组+链表的方式。 HashMap在JDK1.8中的源码源码注释： 1234567891011121314151617181920212223242526272829// 1、哈希表基于map接口的实现，这个实现提供了map所有的操作，并且提供了key和value可以为null，(HashMap和HashTable大致上市一样的除了hashmap是异步的和允许key和value为null)，这个类不确定map中元素的位置，特别要提的是，这个类也不确定元素的位置随着时间会不会保持不变。Hash table based implementation of the Map interface. This implementation provides all of the optional map operations, and permits null values and the null key. (The HashMap class is roughly equivalent to Hashtable, except that it is unsynchronized and permits nulls.) This class makes no guarantees as to the order of the map; in particular, it does not guarantee that the order will remain constant over time. // 假设哈希函数将元素合适的分到了每个桶(其实就是指的数组中位置上的链表)中，则这个实现为基本的操作(get、put)提供了稳定的性能，迭代这个集合视图需要的时间跟hashMap实例(key-value映射的数量)的容量(在桶中)成正比，因此，如果迭代的性能很重要的话，就不要将初始容量设置的太高或者loadfactor设置的太低，【这里的桶，相当于在数组中每个位置上放一个桶装元素】This implementation provides constant-time performance for the basic operations (get and put), assuming the hash function disperses the elements properly among the buckets. Iteration over collection views requires time proportional to the \"capacity\" of the HashMap instance (the number of buckets) plus its size (the number of key-value mappings). Thus, it's very important not to set the initial capacity too high (or the load factor too low) if iteration performance is important.// HashMap的实例有两个参数影响性能，初始化容量(initialCapacity)和loadFactor加载因子，在哈希表中这个容量是桶的数量【也就是数组的长度】，一个初始化容量仅仅是在哈希表被创建时容量，在容量自动增长之前加载因子是衡量哈希表被允许达到的多少的。当entry的数量在哈希表中超过了加载因子乘以当前的容量，那么哈希表被修改(内部的数据结构会被重新建立)所以哈希表有大约两倍的桶的数量An instance of HashMap has two parameters that affect its performance: initial capacity and load factor. The capacity is the number of buckets in the hash table, and the initial capacity is simply the capacity at the time the hash table is created. The load factor is a measure of how full the hash table is allowed to get before its capacity is automatically increased. When the number of entries in the hash table exceeds the product of the load factor and the current capacity, the hash table is rehashed (that is, internal data structures are rebuilt) so that the hash table has approximately twice the number of buckets.// 通常来讲，默认的加载因子(0.75)能够在时间和空间上提供一个好的平衡，更高的值会减少空间上的开支但是会增加查询花费的时间（体现在HashMap类中get、put方法上），当设置初始化容量时，应该考虑到map中会存放entry的数量和加载因子，以便最少次数的进行rehash操作，如果初始容量大于最大条目数除以加载因子，则不会发生 rehash 操作。As a general rule, the default load factor (.75) offers a good tradeoff between time and space costs. Higher values decrease the space overhead but increase the lookup cost (reflected in most of the operations of the HashMap class, including get and put). The expected number of entries in the map and its load factor should be taken into account when setting its initial capacity, so as to minimize the number of rehash operations. If the initial capacity is greater than the maximum number of entries divided by the load factor, no rehash operations will ever occur.// 如果很多映射关系要存储在 HashMap 实例中，则相对于按需执行自动的 rehash 操作以增大表的容量来说，使用足够大的初始容量创建它将使得映射关系能更有效地存储。If many mappings are to be stored in a HashMap instance, creating it with a sufficiently large capacity will allow the mappings to be stored more efficiently than letting it perform automatic rehashing as needed to grow the table HashMap的继承关系1234public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; /****省略代码****/&#125; HashMap继承了AbstractMap实现了Map、Cloneable、Serializable接口。 HashMap的属性12345678910111213141516171819202122232425262728293031public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; // 序列号，序列化的时候使用。 private static final long serialVersionUID = 362498820763181265L; /**默认容量，1向左移位4个，00000001变成00010000，也就是2的4次方为16，使用移位是因为移位是计算机基础运算，效率比加减乘除快。**/ static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // 最大容量，2的30次方。 static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; // 加载因子，用于扩容使用。 static final float DEFAULT_LOAD_FACTOR = 0.75f; // 当某个桶节点数量大于8时，会转换为红黑树。 static final int TREEIFY_THRESHOLD = 8; // 当某个桶节点数量小于6时，会转换为链表，前提是它当前是红黑树结构。 static final int UNTREEIFY_THRESHOLD = 6; // 当整个hashMap中元素数量大于64时，也会进行转为红黑树结构。 static final int MIN_TREEIFY_CAPACITY = 64; // 存储元素的数组，transient关键字表示该属性不能被序列化 transient Node&lt;K,V&gt;[] table; // 将数据转换成set的另一种存储形式，这个变量主要用于迭代功能。 transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; // 元素数量 transient int size; // 统计该map修改的次数 transient int modCount; // 临界值，也就是元素数量达到临界值时，会进行扩容。 int threshold; // 也是加载因子，只不过这个是变量。 final float loadFactor; /****省略代码****/&#125; 默认容量16，默认加载因子0.75。 HashMap构造方法 HashMap有四个构造方法： 1、空参构造方法，使用默认的负载因子0.75； 2、设置初始容量并使用默认加载因子； 3、设置容量和加载因子，第二个构造方法最终还是调用了第三个构造方法； 4、将一个Map转换为HashMap。 第四个构造方法源码： 12345678910111213141516171819202122232425262728293031public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false);&#125;final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123; // 获取该map的实际长度 int s = m.size(); if (s &gt; 0) &#123; // 判断table是否初始化，如果没有初始化 if (table == null) &#123; // pre-size /**求出需要的容量，因为实际使用的长度=容量*0.75得来的，+1是因为小数相除，基本都不会是整数，容量大小不能为小数的，后面转换为int，多余的小数就要被丢掉，所以+1，例如，map实际长度22，22/0.75=29.3,所需要的容量肯定为30，有人会问如果刚刚好除得整数呢，除得整数的话，容量大小多1也没什么影响**/ float ft = ((float)s / loadFactor) + 1.0F; //判断该容量大小是否超出上限。 int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ? (int)ft : MAXIMUM_CAPACITY); /**对临界值进行初始化，tableSizeFor(t)这个方法会返回大于t值的，且离其最近的2次幂，例如t为29，则返回的值是32**/ if (t &gt; threshold) threshold = tableSizeFor(t); &#125; // 如果table已经初始化，则进行扩容操作，resize()就是扩容。 else if (s &gt; threshold) resize(); // 遍历，把map中的数据转到hashMap中。 for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123; K key = e.getKey(); V value = e.getValue(); putVal(hash(key), key, value, false, evict); &#125; &#125;&#125; 构造函数中传入了一个Map，然后把这个Map转换为HashMap，这里还调用了resize()进行扩容。 在上面的entrySet()中返回一个Set&lt;Map.Entry&lt;K, V&gt;&gt;，泛型为Map的内部类Entry，它是一个存放key-value的实例，因为hash表的遍历，插入效率高。 构造函数就到这里，下面重点看看HashMap是如何将key和value存储的。下面看看HashMap的put(K key,V value)方法。 HashMap的put方法1234 public V put(K key, V value) &#123; /**四个参数，第一个hash值，第四个参数表示如果该key存在值，如果为null的话，则插入新的value，最后一个参数，在hashMap中没有用，可以不用管，使用默认的即可**/ return putVal(hash(key), key, value, false, true);&#125; 这里调用了putVal之前调用了hash方法。 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 这里将键值的hashCode做异或运算，目的是为了减少哈希冲突。 下面看看putVal的源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; // tab:哈希数组，p:该哈希桶的首节点，n:hashMap的长度，i:计算出的数组下标 Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // 获取长度并进行扩容，使用的是懒加载，table一开始是没有加载的，等put后才开始加载 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; /**如果计算出的该哈希桶的位置没有值，则把新插入的key-value放到此处，此处就算没有插入成功，也就是发生哈希冲突时也会把哈希桶的首节点赋予p**/ if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); // 发生哈希冲突的几种情况 else &#123; // e:临时节点的作用，k:存放该当前节点的key Node&lt;K,V&gt; e; K k; // 第一种，插入的key-value的hash值，key都与当前节点的相等，e = p，则表示为首节点 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 第二种，hash值不等于首节点，判断该p是否属于红黑树的节点 else if (p instanceof TreeNode) /**为红黑树的节点，则在红黑树中进行添加，如果该节点已经存在，则返回该节点（不为null），该值很重要，用来判断put操作是否成功，如果添加成功返回null**/ e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 第三种，hash值不等于首节点，不为红黑树的节点，则为链表的节点 else &#123; // 遍历该链表 for (int binCount = 0; ; ++binCount) &#123; // 如果找到尾部，则表明添加的key-value没有重复，在尾部进行添加 if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); // 判断是否要转换为红黑树结构 if (binCount &gt;= TREEIFY_THRESHOLD - 1) treeifyBin(tab, hash); break; &#125; // 如果链表中有重复的key，e则为当前重复的节点，结束循环 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; // 有重复的key，则用待插入值进行覆盖，返回旧值。 if (e != null) &#123; V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; // 到了此步骤，则表明待插入的key-value是没有key的重复，因为插入成功e节点的值为null // 修改次数+1 ++modCount; // 实际长度+1，判断是否大于临界值，大于则扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); // 添加成功 return null;&#125; 主要有以下几个步骤： 1、根据key计算处在数组中存储的下标； 2、根据使用的大小，判断是否需要扩容； 3、根据数组下标判断是否当前下标已存储数据，如果没有，则直接插入； 4、如果存储了，则存在哈希冲突，判断当前entry的key是否相等，如果相等则替换，否则判断下一个节点是否为空，为空则直接插入，否则取下一节点重复上述步骤； 5、判断链表长度是否大于8，当达到8时，转换为红黑树。 HashMap的扩容函数resize()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103final Node&lt;K,V&gt;[] resize() &#123; // 把没插入之前的哈希数组作为oldTal Node&lt;K,V&gt;[] oldTab = table; // old的长度 int oldCap = (oldTab == null) ? 0 : oldTab.length; // old的临界值 int oldThr = threshold; // 初始化new的长度和临界值 int newCap, newThr = 0; // oldCap &gt; 0也就是说不是首次初始化，因为hashMap用的是懒加载 if (oldCap &gt; 0) &#123; // 大于最大值 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; // 临界值为整数的最大值 threshold = Integer.MAX_VALUE; return oldTab; &#125; // 标记##，其它情况，扩容两倍，并且扩容后的长度要小于最大值，old长度也要大于16 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) // 临界值也扩容为old的临界值2倍 newThr = oldThr &lt;&lt; 1; &#125; /**如果oldCap&lt;0，但是已经初始化了，像把元素删除完之后的情况，那么它的临界值肯定还存在， 如果是首次初始化，它的临界值则为0 **/ else if (oldThr &gt; 0) newCap = oldThr; // 首次初始化，给与默认的值 else &#123; newCap = DEFAULT_INITIAL_CAPACITY; // 临界值等于容量*加载因子 newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; // 此处的if为上面标记##的补充，也就是初始化时容量小于默认值16的，此时newThr没有赋值 if (newThr == 0) &#123; // new的临界值 float ft = (float)newCap * loadFactor; // 判断是否new容量是否大于最大值，临界值是否大于最大值 newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; // 把上面各种情况分析出的临界值，在此处真正进行改变，也就是容量和临界值都改变了。 threshold = newThr; // 表示忽略该警告 @SuppressWarnings(&#123;\"rawtypes\",\"unchecked\"&#125;) // 初始化 Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; // 赋予当前的table table = newTab; // 此处自然是把old中的元素，遍历到new中 if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; // 临时变量 Node&lt;K,V&gt; e; // 当前哈希桶的位置值不为null，也就是数组下标处有值，因为有值表示可能会发生冲突 if ((e = oldTab[j]) != null) &#123; // 把已经赋值之后的变量置位null，当然是为了好回收，释放内存 oldTab[j] = null; // 如果下标处的节点没有下一个元素 if (e.next == null) // 把该变量的值存入newCap中，e.hash &amp; (newCap - 1)并不等于j newTab[e.hash &amp; (newCap - 1)] = e; // 该节点为红黑树结构，也就是存在哈希冲突，该哈希桶中有多个元素 else if (e instanceof TreeNode) // ✨✨✨把此树进行转移到newCap中✨✨✨ ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; /**此处表示为链表结构，同样把链表转移到newCap中，就是把链表遍历后，把值转过去，在置位null**/ Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; // 返回扩容后的hashMap return newTab;&#125; HashMap的结构为数组+链表（红黑树）。 逻辑： 1、对数组进行扩容； 2、扩容后重新计算hashCode，即key的下标，将原始数据放入扩容后的数据结构中； 3、当存在哈希冲突时，在数组后面以链表的形式追加到后面，当链表长度达到8时，就会将链表转换为红黑树。 对于红黑树新增节点，需要考虑前面所说的红黑树性质。就需要对红黑树做调整，使红黑树达到平衡。这种平衡就是红黑树的旋转。 红黑树的旋转分为左旋和右旋，以某个节点为圆心向左或向右旋转。史上最清晰的红黑树讲解 左旋 上图中各子树可以是多个节点构成的子树，也可以是一个具体的节点，也可以是null。 HashMap中红黑树的左旋12345678910111213141516static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateLeft(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; p) &#123; TreeNode&lt;K,V&gt; r, pp, rl; if (p != null &amp;&amp; (r = p.right) != null) &#123; if ((rl = p.right = r.left) != null) rl.parent = p; if ((pp = r.parent = p.parent) == null) (root = r).red = false; else if (pp.left == p) pp.left = r; else pp.right = r; r.left = p; p.parent = r; &#125; return root;&#125; 上图中各子树可以是多个节点构成的子树，也可以是一个具体的节点，也可以是null。 HashMap中红黑树的右旋12345678910111213141516static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateRight(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; p) &#123; TreeNode&lt;K,V&gt; l, pp, lr; if (p != null &amp;&amp; (l = p.left) != null) &#123; if ((lr = p.left = l.right) != null) lr.parent = p; if ((pp = l.parent = p.parent) == null) (root = l).red = false; else if (pp.right == p) pp.right = l; else pp.left = l; l.right = p; p.parent = l; &#125; return root;&#125; 红黑树新增节点的例子TreeMap的结构也是红黑树，它新增节点的过程如下：这里跟HashMap的红黑树的新增原理一样: 现在回到resize()，里面有： 12// ✨✨✨把此树进行转移到newCap中✨✨✨((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); HashMap中TreeNode.split123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051final void split(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int index, int bit) &#123; TreeNode&lt;K,V&gt; b = this; // 拿到调用此方法的节点 TreeNode&lt;K,V&gt; loHead = null, loTail = null; // 存储跟原索引位置相同的节点 TreeNode&lt;K,V&gt; hiHead = null, hiTail = null; // 存储索引位置为:原索引+oldCap的节点 int lc = 0, hc = 0; for (TreeNode&lt;K,V&gt; e = b, next; e != null; e = next) &#123; // 从b节点开始遍历 next = (TreeNode&lt;K,V&gt;)e.next; // next赋值为e的下个节点 e.next = null; // 同时将老表的节点设置为空，以便垃圾收集器回收 //如果e的hash值与老表的容量进行与运算为0,则扩容后的索引位置跟老表的索引位置一样 if ((e.hash &amp; bit) == 0) &#123; if ((e.prev = loTail) == null) // 如果loTail为空, 代表该节点为第一个节点 loHead = e; // 则将loHead赋值为第一个节点 else loTail.next = e; // 否则将节点添加在loTail后面 loTail = e; // 并将loTail赋值为新增的节点 ++lc; // 统计原索引位置的节点个数 &#125; //如果e的hash值与老表的容量进行与运算为1,则扩容后的索引位置为:老表的索引位置＋oldCap else &#123; if ((e.prev = hiTail) == null) // 如果hiHead为空, 代表该节点为第一个节点 hiHead = e; // 则将hiHead赋值为第一个节点 else hiTail.next = e; // 否则将节点添加在hiTail后面 hiTail = e; // 并将hiTail赋值为新增的节点 ++hc; // 统计索引位置为原索引+oldCap的节点个数 &#125; &#125; if (loHead != null) &#123; // 原索引位置的节点不为空 if (lc &lt;= UNTREEIFY_THRESHOLD) // 节点个数少于6个则将红黑树转为链表结构 tab[index] = loHead.untreeify(map); else &#123; tab[index] = loHead; // 将原索引位置的节点设置为对应的头结点 // hiHead不为空则代表原来的红黑树(老表的红黑树由于节点被分到两个位置) // 已经被改变, 需要重新构建新的红黑树 if (hiHead != null) loHead.treeify(tab); // 以loHead为根结点, 构建新的红黑树 &#125; &#125; if (hiHead != null) &#123; // 索引位置为原索引+oldCap的节点不为空 if (hc &lt;= UNTREEIFY_THRESHOLD) // 节点个数少于6个则将红黑树转为链表结构 tab[index + bit] = hiHead.untreeify(map); else &#123; tab[index + bit] = hiHead; // 将索引位置为原索引+oldCap的节点设置为对应的头结点 // loHead不为空则代表原来的红黑树(老表的红黑树由于节点被分到两个位置) // 已经被改变, 需要重新构建新的红黑树 if (loHead != null) hiHead.treeify(tab); // 以hiHead为根结点, 构建新的红黑树 &#125; &#125;&#125; 下面看看treeify() HashMap中的treeify()12345678910111213141516171819202122232425262728293031323334353637383940414243444546final void treeify(Node&lt;K,V&gt;[] tab) &#123; // 构建红黑树 TreeNode&lt;K,V&gt; root = null; for (TreeNode&lt;K,V&gt; x = this, next; x != null; x = next) &#123;// this即为调用此方法的TreeNode next = (TreeNode&lt;K,V&gt;)x.next; // next赋值为x的下个节点 x.left = x.right = null; // 将x的左右节点设置为空 if (root == null) &#123; // 如果还没有根结点, 则将x设置为根结点 x.parent = null; // 根结点没有父节点 x.red = false; // 根结点必须为黑色 root = x; // 将x设置为根结点 &#125; else &#123; K k = x.key; // k赋值为x的key int h = x.hash; // h赋值为x的hash值 Class&lt;?&gt; kc = null; // 如果当前节点x不是根结点, 则从根节点开始查找属于该节点的位置 for (TreeNode&lt;K,V&gt; p = root;;) &#123; int dir, ph; K pk = p.key; if ((ph = p.hash) &gt; h) // 如果x节点的hash值小于p节点的hash值 dir = -1; // 则将dir赋值为-1, 代表向p的左边查找 else if (ph &lt; h) // 与上面相反, 如果x节点的hash值大于p节点的hash值 dir = 1; // 则将dir赋值为1, 代表向p的右边查找 // 走到这代表x的hash值和p的hash值相等，则比较key值 else if ((kc == null &amp;&amp; // 如果k没有实现Comparable接口 或者 x节点的key和p节点的key相等 (kc = comparableClassFor(k)) == null) || (dir = compareComparables(kc, k, pk)) == 0) // 使用定义的一套规则来比较x节点和p节点的大小，用来决定向左还是向右查找 dir = tieBreakOrder(k, pk); TreeNode&lt;K,V&gt; xp = p; // xp赋值为x的父节点,中间变量用于下面给x的父节点赋值 // dir&lt;=0则向p左边查找,否则向p右边查找,如果为null,则代表该位置即为x的目标位置 if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123; x.parent = xp; // x的父节点即为最后一次遍历的p节点 if (dir &lt;= 0) // 如果时dir &lt;= 0, 则代表x节点为父节点的左节点 xp.left = x; else // 如果时dir &gt; 0, 则代表x节点为父节点的右节点 xp.right = x; // 进行红黑树的插入平衡(通过左旋、右旋和改变节点颜色来保证当前树符合红黑树的要求) root = balanceInsertion(root, x); break; &#125; &#125; &#125; &#125; moveRootToFront(tab, root); // 如果root节点不在table索引位置的头结点, 则将其调整为头结点&#125; balanceInsertion()使红黑树达到平衡。要平衡红黑树，就要进行左旋或右旋。 HashMap中的balanceInsertion()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceInsertion(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x) &#123; x.red = true; for (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123; if ((xp = x.parent) == null) &#123; x.red = false; return x; &#125; else if (!xp.red || (xpp = xp.parent) == null) return root; if (xp == (xppl = xpp.left)) &#123; if ((xppr = xpp.right) != null &amp;&amp; xppr.red) &#123; xppr.red = false; xp.red = false; xpp.red = true; x = xpp; &#125; else &#123; if (x == xp.right) &#123; root = rotateLeft(root, x = xp);//对红黑树进行左旋 xpp = (xp = x.parent) == null ? null : xp.parent; &#125; if (xp != null) &#123; xp.red = false; if (xpp != null) &#123; xpp.red = true; root = rotateRight(root, xpp);//对红黑树进行右旋 &#125; &#125; &#125; &#125; else &#123; if (xppl != null &amp;&amp; xppl.red) &#123; xppl.red = false; xp.red = false; xpp.red = true; x = xpp; &#125; else &#123; if (x == xp.left) &#123; root = rotateRight(root, x = xp);//对红黑树进行右旋 xpp = (xp = x.parent) == null ? null : xp.parent; &#125; if (xp != null) &#123; xp.red = false; if (xpp != null) &#123; xpp.red = true; root = rotateLeft(root, xpp);//对红黑树进行左旋 &#125; &#125; &#125; &#125; &#125;&#125; 总结HashMap的存储结构数组+链表+红黑树 HashMap扩容扩容过程:","categories":[{"name":"Java","slug":"Java","permalink":"https://tylerLiu.top/categories/Java/"},{"name":"源码","slug":"Java/源码","permalink":"https://tylerLiu.top/categories/Java/源码/"}],"tags":[{"name":"源码","slug":"源码","permalink":"https://tylerLiu.top/tags/源码/"}]},{"title":"Android-RecyclerView的缓存机制","slug":"Android-RecyclerView的缓存机制","date":"2020-05-15T01:43:45.000Z","updated":"2020-05-16T05:54:24.150Z","comments":true,"path":"2020/05/15/Android-RecyclerView的缓存机制/","link":"","permalink":"https://tylerLiu.top/2020/05/15/Android-RecyclerView的缓存机制/","excerpt":"","text":"使用ScrollView时，它的所有子View会一次性加载出来。RecyclerView可以做到按需加载、按需绑定，并实现复用。这里主要分析RecyclerView缓存复用的原理。 从缓存获取ViewHolder流程概览 说明： 在创建ViewHolder之前，RecyclerView会先从缓存中尝试获取是否有符合要求的ViewHolder，详见RecyclerView#tryGetViewHolderForPositionByDeadline方法。 第一次，尝试从mChangedScrap中获取。 只有在mState.isPreLayout()为true时，也就是预布局阶段，才做这次尝试。 第二次，getScrapOrHiddenOrCachedHolderForPosition()获得ViewHolder。 尝试从mAttachedScrap、mHiddenViews或mCachedViews中查找ViewHolder。 其中mAttachedScrap和mCachedViews都是Recycler的成员变量。 如果成功获得ViewHolder则检验其有效性， 若检验失败则将其收回到RecyclerViewPool中 检验成功，则可以正常使用 第三次，如果给Adapter设置了stableld，调用getScrappOrCachedViewForld尝试获取ViewHolder。 和第二次的区别在于，之前是根据position查找，现在是根据id查找 第四次，mViewCahceExtension不为空的话，则调用ViewCacheExtension#getViewForPositionAndType方法尝试获取View。 注，ViewCacheExtension是由开发者设置的，默认情况下为空，一般不会设置。这层缓存大部分情况下可以忽略。 第五次，尝试从RecyclerViewPool中获取，相较于mCacheViews，从RecyclerViewPool中成功获取ViewHolder对象后并没有做合法性和item的位置校验，只检验viewtype是否一致。 从RecyclerViewPool中取出来的ViewHodler需要重新执行bind才能使用。 如果上面的五次尝试都失败了，就调用RecyclerView.Adapter#createViewHolder新建一个ViewHolder。 最后根据ViewHodler的状态，确定是否需要调用bindViewHolder进行数据绑定。 问题预布局、预测动画是什么？理解“预布局”就需要理解“预测动画”。例如： 用户有A、B、C三个item，A、B正好显示在屏幕中，这时，用户把B删除了，最终C会显示在原先B的位置。 如果C从底部平滑地滑动到B的位置会更加合适，但是要想实现，并不简单。因为知道C的最终位置，但是不知道C的起始位置，就无法确定C应该从哪里滑动过来。有可能是底部，也可能是侧边。 根据原状态和最终状态之间的差异，是无法得出应该执行怎样的动画的。 设计RecyclerView的工程师是这样解决的。当Adapter发生变化时，RecyclerView会让LayoutManager进行两次布局。 第一次是预布局，将之前原状态下的item都布局出来。并且根据Adapter的notify信息，知道哪些item即将变化，所以可以加载出另外的View。上述例子中，因为知道B已经被删除，所以可以把屏幕之外的C也加载进来。 第二，最终的布局。 这样只要比较前后布局的变化，就能得出应该执行什么动画了。 这种负责执行动画的View在原布局或新布局中不存在的动画，就是预测动画。 预布局是实现预测动画的一个步骤。 下面两个动图展示了普通动画和预测动画的区别。 普通动画： 预测动画： 关于预测动画，可以阅读文章。 关于ScrapScrap，缓存列表（mChangedScrap、mAttachedScrap）是RecyclerView最先查找ViewHolder的地方，它跟RecyclerViewPool或者ViewCache有很大的区别。 mChangedScrap和mAttchedScrap只在布局阶段使用。其他时候它们为空。布局完成之后，这两个缓存中的ViewHolder，会移到mCacheView和RecyclerViewPool中。 当LayoutManage开始布局的时候（预布局或者是最终布局），当前布局中的所有view，都会被dump到scrap中（具体可见LinearLayoutManage#onLayoutChildren中调用的了detachAndScrap），然后LayoutManager挨个取回view，除非view发生了什么变化，否则它会马上从scrap中回到原来的位置。 以上图为例，删除B，调用notifyItemRemove()方法，触发重新布局，这时，A、B、C都会被dump到scrap中，然后LayoutManager会从scrap中取回A和C。 此时，B去哪里了？RecyclerView看到B没有出现在最终布局中，会unscrap它，让他它执行一个消失的动画，然后隐藏。动画执行结束后，B会放到RecyclerViewPool中。 为什么LayoutManager需要先执行detach，然后再重新attach这些view，而不是只移除那些变化的子view呢？Scrap缓存列表的存在，是为了隔离LayoutManager和RecyclerView.Recycler之间的关注点/职责。LayoutManager不需要知道哪些子view需要保留或者被回收到RecyclerViewPool或者其他地方。这是Recycler的职责。 除了在布局时不为空之外，还有另外一个与scrap有关的规律：所有scrap的view都会跟RecyclerView分离。ViewGroup中的attachView和detachView方法跟addView和removeView很像，但是不会触发请求布局重绘的事件。它们只是从ViewGroup的子view列表中删除对应的子view。，并将该子view的parent设置为null。detached状态必须是临时的，后面紧随着attach或remove事件。 如果在计算一个新布局的时候，已经添加了一堆子view，可以放心的将它们detach，RecyclerView也是这么做的。 Attached VS Changed scrapRecycler中，可以看到两个单独的scrap容器：mAttachedScrap和mChangedScrap。为什么需要两个呢？ ViewHolder只有在满足下面情况才会被添加到mChangedScrap：当它关联的item发生变化（notifyItemChanged或notifyItemRangeChanged被调用），并且ItemAnimator调用ViewHolder#canReuseUpdatedViewHolder方法时，返回false。否则，ViewHolder会被添加到AttachScrap中。 canReuseUpdatedViewHolder返回false表示要执行用一个view替换另一个view的动画，true表示动画在内部发生。 mAttachedScrap在整个布局过程中都能使用，但是changed scrap只能在预布局阶段使用。 原因：在布局后，新的ViewHolder应该替换调“改变了的”视图，因此AttachedScrap在布局后是没有用的。更改动画执行完成后，changed scrop将按照预期方式转存到pool中。 默认的ItemAnimator可以在3种情况下重用更新的ViewHolder： 调用setSupportsChangeAnimation(false) 调用notifyDataSetChanged()而不是notifyItemChanged()或notifyItemRangeChanged() 提供这样的更改playload: adapter.notifyItemChanged(index, anyObject) 最后一种显示了一种很好的方法，当只想更改一些内部元素时，可以避免创建/绑定新的ViewHolder。 Hidden View 是什么？前面说的第二次尝试获取ViewHodler时，有一个子步骤会从hidden view中搜索。hidden view指的是那些正在从RecyclerView边界中脱离的view。为了让这些view正确的执行对应的分离动画，它们仍然作为RecyclerView的子view被保留下来。 站在LayoutManager的角度，这些view已经不存在了，因此不应该被包含在计算里面。比如在部分view正在执行消失动画过程中，调用LayoutManager#getChildAt方法，这些view不算在下标里面。来自LayoutManager的所有对getChild()、getChildCount()、addView()等的方法调用在应用到实际的可回收view之前，都要通过ChildHelper处理，ChildHelper的职责是重新计算非隐藏的子view列表和完整的子view列表之间的索引。 注意，正在搜索要提供给LayoutManager的视图，但是LayoutManager不应了解隐藏View。 举一个实际的例子：这种“从隐藏的view弹跳”（bounching from hidden views）机制对于处理下面这种情况很有必要。现在要插入一个item，然后在插入动画完成之前，马上删除该item： 想要看到B从C移除的位置开始向上平移。但是在那个时候，B是一个隐藏的view。如果忽略它（”隐藏“的B），那么会导致在现有B下面创建一个新的B。更糟糕的是，这两个view会重叠，因为新的B会往上，旧的B会往下。为了避免这种错误，在搜索ViewHolder的较早步骤中，RecyclerView会询问ChildHelper是否具有合适的hidden view。所谓”合适“，表示这个view和需要的位置相关联，并具有正确的view type，并且这个view的被隐藏的原因不是为了移除它。 如果有这样的view，RecyclerView会将其返回到LayoutManger并将其添加到preLayout中以标记应从其进行动画处理的位置（详见recordAnimationInfoIfBouncedHiddenView()方法）。 在布局前后添加内容的不应该是LayoutManager的职责吗？怎么现在RecyclerView也往preLayout中添加view？这有必要了解。 Stable Id的作用？Stable Id只会在调用notifyDataSetChanged()方法之后，影响RecyclerView的行为。 如果调用notifyDataSetChanged()的时候，Adapter并没有设置hasStableId，RecyclerView不知道发生了什么，哪一些东西变化了，所以，它假设所有东西都变了，每一个ViewHolder都是无效的，因此应该把它们放到RecyclerViewPool而不是scrap中。 如果有Stable Id，就会如下： ViewHolder会进入scrap而不是pool中。然后会通过特定的Id（Adapter中的getItemId()获取到的id），而不是position到scrap中查找ViewHodler。 好处： 1、不会导致RecyclerViewPool溢出，因此非必须情况下，不需要创建新的ViewHoler。之前的ViewHolder会重新绑定，因为Id没有变化不代表内容没有变化 2、最大的好处是支持动画。上面移动item4到item6的位置。通常，需要调用notifyItemMoved(4, 6)才能得到一个移动动画。但是通过stable id，调用notifyDataSetChanged()也可以实现。因为RecyclerView可以看到特定id的view在新旧布局的位置。 注意，这里的动画只支持简单的动画，预测动画无法支持。如果在新布局中看到一些id，而旧布局中没有，那么如何知道它是新插入的item还是从某处移入的item，后一种情况item究竟是从哪来的？通常，这些问题的答案在预布局中可以找到，根据适配器的更改，该布局已经超出RecyclerView的范围，但现在这种情况下，不知道聚义更改了什么。 总之，stable id的使用场景比较有限，不过，还是有一个使用场景：如果是从ListView迁移到RecyclerView，将所有notifyDataSetChanged()调用，都转换为特定更改的通知可能会很麻烦，这时，stable id可以提供简单的RecyclerView动画。 缓存优化实践 尽量使用notifyItemXxx方法进行通知更新，而不是notifyDataSetChanged() 如果变更前后是两个数据集，无法确定具体哪一些数据项变化了，可以考虑使用DiffUtil 如果数据集较大，建议结合使用AsyncListDiffer在子线程做diff运算。 如果特定viewType的item只有一个，可以通过RecyclerView#getRecycledViewPool()#setMaxRecycledViews(viewType, 1);来调整缓存区的大小，减少内存占用 如果特定viewType的item特别多，但是不得不通过notifyDataSetChanged()方法更新数据，可以通过下面这种方式，在变更前调大缓存，变更完成后，调小缓存。这样布局变化也可以最大程度地复用已有的ViewHolder。 12345678mRecyclerView.getRecycledViewPool().setMaxRecycledViews(0, 屏幕显示的item总数 + 7);mAdapter.notifyDataSetChanged();new Handler().post(new Runnable() &#123; @Override public void run() &#123; mRecyclerView.getRecycledViewPool().setMaxRecycledViews(0, 5); &#125;&#125;); 如果RecyclerView中每个item都是一个RecycleyView，并且子RecyclerView的item type相同可以通过RecyclerView#setRecycledViewPool()方法，实现缓存池复用。 参考资料RecyclerView caching mechanism ( multiplexing?) RecyclerView缓存原理，有图有真相 RecyclerView缓存机制（咋复用？）","categories":[{"name":"Android","slug":"Android","permalink":"https://tylerLiu.top/categories/Android/"},{"name":"View","slug":"Android/View","permalink":"https://tylerLiu.top/categories/Android/View/"}],"tags":[{"name":"RecyclerView","slug":"RecyclerView","permalink":"https://tylerLiu.top/tags/RecyclerView/"}]},{"title":"Binder原理 04：ServiceManager的启动过程（基于Android 9.0/goldfish3.4）","slug":"Binder原理-04：ServiceManager的启动过程","date":"2019-12-09T01:38:18.000Z","updated":"2019-12-12T08:07:21.141Z","comments":true,"path":"2019/12/09/Binder原理-04：ServiceManager的启动过程/","link":"","permalink":"https://tylerLiu.top/2019/12/09/Binder原理-04：ServiceManager的启动过程/","excerpt":"","text":"前言前面以MediaPlayerService为例，讲解了系统服务是如何注册的（addService()），既然有注册，就会有获取，但是在获取服务之前，需要先了解ServiceManager的启动过程，有助于理解系统服务的注册和获取的过程。另外，想要了解ServiceManager的启动过程，需要查看Kernel Binder部分的源码，这部分源码包含在内核源码中，AOSP不包含内核源码，需要单独下载。 1. ServiceManager的入口函数ServiceManager是init进程负责启动的，具体在解析init.rc配置文件时启动的，init进程是在系统启动时启动的，因此ServiceManager也是。rc文件内部由Android初始化语言（Android Init Language）编写的脚本，主要包含五种类型语句：Action、Commands、Servcies、Options和Import。在Android 7.0中对init.rc文件进行了拆分，每个服务一个rc文件。ServiceManager的启动脚本在servicemanager.rc中：frameworks/native/cmds/servicemanager/servicemanager.rc 1234567891011121314151617service servicemanager /system/bin/servicemanager class core animation user system // 1 group system readproc critical // 2 onrestart restart healthd onrestart restart zygote onrestart restart audioserver onrestart restart media onrestart restart surfaceflinger onrestart restart inputflinger onrestart restart drm onrestart restart cameraserver onrestart restart keystore onrestart restart gatekeeperd writepid /dev/cpuset/system-background/tasks shutdown critical service用于通知init进程创建名为servicemanager的进程，这个servicemanager进程执行程序的路径为/system/bin/servicemanager。注释1，关键字user说明servicemanager是以用户systemdd的身份运行的。注释2，critical说明servicemanager是系统中的关键服务，关键服务是不会退出的，如果退出了，系统就会重启，当系统重启时，就会启动onrestart关键字修饰的进程，比如，zygote、media、surfaceflinger等。servicemanager的入口函数在service_manager.c中：frameworks/native/cmds/servicemanager/service_manager.c 123456789101112131415161718192021222324252627int main(int argc, char** argv)&#123; struct binder_state *bs; // 1 union selinux_callback cb; char *driver; if (argc &gt; 1) &#123; driver = argv[1]; &#125; else &#123; driver = \"/dev/binder\"; &#125; bs = binder_open(driver, 128*1024); // 2 ... if (binder_become_context_manager(bs)) &#123; // 3 ALOGE(\"cannot become context manager (%s)\\n\", strerror(errno)); return -1; &#125; ... if (getcon(&amp;service_manager_context) != 0) &#123; ALOGE(\"SELinux: Failed to acquire service_manager context. Aborting.\\n\"); abort(); &#125; binder_loop(bs, svcmgr_handler); // 4 return 0;&#125; 注释1，binder_state结构体用来存储binder的三个信息： 123456struct binder_state&#123; int fd; // binder设备的文件描述符 void *mapped; // binder设备文件映射到进程的地址空间 size_t mapsize; // 内存映射后，系统分配的地址空间的大小，默认为128KB&#125;; main()函数主要做了三件事： 注释2调用binder设备文件，并申请了128KB字节大小的内存空间。 注释3调用binder_become_context_manager()函数，将servicemanager注册成Binder机制的上下文管理者。 注释4调用binder_loop()函数，循环等待和处理client端发来的请求。 下面详细讲解。 1.1 打开binder设备binder_open()函数用于打开binder设备文件，并将它映射到进程的地址空间，如下。frameworks/native/cmds/servicemanager/binder.c 1234567891011121314151617181920212223242526272829303132333435363738394041struct binder_state *binder_open(const char* driver, size_t mapsize)&#123; struct binder_state *bs; struct binder_version vers; bs = malloc(sizeof(*bs)); if (!bs) &#123; errno = ENOMEM; return NULL; &#125; bs-&gt;fd = open(driver, O_RDWR | O_CLOEXEC); // 1 if (bs-&gt;fd &lt; 0) &#123; fprintf(stderr,\"binder: cannot open %s (%s)\\n\", driver, strerror(errno)); goto fail_open; &#125; //获取Binder的version if ((ioctl(bs-&gt;fd, BINDER_VERSION, &amp;vers) == -1) || (vers.protocol_version != BINDER_CURRENT_PROTOCOL_VERSION)) &#123; // 2 fprintf(stderr, \"binder: kernel driver version (%d) differs from user space version (%d)\\n\", vers.protocol_version, BINDER_CURRENT_PROTOCOL_VERSION); goto fail_open; &#125; bs-&gt;mapsize = mapsize; bs-&gt;mapped = mmap(NULL, mapsize, PROT_READ, MAP_PRIVATE, bs-&gt;fd, 0); // 3 if (bs-&gt;mapped == MAP_FAILED) &#123; fprintf(stderr,\"binder: cannot map device (%s)\\n\", strerror(errno)); goto fail_map; &#125; return bs;fail_map: close(bs-&gt;fd);fail_open: free(bs); return NULL;&#125; 注释1，打开binder设备文件，后面会进行分析。注释2，ioct()函数用于获取Binder的版本，如果获取不到或者内核空间和用户空间的binder不是同一个版本，就会直接goto到fail_open标签，释放binder的内存空间。注释3，调用mmap()函数进行内存映射，通俗来讲就是将binder设备文件映射到进程的地址空间，地址空间的大小为mapsize，即128K。映射完毕后会将地址空间的起始地址和大小保存在binder_state结构体中的mmaped和mapsize变量中。 这里说明一下open()函数，它会调用Kernel Binder部分的binder_open()函数，这部分的源码在内核源码中，这里展示的代码版本为goldfish 3.4。 用户态和内核态Intel的X86架构的CPU提供了0~3四个特权级别，数字越小，权限越高，Linux系统主要采用了0和3两个特权级别，分别对应内核态和用户态。用户态的特权级别低，因此进程在用户态下不经过系统调用是无法主动访问到内核空间中的数据的，这样用户无法随意进入所有进程共享的内核空间，起到保护作用。当一个进程在执行用户自己的代码时处于用户态，比如open()函数，它运行在用户空间，当前的进程处于用户态。当一个进程因为系统调用进入内核代码中执行时，就处于内核态，比如open()函数通过系统调用（_open()函数），查找到了open()函数在Kernel Binder对应的函数为binder_open()，这是binder_open()运行在内核空间，当前的进程由用户态切换到内核态。kernel/goldfish/drivers/staging/android/binder.c 123456789101112131415161718192021222324252627static int binder_open(struct inode *nodp, struct file *filp)&#123; // 代表Binder进程 struct binder_proc *proc; // 1 binder_debug(BINDER_DEBUG_OPEN_CLOSE, \"binder_open: %d:%d\\n\", current-&gt;group_leader-&gt;pid, current-&gt;pid); // 分配内存空间 proc = kzalloc(sizeof(*proc), GFP_KERNEL); // 2 if (proc == NULL) return -ENOMEM; get_task_struct(current); proc-&gt;tsk = current; INIT_LIST_HEAD(&amp;proc-&gt;todo); init_waitqueue_head(&amp;proc-&gt;wait); proc-&gt;default_priority = task_nice(current); // binder同步锁 binder_lock(__func__); binder_stats_created(BINDER_STAT_PROC); hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs); proc-&gt;pid = current-&gt;group_leader-&gt;pid; INIT_LIST_HEAD(&amp;proc-&gt;delivered_death); filp-&gt;private_data = proc; // 3 // binder同步锁释放 binder_unlock(__func__); ...... return 0;&#125; 注释1，binder_proc结构体代表binder进程，用于管理binder的各种信息。注释2，用于为binder_proc分配内存空间。注释3，将binder_proc赋值给file指针的private_data变量，下一小节会再次提到变量private_data。 1.2 注册称为Binder机制的上下文管理者binder_become_context_manager()函数用于将servicemanager注册成为Binder机制的上下文管理者，这个管理者在整个系统只有一个，代码如下。frameworks/native/cmds/servicemanager/binder.c 1234int binder_become_context_manager(struct binder_state *bs)&#123; return ioctl(bs-&gt;fd, BINDER_SET_CONTEXT_MGR, 0);&#125;","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://tylerLiu.top/categories/Android进阶/"},{"name":"框架层","slug":"Android进阶/框架层","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/"},{"name":"Binder原理","slug":"Android进阶/框架层/Binder原理","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/Binder原理/"}],"tags":[{"name":"Binder","slug":"Binder","permalink":"https://tylerLiu.top/tags/Binder/"}]},{"title":"Binder原理 03：系统服务的注册过程（基于Android 9.0）","slug":"Binder原理-03：系统服务的注册过程","date":"2019-11-15T07:39:27.000Z","updated":"2019-12-09T01:36:56.321Z","comments":true,"path":"2019/11/15/Binder原理-03：系统服务的注册过程/","link":"","permalink":"https://tylerLiu.top/2019/11/15/Binder原理-03：系统服务的注册过程/","excerpt":"","text":"前言前面学习了ServiceManager中的Binder机制，但是并没有看到MediaPlayerService是如何注册的。下面通过了解MediaPlayerService的注册，看看系统服务的注册过程。 1. 从调用链角度说明MediaPlayerService是如何注册的MediaServer的入口函数。frameworks/av/media/mediaserver/main_mediaserver.cpp 1234567891011121314151617int main(int argc __unused, char **argv __unused)&#123; signal(SIGPIPE, SIG_IGN); // 获取ProcessState实例 sp&lt;ProcessState&gt; proc(ProcessState::self()); sp&lt;IServiceManager&gt; sm(defaultServiceManager()); ALOGI(\"ServiceManager: %p\", sm.get()); InitializeIcuOrDie(); // 注册MediaPlayerService MediaPlayerService::instantiate(); // 1 ResourceManagerService::instantiate(); registerExtensions(); // 启动Binder线程池 ProcessState::self()-&gt;startThreadPool(); // 当前线程加入到线程池 IPCThreadState::self()-&gt;joinThreadPool();&#125; 在注释1处注册了MediaPlayerService。frameworks/av/media/libmediaplayerservice/MediaPlayerService.cpp 1234void MediaPlayerService::instantiate() &#123; defaultServiceManager()-&gt;addService( String16(\"media.player\"), new MediaPlayerService，());&#125; defaultServiceManager()返回的是BpServiceManager。参数是字符串和MediaPlayerService，就像key/value的形式来完成注册，接着看addService()。frameworks/native/libs/binder/IServiceManager.cpp 1234567891011virtual status_t addService(const String16&amp; name, const sp&lt;IBinder&gt;&amp; service, bool allowIsolated, int dumpsysPriority) &#123; Parcel data, reply; // 数据包 data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor()); data.writeString16(name); // name值为\"media.player\" data.writeStrongBinder(service); // service值为MediaPlayerService data.writeInt32(allowIsolated ? 1 : 0); data.writeInt32(dumpsysPriority); status_t err = remote()-&gt;transact(ADD_SERVICE_TRANSACTION, data, &amp;reply); // 1 return err == NO_ERROR ? reply.readExceptionCode() : err;&#125; data是一个数据包，后面会不断的将数据写入data中。注释1，remote()指的是mRemote，也就是BpBinder。addService()函数的作用就是将请求数据打包成data，然后传给BpBinder的transact()函数。frameworks/native/libs/binder/BpBinder.cpp 1234567891011status_t BpBinder::transact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)&#123; if (mAlive) &#123; status_t status = IPCThreadState::self()-&gt;transact( mHandle, code, data, reply, flags); if (status == DEAD_OBJECT) mAlive = 0; return status; &#125; return DEAD_OBJECT;&#125; BpBinder将逻辑处理交给了IPCThreadState，先来看看IPCThreadState::self()。frameworks/native/libs/binder/IPCThreadState.cpp 1234567891011121314IPCThreadState* IPCThreadState::self()&#123; // 首次进来gHaveTLS的值为false if (gHaveTLS) &#123;restart: const pthread_key_t k = gTLS; // 1 IPCThreadState* st = (IPCThreadState*)pthread_getspecific(k); // 2 if (st) return st; return new IPCThreadState; // 3 &#125; ... pthread_mutex_unlock(&amp;gTLSMutex); goto restart;&#125; 注释1，TLS的全称为Thread local storge，线程本地存储空间，在每个线程中都有TLS，并且线程间不共享。注释2，获取TLS中的内容并赋值给IPCThreadState指针。注释3，新建一个IPCThreadState，这里可以得知IPCThreadState::self()实际上是为了创建IPCThreadState，它的构造函数如下。frameworks/native/libs/binder/IPCThreadState.cpp 12345678910IPCThreadState::IPCThreadState() : mProcess(ProcessState::self()), mStrictModePolicy(0), mLastTransactionBinderFlags(0)&#123; pthread_setspecific(gTLS, this); // 1 clearCaller(); mIn.setDataCapacity(256); mOut.setDataCapacity(256);&#125; 注释1，pthread_setspecific()函数用于设置TLS，将IPCThreadState::self()获得的TLS和自身传进去。IPCThreadState还包含一个mIn和一个mOut，mIn用来接收来自Binder驱动的数据，mOut用来存储发往Binder驱动的数据，默认大小都是256字节。再来看看IPCThreadState的transact()函数。frameworks/native/libs/binder/IPCThreadState.cpp 123456789101112131415161718192021222324252627status_t IPCThreadState::transact(int32_t handle, uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)&#123; status_t err; flags |= TF_ACCEPT_FDS; ...... err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL); // 1 if (err != NO_ERROR) &#123; if (reply) reply-&gt;setError(err); return (mLastError = err); &#125; if ((flags &amp; TF_ONE_WAY) == 0) &#123; ...... if (reply) &#123; err = waitForResponse(reply); // 2 &#125; else &#123; Parcel fakeReply; err = waitForResponse(&amp;fakeReply); &#125; ... &#125; else &#123; // 不需要等待reply的分支 err = waitForResponse(NULL, NULL); &#125; return err;&#125; 调用BpBinder的transact()函数实际上就是调用IPCThreadState的transact()函数。注释1，writeTransactionData()函数用于传输数据，其中第一个参数BC_TRANSACTION代表向Binder驱动发送命令协议，向Binder设备发送的命令协议都以BC_开头，而Binder驱动返回的命令都以BR_开头。现在来分别分析注释1的writeTransactionData()和注释2的waitForResponse()函数。 1.1 writeTransactionData()frameworks/native/libs/binder/IPCThreadState.cpp 1234567891011121314151617181920212223242526272829303132333435status_t IPCThreadState::writeTransactionData(int32_t cmd, uint32_t binderFlags, int32_t handle, uint32_t code, const Parcel&amp; data, status_t* statusBuffer)&#123; binder_transaction_data tr; // 1 tr.target.ptr = 0; tr.target.handle = handle; // 2 tr.code = code; // code=ADD_SERVICE_TRANSACTION tr.flags = binderFlags; tr.cookie = 0; tr.sender_pid = 0; tr.sender_euid = 0; const status_t err = data.errorCheck(); // 3 if (err == NO_ERROR) &#123; tr.data_size = data.ipcDataSize(); tr.data.ptr.buffer = data.ipcData(); tr.offsets_size = data.ipcObjectsCount()*sizeof(binder_size_t); tr.data.ptr.offsets = data.ipcObjects(); &#125; else if (statusBuffer) &#123; tr.flags |= TF_STATUS_CODE; *statusBuffer = err; tr.data_size = sizeof(status_t); tr.data.ptr.buffer = reinterpret_cast&lt;uintptr_t&gt;(statusBuffer); tr.offsets_size = 0; tr.data.ptr.offsets = 0; &#125; else &#123; return (mLastError = err); &#125; mOut.writeInt32(cmd); // cmd=BC_TRANSACTION mOut.write(&amp;tr, sizeof(tr)); return NO_ERROR;&#125; 注释1，binder_transaction_data结构体（tr结构体）是向Binder驱动通信的数据结构。注释2，将handle传递给target的handle，用于标识目标，这里的handle的值为0，代表了ServiceManager。注释3，对数据data进行错误检查，如果没有错误，就将数据赋值给对应的tr结构体。最后会将BC_TRANSACTION和tr结构体写入到mOut中。 1.2 waitForResponse函数分析waitForResponse()中有很多case语句，这里截取部分。frameworks/native/libs/binder/IPCThreadState.cpp 123456789101112131415161718192021222324252627282930313233status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)&#123; uint32_t cmd; int32_t err; while (1) &#123; if ((err=talkWithDriver()) &lt; NO_ERROR) break; // 1 err = mIn.errorCheck(); if (err &lt; NO_ERROR) break; if (mIn.dataAvail() == 0) continue; cmd = (uint32_t)mIn.readInt32(); IF_LOG_COMMANDS() &#123; alog &lt;&lt; \"Processing waitForResponse Command: \" &lt;&lt; getReturnString(cmd) &lt;&lt; endl; &#125; switch (cmd) &#123; case BR_TRANSACTION_COMPLETE: if (!reply &amp;&amp; !acquireResult) goto finish; break; case BR_DEAD_REPLY: err = DEAD_OBJECT; goto finish; ...... default: // 处理各种命令协议 err = executeCommand(cmd); if (err != NO_ERROR) goto finish; break; &#125;&#125;finish: ...... return err;&#125; 注释1，talkWithDriver()内部通过ioctl与Binder驱动进行通信。frameworks/native/libs/binder/IPCThreadState.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142status_t IPCThreadState::talkWithDriver(bool doReceive)&#123; if (mProcess-&gt;mDriverFD &lt;= 0) &#123; return -EBADF; &#125; // 和Binder驱动通信的结构体 binder_write_read bwr; // 1 // mIn是否有可读的数据，接收的数据存储在mIn const bool needRead = mIn.dataPosition() &gt;= mIn.dataSize(); const size_t outAvail = (!doReceive || needRead) ? mOut.dataSize() : 0; bwr.write_size = outAvail; bwr.write_buffer = (uintptr_t)mOut.data(); // 2 // 这时doReceive的值为true if (doReceive &amp;&amp; needRead) &#123; bwr.read_size = mIn.dataCapacity(); bwr.read_buffer = (uintptr_t)mIn.data(); // 3 &#125; else &#123; bwr.read_size = 0; bwr.read_buffer = 0; &#125; ...... if ((bwr.write_size == 0) &amp;&amp; (bwr.read_size == 0)) return NO_ERROR; bwr.write_consumed = 0; bwr.read_consumed = 0; status_t err; do &#123; IF_LOG_COMMANDS() &#123; alog &lt;&lt; \"About to read/write, write size = \" &lt;&lt; mOut.dataSize() &lt;&lt; endl; &#125; #if defined(__ANDROID__) if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0) // 4 err = NO_ERROR; else err = -errno; #else err = INVALID_OPERATION; #endif ...... &#125; while (err == -EINTR); ...... return err;&#125; 注释1，binder_write_read是与Binder驱动通信的结构体，在注释2和3处将mOut、mIn赋值给binder_write_read的相应字段，最终通过注释4的ioctl()函数和Binder驱动进行通信，这部分涉及Kernel Binder的内容，在Kernel Binder中会记录服务名和handle，用于后续的服务查询。 1.3 小结从调用链的角度来看，MediaPlayerService注册并不复杂，这里只是简单介绍了一个调用链的分支，可以简单总结为以下步骤： addService()函数将数据打包发送给BpBinder来进行处理。 BpBinder新建一个IPCThreadState对象，并将通信的任务交给IPCThreadState。 IPCThreadState的writeTransactionData()函数用于将命令协议和数据写入到mOut中。 IPCThreadState的waitForResponse()函数主要做两件事，一是通过ioctl()函数操作mOut和mIn来与Binder驱动进行数据交互，二是处理各种命令协议。 2. 从进程角度说明MediaPlayerService是如何注册的 从图中可以看出是以C/S架构为基础的，addService()是在MediaPlayerService进行的，它是Client端，用于请求添加系统服务。而Server端则指的是ServiceManager，用于完成系统服务的添加。Client端和Server端分别运行在两个进程中，通过Binder驱动来进行通信。两端通过向Binder驱动发送命令协议来完成系统服务的添加。其中命令协议非常多，过程比较复杂，这里对命令协议进行了简化，只涉及四个命令协议，其中BC_TRANSACTION和BR_TRANSACTION过程是一个完整的事务，BC_REPLAY和BR_REPLAY过程是一个完整的事务。Client端和Server端向Binder驱动发送命令协议以BC开头，而Binder驱动向Client端和Server端返回的命令协议以BR开头。步骤如下： Client端向Binder驱动发送BC_TRANSACTION命令。 Binder驱动接收请求后生成BR_TRANSACTION命令，唤醒Server端的线程后将BR_TRANSACTION命令发送给ServiceManager。 Server端中的服务注册完成后，生成BC_REPLAY命令发动给Binder驱动。 Binder驱动生成BR_REPLAY命令，唤醒Client端的线程后将BR_REPLAY命令发送给Client端。 通过这些协议命令来完成系统服务的注册。","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://tylerLiu.top/categories/Android进阶/"},{"name":"框架层","slug":"Android进阶/框架层","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/"},{"name":"Binder原理","slug":"Android进阶/框架层/Binder原理","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/Binder原理/"}],"tags":[{"name":"Binder","slug":"Binder","permalink":"https://tylerLiu.top/tags/Binder/"}]},{"title":"Binder原理 02：ServiceManager中的Binder机制（基于Android 9.0）","slug":"Binder原理-02：ServiceManager中的Binder机制","date":"2019-11-12T07:41:04.000Z","updated":"2019-11-15T07:38:11.546Z","comments":true,"path":"2019/11/12/Binder原理-02：ServiceManager中的Binder机制/","link":"","permalink":"https://tylerLiu.top/2019/11/12/Binder原理-02：ServiceManager中的Binder机制/","excerpt":"","text":"前言前面说到Binder机制分成三个部分：Java Binder、Native Binder、Kernel Binder，其中Java Binder和Native Binder都是应用开发需要掌握的的。Java Binder是需要借助Native Binder来工作的，因此需要先了解Native Binder，Native Binder架构的原型就是基于Binder通信的C/S架构。 1. 基于Binder通信的C/S架构在Android系统中，Binder进程间的通信的使用很普遍，在MadiaPlayer框架中，就是基于C/S架构，并采用了Binder来进行进程间通信的。 从上图可以看出，除了常规C/S架构的Client端和Server端，还包括了ServiceManager，用于管理系统中的服务。首先，Server进程会注册一些Service到ServiceManager中，Client要使用某个Service，则需要先到ServiceManager查询Service的相关信息，然后根据Service的相关信息与Service所在的Server进程建立通信通路，这样Client就可以使用Service了。 2. MediaServer的main函数Client、Server、ServiceManager三者的交互都是基于Binder通信的，可以说Native Binder的原理的核心就是ServiceManager的原理，为了更好了解ServiceManager，这里拿MediaPlayer框架为例。 可以看到，MediaPlayer和MediaPlayerService是通过Binder通信的，MediaPlayer是Client端，MediaPlayerService是Server端，MediaPlayerService是系统多媒体服务的一种，系统多媒体服务是由一个叫MediaServer的服务进程提供的，它是一个可执行程序，在Android系统启动时，MediaServer也被启动，它的函数入口如下。frameworks/av/media/mediaserver/main_mediaserver.cpp 12345678910111213141516int main(int argc __unused, char **argv __unused)&#123; signal(SIGPIPE, SIG_IGN); // 获取ProcessState实例 sp&lt;ProcessState&gt; proc(ProcessState::self()); // 1 sp&lt;IServiceManager&gt; sm(defaultServiceManager()); // 2 ALOGI(\"ServiceManager: %p\", sm.get()); InitializeIcuOrDie(); // 注册MediaPlayerService MediaPlayerService::instantiate(); // 3 ResourceManagerService::instantiate(); registerExtensions(); // 启动Binder线程池 ProcessState::self()-&gt;startThreadPool(); // 当前线程加入到线程池 IPCThreadState::self()-&gt;joinThreadPool();&#125; 注释1，用于获取ProcessState实例，在这一过程中会打开/dev/binder设备，并使用mmap为Binder驱动分配一个虚拟地址空间来接收数据。注释2，获取一个IServiceManager，通过这个IServiceManager，其他进程就可以和当前的ServiceManager进行交互，这里就用到Binder通信。注释3，注册MediaPlayerService。 3. 每个进程唯一的ProcessStateProcessState用于表示进程的状态，先从ProcessState的self()函数开始。frameworks/native/libs/binder/ProcessState.cpp 12345678sp&lt;ProcessState&gt; ProcessState::self()&#123; Mutex::Autolock _l(gProcessMutex); if (gProcess != NULL) &#123; return gProcess; &#125; gProcess = new ProcessState(\"/dev/binder\"); // 1 return gProcess;&#125; 采用了单例模式，确保每个进程只有一个ProcessState。注释1，创建一个ProcessState实例，参数为&quot;/dev/Binder&quot;。接着查看ProcessState的构造函数。frameworks/native/libs/binder/ProcessState.cpp 1234567891011121314151617181920212223242526ProcessState::ProcessState(const char *driver) : mDriverName(String8(driver)) , mDriverFD(open_driver(driver)) // 1 , mVMStart(MAP_FAILED) , mThreadCountLock(PTHREAD_MUTEX_INITIALIZER) , mThreadCountDecrement(PTHREAD_COND_INITIALIZER) , mExecutingThreadsCount(0) , mMaxThreads(DEFAULT_MAX_BINDER_THREADS) , mStarvationStartTimeMs(0) , mManagesContexts(false) , mBinderContextCheckFunc(NULL) , mBinderContextUserData(NULL) , mThreadPoolStarted(false) , mThreadPoolSeq(1)&#123; if (mDriverFD &gt;= 0) &#123; mVMStart = mmap(0, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, 0); // 2 if (mVMStart == MAP_FAILED) &#123; // *sigh* ALOGE(\"Using %s failed: unable to mmap transaction memory.\\n\", mDriverName.c_str()); close(mDriverFD); mDriverFD = -1; mDriverName.clear(); &#125; &#125; LOG_ALWAYS_FATAL_IF(mDriverFD &lt; 0, \"Binder driver could not be opened. Terminating.\");&#125; 注释1，打开/dev/Binder设备。注释2，mmap()函数会在内核虚拟地址空间中申请一块与用户虚拟内存相同大小的内存，然后再申请物理内存，将同一块物理内存分别映射到内核虚拟地址空间和用户虚拟内存空间，实现内核虚拟地址空间和用户虚拟内存空间的数据同步操作，即内存映射。mmap()函数用于对Binder设备进行内存映射，除了它还有open()、ioct()函数，下面来看看它们实现了什么。open_driver()。frameworks/native/libs/binder/ProcessState.cpp 1234567891011121314static int open_driver(const char *driver)&#123; int fd = open(driver, O_RDWR | O_CLOEXEC); // 1 if (fd &gt;= 0) &#123; ... size_t maxThreads = DEFAULT_MAX_BINDER_THREADS; result = ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads); // 2 if (result == -1) &#123; ALOGE(\"Binder ioctl to set max threads failed: %s\", strerror(errno)); &#125; &#125; else &#123; ALOGW(\"Opening '%s' failed: %s\\n\", driver, strerror(errno)); &#125; return fd;&#125; 注释1，打开/dev/Binder设备并返回文件操作符fd，这样就可以操作内核的Binder驱动了。注释2，ioct()函数的作用就是和Binder设备进行参数的传递，这里的ioct()函数用于设定binder支持的最大线程数为15（maxThreads的值为15）。最终open_driver()函数返回文件操作符fd。 ProcessState主要做了两件事： 打开/dev/Binder设备并设定Binder最大的支持线程数。 通过mmap()为binder分配一块虚拟地址空间，达到内存映射的目的。 4. ServiceManager中的Binder机制回到MediaServer的入口函数，在注释2调用了defaultServiceManager()函数。frameworks/native/libs/binder/IServiceManager.cpp 123456789101112131415sp&lt;IServiceManager&gt; defaultServiceManager()&#123; if (gDefaultServiceManager != NULL) return gDefaultServiceManager; &#123; AutoMutex _l(gDefaultServiceManagerLock); while (gDefaultServiceManager == NULL) &#123; gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;( ProcessState::self()-&gt;getContextObject(NULL)); // 1 if (gDefaultServiceManager == NULL) sleep(1); &#125; &#125; return gDefaultServiceManager;&#125; 从IServiceManager所在文件路径就可以知道，ServiceManager中不仅仅使用了Binder通信，它自身也属于Binder体系。defaultServiceManager()中同样使用了单例。注释1，interface_cast()函数生成了gDefaultServiceManager，其内部调用了ProcessState的getContextObject()函数。frameworks/native/libs/binder/ProcessState.cpp 12345678910111213141516171819202122232425262728293031sp&lt;IBinder&gt; ProcessState::getContextObject(const sp&lt;IBinder&gt;&amp; /*caller*/)&#123; return getStrongProxyForHandle(0);&#125;sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(int32_t handle)&#123; sp&lt;IBinder&gt; result; AutoMutex _l(mLock); handle_entry* e = lookupHandleLocked(handle); // 1 if (e != NULL) &#123; IBinder* b = e-&gt;binder; if (b == NULL || !e-&gt;refs-&gt;attemptIncWeak(this)) &#123; if (handle == 0) &#123; Parcel data; status_t status = IPCThreadState::self()-&gt;transact( 0, IBinder::PING_TRANSACTION, data, NULL, 0); if (status == DEAD_OBJECT) return NULL; &#125; b = BpBinder::create(handle); // 2 e-&gt;binder = b; if (b) e-&gt;refs = b-&gt;getWeakRefs(); result = b; &#125; else &#123; result.force_set(b); e-&gt;refs-&gt;decWeak(this); &#125; &#125; return result;&#125; getContextObject()函数中直接调用了getStrongProxyForHandle()函数，传入的参数的值为0，即handle的值就是0，handle是一个资源标识。注释1，查询这个资源标识对应的资源handle_entry是否存在，如果不存在就会在注释2处新建BpBinder，并在注释3赋值给handle_entry的binder。最终返回的result的值为BpBinder。 4.1 BpBinder和BBinder它们都继承了IBinder。BpBinder是Client端与Server交互的代理类，BBinder代表了Server端。BpBinder和BBinder是一一对应的，BpBinder会通过handle来找到对应的BpBinder。在ServiceManager中创建BpBinder，通过handle（值为0）可以找到对应的BBinder。 分析完ProcessState的getContextObject()函数，回到interface_cast()函数。 1gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;(ProcessState::self()-&gt;getContextObject(NULL)); interface_cast()函数的具体实现如下。frameworks/native/libs/binder/include/binder/IInterface.h 12345template&lt;typename INTERFACE&gt;inline sp&lt;INTERFACE&gt; interface_cast(const sp&lt;IBinder&gt;&amp; obj)&#123; return INTERFACE::asInterface(obj);&#125; 当前场景中，INTERFACE的值为IServiceManager，那么替换后代码如下。 1234inline sp&lt;IServiceManager&gt; interface_cast(const sp&lt;IBinder&gt;&amp; obj)&#123; return IServiceManager::asInterface(obj);&#125; 下面来分析IServiceManager。 4.2 IServiceManagerBpBinder和BBinder负责Binder通信，而IServiceManager用于处理ServiceManager的业务，IServiceManager是C++代码，因此它被定义在IServiceManager.h中。frameworks/native/libs/binder/include/binder/IServiceManager.h 12345678910111213141516171819class IServiceManager : public IInterface&#123;public: DECLARE_META_INTERFACE(ServiceManager) // 1 ...... // 一些操作Service的函数 virtual sp&lt;IBinder&gt; getService( const String16&amp; name) const = 0; virtual sp&lt;IBinder&gt; checkService( const String16&amp; name) const = 0; virtual status_t addService(const String16&amp; name, const sp&lt;IBinder&gt;&amp; service, bool allowIsolated = false, int dumpsysFlags = DUMP_FLAG_PRIORITY_DEFAULT) = 0; virtual Vector&lt;String16&gt; listServices(int dumpsysFlags = DUMP_FLAG_PRIORITY_ALL) = 0; enum &#123; GET_SERVICE_TRANSACTION = IBinder::FIRST_CALL_TRANSACTION, CHECK_SERVICE_TRANSACTION, ADD_SERVICE_TRANSACTION, LIST_SERVICES_TRANSACTION, &#125;;&#125;; IServiceManager继承了IInterface，其内部定义了一些常量和一些操作Service的函数，在注释1调用了DECLARE_META_INTERFACE()宏，它的定义在IInterface.h中。frameworks/native/libs/binder/include/binder/IInterface.h 12345678910111213141516171819#define DECLARE_META_INTERFACE(INTERFACE) \\ static const ::android::String16 descriptor; \\ static ::android::sp&lt;I##INTERFACE&gt; asInterface( \\ const ::android::sp&lt;::android::IBinder&gt;&amp; obj); \\ virtual const ::android::String16&amp; getInterfaceDescriptor() const; \\ I##INTERFACE(); \\ virtual ~I##INTERFACE(); ``` 其中`INTERFACE`的值为`ServiceManager`，那么经过替换后的代码如下所示。```cpp static const ::android::String16 descriptor; // 定义asInterface函数 static ::android::sp&lt;IServiceManager&gt; asInterface( const ::android::sp&lt;::android::IBinder&gt;&amp; obj); virtual const ::android::String16&amp; getInterfaceDescriptor() const; // 定义IServiceManager构造函数 IServiceManager(); // 定义IServiceManager析构函数 virtual ~IServiceManager(); 从DECLARE_META_INTERFACE宏的名称和上面的代码中，可以发现它主要声明了一些函数和一个变量。那么这些函数和变量的实现在哪呢？答案还是在IInterface.h中，叫做IMPLEMENT_META_INTERFACE宏，代码如下所示.frameworks/native/libs/binder/include/binder/IInterface.h 12345678910111213141516171819202122#define IMPLEMENT_META_INTERFACE(INTERFACE, NAME) \\const ::android::String16 I##INTERFACE::descriptor(NAME); \\const ::android::String16&amp; \\ I##INTERFACE::getInterfaceDescriptor() const &#123; \\ return I##INTERFACE::descriptor; \\&#125; \\::android::sp&lt;I##INTERFACE&gt; I##INTERFACE::asInterface( \\ const ::android::sp&lt;::android::IBinder&gt;&amp; obj) \\&#123; \\ ::android::sp&lt;I##INTERFACE&gt; intr; \\ if (obj != NULL) &#123; \\ intr = static_cast&lt;I##INTERFACE*&gt;( \\ obj-&gt;queryLocalInterface( \\ I##INTERFACE::descriptor).get()); \\ if (intr == NULL) &#123; \\ intr = new Bp##INTERFACE(obj); \\ &#125; \\ &#125; \\ return intr; \\&#125; \\I##INTERFACE::I##INTERFACE() &#123; &#125; \\I##INTERFACE::~I##INTERFACE() &#123; &#125; \\ DECLARE_META_INTERFACE()和IMPLEMENT_META_INTERFACE()宏是配合使用的，很多系统服务都使用它们，IServiceManager使用IMPLEMENT_META_INTERFACE()宏只有一行代码，如下。frameworks/native/libs/binder/IServiceManager.cpp 1IMPLEMENT_META_INTERFACE(ServiceManager, \"android.os.IServiceManager\"); IMPLEMENT_META_INTERFACE()宏的INTERFACE值为ServiceManager，NAME值为&quot;android.os.IServiceManager&quot;，进行替换后，代码如下。 12345678910111213141516171819202122const ::android::String16 IServiceManager::descriptor(\"android.os.IServiceManager\"); const ::android::String16&amp; IServiceManager::getInterfaceDescriptor() const &#123; return IServiceManager::descriptor; &#125; // 实现了asInterface函数::android::sp&lt;IServiceManager&gt; IServiceManager::asInterface( const ::android::sp&lt;::android::IBinder&gt;&amp; obj) &#123; ::android::sp&lt;IServiceManager&gt; intr; if (obj != NULL) &#123; intr = static_cast&lt;IServiceManager&gt;( obj-&gt;queryLocalInterface( IServiceManager::descriptor).get()); if (intr == NULL) &#123; intr = new BpServiceManager(obj); // 1 &#125; &#125; return intr; &#125; IServiceManager::IServiceManager() &#123; &#125; IServiceManager::~IServiceManager() &#123; &#125; 关键在于注释1，新建一个BpServiceManager，传入的参数obj的值为BpBinder。所以，asInterface()函数就是用BpBinder为参数创建BpServiceManager，从而推断出interface_cast()函数创建了BpServiceManager，再往上推断，IServiceManager的defaultServiceManaher()函数返回的就是BpServiceManager。BpServiceManager有什么作用？先来看看它的构造函数。frameworks/native/libs/binder/IServiceManager.cpp 123456789class BpServiceManager : public BpInterface&lt;IServiceManager&gt;&#123;public: explicit BpServiceManager(const sp&lt;IBinder&gt;&amp; impl) : BpInterface&lt;IServiceManager&gt;(impl) &#123; &#125; ......&#125; impl的值就是BpBinder，BpServiceManager的构造函数调用了基类BpInterface的构造函数。frameworks/native/libs/binder/include/binder/IInterface.h 12345template&lt;typename INTERFACE&gt;class BpInterface : public INTERFACE, public BpRefBase&#123;...&#125;; BpInterface又继承了BpRefBase。BpRefBase的实现如下。frameworks/native/libs/binder/Binder.cpp 12345678910BpRefBase::BpRefBase(const sp&lt;IBinder&gt;&amp; o) : mRemote(o.get()), mRefs(NULL), mState(0)&#123; extendObjectLifetime(OBJECT_LIFETIME_WEAK); if (mRemote) &#123; mRemote-&gt;incStrong(this); mRefs = mRemote-&gt;createWeak(this); &#125;&#125; mRemote是一个IBinder*指针，它的最终指向为BpBinder，即BpServiceManager的mRemote指向了BpBinder。那么BpServiceManager的作用就是实现了IServiceManager，并通过BpBinder实现通信。 4.3 IServiceManager关系图 BpBinder和BBinder都和通信有关，它们都继承了IBinder。 BpServiceManager派生自IServiceManager，它们都和业务有关。 BpRefBase包含了mRemote，通过不断地派生，BpServiceManager也同样包含mRemote，它指向了BpBidner，通过BpBinder来实现通信。","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://tylerLiu.top/categories/Android进阶/"},{"name":"框架层","slug":"Android进阶/框架层","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/"},{"name":"Binder原理","slug":"Android进阶/框架层/Binder原理","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/Binder原理/"}],"tags":[{"name":"Binder","slug":"Binder","permalink":"https://tylerLiu.top/tags/Binder/"}]},{"title":"Binder原理 01：基础知识（基于Android 9.0）","slug":"Binder原理-01：基础知识","date":"2019-11-05T06:53:09.000Z","updated":"2019-11-12T07:37:34.750Z","comments":true,"path":"2019/11/05/Binder原理-01：基础知识/","link":"","permalink":"https://tylerLiu.top/2019/11/05/Binder原理-01：基础知识/","excerpt":"","text":"1. Linux和Android的IPC机制种类IPC全称Inter-Process Communication，进程间通信，指两个进程间进行数据交换的过程。Android和Linux各有各的IPC机制。 1.1 Linux中IPC机制种类 管道（pipe） 信号（sinal） 信号量（semophore） 消息队列（Message） 内存共享（Share Memory） 套接字（Socket） ……等 管道管道是Linux从Unix继承过来的，它是Unix早期的一个重要通信机制。管道的主要思想是，在内存中创建一个共享文件，从而使通信双方利用这个共享文件来传递信息。这个共享文件比较特殊，它不属于系统文件并且只存在于内存中。另外，管道采用的是半双工通信方式，数据只能在一个方向上流动。 信号信号是软件层次上对中断机制的一种模拟，是一种异步通信方式，进程不必通过任何操作来等待信号的到达。信号可以在用户空间进程和内核之间直接交互，内核可以利用信号来通知用户空间的进程发生了哪些系统事件。信号不适用于信息交换，比较适用于进程中断控制。 信号量信号量是一个计数器，用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程访问该资源。主要作为进程间以及同一进程内不用线程之间的同步手段。 消息队列消息队列是消息的链表，具有特定的格式，存放在内存中并由消息队列标识符标识，并且允许一个或多个进程向它写入和读取消息。信息会复制两次，因此对于频繁或信息量大的通信不宜使用消息队列。 共享内存多个进程可以直接读写的一块内存空间，是针对其他通信机制运行效率较低而设计的。为了在多个进程间交换信息，内核专门留了一块内存区域，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这块内存而不需要进行数据的拷贝，从而提高效率。 套接字更为基础的进程间通信机制，与其他的方式不同的是，套接字可用于不同机器之间的进程间通信。 1.2 Android中的IPC机制Android系统是基于Linux内核的，在Linux内核的基础上，拓展了一些IPC的机制。Android系统除了支持套接字，还支持序列化、Messenger、AIDL、Bundle、文件共享、ContentProvider、Binder等。 序列化指的是Serializable/Parcelable，Serializable是Java提供的一个序列化接口，是一个空接口，为对象提供标准的序列化和反序列化操作。Parcelable接口是Android中的序列化方式，用起来比较麻烦，但效率更高。 Messenger在Android应用开发中使用率不高，可以在不同进程中传递Message对象，在Message中加入想要传递的数据就可以在进程间进行数据传递了。Messenger是轻量级的IPC方案，并对AIDL进行了封装。 AIDL全称Android interface definition Language，即Android接口定义语言。Messenger是以串行的方式来处理客户端发来的信息，如果有大量的消息发送到服务端，服务端仍然是一个一个的处理，再响应客户端，显然是不合适的。另外，Messenger用来进行进程间的数据传递，但是不能满足跨进程的方法调用，这时就需要使用AIDL。 Bundle实现了Parcelable接口，可以方便的在不同的进程间传输。Activity、Service、Receiver都在Intent中通过Bundle来传递数据。 文件共享两个进程通过读写一个文件来进行数据共享，共享的文件可以是文本、XML、Json。文件共享适用于对数据同步要求不高的进程间通信。 ContentProvierContentProvier为存储和获取数据提供了统一的接口，它可以在不同的应用程序间共享数据，本身就适合进程间通信。ContentProvier底层实现也是Binder，但是使用要比AIDL容易。系统很多操作都采用了ContentProvider，如通讯录、音频等，这些操作本身就是跨进程进行通信。 2. Linux和Binder的IPC通信原理 先看看几个基本概念： 内核空间（Kernel space）和用户空间（User space）为了确保用户进程不能直接操作内核，保证内核的安全，操作系统从逻辑上将虚拟空间划分为用户空间和内核空间。Linux操作系统将最高的1GB字节供内核使用，称为内核空间，较低的3GB字节供进程使用，称为用户空间。内核空间是Linux内核运行的空间，用户空间是用户程序的运行空间。为了安全，它们是隔离的，即使用户的程序崩溃了，内核也不受影响。内核空间的数据是可以进程间共享的，而用户空间则不可以。 进程隔离一个进程不能直接操作或访问另一个进程。 系统调用用户空间需要访问内核空间，就需要借助系统调用来实现。系统调用是用户空间访问内核空间的唯一方式，保证了所有的资源访问都是在内核的控制下进行的，避免用户程序对系统资源的越权访问，提升系统安全性和稳定性。进程A和进程B的用户空间可以通过如下系统函数与内核空间进行交互。 copy_from_user：将用户空间数据拷贝到内核空间 copy_to_user：将内核空间的数据拷贝到用户空间 内存映射由于应用程序不能直接操作设备硬件地址，所以操作系统提供了一种机制：内存映射，把设备地址映射到进程虚拟内存区。 由于新建虚拟内存区域，磁盘文件和虚拟内存区域就可以直接映射，少了一次拷贝。内存映射全称Memory Map，在Linux中通过系统调用函数mmap()来实现内存映射。将用户空间的一块内存区域映射到内核空间。映射关系建立之后，用户对这块内存区域的修改可以直接反映到内核空间，反之也是。内u才能映射能减少数据拷贝的次数，实现用户空间和内核空间的高效互动。 2.1 Linux的IPC通信原理 内核程序在内核空间分配内存并开辟一块内核缓存区，发送进程通过copy_from_user()函数将数据拷贝到内核空间的缓存区中。同样的，接收进程在接收数据时在自己的用户空间开辟一块内存缓存区，然后内核程序调用copy_to_user()函数将数据从内核缓存区拷贝到接收进程。这样数据发送进程和数据接收进程完成一次数据传输，即一次进程间通信。Linux的IPC通信原理有两个问题： 一次数据传递需要经历：用户空间 -&gt; 内核缓存区 -&gt; 用户空间，需要2次数据拷贝，效率不高。 接收数据的缓存区由数据接收进程提供，但是接收进程并不知道需要多大的空间来存放将要传递过来的数据，因此只能开辟尽可能大的内存空间或者先调用API接收消息头来获取消息体的大小，这样就会浪费空间或时间。 2.2 Binder通信原理Binder是基于开源的OpenBinder实现的，OpenBinder最早并不是Google开发的，而是BeInc开发的，接着由Palm, Inc.负责开发。后来OpenBinder作者加入了Google，并负责Android平台的开发，也就将Binder带到了Android。Binder是基于内存映射来实现的，内存映射通常是用在物理介质的文件系统上的，Binder没有物理介质，它使用内存映射是为了跨进程传递数据。 Binder通信步骤： Binder驱动在内核空间创建一个数据接收缓存区。 在内核空间开辟一块内存缓存区，建立内存缓存区和数据接收缓存区的映射关系，以及数据接收缓存区和接收进程用户空间地址的映射关系。 发送进程通过copy_to_user()函数将数据拷贝到内核中的内核缓存区，由于内核缓存区和接收的用户空间存在内存映射，因此就相当于把数据发送到了接收进程的用户空间，这样就完成了一次进程间通信。 整个过程只使用一次拷贝，不会因为不知道数据的大小而浪费空间和时间，效率更高。 3. 为什么要使用BinderAndroid是基于Linux内核的，Linux提供了很多IPC机制，而Android自己设计了Binder来进行通信，主要有以下几点原因。 性能方面性能方面的主要影响因素是拷贝次数，管道、消息队列、Socket的拷贝次数都是两次，性能不是很好，共享内存不需要拷贝，性能最好，Binder的拷贝次数为一次，性能仅次于内存拷贝。 稳定性方面Binder是基于C/S架构的，这个架构通常采用两层结构，技术上已经很成熟。共享内存没有分层，难以控制，并发同步访问临界资源时，可能会产生死锁。从稳定性角度来看，Binder优于共享内存。 安全方面Android是一个开源系统，并且拥有开放的平台，因此安全性对于Android平台很重要。传统的IPC接收方法无法获得对方可靠的进程用户ID/进程ID（UID/PID），无法鉴别对方的身份。Android为每个安装好的APP分配了自己的UID，通过进程的UID来鉴别进程身份。另外，Android系统中的Server端会判断UID/PID是否满足访问权限，而对外只暴露Client端，加强了系统的安全性。 语言方面Linux是基于C语言的，C语言是面向过程的，Android应用层和Java Framework是基于Java语言的，是面向对象的。Binder本身符合面向对象的思想，因此作为Android的通信机制更加合适。 从以上四个方面来看，Linux提供的大部分IPC机制无法和Binder相比较，而共享内存只在性能方面优于Binder，这就是为什么Android使用Binder进行进程间通信。当然系统中并不是所有的进程间通信都使用Bidner，也要结合不同场景，如Zygote进程与AMS通信使用的是Socket，Kill Process使用的是信号。 4. 为什么要学习Binder？Binder机制在Android中很重要，许多需要掌握的原理都和Binder有关： 系统中各个进程是如何通信的？ Android系统启动过程 AMS、PMS的原理 四大组件的原理，比如Activity是如何启动的？ 插件化原理 系统服务的Client端和Server端如何进行通信？（比如MediaPlayer和MediaPlayerService） …… 上面只是列出一小部分，简单来说，比如在系统启动过程时，SystemServer进程启动过程后会创建Binder线程池，目的是通过Binder，使得在SystemServer进程中的服务可以和其他进程进行通信。再比如常说的AMS、PMS都是基于Binder来实现的，拿PMS来说，PMS运行在SystemServer进程，如果它想要和DefaultContainerService通信（是用于检查和复制可移动文件的系统服务），就需要通过Binder，因为DefaultContainerService运行在com.android.defcontainer进程。还有一个比较常见的C/S架构间通信的问题，Client端的MediaPlayer和Server端的MediaPlayerService不是运行在一个进程中的，同样需要Binder来实现通信。可以说Binder机制是掌握系统底层原理的基石。根据Android系统的分层，Binder机制主要分为以下几个部分。 根据Android系统的分层，将Binder机制分为Java Binder、Native Binder和Kernel Binder，后面会主要讲解Java Binder和Native Binder。","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://tylerLiu.top/categories/Android进阶/"},{"name":"框架层","slug":"Android进阶/框架层","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/"},{"name":"Binder原理","slug":"Android进阶/框架层/Binder原理","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/Binder原理/"}],"tags":[{"name":"Binder","slug":"Binder","permalink":"https://tylerLiu.top/tags/Binder/"}]},{"title":"Android解析WindowManagerService 03：Window的删除过程（基于Android 8.0）","slug":"Android解析WindowManagerService-03：Window的删除过程","date":"2019-11-04T02:14:59.000Z","updated":"2019-11-05T06:49:02.396Z","comments":true,"path":"2019/11/04/Android解析WindowManagerService-03：Window的删除过程/","link":"","permalink":"https://tylerLiu.top/2019/11/04/Android解析WindowManagerService-03：Window的删除过程/","excerpt":"","text":"和Android解析WindowManagerService 02：WMS的重要成员和Window的添加过程（基于Android 8.0）中Window的创建和更新过程类似，要删除Window需要先调用WindowManagerImpl的removeView()方法，removeView()方法中调用WindowManagerGlobal的removeView()方法。frameworks/base/core/java/android/view/WindowManagerGlobal.java 1234567891011121314151617public void removeView(View view, boolean immediate) &#123; if (view == null) &#123; throw new IllegalArgumentException(\"view must not be null\"); &#125; synchronized (mLock) &#123; int index = findViewLocked(view, true); // 1 View curView = mRoots.get(index).getView(); removeViewLocked(index, immediate); // 2 if (curView == view) &#123; return; &#125; throw new IllegalStateException(\"Calling with view \" + view + \" but the ViewAncestor is attached to \" + curView); &#125;&#125; 注释1，找到要删除的View在view列表中的索引。注释2，调用removeViewLocked()将该索引传入。frameworks/base/core/java/android/view/WindowManagerGlobal.java 123456789101112131415161718private void removeViewLocked(int index, boolean immediate) &#123; ViewRootImpl root = mRoots.get(index); // 1 View view = root.getView(); if (view != null) &#123; InputMethodManager imm = InputMethodManager.getInstance(); // 2 if (imm != null) &#123; imm.windowDismissed(mViews.get(index).getWindowToken()); // 3 &#125; &#125; boolean deferred = root.die(immediate); // 4 if (view != null) &#123; view.assignParent(null); if (deferred) &#123; mDyingViews.add(view); &#125; &#125;&#125; 注释1，根据传入的索引在ViewRootImpl列表中获得需要删除的Window的ViewRootImpl。注释2，获取InputMethodManager实例，如果InputMethodManager实例不为空，则在注释3调用InputMethodManager的windowDismissed()来结束需要删除的Window的输入法相关的逻辑。注释4，调用ViewRootImpl的die()方法。frameworks/base/core/java/android/view/ViewRootImpl.java 1234567891011121314151617boolean die(boolean immediate) &#123; // Make sure we do execute immediately if we are in the middle of a traversal or the damage // done by dispatchDetachedFromWindow will cause havoc on return. // die()方法需要立即被执行并且此时ViewRootImpl不在执行performTraversals()方法 if (immediate &amp;&amp; !mIsInTraversal) &#123; 1// doDie(); // 2 return false; &#125; if (!mIsDrawing) &#123; destroyHardwareRenderer(); &#125; else &#123; ...... &#125; mHandler.sendEmptyMessage(MSG_DIE); return true;&#125; 注释1的immediate如果为true（需要立即执行），并且mIsTraversal为false则执行注释2的代码，mIsTraverrsal在执行ViewRootImpl的performTraversals()方法时被设置为true，在performTraversals()方法执行结束时被设置为false，因此注释1可以理解为die()方法需要立即执行并且此时ViewRootImpl不在执行performTraversals()方法。注释2，doDie()。frameworks/base/core/java/android/view/ViewRootImpl.java 12345678910111213141516171819202122232425262728293031323334353637383940void doDie() &#123; // 检查执行方法线程的正确性 checkThread(); // 1 if (LOCAL_LOGV) Log.v(mTag, \"DIE in \" + this + \" of \" + mSurface); synchronized (this) &#123; if (mRemoved) &#123; // 2 return; &#125; mRemoved = true; // 3 if (mAdded) &#123; // 4 dispatchDetachedFromWindow(); // 5 &#125; if (mAdded &amp;&amp; !mFirst) &#123; // 6 destroyHardwareRenderer(); if (mView != null) &#123; int viewVisibility = mView.getVisibility(); boolean viewVisibilityChanged = mViewVisibility != viewVisibility; if (mWindowAttributesChanged || viewVisibilityChanged) &#123; // If layout params have been changed, first give them // to the window manager to make sure it has the correct // animation info. try &#123; if ((relayoutWindow(mWindowAttributes, viewVisibility, false) &amp; WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) &#123; mWindowSession.finishDrawing(mWindow); &#125; &#125; catch (RemoteException e) &#123; &#125; &#125; mSurface.release(); &#125; &#125; mAdded = false; &#125; WindowManagerGlobal.getInstance().doRemoveView(this); // 7&#125; 注释1，检查执行duDie()方法的线程的正确性，checkThread()内部会判断执行duDie()方法线程是否是创建需要删除的Window的原始线程，如果不是，就抛出异常，因为只有创建需要删除的Window的原始线程才能操作该Window。注释2、3，用于防止doDie()方法被重复调用。注释4，需要删除的Window有子View，就会调用dispatchDetachedFromWindow()方法来销毁View。注释6，如果需要删除的Window有子View并且不是第一次被添加，就会执行后面的代码。注释7，WindowManagerGlobal的doRemoveView()方法。frameworks/base/core/java/android/view/WindowManagerGlobal.java 1234567891011121314void doRemoveView(ViewRootImpl root) &#123; synchronized (mLock) &#123; final int index = mRoots.indexOf(root); // 1 if (index &gt;= 0) &#123; mRoots.remove(index); mParams.remove(index); final View view = mViews.remove(index); mDyingViews.remove(view); &#125; &#125; if (ThreadedRenderer.sTrimForeground &amp;&amp; ThreadedRenderer.isAvailable()) &#123; doTrimForeground(); &#125;&#125; WindowManagerGlobal中维护了和Window操作相关的三个列表，doRemoveView()方法会从这三个列表中清除需要删除的Window对应的元素。注释1，找到需要删除的Window对应的ViewRootImpl在ViewRootImpl列表中的索引，接着根据这个索引从ViewRootImpl列表、布局参数列表和View列表中删除与需要删除的Window对应的元素。再回到doDie()方法，注释5，dispatchDetachedFromWindow()。frameworks/base/core/java/android/view/ViewRootImpl.java 12345678void dispatchDetachedFromWindow() &#123; ...... try &#123; mWindowSession.remove(mWindow); &#125; catch (RemoteException e) &#123; &#125; ......&#125; 调用了IWindowSession的remove()方法，IWindowSession在Server端的实现为Session，Session的remove()方法如下：frameworks/base/services/core/java/com/android/server/wm/Session.java 123public void remove(IWindow window) &#123; mService.removeWindow(this, window);&#125; 再来查看WMS的removeWindow()。frameworks/base/services/core/java/com/android/server/wm/WindowManagerService .java 123456789void removeWindow(Session session, IWindow client) &#123; synchronized(mWindowMap) &#123; WindowState win = windowForClientLocked(session, client, false); // 1 if (win == null) &#123; return; &#125; win.removeIfPossible(); // 2 &#125;&#125; 注释1，用于获取Window对应的WindowState，WindowState用于保存窗口的信息，在WMS中它用来描述一个窗口。注释2，调用WindowState的removeIfPossible()方法。frameworks/base/services/core/java/com/android/server/wm/WindowState.java 12345@Overridevoid removeIfPossible() &#123; super.removeIfPossible(); removeIfPossible(false /*keepVisibleDeadWindow*/);&#125; 123456789101112private void removeIfPossible(boolean keepVisibleDeadWindow) &#123; // 条件判断过滤，满足其中一个条件就会return，推迟删除操作 ...... removeImmediately(); // Removing a visible window will effect the computed orientation // So just update orientation if needed. if (wasVisible &amp;&amp; mService.updateOrientationFromAppTokensLocked(false, displayId)) &#123; mService.mH.obtainMessage(SEND_NEW_CONFIGURATION, displayId).sendToTarget(); &#125; mService.updateFocusedWindowLocked(UPDATE_FOCUS_NORMAL, true /*updateInputWindows*/); Binder.restoreCallingIdentity(origId);&#125; removeIfPossible()不会立即执行删除操作，而是进行了多个条件过滤，只要其中一个条件，就会return，推迟删除操作。条件判断都通过的话，就会调用removeImmediately()。frameworks/base/services/core/java/com/android/server/wm/WindowState.java 12345678910111213141516171819202122232425262728@Overridevoid removeImmediately() &#123; super.removeImmediately(); if (mRemoved) &#123; // 1 // Nothing to do. ...... return; &#125; mRemoved = true; // 2 ...... mPolicy.removeWindowLw(this); // 3 disposeInputChannel(); mWinAnimator.destroyDeferredSurfaceLocked(); mWinAnimator.destroySurfaceLocked(); mSession.windowRemovedLocked(); // 4 try &#123; mClient.asBinder().unlinkToDeath(mDeathRecipient, 0); &#125; catch (RuntimeException e) &#123; &#125; mService.postWindowRemoveCleanupLocked(this); // 5&#125; 注释1，mRemoved为true意味着正在执行删除Window操作，注释1到注释2之间的代码用于防止重复删除操作。注释3，如果当前要删除的Window是StatusBar或者NavigationBar就会将这个Window从对应的控制器中删除。注释4，将需要删除的Window对应的Session从WMS的ArraySet&lt;Session&gt; mSession中删除并清除Session对应的SurfaceSession资源（SurfaceSession是SurfaceFlinger的一个连接，通过这个连接可以创建一个或多个Surface并渲染到屏幕上）。注释5，调用WMS的postWindowRemoveCleanupLocked()方法用于对需要删除的Window进行一些集中的清理工作。删除的逻辑总结如下： 检查删除线程的正确性，如果不正确则抛出异常； 从ViewRootImpl列表、布局参数列表和View列表中删除与需要删除的Window对应的元素； 判断是否可以直接执行删除操作，如果不能，就推迟删除操作； 执行删除操作，清理和释放与需要删除的Window相关的资源。","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://tylerLiu.top/categories/Android进阶/"},{"name":"框架层","slug":"Android进阶/框架层","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/"},{"name":"解析WindowManagerService","slug":"Android进阶/框架层/解析WindowManagerService","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/解析WindowManagerService/"}],"tags":[{"name":"WindowManagerService","slug":"WindowManagerService","permalink":"https://tylerLiu.top/tags/WindowManagerService/"}]},{"title":"Android解析WindowManagerService 02：WMS的重要成员和Window的添加过程（基于Android 8.0）","slug":"Android解析WindowManagerService-02：WMS的重要成员和Window的添加过程","date":"2019-10-29T05:35:02.000Z","updated":"2019-11-04T02:09:21.346Z","comments":true,"path":"2019/10/29/Android解析WindowManagerService-02：WMS的重要成员和Window的添加过程/","link":"","permalink":"https://tylerLiu.top/2019/10/29/Android解析WindowManagerService-02：WMS的重要成员和Window的添加过程/","excerpt":"","text":"前言WMS在创建之后，它的重要成员有哪些？Window添加过程的WMS部分做了什么？ 1. WMS的重要成员即WMS的重要成员变量，如下：frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java 12345678910111213141516171819202122final WindowManagerPolicy mPolicy;final IActivityManager mActivityManager;final ActivityManagerInternal mAmInternal;final AppOpsManager mAppOps;final DisplaySettings mDisplaySettings;......final ArraySet&lt;Session&gt; mSessions = new ArraySet&lt;&gt;();final WindowHashMap mWindowMap = new WindowHashMap();final ArrayList&lt;AppWindowToken&gt; mFinishedStarting = new ArrayList&lt;&gt;();final ArrayList&lt;AppWindowToken&gt; mFinishedEarlyAnim = new ArrayList&lt;&gt;();final ArrayList&lt;AppWindowToken&gt; mWindowReplacementTimeouts = new ArrayList&lt;&gt;();final ArrayList&lt;WindowState&gt; mResizingWindows = new ArrayList&lt;&gt;();final ArrayList&lt;WindowState&gt; mPendingRemove = new ArrayList&lt;&gt;();WindowState[] mPendingRemoveTmp = new WindowState[20];final ArrayList&lt;WindowState&gt; mDestroySurface = new ArrayList&lt;&gt;();final ArrayList&lt;WindowState&gt; mDestroyPreservedSurface = new ArrayList&lt;&gt;();......final H mH = new H();......final WindowAnimator mAnimator;......final InputManagerService mInputManager WindowManagerPolicy mPolicy：WindowManagerPolicy是窗口管理策略的接口类，用来定义一个窗口策略所要遵循的通用规范，并提供了WindowManager所有的特定的UI行为。其具体实现类为PhoneWindowManager，这个实现类在WMS创建时被创建。WMP允许定制窗口层级和特殊窗口类型以及关键的调度和布局。 ArraySet mSessions：在Android解析WindowManager 03：Window的添加过程这篇文章中提到过Session，它主要用于进程间通信，其他的应用程序进程想要和WMS进程进行通信就需要经过Session，并且每个应用程序进程都会对应一个Session，WMS保存这些Session用来记录所有向WMS提出窗口管理服务的客户端。 WindowHashMap mWindowMap：WindowHashMap继承了HashMap，它限制了HashMap的key值的类型为IBinder，value值的类型为WindowState。WindowState用户保存窗口的信息，在WMS中，它用来描述一个窗口。综上，mWindowMap就是用来保存WMS中各种窗口的集合。 ArrayList mFinishedStarting：AppWindowToken的集合，AppWindowToken是WindowToken的子类。要想理解mFinishedStarting的意义，需要先理解WindowToken。WindowToken主要有两个作用： 可以理解为窗口令牌，当应用程序想要向WMS申请新创建一个窗口，则需要向WMS出示有效的的WindowToken。AppWindowToken作为WindowToken的子类，主要用来描述应用程序的WindowToken结构。应用程序中每个Activity都对应一个AppWindowToken。 WindowToken会将相同组件（比如Activity）的窗口（WindowState）集合在一起，方便管理。 mFinishedStarting就是用于存储已经完成启动的应用程序窗口（比如Activity）的AppWindowToken的列表。除了mFinishedStarting，还有类似的mFinishedEarlyAnim和mWindowReplacementTimeouts，其中mFinishedEarlyAnim用于存储已经完成绘制并且不需要任何已保存surface的应用程序窗口的AppWindowToken。mWindowReplacementTimeouts存储了等待更换的应用程序窗口的AppWindowToken，如果更换不及时，旧窗口就需要被处理。 ArrayList mResizingWindows：类型为WindowState。用来存储正在调整大小的窗口的列表。与mResizingWindows类似的还有mPendingRemove、mDestoryPreservedSurface等等。其中mPendingRemove是在内存耗尽时设置的，里面存着需要强制删除的窗口。mDestorySurface里面存有需要被Destory的Surface。mDestoryPreservedSurface里面存着窗口需要保存的等待销毁的Surface，因为当窗口经历Surface变化时，窗口需要一直保持旧Surface，直到新Surface的第一帧绘制完成。 WindowAnimator mAnimator：用于管理窗口的动画以及特效动画。 H mH：系统的Handler类，用于将任务加入到主线程的消息队列中，这样代码逻辑就会在主线程中执行。 InputManagerService mInputManager：输入系统管理者。IMS会对触摸事件进行处理，它会寻找一个最合适的窗口来处理触摸反馈信息，WMS是窗口管理者，因此WMS就是输入系统的中转站，WMS包含IMS的引用。 2. Window的添加过程（WMS部分）Window的操作分为两大部分，WindowManager处理部分和WMS处理部分。 在Android解析WindowManager 03：Window的添加过程中，讲解了Window的添加过程的WindowManager处理部分，这里再来看看WMS部分。无论是系统窗口还是Activity，它们的Window的添加过程都会调用WMS的addWindow()方法。frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java这段代码分成三个部分来看。 123456789101112131415161718192021222324252627282930313233343536public int addWindow(Session session, IWindow client, int seq, WindowManager.LayoutParams attrs, int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, InputChannel outInputChannel) &#123; int[] appOp = new int[1]; int res = mPolicy.checkAddPermission(attrs, appOp); // 1 if (res != WindowManagerGlobal.ADD_OKAY) &#123; return res; &#125; ...... synchronized(mWindowMap) &#123; if (!mDisplayReady) &#123; throw new IllegalStateException(\"Display has not been initialialized\"); &#125; final DisplayContent displayContent = mRoot.getDisplayContentOrCreate(displayId); // 2 if (displayContent == null) &#123; ...... return WindowManagerGlobal.ADD_INVALID_DISPLAY; &#125; ...... if (type &gt;= FIRST_SUB_WINDOW &amp;&amp; type &lt;= LAST_SUB_WINDOW) &#123; // 3 parentWindow = windowForClientLocked(null, attrs.token, false); // 4 if (parentWindow == null) &#123; ...... return WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN; &#125; if (parentWindow.mAttrs.type &gt;= FIRST_SUB_WINDOW &amp;&amp; parentWindow.mAttrs.type &lt;= LAST_SUB_WINDOW) &#123; ...... return WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN; &#125; &#125; ...... &#125; ......&#125; WMS的addWindow()方法返回的是各种状态值，比如，添加Window成功，无效的display等，这些状态被定义在WindowManagerGlobal中。注释1，根据Window的属性，调用WMP的checkAddPermission()方法来检查权限，具体的实现在PhoneWindowManager的checkAddPermission()中，如果没有权限则不会执行后面的代码。注释2，通过display来获得窗口要添加到哪个DisplayContent上，如果没没有找到DisplayContent，则返回WindowManagerGlobal.ADD_INVALID_DISPLAY状态，其中DisplayContent是用来描述一块屏幕的。注释3，type表示窗口的类型，其数值介于FIRST_SUB_WINDOW和LAST_SUB_WINDOW（1000-1999），该数值定义在WindowManager中，说明这个窗口是一个子窗口。注释4，attrs.token是IBinder类型的对象，windowForClientLocked()方法内部会根据attrs.token作为key值，从mWindowMap中得到该子窗口的父窗口。接着对父窗口进行判断，如果父窗口为空或者type的取值范围不正确，就返回错误的状态。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849......AppWindowToken atoken = null;final boolean hasParent = parentWindow != null;WindowToken token = displayContent.getWindowToken(hasParent ? parentWindow.mAttrs.token : attrs.token); // 1final int rootType = hasParent ? parentWindow.mAttrs.type : type; // 2boolean addToastWindowRequiresToken = false;if (token == null) &#123; if (rootType &gt;= FIRST_APPLICATION_WINDOW &amp;&amp; rootType &lt;= LAST_APPLICATION_WINDOW) &#123; ...... return WindowManagerGlobal.ADD_BAD_APP_TOKEN; &#125; if (rootType == TYPE_INPUT_METHOD) &#123; ...... return WindowManagerGlobal.ADD_BAD_APP_TOKEN; &#125; if (rootType == TYPE_VOICE_INTERACTION) &#123; ...... return WindowManagerGlobal.ADD_BAD_APP_TOKEN; &#125; if (rootType == TYPE_WALLPAPER) &#123; ...... return WindowManagerGlobal.ADD_BAD_APP_TOKEN; &#125; ...... if (type == TYPE_TOAST) &#123; // Apps targeting SDK above N MR1 cannot arbitrary add toast windows. if (doesAddToastWindowRequireToken(attrs.packageName, callingUid, parentWindow)) &#123; ...... return WindowManagerGlobal.ADD_BAD_APP_TOKEN; &#125; &#125; final IBinder binder = attrs.token != null ? attrs.token : client.asBinder(); token = new WindowToken(this, binder, type, false, displayContent, session.mCanAddInternalSystemWindow); // 3&#125; else if (rootType &gt;= FIRST_APPLICATION_WINDOW &amp;&amp; rootType &lt;= LAST_APPLICATION_WINDOW) &#123; // 4 atoken = token.asAppWindowToken(); // 5 if (atoken == null) &#123; ...... return WindowManagerGlobal.ADD_NOT_APP_TOKEN; &#125; else if (atoken.removed) &#123; ...... return WindowManagerGlobal.ADD_APP_EXITING; &#125;&#125; else if (rootType == TYPE_INPUT_METHOD) &#123; if (token.windowType != TYPE_INPUT_METHOD) &#123; ...... return WindowManagerGlobal.ADD_BAD_APP_TOKEN; &#125;&#125;...... 注释1，通过displayContent的getWindowToken()得到WindowToken。注释2，如果有父窗口就将父窗口的type值赋值给rootType，如果没有就将当前窗口的type值赋值给rootType。如果WindowToken为空，则根据rootType或者type的值进行区分判断，如果rootType值等于TYPE_INPUT_METHOD、TYPE_WALLPAPER等值时，则返回状态值WindowManagerGlobal.ADD_BAD_APP_TOKEN，说明rootType值等于TYPE_INPUT_METHOD、TYPE_WALLPAPER等值时不允许WindowToken为空。注释3，隐式创建WindowToken，说明当添加窗口时可以不向WMS提供WindowToken，前提是rootTtpe或type的值不为前面条件筛选的值。WindowToken隐式和显示的创建需要加以区分，注释3的第4个参数为false就表示是隐式创建。下面就是WindowToken不为空的情况，根据rootType和type的值进行判断，如在注释4，如果窗口为应用程序窗口，在注释5会将WindowToken转换为专门针对应用程序窗口的AppWindowToken，然后根据AppWindowToken的值进行后续的判断。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647......final WindowState win = new WindowState(this, session, client, token, parentWindow, appOp[0], seq, attrs, viewVisibility, session.mUid, session.mCanAddInternalSystemWindow); // 1if (win.mDeathRecipient == null) &#123; // 2 ...... return WindowManagerGlobal.ADD_APP_EXITING;&#125;if (win.getDisplayContent() == null) &#123; // 3 ...... return WindowManagerGlobal.ADD_INVALID_DISPLAY;&#125;mPolicy.adjustWindowParamsLw(win.mAttrs); // 4win.setShowToOwnerOnlyLocked(mPolicy.checkShowToOwnerOnly(attrs));res = mPolicy.prepareAddWindowLw(win, attrs); // 5......win.attach();mWindowMap.put(client.asBinder(), win); // 6if (win.mAppOp != AppOpsManager.OP_NONE) &#123; int startOpResult = mAppOps.startOpNoThrow(win.mAppOp, win.getOwningUid(), win.getOwningPackage()); if ((startOpResult != AppOpsManager.MODE_ALLOWED) &amp;&amp; (startOpResult != AppOpsManager.MODE_DEFAULT)) &#123; win.setAppOpVisibilityLw(false); &#125;&#125;final AppWindowToken aToken = token.asAppWindowToken();if (type == TYPE_APPLICATION_STARTING &amp;&amp; aToken != null) &#123; aToken.startingWindow = win; ......&#125;boolean imMayMove = true;win.mToken.addWindow(win); // 7if (type == TYPE_INPUT_METHOD) &#123; win.mGivenInsetsPending = true; setInputMethodWindowLocked(win); imMayMove = false;&#125; else if (type == TYPE_INPUT_METHOD_DIALOG) &#123; displayContent.computeImeTarget(true /* updateImeTarget */); imMayMove = false;&#125; else &#123; if (type == TYPE_WALLPAPER) &#123; displayContent.mWallpaperController.clearLastWallpaperTimeoutTime(); displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER; &#125; else if ((attrs.flags&amp;FLAG_SHOW_WALLPAPER) != 0) &#123; displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER; &#125; else if (displayContent.mWallpaperController.isBelowWallpaperTarget(win)) &#123; displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER; &#125;&#125;...... 注释1，创建WindowState，它存有窗口的所有的状态信息，在WMS中它代表一个窗口。从WindowState传入的参数，可以发现WindowState中包含了WMS、Session、WindowToken、父类的WindowState、LayoutParams等信息。注释2、3，分别判断请求添加窗口的客户端是否已经死亡、窗口的DisplayContent是否为空，如果是，则不会再执行后面的代码。注释4，调用WMP的adjustWindowParamsLw()方法，该方法的实现在PhoneWindowManager中，会根据窗口的type对窗口的LayoutParams的一些成员变量进行修改。注释5，调用WMP的prepareAddWindowLw()方法，用于准备将窗口添加到系统中。注释6，将WindowState添加到mWindowMap中。注释7，将WindowState添加到该WindowState对应的WindowToken中（实际是保存在WindowToken的父类WindowContainer中），这样WindowToken就包含了相同组件的WindowToken。 addWindow()方法总结：主要做了下面4件事 对所要添加的窗口进行检查，如果窗口不满足一些条件，就不会再执行后面的代码； WindowToken相关的处理，比如有的窗口类型需要提供WindowToken，没有提供的话就不会执行后面的代码，有的窗口类型则需要由WMS隐式创建WindowToken； WindowState的创建和相关处理，将WindowToken与WindowState相关联； 创建和配置DisplayContent，完成窗口添加到系统前的准备工作。","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://tylerLiu.top/categories/Android进阶/"},{"name":"框架层","slug":"Android进阶/框架层","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/"},{"name":"解析WindowManagerService","slug":"Android进阶/框架层/解析WindowManagerService","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/解析WindowManagerService/"}],"tags":[{"name":"WindowManagerService","slug":"WindowManagerService","permalink":"https://tylerLiu.top/tags/WindowManagerService/"}]},{"title":"Android解析WindowManagerService 01：WMS的概述（基于Android 8.0）","slug":"Android解析WindowManagerService-01：WMS的概述","date":"2019-10-26T05:51:30.000Z","updated":"2019-10-30T00:29:34.580Z","comments":true,"path":"2019/10/26/Android解析WindowManagerService-01：WMS的概述/","link":"","permalink":"https://tylerLiu.top/2019/10/26/Android解析WindowManagerService-01：WMS的概述/","excerpt":"","text":"1. 概述WMS属于系统服务中的其他服务，其主要职责： 窗口管理：WMS是窗口管理者，负责窗口的启动、添加和删除，另外窗口的大小和层级也是由WMS进行管理的。窗口管理的核心成员由DisplayContent、WindowToken和WindowState。 窗口动画：窗口间进行切换时，可以使用窗口动画，窗口动画由WMS的动画子系统来负责，动画子系统的管理者为WindowAnimator。 输入系统的中转站：通过对窗口的触摸从而产生触摸事件，InputManagerService(IMS)会对触摸事件进行处理，它会寻找一个最合适的窗口来处理触摸反馈信息，WMS是窗口的管理者，因此，WMS就成为输入系统的中转站。 Surface管理：窗口并不具备有绘制的功能，因此每个窗口都需要一块Surface来供自己绘制。为每个窗口分配Surface是由WMS来完成的。 WMS的职责： 2. WMS的诞生WMS是在SystemServer进程中启动的。先看看SystemServer的main()方法：frameworks/base/services/java/com/android/server/SystemServer.java 123public static void main(String[] args) &#123; new SystemServer().run();&#125; 里面只调用了SystemServer的run()：frameworks/base/services/java/com/android/server/SystemServer.java 123456789101112131415161718192021222324252627282930private void run() &#123; try &#123; ...... // Initialize native services. System.loadLibrary(\"android_servers\"); // 1 ...... // Create the system service manager. mSystemServiceManager = new SystemServiceManager(mSystemContext); // 2 mSystemServiceManager.setStartInfo(mRuntimeRestart, mRuntimeStartElapsedTime, mRuntimeStartUptime); LocalServices.addService(SystemServiceManager.class, mSystemServiceManager); // Prepare the thread pool for init tasks that can be parallelized SystemServerInitThreadPool.get(); &#125; finally &#123; traceEnd(); // InitBeforeStartServices &#125; // Start services. try &#123; traceBeginAndSlog(\"StartServices\"); startBootstrapServices(); startCoreServices(); startOtherServices(); SystemServerInitThreadPool.shutdown(); &#125; catch (Throwable ex) &#123; ...... &#125; finally &#123; traceEnd(); &#125; ......&#125; 注释1，加载了android_servers.so库。 注释2，创建SystemServiceManager，它会对系统的服务进行创建、启动和生命周期管理。 接下来会启动系统的各种服务。WMS是其他服务的一种。下面查看startOtherServices()。frameworks/base/services/java/com/android/server/SystemServer.java 123456789101112131415161718192021222324252627282930private void startOtherServices() &#123; ...... traceBeginAndSlog(\"InitWatchdog\"); final Watchdog watchdog = Watchdog.getInstance(); // 1 watchdog.init(context, mActivityManagerService); // 2 traceEnd(); traceBeginAndSlog(\"StartInputManagerService\"); inputManager = new InputManagerService(context); // 3 traceEnd(); traceBeginAndSlog(\"StartWindowManagerService\"); ConcurrentUtils.waitForFutureNoInterrupt(mSensorServiceStart, START_SENSOR_SERVICE); mSensorServiceStart = null; wm = WindowManagerService.main(context, inputManager, mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL, !mFirstBoot, mOnlyCore, new PhoneWindowManager()); // 4 ServiceManager.addService(Context.WINDOW_SERVICE, wm); // 5 ServiceManager.addService(Context.INPUT_SERVICE, inputManager); // 6 traceEnd(); ...... try &#123; wm.displayReady(); // 7 &#125; catch (Throwable e) &#123; reportWtf(\"making display ready\", e); &#125; ...... try &#123; wm.systemReady(); // 8 &#125; catch (Throwable e) &#123; reportWtf(\"making Window Manager Service ready\", e); &#125; ...... &#125; 这里只保留和WMS启动相关的代码。 注释1、2，获得WatchDog实例并对其进行初始化，WatchDog是用来监控系统的一些关键服务的运行状况。 注释3，创建IMS，并赋值给IMS类型的inputManager对象。 注释4，执行WMS的main()方法，其内部会创建WMS，main()方法其中一个传入的参数就是注释1创建的IMS，WMS是输入事件的中转站，其内部包含了IMS的引用。结合上文，可以得知WMS的main()方法是运行在SystemServer的run()方法中，即是运行在”system_server”线程中。 注释5、6分别将WMS和IMS注册到ServiceManager中，这样如果某个客户端想要使用WMS，就需要先去ServiceManager中查询信息，然后根据信息与WMS所在的进程建立通信通路，客户端就可以使用WMS了。 注释7，用来处理初始化显示信息。 注释8，通知WMS，系统的初始化工作已经完成，其内部调用了WindowManagerPolicy的systemReady()方法。 下面来看看注释4的main()方法。frameworks/base/services/core/java/com/android/server/wm/WindowManagerService .java 123456public static WindowManagerService main(final Context context, final InputManagerService im, final boolean haveInputMethods, final boolean showBootMsgs, final boolean onlyCore, WindowManagerPolicy policy) &#123; DisplayThread.getHandler().runWithScissors(() -&gt; // 1 sInstance = new WindowManagerService(context, im, haveInputMethods, showBootMsgs, onlyCore, policy), 0); // 2 return sInstance;&#125; 注释1，调用了DisplayThread的getHandler()方法，获取DisplayThread的实例。DisplayThread是一个单例的前台线程，这个线程用来处理需要低延时显示的相关操作，并只能由WindowManager、DisplayManager和InputManager实时执行快速操作。 注释2，创建WMS实例，该过程是运行在Runnable的run()方法中，Runnable会传入到DisplayThread对应Handler的runWithScissors()中，说明WMS的创建是运行在”android.display”中的。需要注意，runWithScissors()的第二个参数传入的是0。来看看Handle的runWithScissors()：frameworks/base/core/java/android/os/Handler.java 1234567891011121314public final boolean runWithScissors(final Runnable r, long timeout) &#123; if (r == null) &#123; throw new IllegalArgumentException(\"runnable must not be null\"); &#125; if (timeout &lt; 0) &#123; throw new IllegalArgumentException(\"timeout must be non-negative\"); &#125; if (Looper.myLooper() == mLooper) &#123; // 1 r.run(); return true; &#125; BlockingRunnable br = new BlockingRunnable(r); return br.postAndWait(this, timeout);&#125; 开头对传入的Runable和timeout进行判断，如果Runable为null或timeout小于0，则抛出异常。 注释1，根据每个线程只有一个Looper的原理来判断当前的线程（”system_server”线程）是否是Handler所指向的线程（”android.display”线程），如果是则直接执行Runnable的run()方法，如果不是则调用BlobkingRunnable的postAndWait()方法，并将当前线程的Runnable作为参数传进去，BlockingRunnable是Handler的内部类，代码如下所示。frameworks/base/core/java/android/os/Handler.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private static final class BlockingRunnable implements Runnable &#123; private final Runnable mTask; private boolean mDone; public BlockingRunnable(Runnable task) &#123; mTask = task; &#125; @Override public void run() &#123; try &#123; mTask.run(); // 1 &#125; finally &#123; synchronized (this) &#123; mDone = true; notifyAll(); &#125; &#125; &#125; public boolean postAndWait(Handler handler, long timeout) &#123; if (!handler.post(this)) &#123; // 2 return false; &#125; synchronized (this) &#123; if (timeout &gt; 0) &#123; final long expirationTime = SystemClock.uptimeMillis() + timeout; while (!mDone) &#123; long delay = expirationTime - SystemClock.uptimeMillis(); if (delay &lt;= 0) &#123; return false; // timeout &#125; try &#123; wait(delay); &#125; catch (InterruptedException ex) &#123; &#125; &#125; &#125; else &#123; while (!mDone) &#123; try &#123; wait(); // 3 &#125; catch (InterruptedException ex) &#123; &#125; &#125; &#125; &#125; return true; &#125;&#125; 注释2，将当前的BlockingRunnable添加到Handler的任务队列中。前面runWithScissors()第二个参数是0，因此timeout等于0，这样如果mDone为false的话会一直调用注释3的wait()方法，是当前线程（”system_server”线程）进入等待状态，那么等待的是哪个线程呢？往上看，注释1，执行了传入的Runnable的run()方法（运行在”andorid.display”线程），执行完毕后在finally代码块中将mDone设为true，并调用notifyAll()方法唤醒处于等待状态的线程，这样就不会继续调用注释3的代码。所以，system_server”线程线程等待的就是”android.display”线程，一直到”android.display”线程执行完毕，再执行”system_server”线程，因为”android.display”线程内部执行了WMS的创建，显然WMS的创建优先级更高。 WMS的构造方法：frameworks/base/services/core/java/com/android/server/wm/WindowManagerService .java 1234567891011121314151617181920private WindowManagerService(Context context, InputManagerService inputManager, boolean haveInputMethods, boolean showBootMsgs, boolean onlyCore, WindowManagerPolicy policy) &#123; ...... mInputManager = inputManager; // 1 Must be before createDisplayContentLocked. ...... mDisplayManager = (DisplayManager)context.getSystemService(Context.DISPLAY_SERVICE); mDisplays = mDisplayManager.getDisplays(); // 2 for (Display display : mDisplays) &#123; createDisplayContentLocked(display); // 3 &#125; ...... mActivityManager = ActivityManager.getService(); // 4 ...... mAnimator = new WindowAnimator(this); // 5 mAllowTheaterModeWakeFromLayout = context.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromWindowLayout); LocalServices.addService(WindowManagerInternal.class, new LocalService()); initPolicy(); // 6 // Add ourself to the Watchdog monitors. Watchdog.getInstance().addMonitor(this); // 7 ......&#125; 注释1，保存传进来的IMS，这样WMS就持有IMS的引用。 注释2，通过DisplayManager的getDisplays()方法，获取Display数组（每个显示设备都有一个Display实例），然后遍历Display数组。 注释3，createDisplayContentLocked()方法会将Display封装成DisplayContent（用于描述一块屏幕）。 注释4，得到AMS实例，并赋值给ActivityManager，这样WMS就持有AMS的引用。 注释5，创建WindowAnimator，用于管理所有的窗口动画。 注释6，初始化窗口管理策略的接口类WindowManagerPolicy(WMP)，它是用来定义一个窗口策略所要遵循的通用规范。 注释7，将自身，即WMS，通过addMonitor()方法添加到Watchdog中，Watchdog是用来监控系统的一些关键服务的运行状况（比如传入的WMS的运行状况），这些被监控的服务都会实现Watchdog.Monitor接口。Watchdog每分钟都会对被监控的系统服务进行检查，如果被监控的系统服务出现死锁，就会杀死Watchdog所在的进程，即SystemServer进程。 注释6，initPolicy()方法。frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java 123456789private void initPolicy() &#123; UiThread.getHandler().runWithScissors(new Runnable() &#123; @Override public void run() &#123; WindowManagerPolicyThread.set(Thread.currentThread(), Looper.myLooper()); mPolicy.init(mContext, WindowManagerService.this, WindowManagerService.this); // 1 &#125; &#125;, 0);&#125; initPolicy()方法和此前WMS的main()方法的实现类似，注释1处执行了WMP的init()方法，WMP是一个接口，init()方法的具体实现在PhoneWindowManager(PWM)中。PWM的init()方法是运行在”android.ui”线程中，它的优先级高于initPolicy()方法所在的”android.display”线程，因此”android.display”线程要等PWM的init()方法执行完毕后，处于等待状态的”android.display”线程才会被唤醒从而继续执行下面的代码。 本文共提及三个线程，”system_server”、”android.display”、”android.ui”，三者关系如下。 “system_server”线程中会调用WMS的main()方法，main()方法中会创建WMS，创建WMS的过程运行在”android.display”线程中，它的优先级更高，因此要等创建WMS完毕后才会唤醒处于等待状态的”system_server”线程。 WMS初始化时会执行initPolicy()方法，initPolicy()方法会调用PWM的init()方法，这个init()方法运行在”android.ui”线程，并且优先级更高，因此要先执行完PWM的init()方法之后，才会唤醒处于等待状态的”andorid.display”线程。 PWM的init()方法执行完毕后会接着执行运行在”system_server”线程的代码，比如WMS的systemReady()方法。","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://tylerLiu.top/categories/Android进阶/"},{"name":"框架层","slug":"Android进阶/框架层","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/"},{"name":"解析WindowManagerService","slug":"Android进阶/框架层/解析WindowManagerService","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/解析WindowManagerService/"}],"tags":[{"name":"WindowManagerService","slug":"WindowManagerService","permalink":"https://tylerLiu.top/tags/WindowManagerService/"}]},{"title":"Android解析WindowManager 03：Window的添加过程","slug":"Android解析WindowManager-03：Window的添加过程","date":"2019-10-24T08:56:00.000Z","updated":"2019-10-26T05:45:06.159Z","comments":true,"path":"2019/10/24/Android解析WindowManager-03：Window的添加过程/","link":"","permalink":"https://tylerLiu.top/2019/10/24/Android解析WindowManager-03：Window的添加过程/","excerpt":"","text":"1. 概述WindowManager对Window进行管理，包括对Window的添加、删除和更新的操作，这里统称为对Window的操作。对于Window的操作，最终都交由WMS进行处理。 窗口的操作分为两个部分：WindowManager处理部分和WMS处理部分。而Window分为三大类：Application Window（应用程序窗口）、Sub Window（子窗口）、System Window（系统窗口），不同类型的窗口添加过程会有所不同，但是对于WMS处理部分，添加的过程基本上是一样的。这里主要讲解对Window的操作的WindowManager部分。 2. 系统窗口的添加过程三大类窗口的添加过程有所不同，这里以系统窗口StatusBar为例，StatusBar是SystemUI的重要组成部分，具体就是指系统状态栏，用于显示时间、电量和信号等信息。来看看StatusBar的实现类PhoneStatusBar的addStatusBarWindow()方法，这个方法负责为StatusBar添加Window，如下。frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBar.java 123456private void addStatusBarWindow() &#123; makeStatusBarView(); // 1 mStatusBarWindowManager = new StatusBarWindowManager(mContext); mRemoteInputController = new RemoteInputController(mStatusBarWindowManager, mHeadsUpManager); mStatusBarWindowManager.add(mStatusBarWindow, getStatusBarHeight()); // 2&#125; 注释1，构建StatusBar的视图。注释2，调用StatusBarWindowManager的add()方法，并传入StatusBar的视图（StatusBarWindowView）和StatusBar。 frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarWindowManager.java 12345678910111213141516171819202122public void add(View statusBarView, int barHeight) &#123; mLp = new WindowManager.LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, barHeight, WindowManager.LayoutParams.TYPE_STATUS_BAR, // 1 WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_TOUCHABLE_WHEN_WAKING | WindowManager.LayoutParams.FLAG_SPLIT_TOUCH | WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH | WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS, PixelFormat.TRANSLUCENT); mLp.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED; mLp.gravity = Gravity.TOP; mLp.softInputMode = WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE; mLp.setTitle(\"StatusBar\"); mLp.packageName = mContext.getPackageName(); mStatusBarView = statusBarView; mBarHeight = barHeight; mWindowManager.addView(mStatusBarView, mLp); // 2 mLpChanged = new WindowManager.LayoutParams(); mLpChanged.copyFrom(mLp);&#125; 首先通过创建LayoutParams来配置StatusBar视图的属性，包括width、height、type、flag、gravity、softInputMode等。 注释1，设置TYPE_STATUSS_BAR，表示StatusBar视图的窗口类型是状态栏。注释2，调用了WindowManager的addView()方法，该方法定义在WindowManager的父类接口ViewManager中，而实现addView()的则是WindowManagerImpl。frameworks/base/core/java/android/WindowManagerImpl.java 12345@Overridepublic void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; applyDefaultToken(params); mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);&#125; 里面会调用WindowManagerGlobal的addView()：frameworks/base/core/java/android/view/WindowManagerGlobal.java 123456789101112131415161718192021222324public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; ..... //参数检查 final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params; if (parentWindow != null) &#123; parentWindow.adjustLayoutParamsForSubWindow(wparams); // 1 &#125; else &#123; ...... &#125; ViewRootImpl root; View panelParentView = null; ...... root = new ViewRootImpl(view.getContext(), display); // 2 view.setLayoutParams(wparams); mViews.add(view); mRoots.add(root); // 3 mParams.add(wparams); &#125; try &#123; root.setView(view, wparams, panelParentView); // 4 &#125; catch (RuntimeException e) &#123; ...... &#125;&#125; 首先会对参数view、params和display进行检查。 注释1，如果当前窗口要作为子窗口，就会根据父窗口对子窗口的WindowManager.LayoutParams类型的wparams对象进行相应的调整。 注释2，创建ViewRootImpl并赋值给root，紧接着在注释3将root存入到ArrayList&lt;ViewRootImpl&gt;类型的mRoots中，除了mRoots，mViews和mParams也是ArrayList类型的，分别用于存储窗口的view对象和WindowManager.LayoutParams类型的wparams对象。 注释4，调用ViewRootImpl的setView()方法。 ViewRootImpl的职责： View树的根并管理View树 触发View的测量、布局和绘制 输入事件的中转站 管理Surface 负责与WMS进行进程间通信 frameworks/base/core/java/android/view/ViewRootImpl.java 1234567891011public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123; synchronized (this) &#123; ...... try &#123; mOrigWindowType = mWindowAttributes.type; mAttachInfo.mRecomputeGlobalAttributes = true; collectViewAttributes(); res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), mAttachInfo.mContentInsets, mAttachInfo.mStableInsets, mAttachInfo.mOutsets, mInputChannel); &#125; ......&#125; 这里截取的部分，主要是调用mWindowSession的addToDisplay()方法。mWindowSession是IWindowSession类型的，它是一个Binder对象，用于进程间通信，IWindowSession是Client端的代理，它的Server端的实现为Session，此前包含ViewRootImpl在内的代码逻辑都是运行在本地进程的，而Session的addToDisplay()方法则运行在WMS所在的进程。frameworks/base/services/core/java/com/android/server/wm/Session.java 1234@Overridepublic int addToDisplay(IWindow window, int seq, WindowManager.LayoutParams attrs, int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, InputChannel outInputChannel) &#123; return mService.addWindow(this, window, seq, attrs, viewVisibility, displayId, outContentInsets, outStableInsets, outOutsets, outInputChannel);&#125; 方法中调用WMS的addWindow()方法，并将自身即Session作为参数传入，每个应用程序进程都会对应一个Session，WMS会用ArrayList来保存这些Session。这样剩下的工作就交由WMS来处理，在WMS中会为这个添加的窗口分配Surface，并确定窗口显示次序，负责显示界面的是画布Surface，而不是窗口本身。WMS会将它管理的Surfece交给SurfaceFlinger处理，SurfaceFlinger会将这些混合并绘制到屏幕上。 窗口添加的WMS处理部分会在WMS中介绍，系统窗口的添加过程的时序图如下。 3. Activity的添加过程任何窗口的添加过程在WMS处理部分基本类似，不过在权限和窗口显示次序等方面会有不同。在WindowManager中的处理会不同，最典型的就是应用程序窗口Activity，Activity在启动过程中，如果Activity所在的进程不存在，则会先创建新的进程，接着会运行代表主线程的ActivityThread实例。ActivityThread管理当前应用程序进程的线程。当界面与用户进行交互时，会调用ActivityThread的handleResumeActivity()，如下。frameworks/base/core/java/android/app/ActivityThread.java 1234567891011121314151617181920212223242526272829303132333435@Overridepublic void handleResumeActivity(IBinder token, boolean finalStateRequest, boolean isForward, String reason) &#123; ...... // TODO Push resumeArgs into the activity for consideration final ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason); // 1 ...... if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123; r.window = r.activity.getWindow(); View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); ViewManager wm = a.getWindowManager(); // 2 WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; if (r.mPreserveWindow) &#123; a.mWindowAdded = true; r.mPreserveWindow = false; ViewRootImpl impl = decor.getViewRootImpl(); if (impl != null) &#123; impl.notifyChildRebuilt(); &#125; &#125; if (a.mVisibleFromClient) &#123; if (!a.mWindowAdded) &#123; a.mWindowAdded = true; wm.addView(decor, l); // 3 &#125; else &#123; a.onWindowAttributesChanged(l); &#125; &#125; ...... &#125; ......&#125; 注释1，performResumeActivity()最终会调用Activity的onResume()。 注释2，得到ViewManager类型的对象vm，并在注释3调用vm的addView()方法，该方法的实现在WindowManagerImpl中，后面的过程在系统窗口添加过程中已经介绍过。","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://tylerLiu.top/categories/Android进阶/"},{"name":"框架层","slug":"Android进阶/框架层","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/"},{"name":"解析WindowManager","slug":"Android进阶/框架层/解析WindowManager","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/解析WindowManager/"}],"tags":[{"name":"WindowManager","slug":"WindowManager","permalink":"https://tylerLiu.top/tags/WindowManager/"}]},{"title":"Android解析WindowManager 02：Window属性","slug":"Android解析WindowManager-02：Window属性","date":"2019-10-24T01:04:25.000Z","updated":"2019-10-24T08:49:36.272Z","comments":true,"path":"2019/10/24/Android解析WindowManager-02：Window属性/","link":"","permalink":"https://tylerLiu.top/2019/10/24/Android解析WindowManager-02：Window属性/","excerpt":"","text":"1. 概述前面讲过了Window、WindowManager、WMS之间的关系，WMS是Window的最终管理者，Window如果是员工， WMS就是老板，为了方便老板管理员工，会定义一些“协议”，这些“协议”就是Window属性，被定义在WindowManager的内部类LayoutParams中。 Window的属性有很多种，最常用的有三种，Type（Window的类型）、Flag（Window的标志）、SoftInputMode（软键盘相关模式）。 2. Window的类型和显示次序Window的类型有很多种，如应用程序窗口、系统错误窗口、输入法窗口、PopupWindow、Toast、Dialog等。总的来说分成三大类：Application Window（应用程序窗口）、Sub Window（子窗口）、Syste Window（系统窗口），每个大类下面有很多种类型，它们都定义在WindowManager的静态内部类LayoutParams中。 2.1 应用程序窗口Activity就是一个典型的应用程序窗口，应用程序窗口包含的类型如下：frameworks/base/core/java/android/view/WindowManager.java 123456public static final int FIRST_APPLICATION_WINDOW = 1; // 1public static final int TYPE_BASE_APPLICATION = 1; // 窗口的基础值，其他的窗口值要大于这个值public static final int TYPE_APPLICATION = 2; // 普通的应用程序窗口类型public static final int TYPE_APPLICATION_STARTING = 3; // 应用程序启动窗口类型，用于系统在应用程序窗口启动前显示的窗口public static final int TYPE_DRAWN_APPLICATION = 4;public static final int LAST_APPLICATION_WINDOW = 99; // 2 注释1，表示应用程序类型初始值，注释2，表示应用程序窗口结束值，即应用程序窗口的Type值范围是1-99，这个数值的大小涉及到窗口的层级。 2.2 子窗口不能独立存在，需要依附在其他窗口之上，PopupWindow就是子窗口，子窗口的类型如下： 12345678public static final int FIRST_SUB_WINDOW = 1000; // 子窗口类型初始值public static final int TYPE_APPLICATION_PANEL = FIRST_SUB_WINDOW;public static final int TYPE_APPLICATION_MEDIA = FIRST_SUB_WINDOW + 1;public static final int TYPE_APPLICATION_SUB_PANEL = FIRST_SUB_WINDOW + 2;public static final int TYPE_APPLICATION_ATTACHED_DIALOG = FIRST_SUB_WINDOW + 3;public static final int TYPE_APPLICATION_MEDIA_OVERLAY = FIRST_SUB_WINDOW + 4; public static final int TYPE_APPLICATION_ABOVE_SUB_PANEL = FIRST_SUB_WINDOW + 5;public static final int LAST_SUB_WINDOW = 1999; // 子窗口类型结束值 子窗口的Type值为1000-1999。 2.3 系统窗口Toast、输入法窗口、系统音量条窗口、系统错误窗口都属于系统窗口。系统窗口的类型定义如下： 123456789public static final int FIRST_SYSTEM_WINDOW = 2000; // 系统窗口类型初始值public static final int TYPE_STATUS_BAR = FIRST_SYSTEM_WINDOW; // 系统状态栏窗口public static final int TYPE_SEARCH_BAR = FIRST_SYSTEM_WINDOW+1; // 搜索条窗口public static final int TYPE_PHONE = FIRST_SYSTEM_WINDOW+2; // 通话窗口public static final int TYPE_SYSTEM_ALERT = FIRST_SYSTEM_WINDOW+3; // 系统ALERT窗口public static final int TYPE_KEYGUARD = FIRST_SYSTEM_WINDOW+4; // 锁屏窗口public static final int TYPE_TOAST = FIRST_SYSTEM_WINDOW+5; // TOAST窗口......public static final int LAST_SYSTEM_WINDOW = 2999; // 系统窗口类型结束值 2.4 窗口显示次序当一个进程向WMS申请一个窗口时，WMS会为窗口确定显示次序。为了方便窗口显示次序的管理，手机屏幕可以虚拟的用x、y、z轴来表示，其中z轴垂直于屏幕，从屏幕内指向屏幕外，这样确定窗口显示次序就是确定窗口在z轴上的次序，这个次序称为Z-Oder。Type值是Z-Oder排序的依据。一般情况下，Type值越大，Z-Oder排序越靠前，就越靠近用户。 3. Window标志即Flag，用于控制Window的显示，也是被定义在WindowManager的内部类LayoutParams中，下面是常用的Flag： Flag 描述 FLAG_ALLOW_LOCK_WHILE_SCREEN_ON 只要窗口可见，就允许在开启状态的屏幕上锁屏 FLAG_NOT_FOCUSABLE 窗口不能获得输入焦点，设置该标志的同时，FLAG_NOT_TOUCH_MODAL也会被设置 FLAG_NOT_TOUCHABLE 窗口不接收任何触摸事件 FLAG_NOT_TOUCH_MODAL 在该窗口区域外的触摸事件会传递给其他的Window，而自己只会处理窗口区域内的触摸事件 FLAG_KEEP_SCREEN_ON 只要窗口可见，屏幕就一直亮着 FLAG_LAYOUT_NO_LIMITS 允许窗口超过屏幕外 FLAG_FULLSCREEN 隐藏所有的屏幕装饰窗口，比如在游戏、播放器中全屏显示 FLAG_SHOW_WHEN_LOCKED 窗口可以在锁屏的窗口之上显示 FLAG_IGNORE_CHEEK_PRESSES 当用户的脸贴近屏幕时（如打电话），不会去响应此事件 FLAG_TURN_SCREEN_ON 窗口显示时将屏幕点亮 设置Window的Flag有三种方式，一是通过Window的addFlag()： 12Window mWindow = getWindow(); mWindow.addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN); 二是通过Window的setFlag()： 12Window mWindow =getWindow();mWindow.setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN , WindowManager.LayoutParams.FLAG_FULLSCREEN); addFlag()内部会调用setFlag()，因此二者区别不大。 第三种是给LayoutParams设置Flag，并通过WindowManager的addView()方法进行添加。 12345WindowManager.LayoutParams mWindowLayoutParams = new WindowManager.LayoutParams();mWindowLayoutParams.flags=WindowManager.LayoutParams.FLAG_FULLSCREEN;WindowManager mWindowManager =(WindowManager) getSystemService(Context.WINDOW_SERVICE); TextView mTextView=new TextView(this);mWindowManager.addView(mTextView,mWindowLayoutParams); 4. 软键盘相关模式一般默认情况下，弹出的软键盘窗口可能会盖住输入框下面的按钮，这样用户体验不好。 为了使软键盘窗口能按照期望来显示，WindowManager的静态内部类LayoutParams中定义了软键盘相关模式，这里列举常用的几个： SoftInputMode 作用 SOFT_INPUT_STATE_UNSPECIFIED 没有指定状态，系统会选择一个合适的状态或依赖于主题的设置 SOFT_INPUT_STATE_UNCHANGED 不会改变软甲盘的状态 SOFT_INPUT_STATE_HIDDEN 当用户进入该窗口时，软键盘默认隐藏 SOFT_INPUT_STATE_ALWAYS_HIDDEN 当窗口获取焦点时，软键盘总是被隐藏 SOFT_INPUT_ADJUST_RESIZE 当软键盘弹出时，窗口会调整大小 SOFT_INPUT_ADJUST_PAN 当软键盘弹出时，窗口不需要调整大小，要确保输入焦点是可见的","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://tylerLiu.top/categories/Android进阶/"},{"name":"框架层","slug":"Android进阶/框架层","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/"},{"name":"解析WindowManager","slug":"Android进阶/框架层/解析WindowManager","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/解析WindowManager/"}],"tags":[{"name":"WindowManager","slug":"WindowManager","permalink":"https://tylerLiu.top/tags/WindowManager/"}]},{"title":"Android解析WindowManager 01：WindowManager体系","slug":"Android解析WindowManager-01：WindowManager体系","date":"2019-10-18T02:59:10.000Z","updated":"2019-10-24T01:01:44.047Z","comments":true,"path":"2019/10/18/Android解析WindowManager-01：WindowManager体系/","link":"","permalink":"https://tylerLiu.top/2019/10/18/Android解析WindowManager-01：WindowManager体系/","excerpt":"","text":"1. Window、WindowManager和WMSWindow，一个抽象类，其具体的实现是PhoneWindow，它对View进行管理。WindowManager是一个接口类，继承自接口ViewManager，用来管理Window，其实现类是WindowManagerImpl。如果要对Window进行添加和删除就可以使用WindowManager，具体的工作会由WMS来完成，WindowManager和WMS通过Binder进行跨进程通信，WMS作为系统服务，有很多API是不会暴露给WindowManager的，这点与AMS和ActivityManager类似。 这里主要介绍Window管理和输入系统。 Window包含了View，并对View进行管理，Window是一个抽象的概念，并不是真实存在的，Window的实体就是View。WindowManager用来管理Window，而WindowManager所提供的功能最终会由WMS进行处理。 2. WindowManager体系WindowManager是一个接口，继承ViewManager，ViewManager中定义了三个方法，分别用来添加、更新和删除View：frameworks/base/core/java/android/view/ViewManager.java 123456789101112131415161718/** Interface to let you add and remove child views to an Activity. To get an instance * of this class, call &#123;@link android.content.Context#getSystemService(java.lang.String) Context.getSystemService()&#125;. */public interface ViewManager &#123; /** * Assign the passed LayoutParams to the passed View and add the view to the window. * &lt;p&gt;Throws &#123;@link android.view.WindowManager.BadTokenException&#125; for certain programming * errors, such as adding a second view to a window without removing the first view. * &lt;p&gt;Throws &#123;@link android.view.WindowManager.InvalidDisplayException&#125; if the window is on a * secondary &#123;@link Display&#125; and the specified display can't be found * (see &#123;@link android.app.Presentation&#125;). * @param view The view to be added to this window. * @param params The LayoutParams to assign to view. */ public void addView(View view, ViewGroup.LayoutParams params); public void updateViewLayout(View view, ViewGroup.LayoutParams params); public void removeView(View view);&#125; WindowManager也继承了这些方法。可以看到里面传入的参数都是View，说明WindowManager具体管理的是以View形式存在的Window。WindowManager在继承ViewManager的同时，加入了其他功能，包括Window的类型和层级相关的常量、内部类以及一些方法，其中有两个方法是根据Window的特性加入的，如下。 12public Display getDefaultDisplay();public void removeViewImmediate(View view); getDefaultDisplay()：获取WindowManager实例将Window添加到哪个屏幕上，即得到WindowManager所管理的屏幕（Display）。 removeViewImmediate()：规定在这个方法返回前要立即执行View.onDetachedFromWindow()，来完成传入的View相关的销毁工作。 Window是一个抽象类，其具体实现是PhoneWindow。在Activity启动过程中会调用ActivityThread的performLaunchActivity()，performLaunchActivity()中又会调用Activity的attach()：frameworks/base/core/java/android/app/Activity.java 12345678910111213141516171819202122final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window, ActivityConfigCallback activityConfigCallback) &#123; attachBaseContext(context); mFragments.attachHost(null /*parent*/); mWindow = new PhoneWindow(this, window, activityConfigCallback); // 1 ...... // 2 mWindow.setWindowManager( (WindowManager)context.getSystemService(Context.WINDOW_SERVICE), mToken, mComponent.flattenToString(), (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0); ......&#125; 注释1，创建PhoneWindow；注释2，调用PhoneWindow的setWindowManager()，它的具体实现在PhoneWindow的父类Window中。frameworks/base/core/java/android/view/Window.java 123456789public void setWindowManager(WindowManager wm, IBinder appToken, String appName, boolean hardwareAccelerated) &#123; mAppToken = appToken; mAppName = appName; mHardwareAccelerated = hardwareAccelerated || SystemProperties.getBoolean(PROPERTY_HARDWARE_UI, false); if (wm == null) &#123; wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE); // 1 &#125; mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this); // 2&#125; 如果传入的WindowManager为空，就会在注释1调用context的getSystemService()并传入服务的名称Context.WINDOW_SERVER，具体的实现在ContextImpl中，如下。frameworks/base/core/java/android/app/ContextImpl.java 123456789@Overridepublic Object getSystemService(String name) &#123; return SystemServiceRegistry.getSystemService(this, name);&#125;@Overridepublic String getSystemServiceName(Class&lt;?&gt; serviceClass) &#123; return SystemServiceRegistry.getSystemServiceName(serviceClass);&#125; 最终会调用SystemServiceRegistry的getSystemSeviceName()。frameworks/base/core/java/android/app/SystemServiceRegistry.java 123public static String getSystemServiceName(Class&lt;?&gt; serviceClass) &#123; return SYSTEM_SERVICE_NAMES.get(serviceClass);&#125; SYSTEM_SERVICE_NAMES是一个HashMap，用来存储服务的名称。传入Context.WINDOW_SERVER对应的是什么呢？frameworks/base/core/java/android/app/SystemServiceRegistry.java 12345678910111213final class SystemServiceRegistry &#123; ...... private SystemServiceRegistry() &#123; &#125; static &#123; ...... registerService(Context.WINDOW_SERVICE, WindowManager.class, new CachedServiceFetcher&lt;WindowManager&gt;() &#123; @Override public WindowManager createService(ContextImpl ctx) &#123; return new WindowManagerImpl(ctx); &#125;&#125;); ...... &#125;&#125; 在SystemServiceRegistry的静态代码块中会调用多个registerService()方法，这里只看Context.WINDOW_SERVICE。registerService()会将传入的服务的名称存入到SYSTEM_SERVICE_NAMES中。从上面的代码可以看出，传入的Context.WINDOW_SERVICE对应的就是WindowManagerImpl的实例，因此Context的getSystemService()得到的是WindowManagerImpl实例。再回到Window的setWindowManager()中，得到WindowManagerImpl实例后转为WindowManger类型，在注释2处调用WindowManagerImpl的createLocalWindowManager()：frameworks/base/core/java/android/view/WindowManagerImpl 123public WindowManagerImpl createLocalWindowManager(Window parentWindow) &#123; return new WindowManagerImpl(mContext, parentWindow);&#125; 在里面也创建了WindowManagerImpl，不过在创建的同时，将创建它的Window作为参数传了进来，这样WindowManagerImpl就持有Window的引用了，就可以对Window进行操作，比如，在Window中添加View，来看看WindowManagerImpl的addView()：frameworks/base/core/java/android/view/WindowManagerImpl 12345@Overridepublic void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; applyDefaultToken(params); mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow); // 1&#125; 注释1，调用了WindowManagerGlobal的addView()方法，其中最后一个参数mParentWindow就是Window，WindowManagerImpl虽然是WindowManager的实现类，但是没有实现任何功能，而是将功能的实现委托给了WindowManagerGlobal，这是桥接模式。 再来看看WindowManagerImpl中是如何定义WindowManagerGlobal的：frameworks/base/core/java/android/view/WindowManagerImpl 1234567891011public final class WindowManagerImpl implements WindowManager &#123; private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance(); private final Context mContext; private final Window mParentWindow; // 1 ...... private WindowManagerImpl(Context context, Window parentWindow) &#123; mContext = context; mParentWindow = parentWindow; &#125; ...... &#125; WindowManagerGlobal是一个单例，说明在一个进程中只有一个WindowManagerGlobal实例。注释1，说明一个WindowManagerImpl可能会实现多个Window，即一个进程中可能会有多个WindowManagerImpl实例。 Window和WindowManager关系图： PhoneWindow继承自Window，Window通过setWindowManager()方法与WindowManager发生联系。WindowManager继承自接口ViewManager，WindowManagerImpl是WindowManager接口的实现类，但是具体的功能都会委托给WindowManagerGlobal来实现。","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://tylerLiu.top/categories/Android进阶/"},{"name":"框架层","slug":"Android进阶/框架层","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/"},{"name":"解析WindowManager","slug":"Android进阶/框架层/解析WindowManager","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/解析WindowManager/"}],"tags":[{"name":"WindowManager","slug":"WindowManager","permalink":"https://tylerLiu.top/tags/WindowManager/"}]},{"title":"九、深入理解绘制原理","slug":"九、深入理解绘制原理","date":"2019-09-25T07:33:53.000Z","updated":"2019-09-25T09:12:54.525Z","comments":true,"path":"2019/09/25/九、深入理解绘制原理/","link":"","permalink":"https://tylerLiu.top/2019/09/25/九、深入理解绘制原理/","excerpt":"","text":"通过前面知道了Widget、Element、RenderObject的关系，也知道Widget的布局逻辑，最终所有Widget都转化为RenderObject对象，它们堆叠出所需的画面。 所以在Flutter中，最终页面的Layout、Paint等都会发生在Widget所对应的RenderObject子类中，而RenderObject也是Flutter跨平台最大的特点之一：所有的控件都与平台无关。简而言之，Flutter只要求系统提供Canvas，然后开发者通过Widget生成RenderObject“直接”通过引擎绘制到屏幕上。 1. 绘制过程Widget最终都会转化为RenderObject，所以要了解绘制过程，要先看RenderObject的paint()： 123456789101112131415161718/// Paint this render object into the given context at the given offset.////// Subclasses should override this method to provide a visual appearance/// for themselves. The render object's local coordinate system is/// axis-aligned with the coordinate system of the context's canvas and the/// render object's local origin (i.e, x=0 and y=0) is placed at the given/// offset in the context's canvas.////// Do not call this function directly. If you wish to paint yourself, call/// [markNeedsPaint] instead to schedule a call to this function. If you wish/// to paint one of your children, call [PaintingContext.paintChild] on the/// given `context`.////// When painting one of your children (via a paint child function on the/// given context), the current canvas held by the context might change/// because draw operations before and after painting children might need to/// be recorded on separate compositing layers.void paint(PaintingContext context, Offset offset) &#123; &#125; 所有的RenderObject子类都必须实现paint()方法，并且该方法并不是给用户直接调用，需要更新绘制时，可以通过markNeddsPaint()方法去触发界面绘制。按照正常流程，在经历大小和布局等位置计算之后，最终paint()方法就会被调用，该方法有两个参数，它们是完成绘制的关键。 PaintingContext的关键是A place to paint，同时它在父类ClipContext是包含有Canvas，并且PaintingContext的构造方法是@protected，只在PaintingContext.repaintCompositedChild和pushLayer时自动创建。 Offset在paint()中主要是提供当前控件在屏幕的相对偏移值，提供绘制时确定绘制的坐标。 123456789101112131415161718192021222324252627/// A place to paint.////// Rather than holding a canvas directly, [RenderObject]s paint using a painting/// context. The painting context has a [Canvas], which receives the/// individual draw operations, and also has functions for painting child/// render objects.////// When painting a child render object, the canvas held by the painting context/// can change because the draw operations issued before and after painting the/// child might be recorded in separate compositing layers. For this reason, do/// not hold a reference to the canvas across operations that might paint/// child render objects.////// New [PaintingContext] objects are created automatically when using/// [PaintingContext.repaintCompositedChild] and [pushLayer].class PaintingContext extends ClipContext &#123; /// Creates a painting context. /// /// Typically only called by [PaintingContext.repaintCompositedChild] /// and [pushLayer]. @protected PaintingContext(this._containerLayer, this.estimatedBounds) : assert(_containerLayer != null), assert(estimatedBounds != null); final ContainerLayer _containerLayer; PaintingContext，从字面上可以看出来它是存在上下文关系，它是在哪开始创建的呢？ 通过源码可以知道，项目在runApp()时，通过WidgetsFlutterBinding启动，而WidgetsFlutterBinding是一个“胶水类”，它会触发Mixins的RenderBinding，如下，创建根node的PaintingContext。 那么Offset呢？在RenderBoxContainerDefaultsMixin可以看到： 1234567891011121314/// Paints each child by walking the child list forwards.////// See also:////// * [defaultHitTestChildren], which implements hit-testing of the children/// in a manner appropriate for this painting strategy.void defaultPaint(PaintingContext context, Offset offset) &#123; ChildType child = firstChild; while (child != null) &#123; final ParentDataType childParentData = child.parentData; context.paintChild(child, childParentData.offset + offset); child = childParentData.nextSibling; &#125;&#125; 对于Offset的传递，是通过父控件和子控件的offset相加之后，一级一级的将需要绘制的坐标结合去传递的。 简单来说，通过PaintingContext和Offset，在布局之后九可以在屏幕上准确绘制绘制需要的画面。 1.1 测试绘制来做一个简单测试。 在屏幕上通过Container限制一个高为60的绿色容器，","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://tylerLiu.top/categories/Flutter/"},{"name":"学习","slug":"Flutter/学习","permalink":"https://tylerLiu.top/categories/Flutter/学习/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://tylerLiu.top/tags/Flutter/"}]},{"title":"八、实用技巧与填坑","slug":"八、实用技巧与填坑","date":"2019-09-25T03:03:25.000Z","updated":"2019-09-25T07:36:12.005Z","comments":true,"path":"2019/09/25/八、实用技巧与填坑/","link":"","permalink":"https://tylerLiu.top/2019/09/25/八、实用技巧与填坑/","excerpt":"","text":"1. Text的TextOverflow.ellipsis不生效设置没有生效，提示如下overflow的警告。大部分时候，这是Text内部的RenderParagraph在判断final bool didOverflowWidth = size.with &lt; textSize.width;时，size.width和textSize.width相等导致。 这需要给Text设置一个Container之类的去约束它的大小，或者是Row中通过Expanded + Container去约束Text。 2. 获取控件的大小和位置前面有介绍过，可以用GlobalKey，通过key去获取到控件对象的buildContext，而前面也说过BuildContext的实现其实是Element，而Element持有RenderObject。所以，RenderObject实际上就是RenderBox，那么通过RenderBox就可以获取控件的大小和位置了： 123456789showSizes() &#123; RenderBox renderBoxRed = fileListKey.currentContext.findRenderObject(); print(renderBoxRed.size);&#125;showPositions() &#123; RenderBox renderBoxRed = fileListKey.currentContext.findRenderObject(); print(renderBoxRed.localToGlobal(Offset.zero));&#125; 3. 获取状态栏高度和安全布局MaterialApp源码内部是一个WidgetApp，而WidgetApp内有一个MediaQuery，所以可以通过MediaQuery.of(context).size去获取屏幕的大小。 MediaQuery其实是一个InheritedWidget，里面有一个MediaQueryData参数，该参数是通过下面的代码设置的，在通过源码可以知道，一般情况下MediaQueryData的padding的top就是状态栏的高度。所以，可以通过MediaQueryData.fromWindow(WidgetsBinding.instance.window).padding.top获取到状态栏高度，有时可能需要考虑viewInsets参数。 123456789class DemoWindow extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MediaQuery( data: MediaQueryData.fromWindow(WidgetsBinding.instance.window), child: Localizations(locale: null, delegates: null), ); &#125;&#125; 至于AppBar的高度，默认是Size.fromHeight(kToolBarHeight + (bottom?.perferredSize?.height ?? 0.0)),，kToolBarHeight是一个固定的数值，可以通过实现PerferredSizeWidget去自定义AppBar。 有时布局位置是从状态栏开始计算的，这时需要用SafeArea嵌套下，原因是因为MediaQueryData的存在，具体需要查看源码。 4. 设置状态栏颜色和图标颜色可以通过AppBar的brightness或者ThemeData去设置状态栏颜色。 如果不想用AppBar，可以嵌套AnnotateRegion&lt;SystemUiOverlayStyle&gt;去设置状态栏样式，通过SystemUiOverlayStyle就可以快速设置状态栏和底部导航栏的样式。 同时还可以通过SystemChrome.setSystemUIOverlayStyle去设置，前提是，没有使用AppBar。注意，所有状态栏设置都是全局的。如果在A页面设置之后，在B页面没有手动设置或者使用AppBar，那么设置的状态栏就会显示在B页面。 5. 系统字体缩放现在一般手机都有字体缩放，大多时候，会选择禁止应用字体跟随系统字体缩放。 Flutter中的字体缩放和MediaQueryData和textScaleFactor有关。可以在需要的页面，通过最外层嵌套如下代码设置，将字体设置为默认不允许缩放。 1234MediaQuery( data: MediaQueryData.fromWindow(WidgetsBinding.instance.window).copyWith(textScaleFactor: 1), child: new Container(),); 6. Margin和Padding在使用Container时，经常会使用margin和padding，Container其实只是对各种布局的封装，内部的margin和padding其实是通过Padding实现的，而Padding不支持负数，如果需要使用负数，可以使用Transform。 1234Transform( transform: Matrix4.translationValues(10, -10, 0), child: new Container(),); 7. 控件圆角剪切日常开发中大致会用到两种圆角方案： 通过Decoration的实现类BoxDecoration去实现。 通过ClipRRect去实现。 其中BoxDecoration一般用在DecoratedBox、Container等控件，这种实现一般都是直接Canvas绘制时，针对当前控件进行背景圆角化，并不会影响其child。意味着如果child也是图片或者也有背景色，圆角效果就有可能消失。 而ClipRRect的效果就会影响child，如下RenderObject源码可知： 1234567891011121314151617181920212223242526272829/// Clip further painting using a rounded rectangle.////// &#123;@macro flutter.rendering.object.needsCompositing&#125;/// * `offset` is the offset from the origin of the canvas' coordinate system/// to the origin of the caller's coordinate system./// * `bounds` is the region of the canvas (in the caller's coordinate system)/// into which `painter` will paint in./// * `clipRRect` is the rounded-rectangle (in the caller's coordinate system)/// to use to clip the painting done by `painter`./// * `painter` is a callback that will paint with the `clipRRect` applied. This/// function calls the `painter` synchronously./// * `clipBehavior` controls how the path is clipped./// &#123;@macro flutter.rendering.object.oldLayer&#125;ClipRRectLayer pushClipRRect(bool needsCompositing, Offset offset, Rect bounds, RRect clipRRect, PaintingContextCallback painter, &#123; Clip clipBehavior = Clip.antiAlias, ClipRRectLayer oldLayer &#125;) &#123; assert(clipBehavior != null); final Rect offsetBounds = bounds.shift(offset); final RRect offsetClipRRect = clipRRect.shift(offset); if (needsCompositing) &#123; final ClipRRectLayer layer = oldLayer ?? ClipRRectLayer(); layer ..clipRRect = offsetClipRRect ..clipBehavior = clipBehavior; pushLayer(layer, painter, offset, childPaintBounds: offsetBounds); return layer; &#125; else &#123; clipRRectAndPaint(offsetClipRRect, clipBehavior, offsetBounds, () =&gt; painter(this, offset)); return null; &#125;&#125; 8. PageView如果在使用TarBarView，并且使用KeepAlive的话，推荐使用PageView。因为在1.2版本中，在KeepAlive的状态下，跨两个页面以上的Tab直接切换，TabBarView会导致页面的dispose()，再重新initState()。尽管TarBarView内部封装了PageView + TabBar。 可以直接使用PageView + TabBar去实现，在tab切换时，使用_pageController.jumpTo(MediaQuery.of(context).size.with * index);可以避免一些问题。当然，这时损失的就是动画效果。事实上，TarBarView只是针对PageView + TabBar进行了封装。 除了这个，还有第二个方法，使用如下PageStorageKey保持页面数状态，因为它是save and restore values，所以页面的dispose()再重新initState()方法，每次都会被调用。 123return new Scaffold( key: new PageStorageKey&lt;your value type&gt;(your value)) 9. 懒加载Flutter中通过FutureBuilder或者StreamBuilder可以简单的实现懒加载，通过future或者stream“异步”获取数据，之后通过AsyncSnapshot的data再去加载数据，至于流和异步的概念，后面再展开讲解。 10. Android返回键回到桌面Flutter官方提供了android_intent插件，实现回到桌面可以按照如下实现： 1234567891011121314151617 Future&lt;bool&gt; _dialogExitApp(BuildContext context) async &#123; if (Platform.isAndroid) &#123; AndroidIntent intent = AndroidIntent( action: 'android.intent.action.MAIN', category: \"android.intent.category.HOME\", ); await intent.launch(); &#125; return Future.value(false); &#125;····· return WillPopScope( onWillPop: () &#123; return _dialogExitApp(context); &#125;, child:xxx);","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://tylerLiu.top/categories/Flutter/"},{"name":"学习","slug":"Flutter/学习","permalink":"https://tylerLiu.top/categories/Flutter/学习/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://tylerLiu.top/tags/Flutter/"}]},{"title":"七、深入布局原理","slug":"七、深入布局原理","date":"2019-09-24T08:36:59.000Z","updated":"2019-09-25T03:02:35.852Z","comments":true,"path":"2019/09/24/七、深入布局原理/","link":"","permalink":"https://tylerLiu.top/2019/09/24/七、深入布局原理/","excerpt":"","text":"前面了解了Widget、Element、RenderObject三者之间的关系，Widget是作为“配置文件”存在的，在Flutter中，其功能比较单一。 1. 单子元素布局在Flutter单子元素的布局Widget中，Container使用广泛，因为它在功能上并不会像Padding等Widget那样功能单一，为什么呢？ Container的build()的实现： 1234567891011121314151617181920212223242526272829303132333435363738394041@overrideWidget build(BuildContext context) &#123; Widget current = child; if (child == null &amp;&amp; (constraints == null || !constraints.isTight)) &#123; current = LimitedBox( maxWidth: 0.0, maxHeight: 0.0, child: ConstrainedBox(constraints: const BoxConstraints.expand()), ); &#125; if (alignment != null) current = Align(alignment: alignment, child: current); final EdgeInsetsGeometry effectivePadding = _paddingIncludingDecoration; if (effectivePadding != null) current = Padding(padding: effectivePadding, child: current); if (decoration != null) current = DecoratedBox(decoration: decoration, child: current); if (foregroundDecoration != null) &#123; current = DecoratedBox( decoration: foregroundDecoration, position: DecorationPosition.foreground, child: current, ); &#125; if (constraints != null) current = ConstrainedBox(constraints: constraints, child: current); if (margin != null) current = Padding(padding: margin, child: current); if (transform != null) current = Transform(transform: transform, child: current); return current;&#125; 从源码可以看出，Container其实也只是把其他“单一”的Widget进行了二次封装，然后通过配置来达到“多功能”的效果。 接着查看ContainerBox的源码： 12345678910111213141516171819202122232425262728293031class ConstrainedBox extends SingleChildRenderObjectWidget &#123; /// Creates a widget that imposes additional constraints on its child. /// /// The [constraints] argument must not be null. ConstrainedBox(&#123; Key key, @required this.constraints, Widget child, &#125;) : assert(constraints != null), assert(constraints.debugAssertIsValid()), super(key: key, child: child); /// The additional constraints to impose on the child. final BoxConstraints constraints; @override RenderConstrainedBox createRenderObject(BuildContext context) &#123; return RenderConstrainedBox(additionalConstraints: constraints); &#125; @override void updateRenderObject(BuildContext context, RenderConstrainedBox renderObject) &#123; renderObject.additionalConstraints = constraints; &#125; @override void debugFillProperties(DiagnosticPropertiesBuilder properties) &#123; super.debugFillProperties(properties); properties.add(DiagnosticsProperty&lt;BoxConstraints&gt;('constraints', constraints, showName: false)); &#125;&#125; 从源码可以看出，它继承了SingleChildRenderObjectWidget，重写了createRenderObject()，返回RenderConstrainedBox。RenderConstrainedBox继承自RenderBox，从而实现了RenderObject布局，关系是： Widget RenderBox（RenderObject） ConstrainedBox RenderConstrainedBox 再来看看其他Widget，可以看到它们都是继承SingleChildRenderObjectWidget，简单来说，它们的不同之处就是RenderObject的实现： Widget RenderBox（RenderObject） Align RenderPositionBox Padding RenderPadding Transform RenderTransform Offstage RenderOffstage 总结：真正的布局和大小计算等行为，都是在RenderBox上实现的。不同Widget通过各自RenderBox实现不同的布局效果。所以找每个Widget的实现，找它们的RenderBox即可。 这里以Offstage为例，Offstage是通过offstage标志控制child是否显示的效果，它也有一个RenderOffstage，如下，通过RenderOffstage的源码可以看到offstage标志位的作用： 123456789101112131415161718192021222324252627@overridedouble computeMinIntrinsicWidth(double height) &#123; if (offstage) return 0.0; return super.computeMinIntrinsicWidth(height);&#125;@overridedouble computeMaxIntrinsicWidth(double height) &#123; if (offstage) return 0.0; return super.computeMaxIntrinsicWidth(height);&#125;@overridedouble computeMinIntrinsicHeight(double width) &#123; if (offstage) return 0.0; return super.computeMinIntrinsicHeight(width);&#125;@overridedouble computeMaxIntrinsicHeight(double width) &#123; if (offstage) return 0.0; return super.computeMaxIntrinsicHeight(width);&#125; 所以大部分时候，Widget都是通过实现RenderBox实现布局的，因此可以直接使用RenderBox，而不使用Widget。 Flutter官方提供了一个CustomSingleChildLayout的类，它抽象了SingleChildLayoutDelegate的对象，使开发者可以方便的使用RenderBox来自定义效果。 123456789101112131415161718192021222324class CustomSingleChildLayout extends SingleChildRenderObjectWidget &#123; /// Creates a custom single child layout. /// /// The [delegate] argument must not be null. const CustomSingleChildLayout(&#123; Key key, @required this.delegate, Widget child, &#125;) : assert(delegate != null), super(key: key, child: child); /// The delegate that controls the layout of the child. final SingleChildLayoutDelegate delegate; @override RenderCustomSingleChildLayoutBox createRenderObject(BuildContext context) &#123; return RenderCustomSingleChildLayoutBox(delegate: delegate); &#125; @override void updateRenderObject(BuildContext context, RenderCustomSingleChildLayoutBox renderObject) &#123; renderObject.delegate = delegate; &#125;&#125; 再来看看SingleChildLayoutDelegate： 12345678910111213141516171819202122abstract class SingleChildLayoutDelegate &#123; /// Creates a layout delegate. /// /// The layout will update whenever [relayout] notifies its listeners. const SingleChildLayoutDelegate(&#123; Listenable relayout &#125;) : _relayout = relayout; final Listenable _relayout; // 下面前三个方法是按照顺序执行的 // 给定大小 Size getSize(BoxConstraints constraints) =&gt; constraints.biggest; // 约束限制子控件的大小 BoxConstraints getConstraintsForChild(BoxConstraints constraints) =&gt; constraints; // 确定位置 Offset getPositionForChild(Size size, Size childSize) =&gt; Offset.zero; // 是否需要重新布局 bool shouldRelayout(covariant SingleChildLayoutDelegate oldDelegate);&#125; 再在RenderCustomSingleChildLayoutBox中使用： 123456789101112131415161718192021222324252627282930/// A delegate that controls this object's layout.SingleChildLayoutDelegate get delegate =&gt; _delegate;SingleChildLayoutDelegate _delegate;set delegate(SingleChildLayoutDelegate newDelegate) &#123; assert(newDelegate != null); if (_delegate == newDelegate) return; final SingleChildLayoutDelegate oldDelegate = _delegate; if (newDelegate.runtimeType != oldDelegate.runtimeType || newDelegate.shouldRelayout(oldDelegate)) markNeedsLayout(); _delegate = newDelegate; if (attached) &#123; oldDelegate?._relayout?.removeListener(markNeedsLayout); newDelegate?._relayout?.addListener(markNeedsLayout); &#125;&#125;......@overridevoid performLayout() &#123; size = _getSize(constraints); if (child != null) &#123; final BoxConstraints childConstraints = delegate.getConstraintsForChild(constraints); assert(childConstraints.debugAssertIsValid(isAppliedConstraint: true)); child.layout(childConstraints, parentUsesSize: !childConstraints.isTight); final BoxParentData childParentData = child.parentData; childParentData.offset = delegate.getPositionForChild(size, childConstraints.isTight ? childConstraints.smallest : child.size); &#125;&#125; 从而控制RenderBox的布局位置、大小等。 2. 多子元素布局多子元素布局和单子元素布局类似，比如： Row、Colum都继承了Flex，而Flex继承了MultiChildRenderObjectWidget，并通过RenderFlex创建RenderBox； Stack同样继承了MultiChildRenderObjectWidget，并通过RenderStack创建RenderBox。 Widget RenderBox（RenderObject） Row/Colum/Flex RenderFlex Stack RenderStack Flow RenderFlow Wrap RenderWrap 同样，多子元素布局也提供了CustomMultiChildLayout和MultiChildLayoutDelegate来满足不同的需求。 3. 多子元素滑动布局滑动布局作为多子元素的一个分支，如ListView、GridView、PageView，它们在实现上要复杂的多，下面是它们的关系图： 从上图可知，最终会产生两个RenderObject： RenderSliver：Base class for the render objects that implement scroll effects in viewports. RenderViewpotr：A render object that is bigger on the inside. RenderViewport的部分注释： 123/// [RenderViewport] cannot contain [RenderBox] children directly. Instead, use/// a [RenderSliverList], [RenderSliverFixedExtentList], [RenderSliverGrid], or/// a [RenderSliverToBoxAdapter], for example. 从这部分的注释可以看出，RenderViewport内部不能直接放置RenderBox，需要通过RenderSliver及其相关的类来完成布局。从源码可知：RenderViewport对应的Widget Viewpoer就是一个MultiChildRenderObjectWidget。这就又回到了MultiChildRenderObjectWidget。 再简单说明上面的流程图： ListView、GridView、PageView等都是通过Scrollable、Viewport、Sliver家族实现的效果。这里可以简单理解为：一个“可滑动”控件，嵌套了一个“视觉窗口”，内部通过“碎片”展示children。 不同的是PageView没有继承ScrollView，而是直接通过NotificationListener和ScrollNotification嵌套实现。 TabBarView内部就是NotificationListener + PageView。 官方提供了自定义滑动CustomScrollView，它继承了ScrollView，可以通过slivers参数实现布局，这些slivers最终通过Scrollable的buildViewport添加到Viewport中，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import 'package:flutter/material.dart';class CustomScrollViewDemo extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return CustomScrollView( slivers: &lt;Widget&gt;[ const SliverAppBar( pinned: true, expandedHeight: 250.0, flexibleSpace: FlexibleSpaceBar( title: Text(\"CustomScrollViewDemo\"), ), ), SliverGrid( gridDelegate: SliverGridDelegateWithMaxCrossAxisExtent( maxCrossAxisExtent: 200.0, mainAxisSpacing: 10.0, crossAxisSpacing: 10.0, childAspectRatio: 4.0, ), delegate: SliverChildBuilderDelegate( (BuildContext context, int index) &#123; return Container( alignment: Alignment.center, color: Colors.teal[100 * (index % 9)], child: Text('girid item $index'), ); &#125;, childCount: 20, ), ), SliverFixedExtentList( itemExtent: 50.0, delegate: SliverChildBuilderDelegate((BuildContext context, int index) &#123; return Container( alignment: Alignment.center, color: Colors.lightBlue[100 * (index % 9)], child: Text('list item $index'), ); &#125;), ), ], ); &#125;&#125;","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://tylerLiu.top/categories/Flutter/"},{"name":"学习","slug":"Flutter/学习","permalink":"https://tylerLiu.top/categories/Flutter/学习/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://tylerLiu.top/tags/Flutter/"}]},{"title":"六、深入Widget原理","slug":"六、深入Widget原理","date":"2019-09-24T06:43:27.000Z","updated":"2019-09-24T08:34:46.228Z","comments":true,"path":"2019/09/24/六、深入Widget原理/","link":"","permalink":"https://tylerLiu.top/2019/09/24/六、深入Widget原理/","excerpt":"","text":"Widget：并不是真正渲染的对象。事实上，在Flutter渲染是经历了从Widget到Element再到RenderObject的过程。 Widget是不可变的，那么Widget是如何在不可变中去构建画面的？从前面知道，Widget是需要转换为Element去渲染的，从下面的注释可以知道，事实上Widget只是Element的一个配置描述，告诉Element这个实例如何去渲染。 123456789101112@immutableabstract class Widget extends DiagnosticableTree &#123; /// Inflates this configuration to a concrete instance. /// /// A given widget can be included in the tree zero or more times. In particular /// a given widget can be placed in the tree multiple times. Each time a widget /// is placed in the tree, it is inflated into an [Element], which means a /// widget that is incorporated into the tree multiple times will be inflated /// multiple times. @protected Element createElement();&#125; Widget和Element之间是怎样的对应关系呢？从上面的注释可以知道：Widget和Element之间是一对多的关系。实际上渲染树是由Element实例的节点构成的，而作为配置文件的Widget可能被复制到树的多个部分，对应产生多个Element对象。 RenderObject又是什么呢？它和Widget、Element有什么关系？源码注释写道：An object in the render tree，可以看出，RenderObject才是实际的渲染对象，通过Element的源码可以看到：Element持有RenderObject和Widget。 12345678910111213141516171819202122/// The configuration for this element.@overrideWidget get widget =&gt; _widget;Widget _widget;/// The render object at (or below) this location in the tree.////// If this object is a [RenderObjectElement], the render object is the one at/// this location in the tree. Otherwise, this getter will walk down the tree/// until it finds a [RenderObjectElement].RenderObject get renderObject &#123; RenderObject result; void visit(Element element) &#123; assert(result == null); // this verifies that there's only one child if (element is RenderObjectElement) result = element.renderObject; else element.visitChildren(visit); &#125; visit(this); return result;&#125; 再结合： 1234567891011/// Creates an instance of the [RenderObject] class that this/// [RenderObjectWidget] represents, using the configuration described by this/// [RenderObjectWidget].////// This method should not do anything with the children of the render object./// That should instead be handled by the method that overrides/// [RenderObjectElement.mount] in the object rendered by this object's/// [createElement] method. See, for example,/// [SingleChildRenderObjectElement.mount].@protectedRenderObject createRenderObject(BuildContext context); 可以得出三者的关系：配置文件Widget生成了Element，而后创建RenderObject关联到Element的内部renderObject对象上，最后Flutter通过RenderObject数据来布局和绘制。理论上可以认为RenderObject是最终给Flutter的渲染数据，它保存了大小和位置等信息，Flutter通过它去绘制画面。 说到RenderObject，就需要说说RenderBox：A render object in a 2D Cartesian coordinate system，从注释可以看出，它是在继承RenderObject基础的布局和绘制功能上，实现了“笛卡尔坐标系”：以Top、Left为基点，通过宽高两个轴实现布局和嵌套的。 RenderBox避免了直接使用RenderObject的麻烦场景，其中RenderBox的布局和计算大小是在performLayout()和performSize()两个方法中实现的，很多时候更多的是选择继承RenderBox去实现自定义。 综上情况： Widget只是显示数据配置，所以相对而言是轻量级的存在，而Flutter中对Widget也做了一定的优化，所以每次改变状态导致的Widget重构并不会有太大的问题。 RenderObject就不同了，RenderObject涉及到布局、计算、绘制等流程，要是每次都全部重新创建，开销就比较大。 所以对于是否每次都创建新的Element和RenderObject对象，Widget都做了对应的判断以便于复用，比如：在newWidget与oldWidget的runtimeType和key相等时，会选择使用newWidget去更新已经存在的Element对象，否则就选择重新创建新的Element。 由此可知：Widget重新创建，Element树和RenderObject树并不会完全重新创建。 如何获取布局的大小和位置呢？ 首先需要用到前面提过的GlobalKey，通过key获取控件对象的BuildContext，而BuildContext的实现其实是Element，而Element持有RenderObject，所以，RenderObject实际上获取的是RenderBox，那么通过RenderBox就能知道布局的大小和位置了。 123456789showSizes() &#123; RenderBox renderBoxRed = fileListKey.currentContext.findRenderObject(); print(renderBoxRed.size);&#125;showPositions() &#123; RenderBox renderBoxRed = fileListKey.currentContext.findRenderObject(); print(renderBoxRed.localToGlobal(Offset.zero));&#125;","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://tylerLiu.top/categories/Flutter/"},{"name":"学习","slug":"Flutter/学习","permalink":"https://tylerLiu.top/categories/Flutter/学习/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://tylerLiu.top/tags/Flutter/"}]},{"title":"五、深入探究","slug":"五、深入探究","date":"2019-09-19T09:15:45.000Z","updated":"2019-09-24T06:42:33.545Z","comments":true,"path":"2019/09/19/五、深入探究/","link":"","permalink":"https://tylerLiu.top/2019/09/19/五、深入探究/","excerpt":"","text":"Demo地址：tyler_flutter_app 1. WidgetsFlutterBinding胶水类。 1.1 Mixins直译：混入。 Flutter使用的Dart支持Mixins，Mixins能更好的解决多继承中出现的问题，如：方法优先顺序混乱、参数冲突、类结构复杂化等。 示例： 12345678910111213141516171819202122232425262728293031323334353637383940class A &#123; a() &#123; print(\"A.a()\"); &#125; b() &#123; print(\"A.b()\"); &#125;&#125;class A2 &#123; a() &#123; print(\"A2.a()\"); &#125;&#125;class B &#123; a() &#123; print(\"B.a()\"); &#125; b() &#123; print(\"B.b()\"); &#125; c() &#123; print(\"B.c()\"); &#125;&#125;class G extends B with A, A2 &#123;&#125;testMixins() &#123; G t = new G(); t.a(); t.b(); t.c();&#125; 输出： 123I/flutter (13627): A2.a()I/flutter (13627): A.b()I/flutter (13627): B.c() Dart中，with就是用于Mixins。class G extends B with A, A2，在执行G的a()、b()、c()方法之后，输出A2.a()、A.b()、B.c()。 结论：相同方法被覆盖了，并且with后面的会覆盖前面的。 下面继续修改代码。定义一个Base抽象类，A、A2、B都继承它，同时print()执行之后，执行super()操作。 从输出可以看出，A、A2、B中的所有方法都被执行，且只执行一次，同时执行顺序和with顺序有关。如果把class A.a()方法的super去掉，就不会有B.a()和base a()的输出。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758abstract class Base &#123; a() &#123; print(\"base a()\"); &#125; b() &#123; print(\"base b()\"); &#125; c() &#123; print(\"base c()\"); &#125;&#125;class A extends Base &#123; a() &#123; print(\"A.a()\"); super.a(); &#125; b() &#123; print(\"A.b()\"); super.b(); &#125;&#125;class A2 extends Base &#123; a() &#123; print(\"A2.a()\"); super.a(); &#125;&#125;class B extends Base &#123; a() &#123; print(\"B.a()\"); super.a(); &#125; b() &#123; print(\"B.b()\"); super.b(); &#125; c() &#123; print(\"B.c()\"); super.c(); &#125;&#125;class G extends B with A, A2 &#123;&#125;testMixins() &#123; G t = new G(); t.a(); t.b(); t.c();&#125; 输出： 123456789A2.a()A.a()B.a()base a()A.b()B.b()base b()B.c()base c() 1.2 WidgetsFlutteBinding12345678910111213141516171819202122/// A concrete binding for applications based on the Widgets framework.////// This is the glue that binds the framework to the Flutter engine.class WidgetsFlutterBinding extends BindingBase with GestureBinding, ServicesBinding, SchedulerBinding, PaintingBinding, SemanticsBinding, RendererBinding, WidgetsBinding &#123; /// Returns an instance of the [WidgetsBinding], creating and /// initializing it if necessary. If one is created, it will be a /// [WidgetsFlutterBinding]. If one was previously initialized, then /// it will at least implement [WidgetsBinding]. /// /// You only need to call this method if you need the binding to be /// initialized before calling [runApp]. /// /// In the `flutter_test` framework, [testWidgets] initializes the /// binding instance to a [TestWidgetsFlutterBinding], not a /// [WidgetsFlutterBinding]. static WidgetsBinding ensureInitialized() &#123; if (WidgetsBinding.instance == null) WidgetsFlutterBinding(); return WidgetsBinding.instance; &#125;&#125; WidgetsFlutterBinding在Flutter启动时，runApp()会被调用，作为App的入口，需要承担类的初始化以及功能配置，这时，Mixins的作用就体现出来了。 1234567891011121314151617181920212223242526272829303132333435363738394041/// The glue between the widgets layer and the Flutter engine.mixin WidgetsBinding on BindingBase, SchedulerBinding, GestureBinding, RendererBinding, SemanticsBinding &#123;&#125;/// The glue between the render tree and the Flutter engine.mixin RendererBinding on BindingBase, ServicesBinding, SchedulerBinding, GestureBinding, SemanticsBinding, HitTestable &#123;&#125;/// The glue between the semantics layer and the Flutter engine.mixin SemanticsBinding on BindingBase &#123;&#125;/// Binding for the painting library.////// Hooks into the cache eviction logic to clear the image cache.////// Requires the [ServicesBinding] to be mixed in earlier.mixin PaintingBinding on BindingBase, ServicesBinding &#123;&#125;/// Scheduler for running the following:////// * _Transient callbacks_, triggered by the system's [Window.onBeginFrame]/// callback, for synchronizing the application's behavior to the system's/// display. For example, [Ticker]s and [AnimationController]s trigger from/// these.////// * _Persistent callbacks_, triggered by the system's [Window.onDrawFrame]/// callback, for updating the system's display after transient callbacks have/// executed. For example, the rendering layer uses this to drive its/// rendering pipeline.////// * _Post-frame callbacks_, which are run after persistent callbacks, just/// before returning from the [Window.onDrawFrame] callback.////// * Non-rendering tasks, to be run between frames. These are given a/// priority and are executed in priority order according to a/// [schedulingStrategy].mixin SchedulerBinding on BindingBase, ServicesBinding &#123;&#125;/// Listens for platform messages and directs them to the [defaultBinaryMessenger]mixin ServicesBinding on BindingBase &#123;&#125;/// A binding for the gesture subsystem.mixin GestureBinding on BindingBase implements HitTestable, HitTestDispatcher, HitTestTarget &#123;&#125; WidgetsFlutterBinding本身没有什么代码，主要继承了BindingBase，之后通过with黏上各类Binding，这些Binding也继承了BindingBase。 这些Binding都可以被单独使用，也可以被“黏”到 WidgetsFlutterBinding中使用，这样的结构比一层一层继承的结构更加清晰。 下面是执行顺序： 2. InheritedWidgetInheritedWidget是一个抽象类。 123456789101112131415161718192021222324abstract class InheritedWidget extends ProxyWidget &#123; /// Abstract const constructor. This constructor enables subclasses to provide /// const constructors so that they can be used in const expressions. const InheritedWidget(&#123; Key key, Widget child &#125;) : super(key: key, child: child); @override InheritedElement createElement() =&gt; InheritedElement(this); /// Whether the framework should notify widgets that inherit from this widget. /// /// When this widget is rebuilt, sometimes we need to rebuild the widgets that /// inherit from this widget but sometimes we do not. For example, if the data /// held by this widget is the same as the data held by `oldWidget`, then we /// do not need to rebuild the widgets that inherited the data held by /// `oldWidget`. /// /// The framework distinguishes these cases by calling this function with the /// widget that previously occupied this location in the tree as an argument. /// The given widget is guaranteed to have the same [runtimeType] as this /// object. @protected bool updateShouldNotify(covariant InheritedWidget oldWidget);&#125; 里面主要实现了两个方法： 创建了InheritedElement，该Element属于特殊Element，主要增加了将自身也添加到映射关系表_inheritedWidgets，方便子element获取；同时通过notifyClients()来更新依赖。 增加updateShouldNotify()方法，当方法返回true时，依赖该Widget的示例就会更新。 可以简单理解为：InheritedWidget通过InheritedElement实现了由下往上查找的支持（因为自身添加到_inheritedWidgets），同时具备更新其子类的功能。 注：每个Element都有一个_inheriteWidgets，它是一个HashMap&lt;Type, InheritedElement&gt;，它保存了上层节点出现的InherotedWidget与其对应element的映射关系。 123456789101112abstract class Element extends DiagnosticableTree implements BuildContext &#123; /// Creates an element that uses the given widget as its configuration. /// /// Typically called by an override of [Widget.createElement]. Element(Widget widget) : assert(widget != null), _widget = widget; Element _parent; ......&#125; 在看BuildContext，BuildContext是一个接口，Element实现了它。InheritedElement是Element的子类，所以每个InheritedElement实例就是一个BuildContext实例。日常传递的BuildContext也是一个Element。 所以，当需要共享State时，如果逐层去传递，实现共享，就会很麻烦，这时，可以使用InheritedWidgets。将需要共享的State放在一个inheritedWidgets中，然后在使用的Widget中直接取用。如下：通常如焦点、主题色、多语言、用户信息等都属于App内的全局共享数据，它们都会通过BuildContext（InheritedElement）获取。 1234567891011121314151617// 收起键盘FocusScope.of(context).requestFocus(new FocusNode());// 主题色Theme.of(context).primaryColor// 多语言Localizations.of(context, GSYLocalizations)// 通过 Redux 获取用户信息StoreProvider.of(context).userInfo// 通过 Redux 获取用户信息StoreProvider.of(context).userInfo// 通过 Scope Model 获取用户信息ScopedModel.of&lt;UserInfo&gt;(context).userInfo 先来看看Theme。 如下代码，通过给MaterialApp设置主题数据，通过Theme.of(context)就可以获取到主题数据并绑定使用。当MaterialApp的主题数据变化时，对应的Widget颜色就会变化。 1234567// 添加主题new MaterialApp( theme: ThemeData.dark());// 使用主题色new Container( color: Theme.of(context).primaryColor, 代码嵌套：MaterialApp -&gt; AnimatedTheme -&gt; Theme -&gt; _InheritedTheme extends InheritedWidget，所以通过MaterialApp为入口，最终嵌套在InheritedWidget下。 12345678910111213static ThemeData of(BuildContext context, &#123; bool shadowThemeOnly = false &#125;) &#123; final _InheritedTheme inheritedTheme = context.inheritFromWidgetOfExactType(_InheritedTheme); if (shadowThemeOnly) &#123; if (inheritedTheme == null || inheritedTheme.theme.isMaterialAppTheme) return null; return inheritedTheme.theme.data; &#125; final MaterialLocalizations localizations = MaterialLocalizations.of(context); final ScriptCategory category = localizations?.scriptCategory ?? ScriptCategory.englishLike; final ThemeData theme = inheritedTheme?.theme?.data ?? _kFallbackTheme; return ThemeData.localize(theme, theme.typography.geometryThemeFor(category));&#125; 通过Theme.of(context)获取主题数据，内部是通过context.inheritFromWidgetOfExactType()去获取的，而Element中实现了BuildContext的inheritFromWidgetOfExactType()方法，如下： 1234567891011@overrideInheritedWidget inheritFromWidgetOfExactType(Type targetType, &#123; Object aspect &#125;) &#123; assert(_debugCheckStateIsActiveForAncestorLookup()); final InheritedElement ancestor = _inheritedWidgets == null ? null : _inheritedWidgets[targetType]; if (ancestor != null) &#123; assert(ancestor is InheritedElement); return inheritFromElement(ancestor, aspect: aspect); &#125; _hadUnsatisfiedDependencies = true; return null;&#125; 既然InheritedElement已经存在于_inheritedWidgets中，就可以直接拿出来。 前文：InteritedWidget内的InheritedElement，该Element属于特殊Element，主要增加了将自身也添加到映射关系表_inheritedWidgets。 该处逻辑有变动 最后，如下，在InheritedElement中，notifyClents通过InheritedWidget的updateShouldNotofy()方法判断是否更新，比如在Theme的_InheritedTheme是： 12 1234567891011121314151617// 逻辑有变动，需要重新查看源码@overridevoid notifyClients(InheritedWidget oldWidget) &#123; assert(_debugCheckOwnerBuildTargetExists('notifyClients')); for (Element dependent in _dependents.keys) &#123; assert(() &#123; // check that it really is our descendant Element ancestor = dependent._parent; while (ancestor != this &amp;&amp; ancestor != null) ancestor = ancestor._parent; return ancestor == this; &#125;()); // check that it really depends on us assert(dependent._dependencies.contains(this)); notifyDependent(oldWidget, dependent); &#125;&#125; 本质上，Theme、Redux、Scope Model、Localizations的核心都是InheritedWidget。 3. 内存咸鱼有发布了关于内存的文章Flutter之禅 内存优化篇，里面有介绍到： Flutter中InmageCache缓存的是ImageStream对象，也就是缓存的是一个异步加载的图片的对象。 在图片加载解码完成前，无法知道需要消耗多少内存。 所以容易产生大量的IO操作，导致内存峰值过高。 如图，是图片缓存相关的流程，目前的拮据处理是通过的： 在页面不可见时，没有必要发出多余的图片 限制缓存图片的数量 在适当的时候CG 这里主要讲讲限制缓存图片的数量。 在之前有说过WidgetFlutterBinding这个胶水类，其中Mixins了PaintingBinding如下，被黏上去的这个Binding就是负责图片的缓存。 123456/// Binding for the painting library.////// Hooks into the cache eviction logic to clear the image cache.////// Requires the [ServicesBinding] to be mixed in earlier.mixin PaintingBinding on BindingBase, ServicesBinding &#123;&#125; 里面注释有说到Hooks into the cache eviction logic to clear the image cache. 直译为：挂钩到缓存回收逻辑以清除映像缓存。 在PaintingBinding内有一个ImageCache对象，该对象全局一个单例，同时在图片加载时的ImageProvider所使用，所以设置缓存图片大小如下： 1234// 缓存个数 100PaintingBinding.instance.imageCache.maximumSize=100;// 缓存大小 50mPaintingBinding.instance.imageCache.maximumSizeBytes= 50 &lt;&lt; 20; 4. 线程在咸鱼技术的深入理解Flutter Platform Channel中有讲到：Flutter四大线程，Platform Task Runner、UI Task Runner、GPU Task Runner和IO Task Runner。其中，Platform Task Runner就是Android和iOS的主线程，UI Task Runner是Flutter的UI线程。 如下图，通过Platform Channel通信的两端就是Platform Task Runner和UI Task Runner，这里总结起来是： 因为Platform Task Runner本来是原生的的主线程，所以尽量不要在Platform端执行耗时操作。 因为Platform Channel不是线程安全的，所以消息处理结果回传到Flutter端时，需要确保回调函数是在Platform Thread（也就是Andorid和iOS的主线程）中执行。 5. 热更新 Flutter依然是Android和iOS工程。 Flutter通过BuildPhase中添加shell（xcode_backend.sh）来生成和嵌入App.framework和Flutter.framework*到iOS。 Flutter通过Gradle引入flutter.jar和把编译完成的二进制文件添加到Android中。 其中Andorid的编译后二进制文件存在于data/data/包名/app_flutter/flutter_assets/下。 注意，1.7.8版本后，Android下生成的Flutter已经编译为纯so文件。","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://tylerLiu.top/categories/Flutter/"},{"name":"学习","slug":"Flutter/学习","permalink":"https://tylerLiu.top/categories/Flutter/学习/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://tylerLiu.top/tags/Flutter/"}]},{"title":"四、Redux、主题、国际化","slug":"四、Redux、主题、国际化","date":"2019-09-19T03:07:36.000Z","updated":"2019-09-19T09:15:07.648Z","comments":true,"path":"2019/09/19/四、Redux、主题、国际化/","link":"","permalink":"https://tylerLiu.top/2019/09/19/四、Redux、主题、国际化/","excerpt":"","text":"Demo地址：tyler_flutter_app 本文主要是使用Redux实现主题切换和多语言切换的功能。 Flutter作为响应式框架，通过state实现跨帧渲染的逻辑。Flutter中使用的Redux库，是flutter_redux。 1. ReduxRedux是状态管理，在已有state基础上，为什么还要用Redux？Redux好处：共享状态和单一数据。 假设，App内有多个使用到了登录用户的数据，这时如果某处对用户数据进行了修改，各个页面的同步更新就会很麻烦。使用Redux后，某个页面修改了用户信息，所有绑定了Redux的控件，将由Redux自动同步刷新。同理，主题和语言的切换也是如此。 如上图，Redux主要组成部分为： Store：用于存储和管理State Action：用于定义一个数据变化的请求行为 Reducer：用于根据Action产生新状态，一般是一个方法 所以一般流程为： Widget绑定Store中的State数据； Widget通过Action发布一个新的动作； Reducer根据Action更新State； 更新Store中State绑定的Widget。 首先，要创建一个Store。创建Store，需要reducer，而reducer实际上是一个带有action和state的方法，并返回新的State。所以需要先创建一个State对象TylerState类，用于存储需要共享的数据，如：用户信息、主题、语言等。 然后定义一个Reducer方法appReducer()：将TylerState内的每个参数和对应的action绑定起来，返回完整的TylerState。 12345678910111213141516171819202122232425262728293031class TylerState &#123; // 用户信息 User userInfo; // 主题数据 ThemeData themeData; // 语言 Locale locale; // 构造方法 TylerState(&#123;this.userInfo, this.themeData, this.locale&#125;);&#125;/*创建 Reducer源码中 Reducer 是一个方法 typedef State Reducer&lt;State&gt;(State state, dynamic action);这里自定义 appReducer 用于创建 store*/TylerState appReducer(TylerState state, action) &#123; return TylerState( // 通过 UserReducer 将 TylerState 内的 userInfo 和 action 关联在一起 userInfo: UserReducer(state.userInfo, action), // 通过 ThemeDataReducer 将 TylerState 内的 themeData 和 action 关联在一起 themeData: ThemeDataReducer(state.themeData, action), // 通过 LocaleReducer 将 TylerState 内的 locale 和 action 关联在一起 locale: LocaleReducer(state.locale, action), );&#125; TylerState中的每个参数都是通过各自的Recuder返回的。比如，themeData是通过ThemeDataReducer()产生的，ThemeDataReducer是将ThemeData和一系列Theme相关的Action绑定起来。 然后通过flutter_redux的combineReducers()与TypedReducer，将RefreshThemeDataAction类和_refresh()方法绑定起来，最终返回一个ThemeData实例。即：用户每发出一个RefreshThemeDataAction，最终都会触发_refresh()，然后更新TylerState中的themeData。 123456789101112final ThemeDataReducer = combineReducers&lt;ThemeData&gt;([TypedReducer&lt;ThemeData, RefreshThemeDataAction&gt;(_refresh)]);ThemeData _refresh(ThemeData themeData, action) &#123; themeData = action.themeData; return themeData;&#125;class RefreshThemeDataAction &#123; final ThemeData themeData; RefreshThemeDataAction(this.themeData);&#125; 这时，就可以创建Store了。在创建Store的同时，通过initialState对TylerState初始化，然后通过StoreProvider加载Store并包裹MaterialApp。这样就完成了Redux的构建。 12345678910111213141516171819202122class FlutterReduxApp extends StatelessWidget &#123; final store = new Store&lt;TylerState&gt;(appReducer, initialState: new TylerState( themeData: new ThemeData( primarySwatch: TylerColor.primarySwatch, ), locale: Locale('zh', 'CH'))); FlutterReduxApp(&#123;Key key&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; // 通过 StoreProvider 应用 store return new StoreProvider( store: store, // 通过 StoreBuilder 获取 themeData child: new StoreBuilder(builder: (context, store) &#123; return new MaterialApp(); &#125;), ); &#125;&#125; 下面就是使用，如下，通过在build()中使用StoreConnector，通过converter转换store.state的数据，最后通过builder返回实际需要渲染的控件，这样就完成了数据和控件的绑定。也可以使用StoreBuilder。 1234567891011121314151617class DemoUserStorePage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; // 通过 StoreConnector 关联 TylerState 中的 User return new StoreConnector&lt;TylerState, User&gt;( // 通过 converter 将 TylerState 中的 userInfo 返回 converter: (store) =&gt; store.state.userInfo, // 在 userInfo 中返回实际渲染的控件 builder: (context, userInfo) &#123; return new Text( userInfo.name, style: Theme.of(context).textTheme.display1, ); &#125;, ); &#125;&#125; 最后，当需要触发更新时，使用下面代码即可： 1StoreProvider.of(context).dispatch(new UpdateUserAction(newUserInfo)); 2. 主题Flutter默认支持主题设置，MaterialApp提供了theme参数设置主题，之后就可以通过Theme.of(context)获取到当前的ThemeData用于设置控件的颜色、字体等。 ThemeData的创建提供很多参数，这里主要说primarySwatch参数。primarySwatch是一个MaterialColor对象，内部由10个不同深浅的颜色组成，可以用来做主题的颜色。 Flutter默认提供了很多主题颜色，同时也可以通过MaterialColor实现自定义的主题颜色： 123456789101112131415static const MaterialColor primarySwatch = const MaterialColor( primaryValue, const &lt;int, Color&gt;&#123; 50: const Color(primaryLightValue), 100: const Color(primaryLightValue), 200: const Color(primaryLightValue), 300: const Color(primaryLightValue), 400: const Color(primaryLightValue), 500: const Color(primaryValue), 600: const Color(primaryDarkValue), 700: const Color(primaryDarkValue), 800: const Color(primaryDarkValue), 900: const Color(primaryDarkValue), &#125;,); 就可以通过Redux实现主题切换。 前面已经在TylerState中创建了themeData，此时将它设置给MaterialApp的theme参数，之后通过dispatch()改变themeData，即实现主题切换。 MaterialApp也是一个StatefulWidget，如下，需要利用StoreBuilder包裹起来，之后就可以通过dispatch()修改主题，通过Theme.of(context).primaryColor获取主题颜色。 12345678910111213141516@overrideWidget build(BuildContext context) &#123; // 通过 StoreProvider 应用 store return new StoreProvider( store: store, child: new StoreBuilder&lt;GSYState&gt;(builder: (context, store) &#123; return new MaterialApp( theme: store.state.themeData); &#125;), );&#125;......ThemeData themeData = new ThemeData(primarySwatch: colors[index]);store.dispatch(new RefreshThemeDataAction(themeData)); 3. 国际化中文官网上有介绍，国际化Flutter App，但是实现起来较为复杂，这里使用Redux可以很简便的实现。 通过默认的MaterialApp设置，自定义的多语言要实现LocalizationsDelegate和Localizations。最终流程会通过Localizations使用Locale加载delegate。 流程： 实现LocalizationsDelegate 实现Localizations 通过Store的Locale切换语言 代码如下，创建自定义delegate需要继承LocalizationsDelegate，实现里面的load()。通过locale，判断需要加载的语言，返回自定义语言实现类TylerLocalizations，最后通过静态delegate对外提供LocalizationsDelegate。 123456789101112131415161718192021222324// 多语言代理class TylerLocalizationsDelegate extends LocalizationsDelegate&lt;TylerLocalizations&gt; &#123; TylerLocalizationsDelegate(); @override bool isSupported(Locale locale) &#123; // 支持中文和英文 return ['en', 'zh'].contains(locale.languageCode); &#125; // 根据 locale，创建一个对象用于提供当前的 locale 下的文本显示 @override Future&lt;TylerLocalizations&gt; load(Locale locale) &#123; return new SynchronousFuture&lt;TylerLocalizations&gt;(new TylerLocalizations(locale)); &#125; @override bool shouldReload(LocalizationsDelegate&lt;TylerLocalizations&gt; old) &#123; return false; &#125; // 全局静态代理 static TylerLocalizationsDelegate delegate = new TylerLocalizationsDelegate();&#125; 其中TylerLocalizations是一个自定义对象，代码如下，它会根据创建时的Locale，通过locale.languageCode判断返回对应的语言实体。 TylerLocalizations对象最后会通过Localizations加载，Local也是那时通过delegate赋予。同时，在该context下，可以通过Loccalizations.of()获取TylerLocalizations，比如：TylerLocalizations.of(context).currentLocalized.app_name。 123456789101112131415161718192021222324// 自定义多语言实现class TylerLocalizations &#123; final Locale locale; TylerLocalizations(this.locale); // 根据 locale.languageCode 加载对应的语言 static Map&lt;String, StringBase&gt; _localizedValues = &#123; 'en': new StringEn(), 'zh': new StringZh(), &#125;; StringBase get currentLocalized &#123; if (_localizedValues.containsKey(locale.languageCode)) &#123; return _localizedValues[locale.languageCode]; &#125; return _localizedValues[\"en\"]; &#125; // 通过 Localizations 加载当前的 TylerLocalizations，获取对应的 StringBase static TylerLocalizations of(BuildContext context) &#123; return Localizations.of(context, Localizations); &#125;&#125; 介绍完delegate，接下来是Localizations。从流程图可以看出，Localizations提供一个override方法构建Localizations，这个方法可以设置locale，而需要的正式实时动态切换语言显示。 代码如下，创建一个TylerLocalizations的Widget，通过StoreBuilder绑定Store，然后通过Localizations.override包裹需要构建的页面，将Store中的locale和Localizations的locale绑定起来。 12345678910111213141516171819202122class TylerLocalizations extends StatefulWidget &#123; final Widget child; TylerLocalizations(&#123;Key key, this.child&#125;) : super(key: key); @override _TylerLocalizationsState createState() =&gt; _TylerLocalizationsState();&#125;class _TylerLocalizationsState extends State&lt;TylerLocalizations&gt; &#123; @override Widget build(BuildContext context) &#123; return new StoreBuilder&lt;TylerState&gt;(builder: (context, store) &#123; // 通过 StoreBuilder 和 Localizations 实现实时多语言切换 return new Localizations.override( context: context, locale: store.state.locale, child: widget.child, ); &#125;); &#125;&#125; 最后将TylerLocalizations使用到MaterialApp中。通过store.dispatch切换Locale即可。 123456789101112131415161718192021222324252627282930313233class FlutterReducerApp extends StatelessWidget &#123; // 创建Store，引用 TylerState 中的 appReducer() 创建的Reducer final store = new Store&lt;TylerState&gt;(appReducer, initialState: new TylerState(userInfo: User.empty())); FlutterReducerApp(&#123;Key key&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; // 通过 StoreProvider 应用 store return new StoreProvider( store: store, child: new StoreBuilder&lt;TylerState&gt;(builder: (context, store) &#123; return new MaterialApp( // 多语言实现代理 localizationsDelegates: [ GlobalMaterialLocalizations.delegate, GlobalWidgetsLocalizations.delegate, TylerLocalizationsDelegate.delegate, ], locale: store.state.locale, supportedLocales: [store.state.locale], routes: &#123; HomePage.sName: (context) &#123; // 通过 Localizations.override 包裹这一层 return new TylerLocalizations( child: new HomePage(), ); &#125; &#125;, ); &#125;)); &#125;&#125; 123456789101112131415class DemoUtils &#123; // 切换主题 static changeLocale(Store&lt;TylerState&gt; store, int index) &#123; Locale locale = store.state.platformLocale; switch (index) &#123; case 1: locale = Locale('zh', 'CH'); break; case 2: locale = Locale('en', 'US'); break; &#125; store.dispatch(RefreshLocaleAction(locale)); &#125;&#125;","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://tylerLiu.top/categories/Flutter/"},{"name":"学习","slug":"Flutter/学习","permalink":"https://tylerLiu.top/categories/Flutter/学习/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://tylerLiu.top/tags/Flutter/"}]},{"title":"三、打包及问题处理","slug":"三、打包及问题处理","date":"2019-09-18T07:46:21.000Z","updated":"2019-09-19T09:15:02.930Z","comments":true,"path":"2019/09/18/三、打包及问题处理/","link":"","permalink":"https://tylerLiu.top/2019/09/18/三、打包及问题处理/","excerpt":"","text":"Demo地址：tyler_flutter_app 1. 打包1.1 Andorid打包 Android上和一般Android开发类似，在andorid/app/build.gradle下可以配置applicationId、versionCode、versionName和签名信息等，最后通过flutter build apk完成编译，编译完成的包在build/app/outputs/apk/release下。（截图里面签名有个小错误，注意。） 1.2 IOS打包关于IOS打包的部分暂时可以参考https://guoshuyu.cn/home/wx/Flutter-3.html。后面会实际操作看看里面可能出现的问题。 也可以参考发布的IOS版APP。 2. 细节点2.1 AppBarAppBar不仅可以作为标题栏，里面的leading和bottom也有相应的作用。 bottom：默认支持TabBar，即顶部Tab效果，因为TabBar实现了PreferredSizeWidget的preferredSize。所以自定义的控件只要实现了preferredSize，就可以放到bottom中。比如下面是的搜索栏。 leading：通常是左侧按键，不设置时，一般是Drawer的图标或者返回按钮。 flexibleSpace：位于bottom和leading之间。 2.2 按键Flutter中的按键，如Flatbutton，默认是有边距和最小大小的。如果想取消这些默认设置，其中一种方式如下： 123456new RawMaterialButton( materialTapTargetSize: MaterialTapTargetSize.shrinkWrap, padding: padding ?? const EdgeInsets.all(0.0), constraints: const BoxConstraints(minWidth: 0.0, minHeight: 0.0), child: child, onPressed: onPressed); 如果在加上Flex，一个可控的填充按键就出来了： 1234567891011new RawMaterialButton( materialTapTargetSize: MaterialTapTargetSize.shrinkWrap, padding: padding ?? const EdgeInsets.all(0.0), constraints: const BoxConstraints(minWidth: 0.0, minHeight: 0.0), // flex child: new Flex( mainAxisAlignment: mainAxisAlignment, direction: Axis.horizontal, children: &lt;Widget&gt;[], ), onPressed: onPressed); 2.3 StatefulWidget赋值这里以给TextField赋值为例，在Flutter中，给有状态的Widget传递状态和数据，一般都是使用controller。示例： 12345678910111213141516171819202122232425262728293031import 'package:flutter/material.dart';class DemoController extends StatefulWidget &#123; @override _DemoControllerState createState() =&gt; _DemoControllerState();&#125;class _DemoControllerState extends State&lt;DemoController&gt; &#123; final TextEditingController _controller = new TextEditingController(); @override void didChangeDependencies() &#123; super.didChangeDependencies(); // 通过给 controller 的 value 新创建一个 TextEditingValue _controller.value = new TextEditingValue(text: \"给输入框填入参数\"); &#125; @override Widget build(BuildContext context) &#123; return new TextField( // controller controller: _controller, onChanged: onChanged, obscureText: obscureText, decoration: new InputDecoration( hintText: hintText, icon: iconData == null ? null : new Icon(iconData); ), ); &#125;&#125; TextEditingValue实际上是ValueNotifier，其中Value的setter方法被重载，一旦改变就触发notifyListeners()方法。而TextEditingController中，通过调用addListener()监听数据改变，从而让UI更新。 赋值还有一个简单的方法：传递一个对象，如class A对象，在控件内部使用对象A.b 的变量绑定控件，外部通过setState({A.b = b2})进行更新。 2.4 GlobalKey在Flutter，要主动改变子控件的状态，还可以使用GlobalKey。比如需要主动调用RefreshIndicator显示刷新状态，代码如下： 123456789101112131415161718GlobalKey&lt;RefreshIndicatorState&gt; refreshIndicatorKey;showForRefresh() &#123; // 显示刷新 refreshIndicatorKey.currentState.show();&#125;@overrideWidget build(BuildContext context) &#123; refreshIndicatorKey = new GlobalKey&lt;RefreshIndicatorState&gt;(); return new RefreshIndicator( key: refreshIndicatorKey, onRefresh: onRefresh, child: new ListView.builder( ...... ), );&#125; 2.5 Redux与主题Redux主要用作Flutter全局State的管理器，详细内容可以查看二、快速开发实战。这里主要是通过Redux来实现切换主题的效果。 代码如下，通过StoreProvider加载store，再通过StoreBuilder将store中的themeData绑定到MaterialApp的theme下，之后，在其他Widget中通过Theme.of(context)调用需要的颜色，最终在任意位置调用store.dispatch实现主题颜色修改。 12345678910111213141516171819202122232425262728class FlutterReduxApp extends StatelessWidget &#123; final store = new Store&lt;TylerState&gt;(appReducer, initialState: new TylerState( themeData: new ThemeData( primarySwatch: TylerColor.primarySwatch, ))); FlutterReduxApp(&#123;Key key&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; // 通过 StoreProvider 应用 store return new StoreProvider( store: store, // 通过 StoreBuilder 获取 themeData child: new StoreBuilder(builder: (context, store) &#123; return new MaterialApp( theme: store.state.themeData, routes: &#123; HomePage.sName: (context) &#123; return HomePage(); &#125; &#125;, ); &#125;), ); &#125;&#125; 2.6 Hotload与PackageFlutter的Debug和Release下分别是JIT和AOT模式，而在Debug下，支持Hotload。但需要注意：如果开发过程中，安装的新的第三方库，新的第三方库中包含了原生代码，就需要停止后重新运行。 pubspec.yaml文件就是包的依赖目录，其中^表示等于等于，一般upgrade和get都能达到下载包的作用。但是：upgrade会在包有更新的情况下，更新pubspec.lock文件下包的版本。 3. 问题处理 Waiting for another flutter command to release the startup lock： 打开flutter安装目录 /bin/cache/ 删除 lockfile 文件 重启 AndroidStudio dialog下的黄色线yellow-lines-under-text-widgets-in-flutter：showDialog中，默认是没使用Scaffold，这会导致文本有黄色溢出线提示，可以使用Material包一层处理。 TabBar + TabView + KeepAlive 的问题，可以通过TabBar + PageView解决。","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://tylerLiu.top/categories/Flutter/"},{"name":"学习","slug":"Flutter/学习","permalink":"https://tylerLiu.top/categories/Flutter/学习/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://tylerLiu.top/tags/Flutter/"}]},{"title":"二、快速开发实战","slug":"二、快速开发实战","date":"2019-09-16T09:29:33.000Z","updated":"2019-09-19T09:14:57.123Z","comments":true,"path":"2019/09/16/二、快速开发实战/","link":"","permalink":"https://tylerLiu.top/2019/09/16/二、快速开发实战/","excerpt":"","text":"Demo地址：tyler_flutter_app 本文将介绍如何搭建一个通用的Flutter App常用功能脚手架，快速开发一个完整的Flutter应用。 前言内容结构： 1. 基础控件1.1 TabBar控件实现TabBar是常用的需求，而在Flutter中，Scaffold + AppBar + TabBar + TabBarView是TabBar页面最简单的实现，在加上AutomaticKeepAliveClientMixin用于页面KeepAlive之后，像#11895就会造成Crash。到flutter V0.5.7 SDK修复后，问题还是没有得到完全解决，所以修改实现方式。 目前是通过Scaffold + AppBar + TabBar + TabBarView来组合实现效果，从而解决上面的问题。地址：FlutterTabBar。 作为一个TabBar Widget，肯定继承StatefulWidget，需要实现它的State： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111class _TylerTabBarState extends State&lt;TylerTabBar&gt; with SingleTickerProviderStateMixin &#123; final int _type; final List&lt;Widget&gt; _tabItems; final List&lt;Widget&gt; _tabViews; final Color _backgroundColor; final Color _indicatorColor; final Widget _title; final Widget _drawer; final Widget _floatingActionButton; final PageController _pageController; _TylerTabBarState(this._type, this._tabItems, this._tabViews, this._backgroundColor, this._indicatorColor, this._title, this._drawer, this._floatingActionButton, this._pageController) : super(); TabController _tabController; @override void initState() &#123; super.initState(); // 初始化时创建控制器 // 通过with SingleTickerProviderStateMixin 实现动画效果 _tabController = new TabController(length: _tabItems.length, vsync: this); &#125; @override Widget build(BuildContext context) &#123; // 顶部TabBar模式 if (this._type == TylerTabBar.TOP_TAB) &#123; return new Scaffold( // 设置侧边滑出 drawer， 不需要可以不设置 drawer: _drawer, // 设置悬浮按钮，不需要可以不设置 floatingActionButton: _floatingActionButton, // 标题栏 appBar: new AppBar( backgroundColor: _backgroundColor, title: _title, // TabBar控件 bottom: new TabBar( //顶部时，tabBar为可以滑动模式 isScrollable: true, // 必须有的控制器，与pageView的控制器同步 controller: _tabController, // 每一个tab item，是一个List&lt;Widget&gt; tabs: _tabItems, // tab底部选中条颜色 indicatorColor: _indicatorColor, ), ), // 页面主体，PageView，用于承载Tab对应的页面 body: new PageView( // 必须有的控制器，与tabBar的控制器同步 controller: _pageController, // 每一个 tab 对应的页面主体，是一个List&lt;Widget&gt; children: _tabViews, // 页面触摸作用滑动回调，用于同步 tab 选中状态 onPageChanged: (index) &#123; _tabController.animateTo(index); &#125;, ), ); &#125; // 底部TabBar模式 return new Scaffold( // 设置侧边滑出 drawer， 不需要可以不设置 drawer: _drawer, // 设置悬浮按钮，不需要可以不设置 floatingActionButton: _floatingActionButton, // 标题栏 appBar: new AppBar( backgroundColor: _backgroundColor, title: _title, ), // 页面主体，PageView，用于承载Tab对应的页面 body: new PageView( // 必须有的控制器，与tabBar的控制器同步 controller: _pageController, // 每一个 tab 对应的页面主体，是一个List&lt;Widget&gt; children: _tabViews, // 页面触摸作用滑动回调，用于同步 tab 选中状态 onPageChanged: (index) &#123; _tabController.animateTo(index); &#125;, ), bottomNavigationBar: new Material( color: _backgroundColor, // tabBar控件 child: new TabBar( // 必须有的控制器，与pageView的控制器同步 controller: _tabController, // 每一个tab item，是一个List&lt;Widget&gt; tabs: _tabItems, // tab底部选中条颜色 indicatorColor: _indicatorColor, ), ), ); &#125; @override void dispose() &#123; // 页面销毁时，销毁控制器 _tabController.dispose(); super.dispose(); &#125;&#125; 这是一个底部TabBar的页面效果。TabBar和PageView之间通过_pageController和_tabController实现Tab和页面的同步，通过SingleTickerProvidersStateMixin实现Tab的动画切换效果，如果需要多个嵌套动画效果，需要使用TickerProvidersStateMixin。代码中可以看到： 手动左右滑动PageView时，通过onPageChanged()回调调用_tabController.animateTo(index);同步TabBar状态。 _tabItems中，监听每个TabBarItem的点击，通过_pageController实现PageView的状态同步。 上面的代码还缺少TabBarItem的点击，这块会被放到外部实现。也可以直接在内部封装好控件，直接传递配置数据显示。 外部调用如下：每个TabBar点击时，通过pageController.jumoTo()跳转页面，每个页面都需要跳转坐标为：当前屏幕大小乘以索引index。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import 'package:flutter/material.dart';import 'package:flutter_tab_bar/tab_bar_page_first.dart';import 'package:flutter_tab_bar/tab_bar_page_second.dart';import 'package:flutter_tab_bar/tab_bar_page_three.dart';import 'package:flutter_tab_bar/tyler_tab_bar.dart';class TabBarBottomPageWidget extends StatefulWidget &#123; @override _TabBarBottomPageWidgetState createState() =&gt; _TabBarBottomPageWidgetState();&#125;class _TabBarBottomPageWidgetState extends State&lt;TabBarBottomPageWidget&gt; &#123; final PageController _topPageController = new PageController(); final List&lt;String&gt; _tab = [\"动态\", \"趋势\", \"我的\"]; _renderTab() &#123; List&lt;Widget&gt; list = new List(); for (int i = 0; i &lt; _tab.length; i++) &#123; list.add(new FlatButton( onPressed: () &#123; _topPageController.jumpTo(MediaQuery.of(context).size.width * i); &#125;, child: new Text( _tab[i], maxLines: 1, ))); &#125; return list; &#125; _renderPage() &#123; return [ new TabBarPageFirst(), new TabBarPageSecond(), new TabBarPageThree(), ]; &#125; @override Widget build(BuildContext context) &#123; return new TylerTabBar( type: TylerTabBar.BOTTOM_TAB, // 渲染 tab tabItems: _renderTab(), // 渲染页面 tabViews: _renderPage(), topPageController: _topPageController, backgroundColor: Colors.black45, indicatorColor: Colors.white, title: new Text(\"Flutter的TabBar\"), ); &#125;&#125; 到这里，会发现，当页面点击切换时，StatefulWidget的子页面每次都会重新调用initState()。无法实现页面同步跳转，这时就需要AutomaticKeepAliveClentMixin。 每个Taba对应的StatefulWidget的State，需要通过with AutomaticKeepAliveClentMixin，然后重写： 12@overridebool get wantKeepAlive =&gt; true; 就可以实现不重新构建的效果了。 这样底部的Tab就实现了，再来看看顶部Tab的实现。顶部Tab和顶部Tab的区别如下： 底部Tab是放在Scaffold的bottomNavigation中的。 顶部Tab是放在AppBar的bottom中的，即标题栏下方。 同时在顶部Tab中增加了isScrollable: true属性，代码如下： 123456789101112131415161718192021222324252627282930313233return new Scaffold( // 设置侧边滑出 drawer， 不需要可以不设置 drawer: _drawer, // 设置悬浮按钮，不需要可以不设置 floatingActionButton: _floatingActionButton, // 标题栏 appBar: new AppBar( backgroundColor: _backgroundColor, title: _title, // TabBar控件 bottom: new TabBar( //顶部时，tabBar为可以滑动模式 isScrollable: true, // 必须有的控制器，与pageView的控制器同步 controller: _tabController, // 每一个tab item，是一个List&lt;Widget&gt; tabs: _tabItems, // tab底部选中条颜色 indicatorColor: _indicatorColor, ), ), // 页面主体，PageView，用于承载Tab对应的页面 body: new PageView( // 必须有的控制器，与tabBar的控制器同步 controller: _pageController, // 每一个 tab 对应的页面主体，是一个List&lt;Widget&gt; children: _tabViews, // 页面触摸作用滑动回调，用于同步 tab 选中状态 onPageChanged: (index) &#123; _tabController.animateTo(index); &#125;, ),); 在TabBar页面中，一般还会出现：父页面需要控制PageView中子页面的需求。这时，就需要用到GlobalKey了。比如GlobalKey&lt;PageOneState&gt; stateOne = new GlobalKet&lt;PageOneState&gt;();，通过globalkey.currentState对象，就可以调用PageOneState中的方法。要注意，GlobalKey需要是全局唯一的，一般可以在build()中创建。 1.2 上下刷新列表Flutter提供了RefreshIndicator作为内置下拉刷新控件；同时通过给ListView添加ScrollController做滑动监听，在最后添加一个item，作为上滑加载更多的Loading显示。 代码如下，通过RefreshIndicator控件可以简单完成下拉刷新工作。注意：可以利用GlobalKey&lt;RefreshIndicatorState&gt;对外提供RefreshIndicator的RefreshIndicatorState，这样外部就可以通过GlobalKey调用globalKey.currenState.show();，主动显示刷新状态并触发onRefresh()。 上拉加载更多在代码中是通过_getListCount()方法，在原本的基础数据上，增加实际需要渲染的item数量给ListView实现的，最后通过ScrollController监听到底部，触发onLoadMore()。 代码如下，通过_getListCount()，还可以配置空白页面，头布局等效果。其实就是在内部通过改变实际item数量与渲染item，以实现更多配置的效果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170import 'package:flutter/material.dart';import 'package:flutter_spinkit/flutter_spinkit.dart';// 上下拉刷新控件class PullLoadWidget extends StatefulWidget &#123; @override _PullLoadWidgetState createState() =&gt; _PullLoadWidgetState(null, null, null, null, null);&#125;class _PullLoadWidgetState extends State&lt;PullLoadWidget&gt; &#123; final IndexedWidgetBuilder itemBuilder; // 载更多回调 final RefreshCallback onLoadMore; // 拉刷新回调 final RefreshCallback onRefresh; final Key refreshKey; // 控制器，比如数据和一些配置 final PullLoadWidgetController _controller; _PullLoadWidgetState(this._controller, this.itemBuilder, this.onRefresh, this.onLoadMore, this.refreshKey); final ScrollController _scrollController = new ScrollController(); @override void initState() &#123; // 添加滑动监听 _scrollController.addListener(() &#123; // 判断当前滑动位置是不是达到底部，触发加载更多的回调 if (_scrollController.position.pixels == _scrollController.position.maxScrollExtent) &#123; if (this.onLoadMore != null &amp;&amp; this._controller.needLoadMore.value) &#123; this.onLoadMore(); &#125; &#125; &#125;); super.initState(); &#125; /* 根据配置状态返回实际列表数量， 实际上这里可以根据需要做更多处理， 比如，多个头部，是否需要空白页面，是否需要显示加载更多。 */ _getListCount() &#123; // 是否需要头部 if (_controller.needHeader) &#123; // 如果需要，用Item 0的 Widget 作为ListView的头部 // 列表数量大于0时，因为头部和底部加载更多选项，需要对列表数据总数 +2 return (_controller.dataList.length &gt; 0) ? _controller.dataList.length + 2 : _controller.dataList.length; &#125; else &#123; // 如果不需要头部，在没有数据时，固定返回数量1，用于空页面呈现 if (_controller.dataList.length == 0) &#123; return 1; &#125; // 如果没有数据，因为头部加载更多选项，需要对列表总数 +1 return (_controller.dataList.length &gt; 0) ? _controller.dataList.length + 1 : _controller.dataList.length; &#125; &#125; /* 根据配置状态返回实际列表渲染的 item */ _getItem(int index) &#123; if (!_controller.needHeader &amp;&amp; index == _controller.dataList.length &amp;&amp; _controller.dataList.length != 0) &#123; // 如果不需要头部，并且数据不为0，当index等于数据长度时，渲染加载更多 Item（因为index是从0开始的） return _buildProgressIndicator(); &#125; else if (_controller.needHeader &amp;&amp; index == _getListCount() - 1 &amp;&amp; _controller.dataList.length != 0) &#123; // 如果需要头部，并且数据不为0，当index等于实际渲染长度 -1时，渲染加载更多 Item（因为index是从0开始的） return _buildProgressIndicator(); &#125; else if (!_controller.needHeader &amp;&amp; _controller.dataList.length == 0) &#123; // 如果不需要头部，并且数据为0，渲染空页面 return _buildEmpty(); &#125; else &#123; // 回调外部，正常渲染 Item，如果这里有需要，可以直接返回相对位置的index return itemBuilder(context, index); &#125; &#125; @override Widget build(BuildContext context) &#123; return new RefreshIndicator( // GlobalKey，用户外部获取RefreshIndicator的State，做显示刷新 key: refreshKey, // 下拉刷新触发，返回的是一个Future onRefresh: onRefresh, child: new ListView.builder( // 保持ListView任何情况下都能滚动，解决在RefreshIndicator的兼容问题 physics: const AlwaysScrollableScrollPhysics(), // 根据状态返回子控件 itemBuilder: (context, index) &#123; return _getItem(index); &#125;, // 根据状态返回数量 itemCount: _getListCount(), // 滑动监听 controller: _scrollController, )); &#125; /* 空页面 */ Widget _buildEmpty() &#123; return new Container( height: MediaQuery.of(context).size.height - 100, child: new Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ FlatButton( onPressed: () &#123;&#125;, child: new Image(image: new AssetImage('static/images/welcome.png'), width: 70.0, height: 70.0), ), Container( child: Text(\"空白页面\", style: TextStyle(color: Color(0xFF121917))), ) ], ), ); &#125; /* 上拉加载更多 */ Widget _buildProgressIndicator() &#123; // 是否需要显示上拉加载更多的Loading Widget bottomWidget = (_controller.needLoadMore.value) ? new Row( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ // loading框 new SpinKitRotatingCircle(color: Theme.of(context).primaryColor), new Container(width: 5.0), //加载中文本 new Text( \"正在加载更多，请稍后...\", style: TextStyle( color: Color(0xFF121917), fontSize: 14.0, fontWeight: FontWeight.bold, ), ) ], ) // 不需要加载更多 : new Container(); return new Padding( padding: const EdgeInsets.all(20.0), child: new Center( child: bottomWidget, ), ); &#125;&#125;class PullLoadWidgetController &#123; // 数据，对齐增减，不能替换 List dataList = new List(); // 是否需要加载更多 ValueNotifier&lt;bool&gt; needLoadMore = new ValueNotifier(false); // 是否需要头部 bool needHeader = false;&#125; 1.3 Loading框系统默认提供了CircularProgressIndicator等，但是有时无法满足需求，这里有一个第三方库：flutter_spinkit。 具体代码实现可以看前面的_buildProgressIndicator()中的实现。 1.4 矢量图标库比起一般的png图片，矢量图标： 可以轻松定义颜色 任意调整大小，且不会模糊 矢量图标库是通过引入ttf字体库文件实现，在Flutter中，通过Icon控件，加载对应的IconData显示即可。 Flutter中默认内置的Icons类就提供了丰富的图标，直接通过Icons对象即可使用，同时推荐阿里的iconfont。代码如下，在pubspec.yaml中添加字体库支持： 1234fonts: - family: wxcIconFont fonts: - asset: static/font/iconfont.ttf 在代码中就可直接使用： 123456789101112131415// 使用Iconsnew Tab( child: new Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[new Icon(Icons.list, size: 16.0), new Text(\"趋势\")], ),),// 使用iconfontnew Tab( child: new Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[new Icon(IconData(0xe6d0, fontFamily: \"wxcIconFont\"), size: 16.0), new Text(\"我的\")], ),) 1.5 路由跳转Flutter中的页面跳转是通过Navigator实现的，路由跳转分为：带参数跳转和不带参数跳转。 不带参数跳转：默认可以通过MaterialApp的路由表跳转 带参数跳转：参数可以通过跳转页面的构造方法传递 常用的跳转有如下几种使用： 12345678910111213// 不带参数的路由表跳转Navigator.pushNamed(context, routeName);// 跳转新页面并且替换，比如登录页跳转主页Navigator.pushReplacementNamed(context, routeName);// 跳转到新的路由，并且关闭给定路由的之前的所有页面Navigator.pushNamedAndRemoveUntil(context, '/calendar', ModalRoute.withName('/'));// 带参数的路由跳转，并且监听返回Navigator.push(context, new MaterialPageRoute(builder: (context) =&gt; new NotifyPage())).then((res) &#123; // 获取返回处理&#125;); Navigato.push()返回的是一个Future，这个Future的作用是在页面返回时被调用的。即，可以通过Navigator.pop()时返回参数，之后在Future中可以的监听中处理页面的返回结果。 1234@optionalTypeArgsstatic Future&lt;T&gt; push&lt;T extends Object&gt;(BuildContext context, Route&lt;T&gt; route) &#123; return Navigator.of(context).push(route);&#125; 2. 数据模块2.1 网络请求Flutter中，最常用的网络请求库是dio。dio中封装了网络请求的数据转换、拦截器、请求返回等。详细使用可以查看文档。 2.2 JSON序列化Flutter中，比如使用前面的dio进行网络请求返回，如果配置了返回数据格式为JSON，实际上得到的是一个Map。在使用过程中不方便，需要对Map再次进行转化，转成Model实体。 可以使用json_serializable插件，在Flutter中文教程中JSON和序列化已经做了介绍，这里说明一下具体的使用逻辑： 12345678dependencies: # Your other regular dependencies here json_annotation: ^3.0.0dev_dependencies: # Your other dev_dependencies here build_runner: ^1.7.0 json_serializable: ^3.2.2 使用步骤： 创建实体Model，继承Object，然后通过@JsonSerializable()标记类名。 通过with _$TemplateSerializerMixin，将fromJson()方法委托到Template.g.dart的实现中。其中*.g.dart、_$*SerializerMixin、_$*fromJson这三个方法的引入，和Model所在的dart的文件名与Model类名有关，具体可以看代码注释。 最后，通过flutter packages pub run build_runner build编译自动生成转换对象。 123456789101112131415161718192021222324import 'package:json_annotation/json_annotation.dart';/*关联文件、允许Template访问 Template.g.dart 中的私有方法Template.g.dart 是通过命令生成的文件。名称为 xxx.g.dart，xxx为当前dart文件的名称Template.g.dart 中实现了 _$TemplateFromJson()和_$TemplateToJson() */part 'Template.g.dart';// 标志class需要实现json序列化功能@JsonSerializable()class Template extends Object&#123; String name; int id; // 通过 @JsonKey(name: \"push_id\") int pushId; Template(this.name, this.id, this.pushId); // 'Xxx.g.dart'文件中，默认会根据当前类名生成 _$XxxFromJson方法 factory Template.fromJson(Map&lt;String,dynamic&gt; json) =&gt; _$TemplateFromJson(json);&#125; 通过flutter packages pub run build_runner build生成的Template.g.dart的代码如下，可以通过_$TemplateFromJson()和_$TemplateToJson()对实体和Map进行转化，再结合json.decode()和json.encode()，就可以在String、Map、实体间相互转化了。 123456789101112131415161718192021// GENERATED CODE - DO NOT MODIFY BY HANDpart of 'Template.dart';// **************************************************************************// JsonSerializableGenerator// **************************************************************************Template _$TemplateFromJson(Map&lt;String, dynamic&gt; json) &#123; return Template( json['name'] as String, json['id'] as int, json['push_id'] as int, );&#125;Map&lt;String, dynamic&gt; _$TemplateToJson(Template instance) =&gt; &lt;String, dynamic&gt;&#123; 'name': instance.name, 'id': instance.id, 'push_id': instance.pushId, &#125;; 2.3 Redux StateRedux，全局状态管理机。可以用来实现跨控件管理、同步State。可以使用第三方库flutter_redux。 Flutter中是通过实现State()和setState()来渲染和改变StatefulWidget的。 使用flutter_redux是怎样的呢？ 比如把用户信息存储在redux的store中，好处：比如修改某个页面修改了当前用户信息，所有绑定的该State的控件都将由Redux同步自动修改。State可以跨页面共享。 flutter_redux的使用。在redux中引入了action、reducer、store的概念： action：用于定义一个数据变化的请求。 reducer：用于根据action产生新状态。 store：用于存储和管理state，监听action，将action自动分配给reducer，并根据reducer返回的结果更新state。 具体使用如下，首先创建一个State用于存储要保存的对象，其中关键代码在于UserReducer： 12345678910111213141516171819// 全局Redux State对象，用于保存State数据import 'package:tyler_flutter_app/single_demo/User.dart';import 'package:tyler_flutter_app/single_demo/user_reducer.dart';class TylerState &#123; // 用户信息 User userInfo; // 构造方法 TylerState(&#123;this.userInfo&#125;);&#125;// 通过 Reducer 创建 用于store 的 ReducerTylerState appReducer(TylerState state, action) &#123; return TylerState( // 通过 UserReducer 将 TylerState 内的 userInfo 和 action 关联在一起 userInfo: UserReducer(state.userInfo, action), );&#125; 下面是UserReducer的实现。在里面主要通过TypedReducer将Reducer的处理逻辑与定义的action绑定，最后通过combineReducer()返回Reducer&lt;User&gt;对象应用于上面的Store中。 12345678910111213141516171819202122import 'package:redux/redux.dart';import 'package:tyler_flutter_app/single_demo/User.dart';// redux的 combineReducers，通过 TyperReducer 将 UpdateUserAction 与 UpdateUserAction 关联起来final UserReducer = combineReducers&lt;User&gt;([TypedReducer&lt;User, UpdateUserAction&gt;(_updateLoaded)]);/*如果由 UpdateUserAction 发起一个请求时，就会调用到 _updateLoaded() _updateLoaded 这里接受一个新的userInfo，并返回 */User _updateLoaded(User user, action) &#123; user = action.userInfo; return user;&#125;// 定义一个 action，用于发起 usrInfo的改变class UpdateUserAction &#123; final User userInfo; UpdateUserAction(this.userInfo);&#125; 最后，通过StoreProvider将创建的store引入到Flutter中。 123456789101112131415161718void main() =&gt; runApp(FlutterReducerApp());class FlutterReducerApp extends StatelessWidget &#123; // 创建Store，引用 TylerState 中的 appReducer() 创建的Reducer final store = new Store&lt;TylerState&gt;(appReducer, initialState: new TylerState(userInfo: User.empty())); FlutterReducerApp(&#123;Key key&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; // 通过 StoreProvider 应用 store return new StoreProvider( store: store, child: new MaterialApp( home: DemoUserStorePage(), )); &#125;&#125; 在DemoUserStorePage中，通过StoreConnector将State绑定到Widget；然后通过StoreProvider.of()获取state对象；通过dispatch()一个Action可以更新State。 12345678910111213141516171819202122232425262728293031import 'package:flutter/material.dart';import 'package:flutter_redux/flutter_redux.dart';import 'package:tyler_flutter_app/single_demo/User.dart';import 'package:tyler_flutter_app/single_demo/tyler_state.dart';class DemoUserStorePage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; // 通过 StoreConnector 关联 TylerState 中的 User return new StoreConnector&lt;TylerState, User&gt;( // 通过 converter 将 TylerState 中的 userInfo 返回 converter: (store) =&gt; store.state.userInfo, // 在 userInfo 中返回实际渲染的控件 builder: (context, userInfo) &#123; return new Text( userInfo.name, style: Theme.of(context).textTheme.display1, ); &#125;, ); &#125;&#125;......// 通过 StoreProvider.of(context) （带有 StoreProvider 下的 context）// 可以任意的位置访问到 state 中的数据StoreProvider.of(context).state.userInfo;......// 通过 dispatch UpdateUserAction，可以更新StateStoreProvider.of(context).dispatch(new UpdateUserAction(newUserInfo)); 2.4 数据库Flutter中常用的数据库第三方库是sqflite。完整代码如下，主要是对sqlite语法的使用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168import 'dart:convert';import 'package:meta/meta.dart';import 'package:sqflite/sqflite.dart';import 'package:tyler_flutter_app/single_demo/User.dart';/// 数据库管理类class DemoSqlManager &#123; static final _VERSION = 1; static final _NAME = \"demo_github_app_flutter.db\"; static Database _database; /* 初始化 */ static init() async &#123; // 打开 Database var databasePath = await getDatabasesPath(); String path = databasePath + _NAME; _database = await openDatabase(path, version: _VERSION, onCreate: (Database db, int version) async &#123; // 打开 Database 时，创建一个表 await db.execute(\"CREATE TABLE Test (id INTEGER PRIMARY KEY, name TEXT, value INTEGER, num REAL)\"); &#125;); &#125; /* 表格是否存在 */ static isTableExits(String tableName) async &#123; await getCurrentDatabase(); var res = await _database.rawQuery(\"select * from Sqlite_master where type = 'table' and name = '$tableName'\"); return res != null &amp;&amp; res.length &gt; 0; &#125; /* 获取当前数据库对象 */ static Future&lt;Database&gt; getCurrentDatabase() async &#123; if (_database == null) &#123; await init(); &#125; return _database; &#125; /* 关闭 */ static close() &#123; if (_database != null) &#123; _database.close(); _database = null; &#125; &#125;&#125;/// 数据库数据提供的基类abstract class DemoBaseDbProvider &#123; bool isTableExits = false; tableSqlString(); tableName(); tableBaseString(String name, String columnId) &#123; return ''' create table $name ( $columnId integer primary key autoincrement, '''; &#125; Future&lt;Database&gt; getDatabase() async &#123; return await open(); &#125; @mustCallSuper prepare(name, String createSql) async &#123; isTableExits = await DemoSqlManager.isTableExits(name); if (!isTableExits) &#123; Database db = await DemoSqlManager.getCurrentDatabase(); return await db.execute(createSql); &#125; &#125; @mustCallSuper open() async &#123; if (!isTableExits) &#123; await prepare(tableName(), tableSqlString()); &#125; return await DemoSqlManager.getCurrentDatabase(); &#125;&#125;/*用户表 */class DemoUserInfoDbProvider extends DemoBaseDbProvider &#123; final String name = 'UserInfo'; final String columnId = \"_id\"; final String columnUserName = \"userName\"; final String columnData = \"data\"; int id; String userName; String data; DemoUserInfoDbProvider(); Map&lt;String, dynamic&gt; toMap(String userName, String data) &#123; Map&lt;String, dynamic&gt; map = &#123;columnUserName: userName, columnData: data&#125;; if (id != null) &#123; map[columnId] = id; &#125; return map; &#125; DemoUserInfoDbProvider.fromMap(Map map) &#123; id = map[columnId]; userName = map[columnUserName]; data = map[columnData]; &#125; @override tableName() &#123; return name; &#125; @override tableSqlString() &#123; return tableBaseString(name, columnId) + ''' $columnUserName text not null, $columnData text not null) '''; &#125; Future _getUserProvider(Database db, String userName) async &#123; List&lt;Map&lt;String, dynamic&gt;&gt; maps = await db.query(name, columns: [columnId, columnUserName, columnData], where: \"$columnUserName = ?\", whereArgs: [userName]); if (maps.length &gt; 0) &#123; DemoUserInfoDbProvider provider = DemoUserInfoDbProvider.fromMap(maps.first); return provider; &#125; return null; &#125; // 插入到数据库 Future insert(String userName, String eventMapString) async &#123; Database db = await getDatabase(); var userProvider = await _getUserProvider(db, userName); if (userProvider != null) &#123; var result = await db.delete(name, where: \"$columnUserName = ?\", whereArgs: [userName]); print(result); &#125; return await db.insert(name, toMap(userName, eventMapString)); &#125; //获取事件数据 Future&lt;User&gt; getUserInfo(String userName) async &#123; Database db = await getDatabase(); var userProvider = await _getUserProvider(db, userName); if (userProvider != null) &#123; return User.fromJson(json.decode(userProvider.data)); &#125; return null; &#125;&#125; 思路：通过定义Provider操作数据库： 在Provider中定义表名和数据库字段常量，用于创建表和字段操作； 提供数据库与数据实体之间的映射，比如数据库对象与User对象之间的转化； 在调用Provider时，先判断表是否创建，然后再返回数据库对象进行用户查询。 如果结合网络请求，通过闭包实现，再需要数据库时，先返回数据库，然后通过next()方法将网络请求的方法返回，最后外部可以通过调用next()方法再执行网络请求。 12345678910111213141516UserDao.getUserInfo(userName, needDb: true).then((res) &#123; // 数据库结果 if (res != null &amp;&amp; res.result) &#123; setState(() &#123; userInfo = res.data; &#125;); &#125; return res.next;&#125;).then((res) &#123; // 网络结果 if (res != null &amp;&amp; res.result) &#123; setState(() &#123; userInfo = res.data; &#125;); &#125;&#125;); 3. 其他功能3.1 返回按键监听Flutter中，通过WillPopScope嵌套，可以用于监听处理Android返回键的逻辑。其实WillPopScope并不是监听返回键，而是当前页面将要被pop时，触发的回调。 通过onWillPop()回调返回的Future，判断是否响应pop。 1234567891011121314151617181920212223242526272829303132333435363738394041import 'package:flutter/material.dart';class HomePage extends StatelessWidget &#123; // 单机提示退出 Future&lt;bool&gt; _dialogExitApp(BuildContext context) &#123; return showDialog( context: context, builder: (context) =&gt; new AlertDialog( content: new Text(\"是否退出？\"), actions: &lt;Widget&gt;[ new FlatButton( onPressed: () =&gt; Navigator.of(context).pop(false), child: new Text(\"取消\"), ), new FlatButton( onPressed: () =&gt; Navigator.of(context).pop(true), child: new Text(\"确定\"), ) ], )); &#125; @override Widget build(BuildContext context) &#123; return WillPopScope( onWillPop: () &#123; /* 如果 return new Future.value(false); popped就不会被处理， 如果 return new Future.value(true); popped就会触发， 这里可以通过 showDialog() 弹出确定框，在返回时通过 Navigator.of(context).pop(true/false); 决定是否退出 */ return _dialogExitApp(context); &#125;, child: new Container( color: Colors.white, child: new Text(\"测试\"), ), ); &#125;&#125; 3.2 前后台监听WidgetBindingObserver包含了各种控件的生命周期通知，其中didChangeAppLifecycleState()可以用于做前后台状态监听。 12345678910111213class _HomePageState extends State&lt;HomePage&gt; with WidgetsBindingObserver &#123; // 重写 WidgetsBindingObserver 中的 didChangeAppLifecycleState() @override void didChangeAppLifecycleState(AppLifecycleState state) &#123; // 通过state判断App前后台切换 if (state == AppLifecycleState.resumed) &#123;&#125; &#125; @override Widget build(BuildContext context) &#123; return new Container(); &#125;&#125; 3.3 键盘焦点处理触摸收起键盘，GestureDetector + FocusScope实现。 12345678910111213141516class _LoginPageState extends State&lt;LoginPage&gt; &#123; @override Widget build(BuildContext context) &#123; // 定义触摸层 return new GestureDetector( // 透明也响应处理 behavior: HitTestBehavior.translucent, onTap: () &#123; // 触摸收起键盘 FocusScope.of(context).requestFocus(new FocusNode()); &#125;, child: new Container( ), ); &#125;&#125; 3.4 启动页IOS启动页，在ios/Runner/Assets.xcassets/LaunchImage.imageset/下，Contents.json文件和启动图片，将你的启动页放置在这个目录下，并且修改Contents.json即可，具体尺寸自行谷歌即可。 Android启动页，在android/app/src/main/res/drawable/launch_background.xml中已经有写好的启动页，&lt;item&gt;&lt;bitmap&gt;部分被屏蔽，只需要打开这个屏蔽，并且将你启动图修改为launch_image并放置到各个mipmap文件夹即可，记得各个文件夹下提供相对于大小尺寸的文件。","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://tylerLiu.top/categories/Flutter/"},{"name":"学习","slug":"Flutter/学习","permalink":"https://tylerLiu.top/categories/Flutter/学习/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://tylerLiu.top/tags/Flutter/"}]},{"title":"一、Dart语言和Flutter基础","slug":"一、Dart语言和Flutter基础","date":"2019-09-16T02:15:07.000Z","updated":"2019-09-19T09:14:46.907Z","comments":true,"path":"2019/09/16/一、Dart语言和Flutter基础/","link":"","permalink":"https://tylerLiu.top/2019/09/16/一、Dart语言和Flutter基础/","excerpt":"","text":"Demo地址：tyler_flutter_app 1. 基础1.1 环境搭建参照Flutter中文网进行环境搭建即可。 需要注意，国内由于一些原因，有时需要配置Flutter的代理，并且国内在搜索Flutter第三方包时，也是在https://pub.flutter-io.cn/中搜索，下面是需要配置的环境变量的地址。 123// win直接配置到环境编辑即可，mac配置到bash_profileexport PUB_HOSTED_URL=https://pub.flutter-io.cnexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn 2. Dart语言下的Flutter2.1 基本类型 var：可以定义变量，如var tag = &quot;1111&quot;，这和JS、Kotlin类似，同时Dart算半个动态类型语言，同时支持闭包。 Darrt属于强类型语言，但可以用var声明变量，Dart会自动推导出数据类型，var实际上是编译器的“语法糖”。dynamic表示动态类型，被编译后，实际是一个Object类型，在编译期间不进行任何的类型检查，而是在运行期进行类型检查。 Dart的number类型分为int和double，其中Java的long对应的也是Dart中的int类型。Dart中没有float类型。 Dart下只有bool类型可以用于if判断，不同于JS这种使用方式是不合法的var g = &quot;null&quot;; if(g){}。 Dart中，switch支持String类型。 2.2 变量 Dart不需要给变量设置setter、getter方法，这和Kotlin类似。Dart中所有的基础类型、类都继承Object，默认值是null，自带setter、getter。如果是final或const的话，那么它只有一个getter方法。 Dart中final和const表示常量，比如final name = &quot;111&quot;; const value = 10000；同时static const组合代表了静态常量。其中const的值在编译期确定，final的值要到运行时才确定。Flutter在Release下是AOT模式。 Dart下的数值，在作为字符串使用时，需要显示指定。比如，int i = 0; print(&quot;aaa&quot; + i);，这样是不支持的，需要print(&quot;aaa&quot; + i.toString());。所以在使用动态类型时，需要注意不要将number类型当作String类型使用。 Dart中数组等于列表，所以var list = [];和List list = new List();可以简单看作是一样的。 2.3 方法 Dart下，??、??=属于操作符，如AA ?? &quot;999&quot;表示如果AA为空，返回&quot;999&quot;；AA ??= &quot;999&quot;表示如果AA为空，给AA设置成&quot;999&quot;。 Dart方法可以设置参数默认值和指定名称。如：getDetail(String userName, reponsName, {branch = &quot;master&quot;}){}方法，这里branch不设置的话，默认&quot;master&quot;。参数类型可以指定或不指定。调用效果：getRepositoryDetailDao(&quot;aaa&quot;, &quot;bbb&quot;, branch : &quot;dev&quot;);。 Dart不像Java，没有关键词public、private等修饰符，_表示private，但是有@protected注解。 Dart中多构造函数可以通过如下代码实现。默认构造方法只能有一个，而通过Model.empty()方法可以创建一个空参数的类，其实方法名可以随意创建。而变量初始化值时，只需要通过this.name在构造方法中指定即可：12345678910111213class ModelA &#123; String name; String tag; ///默认构造方法，赋值给name和tag ModelA(this.name, this.tag); ///返回一个空的ModelA ModelA.empty(); ///返回一个设置了name的ModelA ModelA.forName(this.name);&#125; 2.4 FlutterFlutter支持async、await。这个E7类似，代码如下，只是定义的位置不同。同时异步操作也和E7中的Promise类似，只是Flutter中返回的是Future对象，通过then可以执行下一步。如果返回的还是Future，就可以通过then().then()...进行流式操作。 1234567891011121314151617181920///模拟等待两秒，返回OKrequest() async &#123; await Future.delayed(Duration(seconds: 1)); return \"ok!\";&#125;///得到\"ok!\"后，将\"ok!\"修改为\"ok from request\"doSomeThing() async &#123; String data = await request(); data = \"ok from request\"; return data;&#125;///打印结果renderSome() &#123; doSomeThing().then((value) &#123; print(value); ///输出ok from request &#125;);&#125; Flutter中也是通过state跨帧实现管理数据状态的。 Flutter中一切都是由Widget呈现的，通过build()返回Widget。 Stream对应的async/yield也可用于异步。 3. Flutter Widget在Flutter中，一切的显示都是Widget。Widget是一切的基础，作为响应式的渲染，类似MVVM的实现机制。 可以通过修改数据，再用setState()设置数据，Flutter会自动通过绑定的数据更新Widget。所以开发者要做的就是实现Widget界面，并且和数据绑定起来。 Widget分为有状态和无状态，在Flutter中每个页面都是一帧，无状态就是保持在那一帧，而有状态的Widget当数据更新时，其实是绘制了新的Widget，只是State实现了跨帧的数据同步保存。 Tip：当代码框中输入stl时，可以自动弹出创建无状态控件的模板选项，而输入stf时，会弹出创建有状态Widget的模板选项。 代码格式化时，括号内外的逗号都会影响格式化时换行的位置。 如果默认换行的线太短，可以在Setting - Editor - Code - Style - Dart - Wrapping and Braces - Hard wrap at设置数值。 3.1 StatelessWidget下面代码是无状态Widget的简单实现。 继承StatelessWidget，通过build()方法返回一个布局好的控件。 Widget和Widget之间通过child进行嵌套。其中有的Widget只能有一个child，比如下面的Container；有的Widget可以有多个child，也就是children，比如Column布局。下面代码是Container Widget嵌套了Text Widget： 1234567891011121314151617181920import 'package:flutter/material.dart';class DemoWidget extends StatelessWidget &#123; final String text; // 数据可以通过构造方法传递进来 DemoWidget(this.text); @override Widget build(BuildContext context) &#123; // 这里返回你需要的控件 // 这里末尾有没有的逗号，对于格式化代码而已是不一样的 return Container( // 白色背景 color: Colors.white, // ?? 表示如果text为空，就返回尾号后的内容 child: Text(text ?? \"无状态Demo\"), ); &#125;&#125; 3.2 StatefulWidget下面是有状态widget的实现。 需要创建管理的主要是State，通过State的build()方法去构建控件。在State中，可以动态改变数据，这类似MVVM的实现，在setState()之后，改变的数据会触发Widget重新构建刷新。下面代码中，通过延迟两秒之后，让文本显示为“数值改变”。 如下代码还可以看到，State中主要的生命周期有： initState()：初始化，理论上只有初始化一次，后面会说一个特殊情况。 didChangeDependencies：在initState()之后调用，此时可以获取其他State。 dispose()：销毁，只会调用一次。 Flutter关注点在于创建StatelessWidget或者StatefulWidget。在build()中添加布局，然后将数据添加到Widget中，最后通过setState()改变数据，从而实现画面变化。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import 'package:flutter/material.dart';class DemoStatefulWidget extends StatefulWidget &#123; final String text; // 通过构造方法传值 DemoStatefulWidget(this.text); // 主要是负责创建state @override _DemoStatefulWidgetState createState() =&gt; _DemoStatefulWidgetState(text);&#125;class _DemoStatefulWidgetState extends State&lt;DemoStatefulWidget&gt; &#123; String text; _DemoStatefulWidgetState(this.text); @override void initState() &#123; // 初始化，这个函数在生命周期中只调用一次 super.initState(); // 定时2秒 new Future.delayed(const Duration(seconds: 1), () &#123; setState(() &#123; text = \"数值改变\"; &#125;); &#125;); &#125; @override void didChangeDependencies() &#123; // 在initState()之后调 Called when a dependency of this [State] object changes. super.didChangeDependencies(); &#125; @override void dispose() &#123; // 销毁 super.dispose(); &#125; @override Widget build(BuildContext context) &#123; return Container( child: Text(text ?? \"这就是有状态Demo\"), ); &#125;&#125; 4. Flutter布局Flutter内置了近30多种布局Widget。下面是常用的布局。 类型 作用特点 Container 只有一个子Widget。默认充满，包含了padding、margin、color、height、width、decoration等配置。 Padding 只有一个子Widget。只用于设置Padding，常用于嵌套child，给child设置padding。 Center 只有一个子Widget。只用于居中显示，常用于嵌套child，给child设置居中。 Stack 可以有多个子Widget。子Widget堆叠在一起。 Column 可以有多个子Widget。垂直布局。 Row 可以有多个子Widget。水平布局。 Expanded 只有一个子Widget。在Column和Row中充满。 ListView 可以有多个子Widget。 Container：最常用的默认布局。只能包含一个child，支持配置padding、margin、color、height、width、decoration（一般配置边框和阴影）等配置。在Flutter中，不是所有的控件都有padding、margin、color、height、width等属性，所有才会有Padding、Center等Widget的存在。 123456789101112131415new Container( // 四周都是10的margin margin: EdgeInsets.all(10.0), height: 120.0, width: 500.0, // 透明黑色遮罩 decoration: new BoxDecoration( // 弧度 borderRadius: BorderRadius.all(Radius.circular(10.0)), // 设置了decoration的color，就不能设置Container的color color: Colors.black, // 边框 border: new Border.all(color: Colors.indigo, width: 3.0)), child: new Text(\"77777\"),); Column和Row也是最常见的布局。如下，它们常用的属性配置有：主轴方向是start或center等；副轴方向是start或center等；mainAxisSize是充满最大尺寸，或者只根据子Widget显示最小尺寸。 123456// 主轴方向，Column的竖向、Row的横向mainAxisAlignment: MainAxisAlignment.start,// 默认是最大充满或根据child显示最小大小mainAxisSize: MainAxisSize.max,// 副轴方向，Column的横向、Row我的竖向crossAxisAlignment :CrossAxisAlignment.center, Expanded：在Column和Row中表示平均充满，当有两个存在的时候，默认均分充满。同时页面可以设置flex属性决定比例。 12345678910111213new Column( // 主轴居中，即竖直向居中 mainAxisAlignment: MainAxisAlignment.center, // 大小按照最小显示 mainAxisSize: MainAxisSize.min, // 横向居中 crossAxisAlignment: CrossAxisAlignment.center, children: &lt;Widget&gt;[ // flex默认为1 new Expanded(child: new Text(\"111\"), flex: 2), new Expanded(child: new Text(\"222\")), ],); 下面来写一个复杂的控件。首先创建一个私有方法_getBottomItem()，返回一个Expanded Widget，后面会将这个方法返回的Widget在Row下平均充满。 如代码中注释，布局内主要实现一个居中的Icon图标和文本，中间间隔5.0的padding： 1234567891011121314151617181920212223242526272829303132333435// 返回一个居中带图标和文本的Item_getBottomItem(IconData icon, String text) &#123; // 充满 Row 横向的布局 return new Expanded( flex: 1, // 居中显示 child: new Center( // 横向布局 child: new Row( // 主轴居中,即是横向居中 mainAxisAlignment: MainAxisAlignment.center, // 大小按照最大充满 mainAxisSize: MainAxisSize.max, // 竖向居中 crossAxisAlignment: CrossAxisAlignment.center, children: &lt;Widget&gt;[ // 一个图标，大小16.0，灰色 new Icon(icon, size: 16.0, color: Colors.grey), // 间隔 new Padding(padding: new EdgeInsets.only(left: 5.0)), // 显示文本 new Text( text, // 设置字体样式：颜色灰色，字体大小14.0 style: new TextStyle(color: Colors.grey, fontSize: 14.0), // 超过的省略为...显示 overflow: TextOverflow.ellipsis, // 最长一行 maxLines: 1, ), ], ), ), );&#125; 接着将上面的方法放到新的布局中。 首先Container包含了Card，用于快速简单的实现圆角和阴影。 然后包含了FlatButton实现了点击，通过Padding实现边距。 接着通过Column垂直包含了两个子Widget，一个是Contain，一个是Row。 Row内使用的是_getBottomItem()方法返回的Widget，效果图如下。123456789101112131415161718192021222324252627282930313233343536373839404142434445@overrideWidget build(BuildContext context) &#123; return new Container( // 卡片包装 child: new Card( // 点击效果 child: new FlatButton( onPressed: () &#123; print(\"点击了\"); &#125;, child: new Padding( padding: new EdgeInsets.only( left: 0.0, top: 10.0, right: 10.0, bottom: 10.0), child: new Column( mainAxisSize: MainAxisSize.min, children: &lt;Widget&gt;[ // 文本描述 new Container( child: new Text( \"这是一点描述\", style: TextStyle( color: Colors.amber, fontSize: 14.0, ), // 最长三行，超过 ... 显示 maxLines: 3, overflow: TextOverflow.ellipsis, ), margin: new EdgeInsets.only(top: 6.0, bottom: 2.0), alignment: Alignment.topLeft), new Padding(padding: EdgeInsets.all(10.0)), // 三个平均分配的横向图标文字 new Row( crossAxisAlignment: CrossAxisAlignment.start, children: &lt;Widget&gt;[ _getBottomItem(Icons.star, \"1000\"), _getBottomItem(Icons.link, \"1000\"), _getBottomItem(Icons.subject, \"1000\"), ], ), ], ), ))), );&#125; 5. Flutter页面Flutter中除了布局的Widget，还有交互显示的Widget和完整页面呈现的Widget。常见的有MaterialApp、Scaffold、Appbar、Text、Image、FlatBotton等。 类型 作用特点 MaterialApp 一般作为App顶层的主页入口，可配置主题、多语言、路由等 Scaffold 一般用户页面的承载Widget，包含appbar、snackbar、drawer等Material Design设定 Appbar 一般用于Scaffold的appbar，内有标题，二级页面返回按键等 Text 显示文本，主要是通过style设置TextStyle来设置字体样式等 RichText 富文本，通过设置TextSpan，可以拼接出富文本场景 TextField 文本输入框，new TextField(controller: // 文本控制器, obscureText: &quot;hint文本&quot;); Image 图片加载，new FadeInImage.assetNetWork(placeholder: &quot;预览图&quot;, fit: BoxFit.fitWindth, image: &quot;url&quot;); FlatBotton 按键点击，new FlatBotton(onPressed:(){}, child: new Container()); 下面再实现一个完整的页面，实现： 创建一个StatefulWidget：DemoPage。 在_DemoPageState()中，通过build()创建一个Scaffold。 Scaffold内包含一个Appbar和一个ListView。 Appbar类似标题区域，其中设置了title为Text Widget。 body是ListView，返回20个之前创建的DemoItem Widget。1234567891011121314151617181920212223242526272829import 'package:flutter/material.dart';import 'package:tyler_flutter_app/widget/demo_stateless_widget.dart';class DemoPage extends StatefulWidget &#123; @override _DemoPageState createState() =&gt; _DemoPageState();&#125;class _DemoPageState extends State&lt;DemoPage&gt; &#123; @override Widget build(BuildContext context) &#123; // 一个页面的开始，如果是新页面，会自带返回按键 return Scaffold( // 背景 backgroundColor: Colors.blue, // 标题栏 appBar: new AppBar( title: new Text(\"一个标题\"), ), // 正式页面开始，一个ListView，内有20个ItemView body: new ListView.builder( itemBuilder: (context, index) &#123; return new DemoItem(); &#125;, itemCount: 20, ), ); &#125;&#125; 将创建的DemoPage传入main： 123456789101112131415161718import 'package:flutter/material.dart';import 'package:tyler_flutter_app/widget/demo_page.dart';void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget &#123; // This widget is the root of your application. @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Tyler Flutter Demo', theme: ThemeData( primarySwatch: Colors.blue, ), home: DemoPage(), ); &#125;&#125;","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://tylerLiu.top/categories/Flutter/"},{"name":"学习","slug":"Flutter/学习","permalink":"https://tylerLiu.top/categories/Flutter/学习/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://tylerLiu.top/tags/Flutter/"}]},{"title":"Android深入理解ActivityManagerService 02：ActivityTask和Activity栈管理","slug":"Android深入理解ActivityManagerService-02：ActivityTask和Activity栈管理","date":"2019-09-12T01:42:50.000Z","updated":"2019-09-16T01:59:28.280Z","comments":true,"path":"2019/09/12/Android深入理解ActivityManagerService-02：ActivityTask和Activity栈管理/","link":"","permalink":"https://tylerLiu.top/2019/09/12/Android深入理解ActivityManagerService-02：ActivityTask和Activity栈管理/","excerpt":"","text":"1. ActivityTaskActivityTask是一个管理类，用来管理系统所有Activity的各种状态，其内部维护了TaskRecord的列表，因此从Activity任务栈这一角度来说，ActivityTask也可以理解为Activity堆栈。它由ActivityStackSupervisor来进行管理的，而ActivityStackSupervisor是在AMS中的构造方法中被创建。frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java 12345public ActivityManagerService(Context systemContext) &#123; ...... mStackSupervisor = new ActivityStackSupervisor(this); ......&#125; 1.1 ActivityStack的实例类型ActivityStackSupervisor中有多种ActivityStack实例，如下：frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java 1234567public final class ActivityStackSupervisor implements DisplayListener &#123; ...... ActivityStack mHomeStack; ActivityStack mFocusedStack; private ActivityStack mLastFocusedStack; ......&#125; mHomeStack用来存储Launcher App的所有Activity mFocusedStack表示当前正在接收输入或启动下一个Activity的所有Activity mLastFocusedStack表示当前接收输入的所有Activity 通过ActiviyStackSupervisor提供了获取上述ActivityStack的方法，如，要获取mFocusedStack，就可以调用：frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java 123ActivityStack getFocusedStack() &#123; return mFocusedStack;&#125; 1.2 ActivityStateActivityStack中通过枚举存储了Activity的所有状态，如下：frameworks/base/services/core/java/com/android/server/am/ActivityStack.java 1234567891011enum ActivityState &#123; INITIALIZING, RESUMED, PAUSING, PAUSED, STOPPING, STOPPED, FINISHING, DESTROYING, DESTROYED&#125; 应用ActivityState的场景会有很多，比如：frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java 12345678@Overridepublic void overridePendingTransition(IBinder token, String packageName, int enterAnim, int exitAnim) &#123; ...... if (self.state == ActivityState.RESUMED || self.state == ActivityState.PAUSING) &#123; // 1 mWindowManager.overridePendingAppTransition(packageName, enterAnim, exitAnim, null); &#125; Binder.restoreCallingIdentity(origId);&#125; overridePendingAppTransition()用于设置Activity的切换动画，注释1，可以看到只有ActivityState为RESUMED状态或PASUED状态时，才会调用WMS类型的mWindowManager对象的overridePendingAppTransition()来进行切换动画。 1.3 特殊状态的Activity在ActivityStack中定义了一些特殊状态的Activity，如下： 1234567891011121314151617// 正在暂停的ActivityActivityRecord mPausingActivity = null;// 上一个已经暂停的ActivityActivityRecord mLastPausedActivity = null;// 最近一次没有历史记录的ActivityActivityRecord mLastNoHistoryActivity = null;// 已经Resume的ActivityActivityRecord mResumedActivity = null;// 最近一次启动的ActivityActivityRecord mLastStartedActivity = null;// 传递给convertToTranslucent方法的最上层的ActivityActivityRecord mTranslucentActivityWaiting = null; 这些特殊状态都是ActivityRecord类型的，ActivityRecord用来记录一个Activity的所有信息。从Activity任务栈的角度来说，一个或多个ActivityRecord会组成一个TaskRecord，TaskRecors用来记录Activity的栈，而ActivityStack包含了一个或多个TaskRecord。 1.4 维护的ArrayListActivityStack内部维护了多个ArrayList，主要用来存储ActivityRecord和TaskRecord，其中TaskRecord用来记录Activity的Task。 ArrayList 元素类型 说明 mTaskHistory TaskRecord 所有没有被销毁的Task mLRUActivvities ActivtiyRecord 正在运行的Activity，列表中第一个条目是最近最少使用的元素 mNoAnimActivities ActivityRecord 不考虑转换动画的Activity mValidateAppTokens TaskGroup 用于与窗口管理器验证应用令牌 2. Activity栈管理Activity是由任务栈来进行管理的，有了栈管理，就可以对应用程序进行操作，应用可以复用自身应用中以及其他应用的Activity，节省资源。 比如，使用一个App，这个App的联系人详情界面提供了联系人的邮箱，当点击邮箱时会跳转到发送邮件的界面。 App和系统Email中的Activity是处于不同程序进程的，而有了栈管理，就可以把发送邮件界面放到社交应用中详情界面所在栈的栈顶，来做到跨进程操作。 为了更灵活的进行栈管理，Android系统提供了很多配置，下面分别进行讨论。 2.1 Launch Mode用于设定Activity的启动模式： standerd：默认模式，每次启动Activity都会创建一个新的Activity实例。 singleTop：如果要启动的Activity已经在栈顶，则不会重新创建Activity，同时该Activity的onNewIntent()方法会被调用。如果要启动Activity的不在栈顶，就会重新创建该Activity的实例。 singleTask：如果要启动的Activity已经存在栈中，就不会创建该Activity的实例，而是将栈中位于该Activity上的所有Activity出栈，同时该Activity的onNewIntnent()会被调用。如果要启动的Activity不存在在该栈中，则要先创建一个新栈，然后创建该Activity的实例，并入栈。 singleInstance：和singleTask类似，不同的是启动Activity时，首先要创建在一个新栈，然后创建该Activity实例并入栈，新栈中只会存在这一个Activity实例。 2.2 Intent的FLAGIntent中定义了很多FLAG，其中有几个FLAG也可以设定Activity的启动方式，如果Launch Mode设定与FLAG设定的Activity的启动方式不同，则以FLAG设定的为准。 FLAG_ACTIVITY_SINGLE_TOP：与Launch Mode中的singleTop相同。 FLAG_ACTIVITY_NEW_TASK：与Launch Mode中的singleTask相同。 FLAG_ACTIVITY_CLEAR_TOP：Launch Mode中没有与之对应的模式，如果要启动Activity已经存在与栈中，则将所有位于它上面的Activity出栈。singleTop默认具有此标记位的效果。 除了上面的三种FLAG，还有一些对分析栈管理有帮助的。 FLAG_ACTIVITY_NO_HISTORY：Activity一旦退出，就不会存在于栈中。同样的，也可以在AndroidManifest.xml中设置&quot;android:noHistory&quot;。 FLAG_ACTIVITY_MULTIPLE_TASK：需要和FLAG_ACTIVITY_NEW_TASK共同使用才有效果，系统会启动一个新的栈来容纳新启动的Activity。 FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS：Activity不会被放入到“最近启动的Activity”列表中。 FLAG_ACTIVITY_BROUGHT_TO_FRONT：这个标志位通常不是由应用程序中的代码设置的，而是由Launch Mode为singleTask时，系统自动添加上的。 FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY：这个标志位通常不是由应用程序中的代码设置的，而是从历史记录中启动的（长按HOME键调出）。 FLAG_ACTIVITY_CLEAR_TASK：需要和FLAG_ACTIVITY_NEW_TASK共同使用才有效果，用于清除于启动的Activity相关的栈的所有其他Activity。 下面通过源码查看FLAG的应用，在Andorid深入理解四大组件 02：应用程序启动过程（下）中讲过，根Activity启动时会调用AMS的startActivity()，经过层层调用，最终会调用ActivityServer的startActivityUnchecked()，如下时序图： frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java 1234567 private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask) &#123; setInitialState(r, options, inTask, doResume, startFlags, sourceRecord, voiceSession, voiceInteractor); // 1 computeLaunchingTaskFlags(); // 2 computeSourceStack(); mIntent.setFlags(mLaunchFlags); // 3 ......&#125; 注释1，初始化启动Activity的各种配置，在初始化前会重置各种配置再进行配置，这些配置包括：ActivityRecord、Intent、TaskReccord和LaunchFlags（启动的FLAG）等。 注释2，用于计算出启动的FLAG，并将其赋值给mLaunchFlags。 注释3，将mLaunchFlags设置给Intent，达到设定Activity启动方式的目的。 再来看computeLaunchingTaskFlags()：frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java 123456789101112131415private void computeLaunchingTaskFlags() &#123; ...... if (mInTask == null) &#123; // 1 if (mSourceRecord == null) &#123; // 2 if ((mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) == 0 &amp;&amp; mInTask == null) &#123; // 3 Slog.w(TAG, \"startActivity called from non-Activity context; forcing \" + \"Intent.FLAG_ACTIVITY_NEW_TASK for: \" + mIntent); mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK; &#125; &#125; else if (mSourceRecord.launchMode == LAUNCH_SINGLE_INSTANCE) &#123; // 4 mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK; &#125; else if (mLaunchSingleInstance || mLaunchSingleTask) &#123; // 5 mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK; &#125; &#125;&#125; 计算启动的FLAG逻辑比较复杂，这里截取了部分代码。 注释1，TaskRecord类型的mInTask为空时，说明Activity要加入的栈不存在。这段代码就是要解决Activity要加入的栈不存在时，如何计算出启动的FLAG的问题。 注释2，ActivityRecord类型的mSourceRecord是用于描述“初始Activity”的。比如ActivityA启动了ActivityB，ActivityA就是“初始Activity”。 同时满足了注释1和2的条件时，就需要创建一个新的栈。 注释4，如果“初始Activity”所在的栈只允许有一个Activity实例，则也需要创建一个新栈。 注释5，如果Launch Mode设置了singleTask或singleInstance，则也需要创建一个新栈。 2.3 taskAffinity可以在AndoridManifest.xml中设置&quot;android:taskAffinity&quot;，用来指定Activity希望归属的栈，默认，同一个应用程序的所有Activity都有着相同的taskAffinity。 taskAffinity会在下面两种情况产生效果： taskAffinity与FLAG_ACTIVITY_NEW_TASK或者singleTask配合。如果新启动Activity的taskAffinity与栈的taskAffiniy相同（栈的taskAffinity取决于根Activity的taskAffinity），则加入到该栈中。如果不相同，就会创建新栈。 taskAffinity与allowTaskReparenting配合。如果allowTaskReparenting为true，说明Activity具有转移的能力。用之前的邮件为例，当App启动了发送邮件的Activity，此时发送邮件的Activity和App应用处于同一个栈中。如果发送邮件的Activity的allowTaskReparenting设为false，此后邮件程序所在的栈就位于前台，这时发送邮件的Activity就会由App的栈中转移到与它更关系密切的邮件程序（taskAffinity相同）所在的栈中。 接着通过源码查看taskAffinity的应用。ActivityStackSupervisor的findTaskLocked方法用于找到Activity最匹配的栈，最终会调用ActivityTask的findTaskLocked()：frameworks/base/services/core/java/com/android/server/am/ActivityStack.java 1234567891011121314void findTaskLocked(ActivityRecord target, FindTaskResult result) &#123; ...... for (int taskNdx = mTaskHistory.size() - 1; taskNdx &gt;= 0; --taskNdx) &#123;// 1 final TaskRecord task = mTaskHistory.get(taskNdx);// 2 ...... &#125; else if (!isDocument &amp;&amp; !taskIsDocument &amp;&amp; result.r == null &amp;&amp; task.canMatchRootAffinity()) &#123; if (task.rootAffinity.equals(target.taskAffinity)) &#123; // 3 ...... result.r = r; result.matchedByRootAffinity = true; &#125; &#125; else if (DEBUG_TASKS) Slog.d(TAG_TASKS, \"Not a match: \" + task); &#125;&#125; 注释1，遍历mTaskHistory列表，列表的元素为TaskRecord，用于存储没有被销毁的Task。 注释2，得到某个Task的信息。 注释3，将Task的rootAffinity（初始的taskAffinity）和目标Activity的taskAffinity做对比，如果相同，则将FindTaskResult的matchedByRootAffinity属性设置为true，说明找到了匹配的Task。","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://tylerLiu.top/categories/Android进阶/"},{"name":"框架层","slug":"Android进阶/框架层","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/"},{"name":"深入理解ActivityManagerService","slug":"Android进阶/框架层/深入理解ActivityManagerService","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/深入理解ActivityManagerService/"}],"tags":[{"name":"ActivityManagerService","slug":"ActivityManagerService","permalink":"https://tylerLiu.top/tags/ActivityManagerService/"}]},{"title":"Android深入理解ActivityManagerService 01：AMS启动流程和相关类","slug":"Android深入理解ActivityManagerService-01：AMS启动流程和相关类","date":"2019-09-10T08:08:38.000Z","updated":"2019-09-12T01:34:15.212Z","comments":true,"path":"2019/09/10/Android深入理解ActivityManagerService-01：AMS启动流程和相关类/","link":"","permalink":"https://tylerLiu.top/2019/09/10/Android深入理解ActivityManagerService-01：AMS启动流程和相关类/","excerpt":"","text":"1. 概述AMS是系统的引导服务，应用程序进程的启动、切换和调度、四大组件的启动和管理都需要AMS的支持。当然，并不是AMS一个类去完成这些，还有一些其他关联的类共同完成，后面会讲到。本文主要涉及以下要点： AMS的启动流程 AMS与进程的启动 AMS相关（关联）的类 2. AMS的启动流程AMS的启动是在SystemServer进程中启动的，在Android系统启动流程 03：SystemServer进程中提过，这里从SystemServer进程的main()开始讲起：frameworks/base/services/java/com/android/server/SystemServer.java 123public static void main(String[] args) &#123; new SystemServer().run();&#125; main()调用了SystemServer的run()：frameworks/base/services/java/com/android/server/SystemServer.java 12345678910111213141516171819private void run() &#123; ...... System.loadLibrary(\"android_servers\"); // 1 ...... mSystemServiceManager = new SystemServiceManager(mSystemContext); // 2 LocalServices.addService(SystemServiceManager.class, mSystemServiceManager); ...... try &#123; Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, \"StartServices\"); startBootstrapServices(); // 3 startCoreServices(); // 4 startOtherServices(); // 5 &#125; catch (Throwable ex) &#123; ...... &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER); &#125; ......&#125; 注释1，加载动态库&quot;android_servers.so&quot;。 注释2，创建SystemServerManager，它会对系统的服务进行创建、启动和生命周期管理。 注释3，startBootstrapServices()中，用SystemServiceManager启动了ActivityManagerService、PowerManagerService、PackageManagerService等服务。 注释4，startCoreServices()中，启动了BatteryService、UsageStatsService、和WebViewUpdateSeervice。 注释5，startOtherServices()中，启动了CameraService、AlarmManagerService、VrManagerService等服务。 这些服务的父类均为SystemService。从注释3、4、5可以看出，系统将服务分成三类，引导服务、核心服务和其他服务，其他服务是一些不紧要的和一些不需要立即启动的服务。系统服务总共有80多个，这里主要看看引导服务中的AMS是如何启动的，注释3的startBootstrapServices()：frameworks/base/services/java/com/android/server/SystemServer.java 12345678private void startBootstrapServices() &#123; Installer installer = mSystemServiceManager.startService(Installer.class); // Activity manager runs the show. mActivityManagerService = mSystemServiceManager.startService(ActivityManagerService.Lifecycle.class).getService(); // 1 mActivityManagerService.setSystemServiceManager(mSystemServiceManager); mActivityManagerService.setInstaller(installer); ......&#125; 注释1，调用了SystemServiceManager的startService()，方法的参数是ActivityManagerService.Lifecycle.class：frameworks/base/services/core/java/com/android/server/SystemServiceManager.java 123456789101112131415161718192021222324@SuppressWarnings(\"unchecked\")public &lt;T extends SystemService&gt; T startService(Class&lt;T&gt; serviceClass) &#123; try &#123; ... final T service; try &#123; Constructor&lt;T&gt; constructor = serviceClass.getConstructor(Context.class); // 1 service = constructor.newInstance(mContext); // 2 &#125; catch (InstantiationException ex) &#123; ...... &#125; // Register it. mServices.add(service); // 3 // Start it. try &#123; service.onStart(); // 4 &#125; catch (RuntimeException ex) &#123; throw new RuntimeException(\"Failed to start service \" + name + \": onStart threw an exception\", ex); &#125; return service; &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER); &#125;&#125; startService()传入的参数是Lifecycle.class，Lifecycle继承自SystemService。首先，通过反射来创建Lifecycle实例，注释1得到传进来的Lifecycle的构造器Constructor，在注释2调用Constructor的newInstance()来创建Lifecycle类型的service对象。 注释3，将刚创建的service添加到ArrayList类型的mService中来完成注册。 注释4，调用onStart()启动service，并返回该service。Lifecycle是AMS的内部类：frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java 1234567891011121314public static final class Lifecycle extends SystemService &#123; private final ActivityManagerService mService; public Lifecycle(Context context) &#123; super(context); mService = new ActivityManagerService(context); // 1 &#125; @Override public void onStart() &#123; mService.start(); // 2 &#125; public ActivityManagerService getService() &#123; return mService; // 3 &#125;&#125; 上面的代码结合SystemServiceManager的startService()来分析，当通过反射来创建Lifecycle实例时，会调用注释1的方法创建ASM实例，当调用Lifecycle类型的service的onStart()时，实际上调用的是注释2处AMS的start()。在SystemServer的startBootstrapService()的注释1处，调用了如下代码： 1mActivityManagerService = mSystemServiceManager.startService(ActivityManagerService.Lifecycle.class).getService(); SystemServiceManager的startService()最终会返回Lifecycle类型的对象，接着又调用Lifecycle的getService()，这个方法会返回AMS类型的mService对象，见注释3，这样AMS实例就会被创建并返回。 3. AMS与进程启动在Android系统启动流程 02：zygote进程中，在Zygote的Java框架层中，会创建一个Server端的Socket，这个Socket用来等待AMS请求Zygote来创建新的应用程序进程。要启动一个应用程序，首先要保证这个应用程序所需要的应用程序进程已经被启动。AMS在启动应用程序时，会检查这个应用程序需要的应用程序进程是否存在，不存在就会请求Zygote进程将需要的应用程序进程启动。Service的启动过程中会调用ActiveService的bringUpServiceLocked()：frameworks/base/services/core/java/com/android/server/am/ActiveServices.java 1234567891011121314151617181920212223242526272829private String bringUpServiceLocked(ServiceRecord r, int intentFlags, boolean execInFg, boolean whileRestarting, boolean permissionsReviewRequired) throws TransactionTooLargeException &#123; ...... final String procName = r.processName; // 1 ProcessRecord app; if (!isolated) &#123; app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, false); // 2 ...... if (app != null &amp;&amp; app.thread != null) &#123; // 3 try &#123; app.addPackage(r.appInfo.packageName, r.appInfo.versionCode, mAm.mProcessStats); realStartServiceLocked(r, app, execInFg); // 4 return null; &#125; ...... &#125; &#125; else &#123; app = r.isolatedProc; &#125; if (app == null &amp;&amp; !permissionsReviewRequired) &#123; // 5 if ((app=mAm.startProcessLocked(procName, r.appInfo, true, intentFlags, \"service\", r.name, false, isolated, false)) == null) &#123; // 6 ...... &#125; if (isolated) &#123; r.isolatedProc = app; &#125; &#125; ...... return null;&#125; 注释1，得到ServiceRecorder的processName，并赋值给procName，其中ServiceRecorder是用来描述Service的andorid:process属性。 注释2，将procName和Service的uid传入到AMS的getProcessRecorderLocked()中，来查询是否存在一个Service对应的ProcessRecorder类型的对象app，ProcessRecorder主要用来记录运行的应用程序进程的信息。 注释5，判断Service对应的app为空，则说明来运行Service的应用程序进程不存在，则调用注释6的startProcessLocked()来创建对应的应用程序进程，具体可以查看Android应用程序进程启动过程 01。 4. 与AMS相关的类ActivityManager是一个和AMS相关联的类，它主要对运行中的Activity进行管理，这些管理工作并不是由ActivitManager来处理的，而是交由AMS来处理，ActivityManager中的方法会通过ActivityManagerNative（后面简称AMN）的getDefaule()来得到ActivityManagerProxy（后面简称AMP），通过AMP就可以和AMN进行通信，而AMN是一个抽象类，它会将功能交给它的子类AMS来处理，因此，AMP是AMS的代理类。AMS作为系统核心服务，很多API不能直接暴露给ActivityManager的，例如Activity的启动过程中会调用Instrumentation的execStartActivity()：frameworks/base/core/java/android/app/Instrumentation.java 123456789101112public ActivityResult execStartActivity(Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) &#123; ...... try &#123; intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(who); int result = ActivityManagerNative.getDefault().startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); checkStartActivityResult(result, intent); &#125; catch (RemoteException e) &#123; throw new RuntimeException(\"Failure from system\", e); &#125; return null;&#125; execStartActivity()中会调用AMN的getDefault()来获取AMS的代理类AMP。接着调用AMP的startActivity()，先来看AMN的getDefault()：frameworks/base/core/java/android/app/ActivityManagerNative.java 1234567891011121314151617static public IActivityManager getDefault() &#123; return gDefault.get(); &#125;private static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() &#123; protected IActivityManager create() &#123; IBinder b = ServiceManager.getService(\"activity\"); // 1 if (false) &#123; Log.v(\"ActivityManager\", \"default service binder = \" + b); &#125; IActivityManager am = asInterface(b); // 2 if (false) &#123; Log.v(\"ActivityManager\", \"default service = \" + am); &#125; return am; &#125;&#125;; 注释1，得到名为&quot;activity&quot;的Service引用，也就是Binder类型的AMS的引用。 注释2，将它封装成AMP类型对象，并将它保存到gDefault中，此后调用AMN的getDefault()就会直接获得AMS的代理对象AMP。注释2的asInterface()：frameworks/base/core/java/android/app/ActivityManagerNative.java 12345678910static public IActivityManager asInterface(IBinder obj) &#123; if (obj == null) &#123; return null; &#125; IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor); if (in != null) &#123; return in; &#125; return new ActivityManagerProxy(obj);&#125; 主要作用是将IBinder类型的AMS引用封装成AMP，AMP的构造方法如下：frameworks/base/core/java/android/app/ActivityManagerNative.java 123456class ActivityManagerProxy implements IActivityManager &#123; public ActivityManagerProxy(IBinder remote) &#123; mRemote = remote; &#125; ......&#125; AMP的构造方法中将AMS的引用赋值给了变量mRemote，这样在AMP中就可以使用AMS了。其中IActivityManager是一个接口，AMN和AMP都实现了这个接口，用于实现代理模式和Binder通信。 再回到Instrumentation的execStartActivity()，查看AMP的startActivity()，AMP是AMN的内部类：frameworks/base/core/java/android/app/ActivityManagerNative.java 123456789101112public int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options) throws RemoteException &#123; ...... data.writeInt(requestCode); data.writeInt(startFlags); ...... mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0); // 1 reply.readException();+ int result = reply.readInt(); reply.recycle(); data.recycle(); return result;&#125; 首先会将传入的参数写入到Parce类型的data中。 注释1，通过IBinder类型对象mRemote（AMS的引用）向服务端的AMS发送一个START_ACTIVITY_TRANSACTION类型的进程间通信请求。那么服务端AMS就会从Binder线程池中读取客户端发送来的数据，最终会调用AMN的onTransact()：frameworks/base/core/java/android/app/ActivityManagerNative.java 123456789101112@Overridepublic boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; switch (code) &#123; case START_ACTIVITY_TRANSACTION: &#123; ...... int result = startActivity(app, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, options); reply.writeNoException(); reply.writeInt(result); return true; &#125;&#125; onTransact()中会调用AMS的startActivity()：frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java 12345678@Overridepublic final int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) &#123; return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, UserHandle.getCallingUserId());&#125; 在startActivity()的最后会return了starttActivityAsUser()：frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java 12345678910@Overridepublic final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) &#123; enforceNotIsolatedCaller(\"startActivity\"); userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, ALLOW_FULL_ONLY, \"startActivity\", null); return mActivityStarter.startActivityMayWait(caller, -1, callingPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, profilerInfo, null, null, bOptions, false, userId, null, null);&#125; 方法中最后return了startActivityMayWait()，这里不再详细介绍，具体可以查看Andorid深入理解四大组件 02：应用程序启动过程（下）。 在Activity中启动过程中提到了AMP、AMN和AMS，如下所示： AMP是AMN的内部类，它们都实现了IActivityManager接口，这样它们就实现了代理模式，具体来讲是远程代理：AMP和AMN的运行在两个进程，AMP是Client端，AMN是Server端，Server端具体的功能都是由AMN的子类AMS来实现，因此，AMP是AMS在Client端的一个代理类。AMN又实现了Binder，这样AMP和AMS就可以通过Binder来进行进程间通信。 ActivityManager通过AMN的getDefault()得到AMP，通过AMP就可以和AMN进行通信，也就间接的与AMS进行通信。除了ActiviyManager，其他要想与AMS进行通信的类都需要通过AMP。","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://tylerLiu.top/categories/Android进阶/"},{"name":"框架层","slug":"Android进阶/框架层","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/"},{"name":"深入理解ActivityManagerService","slug":"Android进阶/框架层/深入理解ActivityManagerService","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/深入理解ActivityManagerService/"}],"tags":[{"name":"ActivityManagerService","slug":"ActivityManagerService","permalink":"https://tylerLiu.top/tags/ActivityManagerService/"}]},{"title":"Android深入理解JNI 02：类型转换、方法签名和JNIEnv","slug":"Android深入理解JNI-02：类型转换、方法签名和JNIEnv","date":"2019-09-10T05:35:32.000Z","updated":"2019-09-11T08:03:54.307Z","comments":true,"path":"2019/09/10/Android深入理解JNI-02：类型转换、方法签名和JNIEnv/","link":"","permalink":"https://tylerLiu.top/2019/09/10/Android深入理解JNI-02：类型转换、方法签名和JNIEnv/","excerpt":"","text":"1. 数据类型的转换首先看看上篇文章中andorid_media_MediaRecorder.cpp中的android_media_MediaRecorder_staret()：frameworks/base/media/jni/android_media_MediaRecorder.cpp 12345static void android_media_MediaRecorder_start(JNIEnv *env, jobject thiz) &#123; ALOGV(&quot;start&quot;); sp&lt;MediaRecorder&gt; mr = getMediaRecorder(env, thiz); process_media_recorder_call(env, mr-&gt;start(), &quot;java/lang/RuntimeException&quot;, &quot;start failed.&quot;);&#125; 里面有一个参数是Object类型，它是JNI层的数据类型，Java的数据类型到了JNI层就需要转换为JNI层的数据类型。Java的数据类型分为基本数据类型和引用数据类型，JNI层对于这两种类型也做了区分，先来看看基本数据类型的转换。 1.1 基本数据类型的转换 Java Native Signature（签名格式） byte jbyte B char jchar C double jdouble D float jfloat F int jint I short jshort S long jlong J boolean jboolean Z void void V 1.2 引用数据类型的转换 Java Native Signature（签名格式） 所有对象 jobject L+classname+; Class jclass Ljava/lang/Class; String jstring Ljava/lang/String; Throwable jthrowable Ljava/lang/Throwable; Object[] jobjectArray [L+Classname+; byte[] jbyteArray [B char[] jcharArray [C double[] jdoubleArray [D float[] jfloatArray [F int[] jintArray [I short[] jshortArray [S long[] jlongArray [J boolean[] jbooleanArray [Z 引用数据类型还具有继承关系： 再来例举MediaRecorder框架的Java方法：frameworks/base/media/java/android/media/MediaRecorder.java 1private native void _setOutputFile(FileDescriptor fd, long offset, long length) throws IllegalStateException, IOException _setOutputFile()方法对应的JNI层的方法为：frameworks/base/media/jni/android_media_MediaRecorder.cpp 123static void android_media_MediaRecorder_setOutputFileFD(JNIEnv *env, jobject thiz, jobject fileDescriptor, jlong offset, jlong length) &#123; ......&#125; 对比这两个方法可以看到，FileDescriptor转成了jobject类型，long转成了jlong类型。 2. 方法签名前面已经列举了数据类型的签名格式，方法签名就是由签名格式组成的，方法签名有什么作用呢？ frameworks/base/media/jni/android_media_MediaRecorder.cpp 1234567static const JNINativeMethod gMethods[] = &#123; ...... &#123;\"native_init\", \"()V\", (void *)android_media_MediaRecorder_native_init&#125;, &#123;\"native_setup\", \"(Ljava/lang/Object;Ljava/lang/String;Ljava/lang/String;)V\", (void *)android_media_MediaRecorder_native_setup&#125;, ......&#125;; gMethods[]数组中存储的是MediaRecorder的Native方法与JNI层方法的对应关系，其中&quot;()V&quot;和&quot;(Ljava/lang/Object;Ljava/lang/String;Ljava/lang/String;)V&quot;就是方法签名。Java有重载方法，可以定义方法名相同，参数不同的方法，因此，在JNI中仅仅通过方法名是为u发找到对应Java的具体方法的，JNI为了解决这一问题，就将参数类型和返回值类型组合在一起作为方法签名。通过方法签名和方法名就可以找到对应的Java方法了。 JNI方法签名的格式为： 1(参数签名格式...)返回值签名格式 拿上面的gMethods()数组的native_setup()为例，在Java中的定义如下： 1private native final void native_setup(Object mediarecorder_this, String clientName, String opPackageName) throws IllegalStateException; 它在JNI中的方法签名为： 1(Ljava/lang/Object;Ljava/lang/String;Ljava/lang/String;)V&quot; 参照前面的类型转换表格，native_setup()方法的第一个参数的签名为&quot;Ljava/lang/Obnject;&quot;，后面两个参数签名为&quot;Ljava/lang/String;&quot;，返回值的类型Void的签名为&quot;V&quot;，组合起来就是上面的签名了。 Java提供了javap命令来自动生成方法签名。 先写一个简单的MediaRecorder.java包含上面的native_sertup()方法： 123456789101112package com.example;public class MediaRecorder &#123; static &#123; System.loadLibrary(\"media_jni\"); native_init(); &#125; private static native final void native_init(); private native final void native_setup(Object mediarecorder_this, String clientName, String opPackageName) throws IllegalStateException;&#125; 该文件的绝对路径为E:\\Project\\MyStudy\\JNISample\\media\\src\\main\\java\\com\\example\\MediaRecorder.java，接着执行如下命令： 1javac E:\\Project\\MyStudy\\JNISample\\media\\src\\main\\java\\com\\example\\MediaRecorder.java 执行后会生成MediaRecorder.class文件，然后执行如下命令： 1javap -s -p E:\\Project\\MyStudy\\JNISample\\media\\src\\main\\java\\com\\example\\MediaRecorder.class 其中s表示输出内部类型签名，p表示打印出所有的方法和成员（默认打印public成员），最终打印如下： 123456789101112131415C:\\Users\\AHXIUWU_RJ_LY&gt;javap -s -p E:\\Project\\MyStudy\\JNISample\\media\\src\\main\\java\\com\\example\\MediaRecorder.classCompiled from &quot;MediaRecorder.java&quot;public class com.example.MediaRecorder &#123; public com.example.MediaRecorder(); descriptor: ()V private static final native void native_init(); descriptor: ()V private final native void native_setup(java.lang.Object, java.lang.String, java.lang.String) throws java.lang.IllegalStateException; descriptor: (Ljava/lang/Object;Ljava/lang/String;Ljava/lang/String;)V static &#123;&#125;; descriptor: ()V&#125; 可以看到输出的native_setup方法的签名和前面给出的一致。 3. JNIEnvJNIEnv是一个指向全部JNI方法的指针，该指针只在创建它的线程有效，不能跨线程传递，因此，不同线程的JNIEnv是独立的，JNIEnv的主要作用： 调用Java方法。 操作Java（获取Java中的对象和变量等）。 先看看JNIEnv的定义：libnativehelper/include/nativehelper/jni.h 1234567#if defined(__cplusplus)typedef _JNIEnv JNIEnv; // C++中JNIEnv的类型typedef _JavaVM JavaVM; #elsetypedef const struct JNINativeInterface* JNIEnv; // C中JNIEnv的类型typedef const struct JNIInvokeInterface* JavaVM;#endif 这里使用预定义宏__cplusplus来区分C和C++两种代码，如果定义了__cplusplus，则是C++代码中的定义，否则就是C代码中的定义。 在这里也看到了JavaVM，它是虚拟机在JNI层中的代表，在一个虚拟机进程中只有一个JavaVM，因此，该进程的所有线程都可以使用这个JavaVM。通过JavaVM的AttachCurrentThread函数可以获取这个线程的JNIEnv，这样就可以在不同的线程中调用Java方法了。要注意在使用AttachCurrentThread函数的线程推出前，使用DetachCurrentThread函数来释放资源。 3.1 jfieldID和jmethodID在JNI中使用jfieldID和jmethodID来代表Java类中的成员变量和方法，可以通过JNIEnv的下面两个方法来分别得到： 12jfieldID GetFieldID(jclass clazz,const char *name,const char *sig);jmethodID GetFieldID(jclass clazz,const char *name,const char *sig); 其中，jclass代表Java类，name代表成员方法或成员变量的名字，sig为这个方法和变量的签名。再来查看MediaRecorder框架的JNI层是如何使用上述两个方法的：frameworks/base/media/jni/android_media_MediaRecorder.cpp 1234567891011121314151617181920212223static void android_media_MediaRecorder_native_init(JNIEnv *env) &#123; jclass clazz; clazz = env-&gt;FindClass(\"android/media/MediaRecorder\"); // 1 if (clazz == NULL) &#123; return; &#125; fields.context = env-&gt;GetFieldID(clazz, \"mNativeContext\", \"J\"); // 2 if (fields.context == NULL) &#123; return; &#125; fields.surface = env-&gt;GetFieldID(clazz, \"mSurface\", \"Landroid/view/Surface;\"); // 3 if (fields.surface == NULL) &#123; return; &#125; jclass surface = env-&gt;FindClass(\"android/view/Surface\"); if (surface == NULL) &#123; return; &#125; fields.post_event = env-&gt;GetStaticMethodID(clazz, \"postEventFromNative\", \"(Ljava/lang/Object;IIILjava/lang/Object;)V\"); // 4 if (fields.post_event == NULL) &#123; return; &#125;&#125; 注释1，通过FindClass来找到Java层的MediaRecorder的Class对象，并赋值给jclass类型的变量clazz，因此，clazz是Java层的MediaRecorder在JNI层的代表。 注释2和注释3，用来找到Java层的MediaRecorder中名为mNativeContext和Surface的成员变量，并分别赋值给context和surface。 注释4，获取Java层的MediaRecorder中名为postEventFromNative()的静态方法，并赋值给post_event。其中fields的定义为： 123456struct fields_t &#123; jfieldID context; jfieldID surface; jmethodID post_event;&#125;;static fields_t fields; 这些成员变量和方法赋值给jfieldID和jmethodID类型的变量，主要是为了效率考虑，如果每次调用相关方法都要进行查询方法和变量，显然效率会很低，因此在MediaRecorder框架JNI层的初始化方法andorid_media_MediaRecorder_native_init()中，将这些jfieldID和jmethodID类型的变量保存起来，以供后面使用。 3.2 使用jfieldID和jmethodID前面保存了jfieldID和jmethodID的变量，下面如何使用呢？frameworks/base/media/jni/android_media_MediaRecorder.cpp 12345void JNIMediaRecorderListener::notify(int msg, int ext1, int ext2) &#123; ALOGV(\"JNIMediaRecorderListener::notify\"); JNIEnv *env = AndroidRuntime::getJNIEnv(); env-&gt;CallStaticVoidMethod(mClass, fields.post_event, mObject, msg, ext1, ext2, NULL);&#125; 在里面调用了JNIEnv的CallStaticVoidMethod()，其中传入了fields.post_event，从上面可以得知，它其实是保存了Java层的MediaRecorder的静态方法postEventFromNative()：frameworks/base/media/java/android/media/MediaRecorder.java 12345678910private static void postEventFromNative(Object mediarecorder_ref, int what, int arg1, int arg2, Object obj) &#123; MediaRecorder mr = (MediaRecorder)((WeakReference)mediarecorder_ref).get(); if (mr == null) &#123; return; &#125; if (mr.mEventHandler != null) &#123; Message m = mr.mEventHandler.obtainMessage(what, arg1, arg2, obj); mr.mEventHandler.sendMessage(m); &#125;&#125; 这样就能在JNI层中访问Java的静态方法了。同理，要想访问Java的方法，则可以使用JNIEnv的CallVoidMethod()函数。 上面例子是使用了jmethodID，下面再来看看jfieldID：frameworks/base/media/jni/android_media_MediaRecorder.cpp 123456789static void android_media_MediaRecorder_prepare(JNIEnv *env, jobject thiz) &#123; ALOGV(\"prepare\"); sp&lt;MediaRecorder&gt; mr = getMediaRecorder(env, thiz); jobject surface = env-&gt;GetObjectField(thiz, fields.surface); // 1 if (surface != NULL) &#123; const sp&lt;Surface&gt; native_surface = get_surface(env, surface); ...... &#125; process_media_recorder_call(env, mr-&gt;prepare(), \"java/io/IOException\", \"prepare failed.\"); 注释1，调用了JNIEnv的GetObjectField()，参数中的fields.surface用来保存Java层MediaRecorder中的成员变量mSurface，mSurface的类型为Surface，这样通过GetObjectField()函数就可以得到mSurface在JNI层中对应的jobject类型的变量mSurface。","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://tylerLiu.top/categories/Android进阶/"},{"name":"框架层","slug":"Android进阶/框架层","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/"},{"name":"深入理解JNI","slug":"Android进阶/框架层/深入理解JNI","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/深入理解JNI/"}],"tags":[{"name":"JNI","slug":"JNI","permalink":"https://tylerLiu.top/tags/JNI/"}]},{"title":"Android深入理解JNI 01：JNI原理与静态、动态注册","slug":"Android深入理解JNI-01：JNI原理与静态、动态注册","date":"2019-09-09T08:57:27.000Z","updated":"2019-09-11T08:03:52.554Z","comments":true,"path":"2019/09/09/Android深入理解JNI-01：JNI原理与静态、动态注册/","link":"","permalink":"https://tylerLiu.top/2019/09/09/Android深入理解JNI-01：JNI原理与静态、动态注册/","excerpt":"","text":"前言JNI不仅在NDK开发中应用，更是Android系统中Java与Native交互的桥梁。 1. JNI概述Android系统按语言可以分成两个部分：Java部分和Native部分。这样分的原因是，一方面是性能，一方面是在Java诞生之前，就有很多程序和库是用Native编写的。Native编写的库具有更好的性能。 Java是如何使用Native的代码呢？可以使用桥梁JNI。 2. MediaRecorder框架概述MediaRecorder，用于录音和录像。这里主要介绍其中用到的JNI。 Java对应的是MediaRecorder.java，也就是应用开发中直接调用的类。JNI层对应的是libmedia_jni.so，它是一个JNI的动态库。Native层对应的是libmedia.so，这个动态库完成了实际的调用的功能。 3. Java层的MediaRecorder先来看看MediaRecorder.java的源码，下面截取了和JNI有关的部分：frameworks/base/media/java/android/media/MediaRecorder.java 1234567891011public class MediaRecorder&#123; static &#123; System.loadLibrary(\"media_jni\"); // 1 native_init(); // 2 &#125; ....... private static native final void native_init(); // 3 ...... public native void start() throws IllegalStateException; ......&#125; 在静态代码块中，首先调用了注释1，用来加载名为&quot;media_jni&quot;的动态库，也就是&quot;libmedia_jni.so&quot;。接着调用注释2的native_init()。注释3的native_init()是用native来修饰的，说明它是一个native方法，表示会由JNI来实现。MediaRecorder的start()方法同样是一个native方法。 对于Java层楼来说，只要加载对应的JNI库，接着声明native方法就可以了，剩下的工作会由JNI层来完成。 4. JNI层的MediaRecorderMediaRecorder的JNI层是由android_media_recorder.cpp实现的，native方法native_init()和start()的JNI层实现如下：frameworks/base/media/jni/android_media_MediaRecorder.cpp 12345678910111213141516171819static void android_media_MediaRecorder_native_init(JNIEnv *env) &#123; jclass clazz; clazz = env-&gt;FindClass(\"android/media/MediaRecorder\"); if (clazz == NULL) &#123; return; &#125; ...... fields.post_event = env-&gt;GetStaticMethodID(clazz, \"postEventFromNative\", \"(Ljava/lang/Object;IIILjava/lang/Object;)V\"); if (fields.post_event == NULL) &#123; return; &#125;&#125;static void android_media_MediaRecorder_start(JNIEnv *env, jobject thiz) &#123; ALOGV(\"start\"); sp&lt;MediaRecorder&gt; mr = getMediaRecorder(env, thiz); process_media_recorder_call(env, mr-&gt;start(), \"java/lang/RuntimeException\", \"start failed.\");&#125; android_media_MediaRecorder_native_init()方法是native_init()方法在JNI层的实现，android_media_MediaRecorder_start()方法是start()在JNI层的实现。native_init()是如何找到对应的android_media_MediaRecorder_native_init()的呢？这就需要了解JNI方法注册的知识。 5. JNI方法的注册JNI方法的注册分成静态注册和动态注册，其中静态注册多用于NDK开发，动态注册多用于Framework开发。 5.1 静态注册在AS中新建一个Java Library名为media，这里参照系统的MediaRecorder.java： 12345678910package com.example;public class MediaRecorder &#123; static &#123; System.loadLibrary(\"media_jni\"); native_init(); &#125; private static native final void native_init(); public native void start() throws IllegalStateException;&#125; 进入项目的media/src/main/java目录中执行如下命令： 12javac com/example/MediaRecorder.javajavah com.example.MediaRecorder 在执行第二条命令后，会在当前目录下生成com_example_MediaRecorder.h文件：E:\\Project\\MyStudy\\JNISample\\media\\src\\main\\java\\com_example_MediaRecorder.h 1234567891011121314151617181920212223242526272829/* DO NOT EDIT THIS FILE - it is machine generated */#include &lt;jni.h&gt;/* Header for class com_example_MediaRecorder */#ifndef _Included_com_example_MediaRecorder#define _Included_com_example_MediaRecorder#ifdef __cplusplusextern \"C\" &#123;#endif/* * Class: com_example_MediaRecorder * Method: native_init * Signature: ()V */JNIEXPORT void JNICALL Java_com_example_MediaRecorder_native_1init (JNIEnv *, jclass); // 1/* * Class: com_example_MediaRecorder * Method: start * Signature: ()V */JNIEXPORT void JNICALL Java_com_example_MediaRecorder_start (JNIEnv *, jobject);#ifdef __cplusplus&#125;#endif#endif navite_init()被声明为注释1的方法，即Java_com_example_MediaRecorder_native_1init，Java开头，说明是在Java平台中调用JNI方法，后面的com_example_MediaRecorder_native_1init指的是包名+类名+方法名的格式，原本在Java中是以.来进行分割，这里使用的是_，因为在Native中，.由特殊的含义。同时在里面多了一个1，这是因为Java的native_init()中包含了&quot;&quot;，转成JNI方法后，就变成了_1。 其中JNIEnv是一个指向全部JNI方法的指针，该指针只在创建它的线程有效，不能跨线程传递。jclass是JNI的数据类型，对应Java的java.lang.Class实例。jobject也是JNI的数据类型，对应Java的Object实例。 当在Java中调用native_init()时，就会从JNI中寻找Java_com_example_MediaRecorder_native_1init()，如果没有，就会报错，如果有，就会为native_init()和Java_com_example_MediaRecorder_native_1init建立关联，其实是保存JNI的方法指针，这样再次调用native_init()，就会直接使用这个方法指针了。 静态注册就是根据方法名，将Java方法和JNI方法建立关联，但它有一些缺点： JNI层的方法名称过长； 声明Native方法的类需要通过javah生成头文件； 初次调用JNI方法时，需要建立关联，影响效率。 静态注册就是Java的Native方法通过方法指针来与JNI进行关联，如果Native方法知道它在JNI中对应的方法指针，就可以避免上面的缺点，这就是动态注册。 5.2 动态注册JNI中有一种结构用来记录Java的Native方法和JNI方法的关联关系，它就是JNINativemethod，它在jni.h中被定义： 12345typedef struct &#123; const char* name; // Java方法的名字 const char* signature; // Java方法的签名信息 void* fnPtr; // JNI中对应的方法指针&#125; JNINativeMethod; 系统的MediaRecorder采用的就是动态注册，来看看它的JNI层是如何定义的：frameworks/base/media/jni/android_media_MediaRecorder.cpp 1234567891011static const JNINativeMethod gMethods[] = &#123; ...... &#123;\"start\", \"()V\", (void *)android_media_MediaRecorder_start&#125;, // 1 &#123;\"stop\", \"()V\", (void *)android_media_MediaRecorder_stop&#125;, &#123;\"pause\", \"()V\", (void *)android_media_MediaRecorder_pause&#125;, &#123;\"resume\", \"()V\", (void *)android_media_MediaRecorder_resume&#125;, &#123;\"native_reset\", \"()V\", (void *)android_media_MediaRecorder_native_reset&#125;, &#123;\"release\", \"()V\", (void *)android_media_MediaRecorder_release&#125;, &#123;\"native_init\", \"()V\", (void *)android_media_MediaRecorder_native_init&#125;, ......&#125;; 上面定义了一个JNINativeMethod类型的gMethods[]数组，里面存储的就是MediaRecorder的Native方法与JNI层方法的对应关系，其中注释1处&quot;start&quot;是Java层的Native方法，它对应的JNI层的方法为android_media_MediaRecorder_start()。&quot;()V&quot;是start()方法的签名信息，会在后面介绍。 只定义JNINativeMethod类型的数组是没有用的，还需要注册它，注册的方法为register_andorid_media_MediaRecorder()：frameworks/base/media/jni/android_media_MediaRecorder.cpp 1234//JNI_OnLoad in android_media_MediaPlayer.cppint register_android_media_MediaRecorder(JNIEnv *env) &#123; return AndroidRuntime::registerNativeMethods(env, \"android/media/MediaRecorder\", gMethods, NELEM(gMethods));&#125; register_android_media_MediaRecorder()中return了AndroidRuntime的registerNativeMethods()方法，如下：frameworks/base/core/jni/AndroidRuntime.cpp 1234/*static*/int AndroidRuntime::registerNativeMethods(JNIEnv* env, const char* className, const JNINativeMethod* gMethods, int numMethods) &#123; return jniRegisterNativeMethods(env, className, gMethods, numMethods);&#125; registerNativeMethods()中，又return了jniRegisterNativeMethods()：libnativehelper/JNIHelp.cpp 12345678910extern \"C\" int jniRegisterNativeMethods(JNIEnv* env, const char* className, const JNINativeMethod* gMethods, int numMethods) &#123; ...... if (env-&gt;RegisterNatives(c.get(), gMethods, numMethods) &lt; 0) &#123; // 1 char* msg; (void)asprintf(&amp;msg, \"RegisterNatives failed for '%s'; aborting...\", className); env-&gt;FatalError(msg); &#125; return 0;&#125; 注释1可以看出，最终调用的JNIEnv的RegisterNatives()，JNIEnv在JNI中很重要，在后面会介绍。 所以，register_android_media_MediaRecorder()最终调用的是JNIEnv的RegisterNatives()。但是register_android_media_MediaRecorder()是在哪里被调用的呢？在它的注释上可以看到&quot;&quot;JNI_OnLoad in android_media_MediaPlayer.cpp。这个JNI_OnLoad方法会在System.loadLibrary()方法后调用，因为多媒体框架中的很多框架都要进行JNINativeMethods数组注册，因此，注册方法就被统一定义在andorid_media_MediaPlayer.cpp中的JNI_OnLoad()中：frameworks/base/media/jni/android_media_MediaPlayer.cpp 12345678910111213141516171819202122jint JNI_OnLoad(JavaVM* vm, void* /* reserved */) &#123; JNIEnv* env = NULL; jint result = -1; if (vm-&gt;GetEnv((void**) &amp;env, JNI_VERSION_1_4) != JNI_OK) &#123; ALOGE(\"ERROR: GetEnv failed\\n\"); goto *bail; &#125; assert(env != NULL); ...... if (register_android_media_MediaPlayer(env) &lt; 0) &#123; ALOGE(\"ERROR: MediaPlayer native registration failed\\n\"); goto *bail; &#125; if (register_android_media_MediaRecorder(env) &lt; 0) &#123; // 1 ALOGE(\"ERROR: MediaRecorder native registration failed\\n\"); goto *bail; &#125; ...... result = JNI_VERSION_1_4;bail: return result;&#125; 在JNI_OnLoad()中调用了整个多媒体框架的注册JNINativeMethod数组的方法。注释1调用了register_android_media_MediaRecorder()方法，同样的，MediaPlayer框架的注册JNINativeMethod数组的方法register_android_media_MediaPlayer也被调用了。","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://tylerLiu.top/categories/Android进阶/"},{"name":"框架层","slug":"Android进阶/框架层","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/"},{"name":"深入理解JNI","slug":"Android进阶/框架层/深入理解JNI","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/深入理解JNI/"}],"tags":[{"name":"JNI","slug":"JNI","permalink":"https://tylerLiu.top/tags/JNI/"}]},{"title":"Android深入理解Context 02","slug":"Android深入理解Context-02","date":"2019-09-09T06:06:04.000Z","updated":"2019-09-11T08:03:46.428Z","comments":true,"path":"2019/09/09/Android深入理解Context-02/","link":"","permalink":"https://tylerLiu.top/2019/09/09/Android深入理解Context-02/","excerpt":"","text":"1. Activity的Context创建过程当在Activity中调用startActivity()时，实际上调用的是Context的startActivity()，如果想要在Activity中使用Context提供的方法，务必要先创建Context。Activity的Context会在Activity的启动过程中被创建，在Andorid深入理解四大组件 02：应用程序启动过程（下）第二节中，讲到ActivityThread启动Activity的过程，现在从这里开始分析。 ActivityThread是应用程序进程的核心类，它的内部类ApplicatonThread会调用scheduleLaunchActivity()来启动Activity：frameworks/base/core/java/android/app/ActivityThread.java 12345678910111213@Overridepublic final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, Configuration overrideConfig, CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123; updateProcessState(procState, false); ActivityClientRecord r = new ActivityClientRecord(); r.token = token; ...... sendMessage(H.LAUNCH_ACTIVITY, r);&#125; scheduleLaunchActivity()中会将启动Activity的参数封装成ActivityClientRecord，sendMessage()会向H类发送类型为LAUNCH_ACTIVITY的消息，并将ActivityClientRecord传递过去。sendMessage()的目的是将启动Activity的逻辑放在主线程中的消息队列中，这样启动Activity的逻辑就会在主线程中执行。H类中在handleMessage()的LAUNCH_ACTIVITY类型的消息进行处理，其中调用了handleLaunchActivity()，而handleLaunchActivity()中又调用了performLaunchActivity()，这个过程在上篇已经讲过，再来看看performLaunchActivity()：frameworks/base/core/java/android/app/ActivityThread.java 12345678910111213141516171819202122232425262728293031323334private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; ...... Activity activity = null; try &#123; java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent); // 1 ...... &#125; catch (Exception e) &#123; ...... &#125; try &#123; ...... if (activity != null) &#123; Context appContext = createBaseContextForActivity(r, activity); // 2 ...... // 3 activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window); ...... if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); // 4 &#125; else &#123; mInstrumentation.callActivityOnCreate(activity, r.state); &#125; ...... &#125; ...... &#125; ...... return activity;&#125; 注释1，创建Activity的实例。 注释2，通过createBaseContextForActivity()创建Activity的ContextImpl，并将ContextImpl传入注释3的activity的attach()。 注释4，Instrumentation的callActivityOnCreate()中会调用Activiy的onCreate()。 先来看看注释2的createBaseContextForActivity()：frameworks/base/core/java/android/app/ActivityThread.java 12345678private Context createBaseContextForActivity(ActivityClientRecord r, final Activity activity) &#123; ...... ContextImpl appContext = ContextImpl.createActivityContext(this, r.packageInfo, r.token, displayId, r.overrideConfig); // 1 appContext.setOuterContext(activity); // 2 Context baseContext = appContext; ...... return baseContext;&#125; 注释1，调用ContextImpl.createActivityContext()来创建ContextImpl。 注释2，调用Context.setOuterContext()，将前面创建的Activity实例赋值给ContextImpl的成员变量mOuterContext，这样ContextImpl也可以访问Activity的变量和方法。 再回到ActivityThread的performLaunchActivity()，在注释3的attach()：frameworks/base/core/java/android/app/Activity.java 123456789101112131415161718192021final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window) &#123; attachBaseContext(context); // 1 mFragments.attachHost(null /*parent*/); mWindow = new PhoneWindow(this, window); // 2 mWindow.setWindowControllerCallback(this); mWindow.setCallback(this); // 3 mWindow.setOnWindowDismissedCallback(this); ...... mWindow.setWindowManager((WindowManager)context.getSystemService(Context.WINDOW_SERVICE), mToken, mComponent.flattenToString(), (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0); // 4 if (mParent != null) &#123; mWindow.setContainer(mParent.getWindow()); &#125; mWindowManager = mWindow.getWindowManager(); // 5 mCurrentConfig = config;&#125; 注释2，创建PhoneWindow，代表应用程序窗口。PhoneWindow在运行中会间接触发很多事件，比如点击事件、菜单弹出、屏幕焦点变化等事件，这些事件需要转发给与PhoneWindow关联的Activity，转发操作是通过Window.Callback接口实现，Activity实现了这个接口，在注释3处将当前Activity通过Window的setCallback()传递给PhoneWindow。 注释4，给PhoneWindow设置WindowManager，并在注释5处获取WindowManager并赋值给Activity的成员变量mWindowManager，这样在Activity中就可以通过getWindowManager()来获取WindowManager。 注释1，调用了ContextThemeWrapper的attachBaseContext()：frameworks/base/core/java/android/view/ContextThemeWrapper.java 1234@Overrideprotected void attachBaseContext(Context newBase) &#123; super.attachBaseContext(newBase);&#125; 在里面调用了ContextThemeWrapper的父类ContextWrapper的attachBaseContext()：frameworks/base/core/java/android/content/ContextWrapper.java 123456protected void attachBaseContext(Context base) &#123; if (mBase != null) &#123; throw new IllegalStateException(\"Base context already set\"); &#125; mBase = base; // 1&#125; 这里的base指的是从前面传过来到Activity的ContextImpl，将它赋值给ContextWrapper的成员变量mBase。这样ContextWrapper的功能就可以交由ContextImpl处理，例如：frameworks/base/core/java/android/content/ContextWrapper.java 1234@Overridepublic Resources.Theme getTheme() &#123; return mBase.getTheme();&#125; 当调用ContextWrapper的getTheme()时，实际上调用的是COntextImpl的getTheme()。 总结，在启动Activity的过程中创建了ContextImpl，并赋值给了ContextWrapper的成员变量mBase中。Activity继承自ContextWrapper的子类ContextThemeWrapper，这样在Activity中就可以使用ContextImpl了。 ActivityThread到ContextImpl的调用时序图： 2. Service的Context创建过程Service的Context创建过程与Activity的Context创建过程类似，也是在Service的启动过程中被创建。在Andorid深入理解四大组件 03：Service的启动过程第二节中讲到ActivityThread启动Service的过程，现在从这里开始分析。 ActivityThread的内部类ApplicationThread会调用scheduleCreateService()来启动Service：frameworks/base/core/java/android/app/ActivityThread.java 12345public final void scheduleCreateService(IBinder token, ServiceInfo info, CompatibilityInfo compatInfo, int processState) &#123; ...... sendMessage(H.CREATE_SERVICE, s);&#125; 向H类发送类型为CREATE_SERVICE的消息。在H中，handleMessage()的对应case作出处理，在里面调用了handleCreateService()：frameworks/base/core/java/android/app/ActivityThread.java 1234567891011121314private void handleCreateService(CreateServiceData data) &#123; ...... try &#123; if (localLOGV) Slog.v(TAG, \"Creating service \" + data.info.name); ContextImpl context = ContextImpl.createAppContext(this, packageInfo); // 1 context.setOuterContext(service); Application app = packageInfo.makeApplication(false, mInstrumentation); service.attach(context, this, data.info.name, data.token, app, ActivityManagerNative.getDefault()); // 2 service.onCreate(); ...... &#125; catch (Exception e) &#123; ...... &#125;&#125; 注释1，创建ContextImpl，并将该ContextImpl传入注释2中Service.attach()中：frameworks/base/core/java/android/app/Service.java 123456789public final void attach(Context context, ActivityThread thread, String className, IBinder token, Application application, Object activityManager) &#123; attachBaseContext(context); // 1 mThread = thread; mClassName = className; mToken = token; mApplication = application; mActivityManager = (IActivityManager)activityManager; mStartCompatibility = getApplicationInfo().targetSdkVersion &lt; Build.VERSION_CODES.ECLAIR;&#125; 注释1，调用ContextWrapper的attachBaseContext()：frameworks/base/core/java/android/content/ContextWrapper.java 123456protected void attachBaseContext(Context base) &#123; if (mBase != null) &#123; throw new IllegalStateException(\"Base context already set\"); &#125; mBase = base;&#125; 该方法已经在前面讲过。 Service的Context创建过程就讲到这里，由于它和Activity的Context创建过程类似，因此，可以参考前文给出的ActivityThread到ContextWrapper的调用时序图。","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://tylerLiu.top/categories/Android进阶/"},{"name":"框架层","slug":"Android进阶/框架层","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/"},{"name":"深入理解Context","slug":"Android进阶/框架层/深入理解Context","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/深入理解Context/"}],"tags":[{"name":"Context","slug":"Context","permalink":"https://tylerLiu.top/tags/Context/"}]},{"title":"Android深入理解Context 01","slug":"Android深入理解Context-01","date":"2019-09-07T07:35:49.000Z","updated":"2019-09-11T08:03:48.958Z","comments":true,"path":"2019/09/07/Android深入理解Context-01/","link":"","permalink":"https://tylerLiu.top/2019/09/07/Android深入理解Context-01/","excerpt":"","text":"前言Context：上下文对象，这里基于Andorid 7.0源码进行解析。 1. 概述Context：一个应用程序的环境信息的接口。 开发中使用场景主要有两类： 使用Context调用方法，比如：启动Activity、访问资源、调用系统级服务等。 调用方法传入Context，比如：弹出Toast、创建Dialog等。 Activity、Service和Application都间接继承了Context。因此可以计算出一个应用程序进程中有多少个Context，其个数等于Activity、Service的总和加1，这个1是Application。 Context是一个抽象类，内部定义了很多方法和静态常量，它的具体实现是ContextImpl。和Context相关联的类，除了ContextImpl，还有ContextWrapper、ContextThemeWrapper和Activity等。下面是Context的关系图： 图中可以看出，ContextImpl和ContextWrapper继承自Context，ContextWrapper内部包含有Context类型的mBase对象，mBase具体的指向是ContextImpl。ContextImpl提供了很多功能，但外界还需要使用和拓展ContextImpl，所以将其设计成装饰模式，ContextWrapper是装饰类，它对ContextImpl类进行了包装，ContextWrapper主要起方法传递作用，ContextWrapper中几乎所有的方法实现都是调用ContextImpl的相应方法来实现的。 ContextThemeWrapper、Service和Applicaiton继承自ContextWrapper，它们都可以通过mBase来使用Context的方法，同时它们也都是装饰类，在ContextWrapper的基础上又添加了不同的功能。 ContextThemeWrapper中包含了和主题相关的方法，比如：getTheme()。因此，需要主题的Activity继承自ContextThemeWrapper，而不需要主题的Service继承自ContextWrapper。 2. Application Context的创建过程通常使用getApplicationContext()来获取全局的Application Context，那么Application Context是如何创建的？ 在Andorid深入理解四大组件 02：应用程序启动过程（下）中最后讲到ActivityThread启动Activity。ActivityThread作为应用程序进程的核心类，它会调用其内部的ApplicationThread的scheduleLaunchActivity()来启动Activity：frameworks/base/core/java/android/app/ActivityThread.java 1234567891011121314151617181920212223242526272829303132333435@Overridepublic final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, Configuration overrideConfig, CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123; updateProcessState(procState, false); ActivityClientRecord r = new ActivityClientRecord(); r.token = token; r.ident = ident; r.intent = intent; r.referrer = referrer; r.voiceInteractor = voiceInteractor; r.activityInfo = info; r.compatInfo = compatInfo; r.state = state; r.persistentState = persistentState; r.pendingResults = pendingResults; r.pendingIntents = pendingNewIntents; r.startsNotResumed = notResumed; r.isForward = isForward; r.profilerInfo = profilerInfo; r.overrideConfig = overrideConfig; updatePendingConfiguration(curConfig); sendMessage(H.LAUNCH_ACTIVITY, r);&#125; 在ApplicationThread的scheduleLaunchActivity()向H类发送类型为LAUNCH_ACTIVITY的消息，目的是将启动Activity的逻辑放到主线程中的消息列里中，这样启动Activity的逻辑就会在主线程中执行。再来查看H中对于LAUNCH_ACTIVITY的处理：frameworks/base/core/java/android/app/ActivityThread.java 12345678case LAUNCH_ACTIVITY: &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityStart\"); final ActivityClientRecord r = (ActivityClientRecord) msg.obj; r.packageInfo = getPackageInfoNoCheck(r.activityInfo.applicationInfo, r.compatInfo); // 1 handleLaunchActivity(r, null, \"LAUNCH_ACTIVITY\"); // 2 Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125; break; 注释1，通过getPackageInfo()获得LoadedApk的对象，并将该值赋值给ActivityClientRecord.packageInfo，LoadedApk是用来描述已加载的APK文件。 注释2，调用handleLaunchActivity()：frameworks/base/core/java/android/app/ActivityThread.java 12345private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) &#123; ...... Activity a = performLaunchActivity(r, customIntent); ......&#125; 查看performLaunchActivity()：frameworks/base/core/java/android/app/ActivityThread.java 123456789private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; ...... try &#123; Application app = r.packageInfo.makeApplication(false, mInstrumentation); ...... &#125; ...... return activity;&#125; 这里只保留与Application Context相关的逻辑。从前面知道，这里的r.packageInfo是LoadedApk类型的，下面查看其makeApplication()：frameworks/base/core/java/android/app/LoadedApk.java 12345678910111213141516171819public Application makeApplication(boolean forceDefaultAppClass, Instrumentation instrumentation) &#123; if (mApplication != null) &#123; // 1 return mApplication; &#125; ...... try &#123; java.lang.ClassLoader cl = getClassLoader(); ...... ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this); // 2 app = mActivityThread.mInstrumentation.newApplication(cl, appClass, appContext); // 3 appContext.setOuterContext(app); // 4 &#125; catch (Exception e) &#123; ...... &#125; mActivityThread.mAllApplications.add(app); mApplication = app; // 5 ...... return app;&#125; 注释1，如果mApplication不为空，就返回mApplication。这里假设是第一次启动应用程序，所以mApplication为空。 注释2，通过ContextImpl的createAppContext()创建其实例。 注释3，创建Application，在Instrumentation的newApplication()中传入了ClassLoader类型的对象以及注释2创建的ContextImpl。 注释4，将Application赋值给ContextImpl的Context类型的成员变量mOuterContext。 注释5，将Application赋值给LoadedApk的成员变量mApplication。 再来看看注释3的Application的创建，Instrumentation的newApplication()：frameworks/base/core/java/android/app/Instrumentation.java 1234567static public Application newApplication(Class&lt;?&gt; clazz, Context context) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; Application app = (Application)clazz.newInstance(); // 1 app.attach(context); return app;&#125; Instrumentation中有两个newApplication()重载方法，最终都会调用上面的这个重载方法。注释1，通过反射创建Application，并调用Application的attach()，传入ContextImpl：frameworks/base/core/java/android/app/Application.java 1234final void attach(Context context) &#123; attachBaseContext(context); mLoadedApk = ContextImpl.getImpl(context).mPackageInfo;&#125; 在attach()中调用了attachBaseContext()，它的实现在Application的父类ContextWrapper中：frameworks/base/core/java/android/content/ContextWrapper.java 123456protected void attachBaseContext(Context base) &#123; if (mBase != null) &#123; throw new IllegalStateException(\"Base context already set\"); &#125; mBase = base;&#125; base指的就是ContextImpl，将ContextImpl赋值给ContextWrapper类型的成员变量mBase。Application Context创建的过程就到这里。 Application Context创建过程的时序图： 3. Application Context的获取过程通过getApplicationContext()来获取Application Context，getApplicationContext()的实现是在ContextWrapper中：frameworks/base/core/java/android/content/ContextWrapper.java 1234@Overridepublic Context getApplicationContext() &#123; return mBase.getApplicationContext();&#125; 从前面得知，mBase指的就是ContextImpl，再来查看ComtextImpl的getApplicationContext()：frameworks/base/core/java/android/app/ContextImpl.java 1234@Overridepublic Context getApplicationContext() &#123; return (mPackageInfo != null) ? mPackageInfo.getApplication() : mMainThread.getApplication();&#125; 如果LoadedApk不为空，就调用LoadedApk的getApplication()，否则就调用ActivityThread的getApplication()。由于应用程序进程已经启动，所以LoadedApk不会为空，就会调用LoadedApk.getApplication()：frameworks/base/core/java/android/app/LoadedApk.java 123Application getApplication() &#123; return mApplication;&#125; 这里的mApplication就是在LoadedApk.makeApplication()中注释5被赋值。这样就通过getApplicationContext()获取Application Context了。","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://tylerLiu.top/categories/Android进阶/"},{"name":"框架层","slug":"Android进阶/框架层","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/"},{"name":"深入理解Context","slug":"Android进阶/框架层/深入理解Context","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/深入理解Context/"}],"tags":[{"name":"Context","slug":"Context","permalink":"https://tylerLiu.top/tags/Context/"}]},{"title":"Andorid深入理解四大组件 08：Android 8.0 根Activity启动过程（下）","slug":"Andorid深入理解四大组件-08：Android-8-0-根Activity启动过程（下）","date":"2019-09-07T03:08:35.000Z","updated":"2019-09-11T08:03:27.983Z","comments":true,"path":"2019/09/07/Andorid深入理解四大组件-08：Android-8-0-根Activity启动过程（下）/","link":"","permalink":"https://tylerLiu.top/2019/09/07/Andorid深入理解四大组件-08：Android-8-0-根Activity启动过程（下）/","excerpt":"","text":"1. ActivityThread启动Activity过程Andorid深入理解四大组件 07：Android 8.0 根Activity启动过程（上）中已经介绍到代码逻辑运行在应用程序进程中。先来查看ActivityThread启动Activity的过程的时序图。 接着查看ApplicationThread的scheduleLaunchActivity()，其中ApplicationThread是ActivityThread的内部类，应用程序进程创建后会运行代表主线程的实例ActivityThread，它会管理当前应用程序进程的线程。frameworks/base/core/java/android/app/ActivityThread.java 1234567891011121314151617@Overridepublic final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, Configuration overrideConfig, CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123; updateProcessState(procState, false); ActivityClientRecord r = new ActivityClientRecord(); r.token = token; r.ident = ident; r.intent = intent; r.referrer = referrer; ...... updatePendingConfiguration(curConfig); sendMessage(H.LAUNCH_ACTIVITY, r);&#125; scheduleLaunchActivity()会将启动Activity的参数封装成ActivityClientRecord，sendMessage()会向H发送类型为LAUNCH_ACTIVITY的消息，并将ActivityClientRecord的对象发送出去：frameworks/base/core/java/android/app/ActivityThread.java 123456789101112private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) &#123; ...... Message msg = Message.obtain(); msg.what = what; msg.obj = obj; msg.arg1 = arg1; msg.arg2 = arg2; if (async) &#123; msg.setAsynchronous(true); &#125; mH.sendMessage(msg);&#125; 最终会调用H的方法，现在查看H的handleMessage()中对于LAUNCH_ACTIVITY的处理：frameworks/base/core/java/android/app/ActivityThread.H.java 12345678case LAUNCH_ACTIVITY: &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityStart\"); final ActivityClientRecord r = (ActivityClientRecord) msg.obj; // 1 r.packageInfo = getPackageInfoNoCheck(r.activityInfo.applicationInfo, r.compatInfo); // 2 handleLaunchActivity(r, null, \"LAUNCH_ACTIVITY\"); // 3 Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125; break; 注释1，将传来的msg.obj转成ActivityCLientRecord。 注释2，通过getPackageInfoNoCheck()获得LoadedApk类型的对象并赋值给ActivityClientRecord的成员变量packageInfo。应用程序进程要启动Activity时需要将该Activity所属的APK加载进来，而LoadedApk就是用来描述已加载的APK文件。 注释3，调用handleLaunchActivity()：frameworks/base/core/java/android/app/ActivityThread.java 1234567891011121314151617181920212223242526private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) &#123; ...... WindowManagerGlobal.initialize(); // 启动Activity Activity a = performLaunchActivity(r, customIntent); // 1 if (a != null) &#123; r.createdConfig = new Configuration(mConfiguration); reportSizeConfigurations(r); Bundle oldState = r.state; // 将Activity的状态设置为Resume handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason); // 2 if (!r.activity.mFinished &amp;&amp; r.startsNotResumed) &#123; performPauseActivityIfNeeded(r, reason); if (r.isPreHoneycomb()) &#123; r.state = oldState; &#125; &#125; &#125; else &#123; try &#123; // 停止Activity启动 ActivityManager.getService().finishActivity(r.token, Activity.RESULT_CANCELED, null, Activity.DONT_FINISH_TASK_WITH_ACTIVITY); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; &#125;&#125; 注释1，performLaunchActivity()用来启动Activity。 注释2，用来将Activity的状态设置为Resume。 如果该Activity为空，就通知AMS停止启动Activity。 先看看performLaunchActivity()：frameworks/base/core/java/android/app/ActivityThread.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; ActivityInfo aInfo = r.activityInfo; // 1 if (r.packageInfo == null) &#123; r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo, Context.CONTEXT_INCLUDE_CODE); // 2 &#125; ComponentName component = r.intent.getComponent(); // 3 ...... // 创建要启动Activity的上下文环境 ContextImpl appContext = createBaseContextForActivity(r); // 4 Activity activity = null; try &#123; java.lang.ClassLoader cl = appContext.getClassLoader(); // 用类加载器创建该Activity的实例 activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent); // 5 StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) &#123; r.state.setClassLoader(cl); &#125; &#125; catch (Exception e) &#123; ...... &#125; try &#123; Application app = r.packageInfo.makeApplication(false, mInstrumentation); // 6 ...... if (activity != null) &#123; ...... // 7 activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window, r.configCallback); ...... if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); // 8 &#125; else &#123; mInstrumentation.callActivityOnCreate(activity, r.state); &#125; ...... &#125; r.paused = true; mActivities.put(r.token, r); &#125; catch (SuperNotCalledException e) &#123; throw e; &#125; catch (Exception e) &#123; ...... &#125; return activity;&#125; 注释1，获取ActivityInfo，用于存储代码和AndroidManifest设置的Activity和receiver节点信息，比如Activity的theme和launchMode。 注释2，获取APK文件的描述类LoadedApk。 注释3，获取要启动的Activity的ComponentName类，在其中保存了该Activity的包名和类名。 注释4，创建要启动Activity的上下文环境。 注释5，根据ComponentName中存储的Activity类名，用类加载器创建该Activity的实例。 注释6，创建Applicaiton，nakeApplication()内部会调用Application的onCreate()。 注释7，调用Activity的attach()初始化Activity，attach()中会创建Window对象（PhoneWindow）并与Activity自身进行关联。 注释8，调用Instrumentation的callActivityOnCreate()来启动Activity：frameworks/base/core/java/android/app/Instrumentation.java 12345public void callActivityOnCreate(Activity activity, Bundle icicle) &#123; prePerformCreate(activity); activity.performCreate(icicle); postPerformCreate(activity);&#125; 在里面调用了Activity的performCreate()：frameworks/base/core/java/android/app/Activity.java 123456final void performCreate(Bundle icicle) &#123; restoreHasCurrentPermissionRequest(icicle); onCreate(icicle); mActivityTransitionState.readState(icicle); performCreateCommon();&#125; performCreate()中会调用Activity的onCreate()。这样根Activity就启动了，即应用程序启动了。 2. 根Activity启动过程中涉及的进程在应用程序进程没有创建的情况下，根Activity启动过程会涉及到4个进程，分别是Zygote进程、Launcher进程、AMS所在的进程（SystemServer进程）和应用程序进程。它们之间的关系如下： 首先Launcher进程向AMS请求创建根Activity，AMS会判断根Activity所需的应用程序进程是否存在并启动，如果不存在就会请求Zygote进程创建应用程序进程。应用程序进程准备就绪后会通知AMS，AMS会请求应用程序进程创建根Activity。上图中步骤2采用的是Stock通信，步骤1和步骤4采用的是Binder通信。 下面是四个进程调用的时序图： 普通Activity启动过程会涉及两个进程，AMS所在的进程和应用程序进程。","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://tylerLiu.top/categories/Android进阶/"},{"name":"框架层","slug":"Android进阶/框架层","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/"},{"name":"深入理解四大组件","slug":"Android进阶/框架层/深入理解四大组件","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/深入理解四大组件/"}],"tags":[{"name":"四大组件","slug":"四大组件","permalink":"https://tylerLiu.top/tags/四大组件/"}]},{"title":"HTTP FAILED: java.net.UnknownServiceException: CLEARTEXT communication to 包名","slug":"HTTP-FAILED-java-net-UnknownServiceException-CLEARTEXT-communication-to-包名","date":"2019-09-06T08:45:04.000Z","updated":"2019-09-06T08:48:08.542Z","comments":true,"path":"2019/09/06/HTTP-FAILED-java-net-UnknownServiceException-CLEARTEXT-communication-to-包名/","link":"","permalink":"https://tylerLiu.top/2019/09/06/HTTP-FAILED-java-net-UnknownServiceException-CLEARTEXT-communication-to-包名/","excerpt":"","text":"Android P以后，如果使用HTTP，将会报以下错误： 1HTTP FAILED: java.net.UnknownServiceException: CLEARTEXT communication to &quot;包名&quot; not permitted by Android P默认是不允许使用明文网络传输的，会强制让应用都使用https。 经过网上查证，还有可以兼容http的方法，在res下新建一个xml目录，然后创建一个名为：network_security_config.xml文件 ，该文件内容如下： 1234&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;network-security-config&gt; &lt;base-config cleartextTrafficPermitted=\"true\" /&gt;&lt;/network-security-config&gt; 然后在清单文件的application标签内加上： 1android:networkSecurityConfig=\"@xml/network_security_config\"","categories":[{"name":"Android","slug":"Android","permalink":"https://tylerLiu.top/categories/Android/"},{"name":"异常","slug":"Android/异常","permalink":"https://tylerLiu.top/categories/Android/异常/"}],"tags":[{"name":"异常","slug":"异常","permalink":"https://tylerLiu.top/tags/异常/"}]},{"title":"Andorid深入理解四大组件 07：Android 8.0 根Activity启动过程（上）","slug":"Andorid深入理解四大组件-07：Android-8-0-根Activity启动过程（上）","date":"2019-09-04T06:26:22.000Z","updated":"2019-09-11T08:03:26.028Z","comments":true,"path":"2019/09/04/Andorid深入理解四大组件-07：Android-8-0-根Activity启动过程（上）/","link":"","permalink":"https://tylerLiu.top/2019/09/04/Andorid深入理解四大组件-07：Android-8-0-根Activity启动过程（上）/","excerpt":"","text":"1. 概述Activity的启动分为两种，一种是根Activity的启动过程，另一种是普通Activity的启动过程，根Activity指的是应用程序进程启动的第一个Activity，因此根Activity一般情况下也能理解为应用程序的启动过程。普通Activity指的是除了应用程序启动的第一个Activity之外的其他Activity。这里介绍的是根Activity的启动过程，它和普通Activity的启动过程又重叠部分。根Activity的启动过程一般指的就是应用程序的启动过程。 根Activity的启动过程比较复杂，这里分成三个部分，分别是Launcher请求AMS的过程、AMS到ApplicationThread的调用过程和ActivityThread启动Activity的。 2. Launcher请求ASM的过程Launcher启动后会将已经安装的应用程序的快捷图标显示到桌面上，这些应用程序的快捷图标就是启动根Activity的入口，当点击某个应用程序的快捷图标时，就会通过Launcher请求AMS来启动该应用程序。 当点击应用程序快捷图标时，就会调用Launcher的startActivitySafely()：packages/apps/Launcher3/src/com/android/launcher3/Launcher.java 123456789101112131415161718192021public boolean startActivitySafely(View v, Intent intent, ItemInfo item) &#123; ...... intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); // 1 if (v != null) &#123; intent.setSourceBounds(getViewBounds(v)); &#125; try &#123; if (Utilities.ATLEAST_MARSHMALLOW &amp;&amp; (item instanceof ShortcutInfo) &amp;&amp; (item.itemType == Favorites.ITEM_TYPE_SHORTCUT || item.itemType == Favorites.ITEM_TYPE_DEEP_SHORTCUT) &amp;&amp; !((ShortcutInfo) item).isPromise()) &#123; startShortcutIntentSafely(intent, optsBundle, item); &#125; else if (user == null || user.equals(Process.myUserHandle())) &#123; startActivity(intent, optsBundle); // 2 &#125; else &#123; LauncherAppsCompat.getInstance(this).startActivityForProfile(intent.getComponent(), user, intent.getSourceBounds(), optsBundle); &#125; return true; &#125; catch (ActivityNotFoundException|SecurityException e) &#123; Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show(); Log.e(TAG, \"Unable to launch. tag=\" + item + \" intent=\" + intent, e); &#125; return false;&#125; 注释1，设置Flag为Intent.FALG_ACTIVITY_NEW_TASK，这样根Activity会在新的任务栈中启动。 注释2，调用startActivity()，这个startActivity()的实现在Activity中：frameworks/base/core/java/android/app/Activity.java 12345678@Overridepublic void startActivity(Intent intent, @Nullable Bundle options) &#123; if (options != null) &#123; startActivityForResult(intent, -1, options); &#125; else &#123; startActivityForResult(intent, -1); &#125;&#125; 在里面会调用startActivityForResult()，它的第二个参数为-1，表示Launcher不需要知道Activtiy的启动结果：frameworks/base/core/java/android/app/Activity.java 12345678public void startActivityForResult(@RequiresPermission Intent intent, int requestCode, @Nullable Bundle options) &#123; if (mParent == null) &#123; // 1 Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity(this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); ...... &#125; else &#123; ...... &#125;&#125; 注释1，mParent是Activity类型，表示当前Activity的父类。因为目前根Activity还没有创建出来，所以mParent == null为true，接着调用Instrumentation的execStartActivity()，Instrumentation主要用来监听应用程序和系统的交互，execStartActivity()代码如下：frameworks/base/core/java/android/app/Instrumentation.java 123456789101112public ActivityResult execStartActivity(Context who, IBinder contextThread, IBinder token, String target, Intent intent, int requestCode, Bundle options) &#123; ...... try &#123; intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(who); int result = ActivityManager.getService().startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target, requestCode, 0, null, options); checkStartActivityResult(result, intent); &#125; catch (RemoteException e) &#123; throw new RuntimeException(\"Failure from system\", e); &#125; return null;&#125; 首先调用ActivityManager的getService()获取AMS的代理对象，接着调用它的startActivity()。这里和Android 7.0不同的是，Android 7.0是通过ActivityManagerNative的getDefault()来获取AMS的代理对象的，现在这个逻辑封装到了ActivityManager中。首先看看ActivtiyManager.getService()：frameworks/base/core/java/android/app/ActivityManager.java 12345678910111213public static IActivityManager getService() &#123; return IActivityManagerSingleton.get();&#125;private static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton = new Singleton&lt;IActivityManager&gt;() &#123; @Override protected IActivityManager create() &#123; final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE); // 1 final IActivityManager am = IActivityManager.Stub.asInterface(b); // 2 return am; &#125; &#125;; getService()中调用了IActivtyManagerSingleton的get()。IActivityManagerSingleton是一个Singleton类。 注释1，获取一个名为&quot;activity&quot;的Service引用，就是IBinder类型的AMS引用。 注释2，将其转换为IActivityManager类型的对象，这段代码采用的是AIDL，IActivityManager.java类是由AIDL工具在编译时自动生成的，IActivityManager.aidl的文件路径为：frameworks/base/core/java/android/app/IActivityManager.aidl。要实现进程间通信，服务端——AMS只需要继承IActivityManager.Stub类并实现相应的方法就可以了。 Android 8.0之前没有采用AIDL，而是采用了类似AIDL的形式，用AMS的代理对象ActivityManagerProxy来与AMS进行进程间通信，Android 8.0去除了ActivityManagerNative的内部类ActivityManagerProxy，替代它的是IActivityManager，它是AMS在本地的代理。 回到Instrumentation类的execStartActivity()，从上面得知execStartActivity()最终调用的是AMS的startActivity()。 3. AMS到ApplicationThread的调用过程Launcher请求AMS后，代码逻辑已经走到了AMS中，接着AMS到ApplicationThread的调用流程，时序图： AMS的startActivity()如下：frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java 1234@Overridepublic final int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) &#123; return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, UserHandle.getCallingUserId());&#125; 在里面return了startActivityAsUser()，可以发现startActivityAsUser()方法比startActivity()多了一个参数UserHandle.getCallingUserId()，这个方法会获得调用者的UserId，AMS会根据UserId来确定调用者的权限。frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java 1234567891011121314@Overridepublic final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) &#123; // 判断调用者进程是否被隔离 enforceNotIsolatedCaller(\"startActivity\"); // 1 // 检查调用者权限 userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, ALLOW_FULL_ONLY, \"startActivity\", null); // 2 return mActivityStarter.startActivityMayWait(caller, -1, callingPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, profilerInfo, null, null, bOptions, false, userId, null, null, \"startActivityAsUser\");&#125; 注释1，判断调用者进程是否被隔离，如果是，抛出SecurityException。 注释2，检查调用者的权限，如果没有权限，也会抛出SecurityException。 最后调用ActivityStarter的startActivityMayWait()，倒数第二个参数是TaskRecord，表示启动的Activity所在的栈。最后一个参数&quot;startActivityAsUser&quot;表示启动的理由：frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java 123456789101112131415161718final int startActivityMayWait(IApplicationThread caller, int callingUid, String callingPackage, Intent intent, String resolvedType, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, WaitResult outResult, Configuration globalConfig, Bundle bOptions, boolean ignoreTargetSecurity, int userId, IActivityContainer iContainer, TaskRecord inTask, String reason) &#123; ...... int res = startActivityLocked(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity, componentSpecified, outRecord, container, inTask, reason); ...... return res; &#125;&#125; ActivityStarter是Andorid 8.0新加入的类，它是加载Activity的控制类，会收集所有的逻辑来决定如何将Intent和Flag转换为Activity，并将Activity和Task以及Stack相关联。startActivityMayWait()里面调用了startActivityLocked()：frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java 12345678910111213141516171819202122232425int startActivityLocked(IApplicationThread caller, Intent intent, Intent ephemeralIntent, String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int realCallingPid, int realCallingUid, int startFlags, ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container, TaskRecord inTask, String reason) &#123; if (TextUtils.isEmpty(reason)) &#123;// 1 throw new IllegalArgumentException(\"Need to specify a reason.\"); &#125; mLastStartReason = reason; mLastStartActivityTimeMs = System.currentTimeMillis(); mLastStartActivityRecord[0] = null; mLastStartActivityResult = startActivity(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity, componentSpecified, mLastStartActivityRecord, container, inTask); if (outActivity != null) &#123; // mLastStartActivityRecord[0] is set in the call to startActivity above. outActivity[0] = mLastStartActivityRecord[0]; &#125; return mLastStartActivityResult;&#125; 注释1，判断启动的理由不为空，如果为空，抛出IllegalArgumentException()。接着调用startActivity()：frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java 123456789101112131415161718192021222324252627282930313233343536private int startActivity(IApplicationThread caller, Intent intent, Intent ephemeralIntent, String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int realCallingPid, int realCallingUid, int startFlags, ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container, TaskRecord inTask) &#123; int err = ActivityManager.START_SUCCESS; final Bundle verificationBundle = options != null ? options.popAppVerificationBundle() : null; ProcessRecord callerApp = null; if (caller != null) &#123; // 1 // 获取Launcher进程 callerApp = mService.getRecordForAppLocked(caller); // 2 if (callerApp != null) &#123; // 获取Launcher进程的pid和uid并赋值 callingPid = callerApp.pid; callingUid = callerApp.info.uid; &#125; else &#123; ...... err = ActivityManager.START_PERMISSION_DENIED; &#125; &#125; ...... // 创建即将要启动的Activity的描述类ActivityRecord ActivityRecord r = new ActivityRecord(mService, callerApp, callingPid, callingUid, callingPackage, intent, resolvedType, aInfo, mService.getGlobalConfiguration(), resultRecord, resultWho, requestCode, componentSpecified, voiceSession != null, mSupervisor, container, options, sourceRecord); // 2 if (outActivity != null) &#123; outActivity[0] = r; // 3 &#125; ...... doPendingActivityLaunchesLocked(false); return startActivity(r, sourceRecord, voiceSession, voiceInteractor, startFlags, true, options, inTask, outActivity); // 4&#125; 注释1，判断IApplicationThread类型的caller是否为空，这个caller指向的是Launche进程的ApplicationThread对象。 注释2，调用AMS的getRecordForAppLocked()获取代表Launcher进程的callerApp对象，它是ProcessRecord类型的，ProcessRecord是用于描述一个应用程序进程。同样的，ActivityRecord用于描述一个Activity，用来记录一个Activity的所有信息。在注释2创建了一个ActiviytRecord，用于描述即将启动的Activity，并在注释3将创建的ActivtiyRecord赋值给ActivityRecord[]类型的outActivity。这个outActivity会在注释4的startActivitiy()传递下去。frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java 123456789101112131415161718private int startActivity(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask, ActivityRecord[] outActivity) &#123; int result = START_CANCELED; try &#123; mService.mWindowManager.deferSurfaceLayout(); result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor, startFlags, doResume, options, inTask, outActivity); &#125; finally &#123; if (!ActivityManager.isStartResultSuccessful(result) &amp;&amp; mStartActivity.getTask() != null) &#123; mStartActivity.getTask().removeActivity(mStartActivity); &#125; mService.mWindowManager.continueSurfaceLayout(); &#125; postStartActivityProcessing(r, result, mSupervisor.getLastStack().mStackId, mSourceRecord, mTargetStack); return result;&#125; 在里面调用了startActivityUnchecked()：frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java 1234567891011121314151617181920212223242526272829303132private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask, ActivityRecord[] outActivity) &#123; ...... if (mStartActivity.resultTo == null &amp;&amp; mInTask == null &amp;&amp; !mAddingToTask &amp;&amp; (mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != 0) &#123; // 1 newTask = true; // 创建新的TaskRecord result = setTaskFromReuseOrCreateNewTask(taskToAffiliate, preferredLaunchStackId, topStack); // 2 &#125; else if (mSourceRecord != null) &#123; result = setTaskFromSourceRecord(); &#125; else if (mInTask != null) &#123; result = setTaskFromInTask(); &#125; else &#123; setTaskToCurrentTopOrCreateNewTask(); &#125; ...... if (mDoResume) &#123; final ActivityRecord topTaskActivity = mStartActivity.getTask().topRunningActivityLocked(); if (!mTargetStack.isFocusable() || (topTaskActivity != null &amp;&amp; topTaskActivity.mTaskOverlay &amp;&amp; mStartActivity != topTaskActivity)) &#123; ...... &#125; else &#123; if (mTargetStack.isFocusable() &amp;&amp; !mSupervisor.isFocusedStack(mTargetStack)) &#123; mTargetStack.moveToFront(\"startActivityUnchecked\"); &#125; mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity, mOptions); // 3 &#125; &#125; else &#123; mTargetStack.addRecentActivityLocked(mStartActivity); &#125; ...&#125; startActivityUnchecked()中主要处理栈管理的相关逻辑。 注释1，前面得知，启动根Activity时，会将Intent的Flag设置为FLAG_ACTIVITY_NEW_TASK，这里的条件就能满足，接着执行注释2的setTaskFromReuseOrCreateNewTask()，内部会创建一个新的TaskRecord，TaskRecord用来描述一个Activity任务栈。Activity任务栈其实是一个假象模型。 注释3，调用ActivityStackSupervisor的resumeFocusedStackTopActivityLocked()：frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java 1234567891011121314boolean resumeFocusedStackTopActivityLocked(ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) &#123; if (targetStack != null &amp;&amp; isFocusedStack(targetStack)) &#123; return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions); &#125; // 获取要启动的Activity所在栈的栈顶的不是处于停止状态的ActivityRecord final ActivityRecord r = mFocusedStack.topRunningActivityLocked();// 1 if (r == null || r.state != RESUMED) &#123; // 2 mFocusedStack.resumeTopActivityUncheckedLocked(null, null); // 3 &#125; else if (r.state == RESUMED) &#123; // Kick off any lingering app transitions form the MoveTaskToFront operation. mFocusedStack.executeAppTransition(targetOptions); &#125; return false;&#125; 注释1，调用ActivityStack的topRunningActivityLocked()获取要启动的Activity所在的栈的栈顶的不是处于停止状态的ActivityRecord。 注释2，如果ActivityRecord不为空，或者要启动的Activity的状态不是RESUMED，就会调用注释3的ActivityStack的resumeTopActivityUncheckedLocked()：frameworks/base/services/core/java/com/android/server/am/ActivityStack.java 12345678910111213141516boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) &#123; if (mStackSupervisor.inResumeTopActivity) &#123; // Don't even start recursing. return false; &#125; boolean result = false; try &#123; // Protect against recursion. mStackSupervisor.inResumeTopActivity = true; result = resumeTopActivityInnerLocked(prev, options); // 1 &#125; finally &#123; mStackSupervisor.inResumeTopActivity = false; &#125; mStackSupervisor.checkReadyForSleepLocked(); return result;&#125; 注释1，resumeTopActivityInnerLocked()：frameworks/base/services/core/java/com/android/server/am/ActivityStack.java 12345678private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) &#123; ...... &#123; mStackSupervisor.startSpecificActivityLocked(next, true, true); &#125; if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked(); return true;&#125; 这里需要注意调用了ActivityStackSupervisor的startSpecificActivityLocked()：frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java 123456789101112131415161718void startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) &#123; // Is this activity's application already running? // 获取将要启动的Activity所在的应用程序进程 ProcessRecord app = mService.getProcessRecordLocked(r.processName, r.info.applicationInfo.uid, true); // 1 r.getStack().setLaunchTime(r); if (app != null &amp;&amp; app.thread != null) &#123; // 2 try &#123; if ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == 0 || !\"android\".equals(r.info.packageName)) &#123; app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode, mService.mProcessStats); &#125; realStartActivityLocked(r, app, andResume, checkConfig); // 3 return; &#125; catch (RemoteException e) &#123; ...... &#125; &#125; mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0, \"activity\", r.intent.getComponent(), false, false, true);&#125; 注释1，获取将要启动的Activity所在的应用程序进程。 注释2，判断要启动的Activity所在的应用程序进程已经在运行后，调用注释3的realStartActivityLocked()，方法的第二个参数是要启动的Activity所在应用程序进程的ProcessRecord：frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java 12345678910final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app, boolean andResume, boolean checkConfig) throws RemoteException &#123; ...... app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken, System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration), new Configuration(task.mOverrideConfig), r.compat, r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results, newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo); ...... return true;&#125; 这里的app.thread指的是IApplicationThread，它的实现是ActivityThread的内部类ApplicationThread，其中ApplicationThread继承了IApplicationThread.Stub。app指的是传入要启动的Activity的所在的应用程序进程，因此，注释1的代码指的是要在目标应用程序进程启动Activity。当前代码逻辑运行在AMS所在的进程（SystemServer进程），通过ApplicationThread来与应用程序进程进行Binder通信，即，ApplicationThread是AMS所在进程（SystemServer进程）和应用程序进程的通信桥梁，如下图：","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://tylerLiu.top/categories/Android进阶/"},{"name":"框架层","slug":"Android进阶/框架层","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/"},{"name":"深入理解四大组件","slug":"Android进阶/框架层/深入理解四大组件","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/深入理解四大组件/"}],"tags":[{"name":"四大组件","slug":"四大组件","permalink":"https://tylerLiu.top/tags/四大组件/"}]},{"title":"Andorid深入理解四大组件 06：ContentProvider的启动过程","slug":"Andorid深入理解四大组件-06：ContentProvider的启动过程","date":"2019-09-04T01:38:27.000Z","updated":"2019-09-11T08:03:24.358Z","comments":true,"path":"2019/09/04/Andorid深入理解四大组件-06：ContentProvider的启动过程/","link":"","permalink":"https://tylerLiu.top/2019/09/04/Andorid深入理解四大组件-06：ContentProvider的启动过程/","excerpt":"","text":"1. query方法到AMS的调用下面是一个常规ContentProvider在Activity中的代码： 12345678910111213141516public class ContentProviderActivity extends AppCompatActivity &#123; private final static String TAG = \"ContentProviderActivity\"; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_content_provider); Uri uri = Uri.parse(\"content://com.example.liuwangshu.mooncontentprovide.GameProvider\"); ContentValues mContentValues = new ContentValues(); mContentValues.put(\"_id\", 2); mContentValues.put(\"name\", \"323232\"); mContentValues.put(\"describe\", \"32323232\"); getContentResolver().insert(uri, mContentValues); // 1 Cursor gameCursor = getContentResolver().query(uri, new String[]&#123;\"name\", \"describe\"&#125;, null, null, null); ... &#125;&#125; 注释1，使用ContentProvider，需要调用``getContentResolver()`：frameworks/base/core/Java/android/content/ContextWrapper.java 1234@Overridepublic ContentResolver getContentResolver() &#123; return mBase.getContentResolver();&#125; mBase指的是ContextImpl，ContextImpl的getContentResolver()：frameworks/base/core/java/android/app/ContextImpl.java 1234@Overridepublic ContentResolver getContentResolver() &#123; return mContentResolver;&#125; 最终return了ApplicationContentResolver类型的mContentResolver对象，ApplicationContentResolver是ContextImpl的静态内部类，继承自ContentResolver，它在ContextImpl的构造方法中被创建。 当调用ContentResolver的insert()、query()、update()等方法时，就会启动ContentProvider，这里用query()为例。 query()的实现在ApplicationContentResolver的父类ContentResolver中：frameworks/base/core/java/android/content/ContentResolver.java 1234567891011121314151617public final @Nullable Cursor query(final @RequiresPermission.Read @NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder, @Nullable CancellationSignal cancellationSignal) &#123; Preconditions.checkNotNull(uri, \"uri\"); IContentProvider unstableProvider = acquireUnstableProvider(uri); // 1 ...... try &#123; ...... try &#123; qCursor = unstableProvider.query(mPackageName, uri, projection, selection, selectionArgs, sortOrder, remoteCancellationSignal); // 2 &#125; catch (DeadObjectException e) &#123; ...... &#125; ...... &#125;&#125; 注释1，通过acquireUnstableProvider()返回IContentProvider类型的unstableProvider对象。 注释2，调用IContentProvider的query()。 先来看看acquireUnstableProvider()：frameworks/base/core/java/android/content/ContentResolver.java 12345678910public final IContentProvider acquireUnstableProvider(Uri uri) &#123; if (!SCHEME_CONTENT.equals(uri.getScheme())) &#123; // 1 return null; &#125; String auth = uri.getAuthority(); if (auth != null) &#123; return acquireUnstableProvider(mContext, uri.getAuthority()); // 2 &#125; return null;&#125; 注释1，检查Uri的scheme是否为&quot;content&quot;，如果不是，就返回null。 注释2，调用acquireUnstableProvider()，这是一个抽象方法，它的实现在ContentProvider的子类ApplicationContentResolver中：frameworks/base/core/java/android/app/ContextImpl.java 1234@Overrideprotected IContentProvider acquireUnstableProvider(Context c, String auth) &#123; return mMainThread.acquireProvider(c, ContentProvider.getAuthorityWithoutUserId(auth), resolveUserIdFromAuthority(auth), false);&#125; return了ActivityThread类型的mMainThread的acquireProvider()：frameworks/base/core/java/android/app/ActivityThread.java 12345678910111213141516171819202122232425262728293031323334353637383940public final IContentProvider acquireProvider(Context c, String auth, int userId, boolean stable) &#123; final IContentProvider provider = acquireExistingProvider(c, auth, userId, stable); // 1 if (provider != null) &#123; return provider; &#125; IActivityManager.ContentProviderHolder holder = null; try &#123; holder = ActivityManagerNative.getDefault().getContentProvider(getApplicationThread(), auth, userId, stable); // 2 &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; if (holder == null) &#123; Slog.e(TAG, \"Failed to find provider info for \" + auth); return null; &#125; holder = installProvider(c, holder, holder.info, true /*noisy*/, holder.noReleaseNeeded, stable); // 3 return holder.provider;&#125;public final IContentProvider acquireExistingProvider(Context c, String auth, int userId, boolean stable) &#123; synchronized (mProviderMap) &#123; final ProviderKey key = new ProviderKey(auth, userId); final ProviderClientRecord pr = mProviderMap.get(key); if (pr == null) &#123; return null; &#125; IContentProvider provider = pr.mProvider; IBinder jBinder = provider.asBinder(); if (!jBinder.isBinderAlive()) &#123; ...... handleUnstableProviderDiedLocked(jBinder, true); return null; &#125; ProviderRefCount prc = mProviderRefCountMap.get(jBinder); if (prc != null) &#123; incProviderRefLocked(prc, stable); &#125; return provider; &#125;&#125; 注释1，调用acquireExistingProvider()，检查ActivityThread中ArrayMap类型的mProviderMap中是否有目标ContentProvider存在，如果有，就返回，没有，就在注释2处调用AMP的getContentProvider()。 注释3，installProvider()用来将注释2处返回的ContentProvider相关的数据存储在mProviderMap中，起到缓存的作用，这样使用相同的ContentProvider时，就不再需要每次都调用AMS的getContentProvider()。 接着查看AMS的getContentProvider()：frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java 12345@Overridepublic final ContentProviderHolder getContentProvider(IApplicationThread caller, String name, int userId, boolean stable) &#123; ...... return getContentProviderImpl(caller, name, null, stable, userId);&#125; getContentProvider()方法return了getContentProviderImpl()：frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java 123456789101112131415161718192021222324252627282930313233343536373839404142private ContentProviderHolder getContentProviderImpl(IApplicationThread caller, String name, IBinder token, boolean stable, int userId) &#123; ...... synchronized(this) &#123; ...... if (!providerRunning) &#123; ...... // If the provider is not already being launched, then get it // started. if (i &gt;= N) &#123; final long origId = Binder.clearCallingIdentity(); try &#123; ...... ProcessRecord proc = getProcessRecordLocked(cpi.processName, cpr.appInfo.uid, false); // 1 if (proc != null &amp;&amp; proc.thread != null &amp;&amp; !proc.killed) &#123; ...... if (!proc.pubProviders.containsKey(cpi.name)) &#123; checkTime(startTime, \"getContentProviderImpl: scheduling install\"); proc.pubProviders.put(cpi.name, cpr); try &#123; proc.thread.scheduleInstallProvider(cpi); // 2 &#125; catch (RemoteException e) &#123; &#125; &#125; &#125; else &#123; checkTime(startTime, \"getContentProviderImpl: before start process\"); proc = startProcessLocked(cpi.processName, cpr.appInfo, false, 0, \"content provider\", new ComponentName(cpi.applicationInfo.packageName, cpi.name), false, false, false); // 3 checkTime(startTime, \"getContentProviderImpl: after start process\"); ...... &#125; cpr.launchingApp = proc; mLaunchingProviders.add(cpr); &#125; finally &#123; Binder.restoreCallingIdentity(origId); &#125; &#125; ...... &#125; ...... &#125; ...... return cpr != null ? cpr.newHolder(conn) : null;&#125; 注释1，getProcessRecordLocked()获取目标ContentProvider的应用程序进程信息，这些信息会保存在ProcessRecord类型的proc中。如果该应用程序进程已经启动，就会调用注释2的代码，否则就调用注释3的startProcessLocked()来启动进程。这里假设ContentProvider的应用程序进程还没有启动，应用程序进程的启动过程，详细查看Andorid深入理解四大组件 01：应用程序启动过程（上），最终会调用ActivityThread的main()：frameworks/base/core/java/android/app/ActivityThread.java 1234567891011121314151617public static void main(String[] args) &#123; ...... Looper.prepareMainLooper(); // 1 ActivityThread thread = new ActivityThread(); // 2 thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, \"ActivityThread\")); &#125; // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); throw new RuntimeException(\"Main thread loop unexpectedly exited\");&#125; 注释1，在ThreadLocal中获取Looper，并在注释3处开启消息循环。 注释2，创建ActivityThread，并调用其attach()：frameworks/base/core/java/android/app/ActivityThread.java 12345678910111213141516private void attach(boolean system) &#123; ...... if (!system) &#123; ...... final IActivityManager mgr = ActivityManagerNative.getDefault(); // 1 try &#123; mgr.attachApplication(mAppThread);// 2 &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; ...... &#125; else &#123; ...... &#125; ......&#125; 注释1，获取AMS实例。 注释2，调用AMS的attachApplication()，并将ApplicationThread类型的mAppThread对象传进去。 query()到AMS的调用过程时序图（省略了应用程序进程启动过程）： 2. AMS启动ContentProvider过程接着看AMS的atrachApplication()：frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java 123456789@Overridepublic final void attachApplication(IApplicationThread thread) &#123; synchronized (this) &#123; int callingPid = Binder.getCallingPid(); final long origId = Binder.clearCallingIdentity(); attachApplicationLocked(thread, callingPid); Binder.restoreCallingIdentity(origId); &#125;&#125; 在里面又调用了attachApplicationLocked()：frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java 1234567891011121314151617181920private final boolean attachApplicationLocked(IApplicationThread thread, int pid) &#123; ...... try &#123; ...... thread.bindApplication(processName, appInfo, providers, app.instrumentationClass, profilerInfo, app.instrumentationArguments, app.instrumentationWatcher, app.instrumentationUiAutomationConnection, testMode, mBinderTransactionTrackingEnabled, enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(mConfiguration), app.compat, getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked()); updateLruProcessLocked(app, false, null); app.lastRequestedGc = app.lastLowMemory = SystemClock.uptimeMillis(); &#125; catch (Exception e) &#123; ...... &#125; ...... return true;&#125; 在里面调用了thread的bindApplication()，thread是IApplicationThread类型的，该类用于进程间通信，具体实现bindApplication()的是ApplicationThreadProxy类：frameworks/base/core/java/android/app/ApplicationThreadNative.java 12345678910111213141516class ApplicationThreadProxy implements IApplicationThread &#123; ...... @Override public final void bindApplication(String packageName, ApplicationInfo info, List&lt;ProviderInfo&gt; providers, ComponentName testName, ProfilerInfo profilerInfo, Bundle testArgs, IInstrumentationWatcher testWatcher, IUiAutomationConnection uiAutomationConnection, int debugMode, boolean enableBinderTracking, boolean trackAllocation, boolean restrictedBackupMode, boolean persistent, Configuration config, CompatibilityInfo compatInfo, Map&lt;String, IBinder&gt; services, Bundle coreSettings) throws RemoteException &#123; ...... mRemote.transact(BIND_APPLICATION_TRANSACTION, data, null, IBinder.FLAG_ONEWAY); data.recycle(); &#125; ......&#125; 到目前为止，上面的代码都还是在AMS进程中执行的，因此，需要通过IBinder类型的mRemote对象向新创建的应用程序进程（目标ContentProvider所在的进程）发送BIND_APPLICATION_TRSANSACTION类型的通信请求。处理这个通信请求的是在新创建的应用程序进程中执行的ApplicationThread的bindApplication()：frameworks/base/core/java/android/app/ActivityThread.java 1234567891011public final void bindApplication(String processName, ApplicationInfo appInfo, List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName, ProfilerInfo profilerInfo, Bundle instrumentationArgs, IInstrumentationWatcher instrumentationWatcher, IUiAutomationConnection instrumentationUiConnection, int debugMode, boolean enableBinderTracking, boolean trackAllocation, boolean isRestrictedBackupMode, boolean persistent, Configuration config, CompatibilityInfo compatInfo, Map&lt;String, IBinder&gt; services, Bundle coreSettings) &#123; ...... sendMessage(H.BIND_APPLICATION, data);&#125; 在最后调用sendMessage()向H发送BIND_APPLICATION类型的消息：frameworks/base/core/java/android/app/ActivityThread.H.java 123456case BIND_APPLICATION: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"bindApplication\"); AppBindData data = (AppBindData)msg.obj; handleBindApplication(data); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; 再来看看handleBindApplicaiton()：frameworks/base/core/java/android/app/ActivityThread.java 123456789101112131415161718192021222324private void handleBindApplication(AppBindData data) &#123; ...... final ContextImpl appContext = ContextImpl.createAppContext(this, data.info); // 1 try &#123; final ClassLoader cl = instrContext.getClassLoader(); mInstrumentation = (Instrumentation)cl.loadClass(data.instrumentationName.getClassName()).newInstance(); // 2 &#125; catch (Exception e) &#123; ...... &#125; final ComponentName component = new ComponentName(ii.packageName, ii.name); mInstrumentation.init(this, instrContext, appContext, component, data.instrumentationWatcher, data.instrumentationUiAutomationConnection); // 3 ...... Application app = data.info.makeApplication(data.restrictedBackupMode, null); // 4 mInitialApplication = app; if (!data.restrictedBackupMode) &#123; if (!ArrayUtils.isEmpty(data.providers)) &#123; installContentProviders(app, data.providers); // 5 mH.sendEmptyMessageDelayed(H.ENABLE_JIT, 10*1000); &#125; &#125; ...... mInstrumentation.callApplicationOnCreate(app); // 6 ......&#125; 注释1，创建ContextImpl。 注释2，通过反射创建Instrumentation，并在注释3对其进行初始化。 注释4，创建Application，并在注释6调用Application的onCreate()，这意味着ContentProvider所在的应用程序进程已经启动完毕。 在这之前，注释5调用installContentProviders()来启动ContentProvider：frameworks/base/core/java/android/app/ActivityThread.java 1234567891011121314private void installContentProviders(Context context, List&lt;ProviderInfo&gt; providers) &#123; final ArrayList&lt;IActivityManager.ContentProviderHolder&gt; results = new ArrayList&lt;IActivityManager.ContentProviderHolder&gt;(); for (ProviderInfo cpi : providers) &#123; // 1 ...... IActivityManager.ContentProviderHolder cph = installProvider(context, null, cpi, false /*noisy*/, true /*noReleaseNeeded*/, true /*stable*/); // 2 ...... &#125; try &#123; ActivityManagerNative.getDefault().publishContentProviders(getApplicationThread(), results); // 3 &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125;&#125; 注释1，遍历当前应用程序进程的ProviderInfo列表，得到每个ContentProvider的ProviderInfo（存储ContentProvider的信息），并在注释2调用installProvider()来启动这些ContentProvider。 注释3，通过AMS的publishContentProviders()将这些ContentProvider存储在AMS的mProviderMap，这个mProviderMap能起到缓存作用。 再来看看installProvider()是如何启动ContentProvdier的：frameworks/base/core/java/android/app/ActivityThread.java 12345678910111213141516171819202122232425private IActivityManager.ContentProviderHolder installProvider(Context context, IActivityManager.ContentProviderHolder holder, ProviderInfo info, boolean noisy, boolean noReleaseNeeded, boolean stable) &#123; ContentProvider localProvider = null; IContentProvider provider; if (holder == null || holder.provider == null) &#123; ...... try &#123; final java.lang.ClassLoader cl = c.getClassLoader(); localProvider = (ContentProvider)cl.loadClass(info.name).newInstance(); // 1 provider = localProvider.getIContentProvider(); if (provider == null) &#123; ...... return null; &#125; ...... localProvider.attachInfo(c, info); // 2 &#125; catch (java.lang.Exception e) &#123; ...... return null; &#125; &#125; else &#123; ...... &#125; ...... return retHolder;&#125; 注释1，通过反射创建ContentProvider类型的对象localProvider，并在注释2调用它的attachInfo()：frameworks/base/core/java/android/content/ContentProvider.java 12345678910111213141516171819private void attachInfo(Context context, ProviderInfo info, boolean testing) &#123; mNoPerms = testing; if (mContext == null) &#123; mContext = context; if (context != null) &#123; mTransport.mAppOpsManager = (AppOpsManager) context.getSystemService(Context.APP_OPS_SERVICE); &#125; mMyUid = Process.myUid(); if (info != null) &#123; setReadPermission(info.readPermission); setWritePermission(info.writePermission); setPathPermissions(info.pathPermissions); mExported = info.exported; mSingleUser = (info.flags &amp; ProviderInfo.FLAG_SINGLE_USER) != 0; setAuthorities(info.authority); &#125; ContentProvider.this.onCreate(); &#125;&#125; 在最后调用了onCreate()，它是一个抽象方法。这样ContentProvider就启动完成了。 AMS启动ContentProvider时序图：","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://tylerLiu.top/categories/Android进阶/"},{"name":"框架层","slug":"Android进阶/框架层","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/"},{"name":"深入理解四大组件","slug":"Android进阶/框架层/深入理解四大组件","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/深入理解四大组件/"}],"tags":[{"name":"四大组件","slug":"四大组件","permalink":"https://tylerLiu.top/tags/四大组件/"}]},{"title":"Andorid深入理解四大组件 05：广播的注册、发送和接收","slug":"Andorid深入理解四大组件-05：广播的注册、发送和接收","date":"2019-09-03T07:02:24.000Z","updated":"2019-09-11T08:03:22.745Z","comments":true,"path":"2019/09/03/Andorid深入理解四大组件-05：广播的注册、发送和接收/","link":"","permalink":"https://tylerLiu.top/2019/09/03/Andorid深入理解四大组件-05：广播的注册、发送和接收/","excerpt":"","text":"1. 广播的注册BroadcastReceiver的注册分为两种，静态注册和动添注册。静态注册在应用安装时由PackageManagerService来完成注册，这个会在后续介绍PackageManagerService中详细介绍。本文重点介绍动态注册。调用其registerReceiver()，它的实现在ContextWrapper中：frameworks/base/core/java/android/content/ContextWrapper.java 1234@Overridepublic Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter) &#123; return mBase.registerReceiver(receiver, filter);&#125; 这里的mBase指向的是ComtextImpl，已经在Andorid深入理解四大组件 03：Service的启动过程说过。ContextImpl的registerReceiver()由很多重载，最终都会调用registerReceiverInternal() 12345678910111213141516171819202122232425262728private Intent registerReceiverInternal(BroadcastReceiver receiver, int userId, IntentFilter filter, String broadcastPermission, Handler scheduler, Context context) &#123; IIntentReceiver rd = null; if (receiver != null) &#123; if (mPackageInfo != null &amp;&amp; context != null) &#123; // 1 if (scheduler == null) &#123; scheduler = mMainThread.getHandler(); &#125; rd = mPackageInfo.getReceiverDispatcher( receiver, context, scheduler, mMainThread.getInstrumentation(), true); // 2 &#125; else &#123; if (scheduler == null) &#123; scheduler = mMainThread.getHandler(); &#125; rd = new LoadedApk.ReceiverDispatcher(receiver, context, scheduler, null, true).getIIntentReceiver(); // 3 &#125; &#125; try &#123; final Intent intent = ActivityManagerNative.getDefault().registerReceiver(mMainThread.getApplicationThread(), mBasePackageName, rd, filter, broadcastPermission, userId); // 4 if (intent != null) &#123; intent.setExtrasClassLoader(getClassLoader()); intent.prepareToEnterProcess(); &#125; return intent; &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; 注释1，判断如果LoadedApk类型的mPackageInfo不为null且context不为null，就调用注释2的代码，通过mPackageInfo的getReceiverDispatcher()获取rd对象，否则就调用注释3的代码来创建rd对象。注释2和注释3的目的都是要获取IIntentReceiver类型的对象rd，IIntentReceiver是一个Binder接口，用于进行跨进程的通信。它的具体实现在LoadedApk.ReceiverDispatcher.InnerReceiver：frameworks/base/core/java/android/app/LoadedApk.java 123456789101112static final class ReceiverDispatcher &#123; final static class InnerReceiver extends IIntentReceiver.Stub &#123; final WeakReference&lt;LoadedApk.ReceiverDispatcher&gt; mDispatcher; final LoadedApk.ReceiverDispatcher mStrongRef; InnerReceiver(LoadedApk.ReceiverDispatcher rd, boolean strong) &#123; mDispatcher = new WeakReference&lt;LoadedApk.ReceiverDispatcher&gt;(rd); mStrongRef = strong ? rd : null; &#125; ...... &#125; ......&#125; 回到registerReceiverInternal()，在注释4调用了ActivityManagerProxy（AMP）的registerReceiver()，实际上就是调用AMS的registerReceiver()，并将rd传进去：frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public Intent registerReceiver(IApplicationThread caller, String callerPackage, IIntentReceiver receiver, IntentFilter filter, String permission, int userId) &#123; ...... synchronized(this) &#123; ...... Iterator&lt;String&gt; actions = filter.actionsIterator(); // 1 ...... // Collect stickies of users int[] userIds = &#123; UserHandle.USER_ALL, UserHandle.getUserId(callingUid) &#125;; while (actions.hasNext()) &#123; String action = actions.next(); for (int id : userIds) &#123; ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt; stickies = mStickyBroadcasts.get(id); if (stickies != null) &#123; ArrayList&lt;Intent&gt; intents = stickies.get(action); if (intents != null) &#123; if (stickyIntents == null) &#123; stickyIntents = new ArrayList&lt;Intent&gt;(); &#125; stickyIntents.addAll(intents); // 2 &#125; &#125; &#125; &#125; &#125; ArrayList&lt;Intent&gt; allSticky = null; if (stickyIntents != null) &#123; final ContentResolver resolver = mContext.getContentResolver(); for (int i = 0, N = stickyIntents.size(); i &lt; N; i++) &#123; Intent intent = stickyIntents.get(i); if (filter.match(resolver, intent, true, TAG) &gt;= 0) &#123; if (allSticky == null) &#123; allSticky = new ArrayList&lt;Intent&gt;(); &#125; allSticky.add(intent); // 3 &#125; &#125; &#125; ...... synchronized (this) &#123; ...... ReceiverList rl = mRegisteredReceivers.get(receiver.asBinder()); // 4 if (rl == null) &#123; rl = new ReceiverList(this, callerApp, callingPid, callingUid, userId, receiver); // 5 if (rl.app != null) &#123; rl.app.receivers.add(rl); &#125; ...... &#125; ...... BroadcastFilter bf = new BroadcastFilter(filter, rl, callerPackage, permission, callingUid, userId); // 6 rl.add(bf); // 7 if (!bf.debugCheck()) &#123; Slog.w(TAG, \"==&gt; For Dynamic broadcast\"); &#125; mReceiverResolver.addFilter(bf); // 8 ...... return sticky; &#125;&#125; 注释1，根据传入的IntentFilter类型的filter得到actions列表，根据actions列表和userIds（userId可以理解为应用程序的uid）得到所有的粘性广播的intent，并在注释2传到stickyIntents中。 注释3，将这些粘性广播的intent传入到allSticky列表中，从这里可以看出粘性广播是存储在AMS中。 注释4，获取ReceiverList列表，如果为空，则在注释5处创建，ReceiverList继承自ArrayList，用来存储广播接收者。 注释6，创建BroadcastFilter，并传入此前创建的ReceiverList，BroadcastFilter用来描述注册的广播接收者，并在注释7通过add()添加将自身添加到ReceiverList中。 注释8，将BroadcastFilter添加到mReceiverResolver中，这样当AMS接收到广播时就可以从mReceiverResolver中获取相应的广播接收者了。 广播注册过程时序图： 2. 广播的发送和接收2.1 ContextImpl到AMS的调用过程广播可以发送多种类型，包括无序广播（普通广播）、有序广播和粘性广播，这里以无序广播为例。 要发送无序广播，要调用sendBroadcast()，它的实现同样在ContextWrapper中：frameworks/base/core/java/android/content/ContextWrapper.java 1234@Overridepublic void sendBroadcast(Intent intent) &#123; mBase.sendBroadcast(intent);&#125; 再来看看ContextImpl中的sendBroadcast()：frameworks/base/core/java/android/app/ContextImpl.java 1234567891011@Overridepublic void sendBroadcast(Intent intent) &#123; warnIfCallingFromSystemProcess(); String resolvedType = intent.resolveTypeIfNeeded(getContentResolver()); try &#123; intent.prepareToLeaveProcess(this); ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, false, getUserId()); // 1 &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; 注释1，之前已经介绍过，最终会调用AMS的broadcastIntent()：frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java 12345678910111213141516171819public final int broadcastIntent(IApplicationThread caller, Intent intent, String resolvedType, IIntentReceiver resultTo, int resultCode, String resultData, Bundle resultExtras, String[] requiredPermissions, int appOp, Bundle bOptions, boolean serialized, boolean sticky, int userId) &#123; enforceNotIsolatedCaller(\"broadcastIntent\"); synchronized(this) &#123; intent = verifyBroadcastLocked(intent); // 1 ...... // 2 int res = broadcastIntentLocked(callerApp, callerApp != null ? callerApp.info.packageName : null, intent, resolvedType, resultTo, resultCode, resultData, resultExtras, requiredPermissions, appOp, bOptions, serialized, sticky, callingPid, callingUid, userId); Binder.restoreCallingIdentity(origId); return res; &#125;&#125; 注释1，调用了verifyBroadcastLocked()：frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java 1234567891011121314151617final Intent verifyBroadcastLocked(Intent intent) &#123; if (intent != null &amp;&amp; intent.hasFileDescriptors() == true) &#123; // 1 throw new IllegalArgumentException(\"File descriptors passed in Intent\"); &#125; int flags = intent.getFlags(); // 2 if (!mProcessesReady) &#123; if ((flags&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT) != 0) &#123; // 3 &#125; else if ((flags&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) &#123; // 4 Slog.e(TAG, \"Attempt to launch receivers of broadcast intent \" + intent + \" before boot completion\"); throw new IllegalStateException(\"Cannot broadcast before boot completed\"); &#125; &#125; if ((flags&amp;Intent.FLAG_RECEIVER_BOOT_UPGRADE) != 0) &#123; throw new IllegalArgumentException(\"Can't use FLAG_RECEIVER_BOOT_UPGRADE here\"); &#125; return intent;&#125; verifyBroadcasstLocked()主要是验证广播是否合法。 注释1，验证intent是否不为null，且有文件描述符。 注释2，获得intent的flag。 注释3，如果系统正在启动过程中，判断flag是否设置为FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT（启动检查时只接受动态广播注册的广播接收者），则不做处理；如果不是，则在注释4判断flag是否设置为FLAG_RECEIVER_REGISTERED_ONLY，如果没有，则抛出异常。 再回到broadcastIntent()，在里面的注释2处调用了broadcastIntentLocked()：frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java 1234567891011121314151617181920212223final int broadcastIntentLocked(ProcessRecord callerApp, String callerPackage, Intent intent, String resolvedType, IIntentReceiver resultTo, int resultCode, String resultData, Bundle resultExtras, String[] requiredPermissions, int appOp, Bundle bOptions, boolean ordered, boolean sticky, int callingPid, int callingUid, int userId) &#123; ...... if ((receivers != null &amp;&amp; receivers.size() &gt; 0) || resultTo != null) &#123; BroadcastQueue queue = broadcastQueueForIntent(intent); // 1 BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp, callerPackage, callingPid, callingUid, resolvedType, requiredPermissions, appOp, brOptions, receivers, resultTo, resultCode, resultData, resultExtras, ordered, sticky, false, userId); ...... boolean replaced = replacePending &amp;&amp; queue.replaceOrderedBroadcastLocked(r); if (!replaced) &#123; queue.enqueueOrderedBroadcastLocked(r); queue.scheduleBroadcastsLocked(); // 2 &#125; &#125; ...... return ActivityManager.BROADCAST_SUCCESS;&#125; 这里省略了很多代码，前面的工作主要是将动添注册的广播接收者和静态注册的广播接收者按照优先级高低存储在不同的列表中，再将这两个列表合并到receivers列表中，这样receivers列表中就包含了所有的广播接收者（有序广播和无序广播）。 注释1，创建BroadcastRecord对象，并将receivers传入。 注释2，调用BroadcastQueue的scheduleBroadcastsLocked()。 这里先给出ContextImpl到AMS的调用过程时序图： 2.2 AMS到BroadReceiver的调用过程BroadcastQueue的scheduleBroadcastsLocked()：frameworks/base/services/core/java/com/android/server/am/BroadcastQueue.java 12345678public void scheduleBroadcastsLocked() &#123; ...... if (mBroadcastsScheduled) &#123; return; &#125; mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, this)); // 1 mBroadcastsScheduled = true;&#125; 注释1，向BroadcastHandler类型的mHandler对象发送BROADCAST_INTENT_MSG消息，该消息在BroadcastHandler中的处理：frameworks/base/services/core/java/com/android/server/am/BroadcastQueue.java 12345case BROADCAST_INTENT_MSG: &#123; ...... processNextBroadcast(true);&#125; break; 调用了processNextBroadcast()，该方法对无序广播和有序广播分别进行了处理：frameworks/base/services/core/java/com/android/server/am/BroadcastQueue.java 1234567891011121314151617final void processNextBroadcast(boolean fromMsg) &#123; ...... if (fromMsg) &#123; mBroadcastsScheduled = false; // 1 &#125; // First, deliver any non-serialized broadcasts right away. while (mParallelBroadcasts.size() &gt; 0) &#123; // 2 r = mParallelBroadcasts.remove(0); // 3 ...... for (int i=0; i&lt;N; i++) &#123; Object target = r.receivers.get(i); ...... deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, false, i); // 4 &#125; ...... &#125;&#125; 从上面传入的值得知，fromMsg为true。 注释1，将mBroadcastsScheduled设置为false，表示对此前发来的BROADCAST_INTENT_MSG类型的消息已经做了处理。 注释2，mParalleBroadcasts用来存储无序广播，通过while()循环将mParalleBroadcasts列表中的无序广播发送给对应的广播接收者。 注释3，获取每一个mParalleBroadcasts列表中存储的BroadcastsRecord类型的r对象。 注释4，将这些r对象描述的广播发送给对应的广播接收者。deliverToRegisteredReceiverLocked：frameworks/base/services/core/java/com/android/server/am/BroadcastQueue.java 123456789101112131415161718private void deliverToRegisteredReceiverLocked(BroadcastRecord r, BroadcastFilter filter, boolean ordered, int index) &#123; ...... try &#123; ...... if (filter.receiverList.app != null &amp;&amp; filter.receiverList.app.inFullBackup) &#123; if (ordered) &#123; skipReceiverLocked(r); &#125; &#125; else &#123; performReceiveLocked(filter.receiverList.app, filter.receiverList.receiver, new Intent(r.intent), r.resultCode, r.resultData, r.resultExtras, r.ordered, r.initialSticky, r.userId); // 1 &#125; if (ordered) &#123; r.state = BroadcastRecord.CALL_DONE_RECEIVE; &#125; &#125; catch (RemoteException e) &#123; ...... &#125;&#125; 在try前面省略了很多代码，这些代码是用来检查广播发送者和广播接收者的权限。如果通过了权限检查，就会调用注释1的performReceiveLocked()：frameworks/base/services/core/java/com/android/server/am/BroadcastQueue.java 123456789101112131415void performReceiveLocked(ProcessRecord app, IIntentReceiver receiver, Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) throws RemoteException &#123; if (app != null) &#123; // 1 if (app.thread != null) &#123; // 2 try &#123; app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode, data, extras, ordered, sticky, sendingUser, app.repProcState); // 3 &#125; catch (RemoteException ex) &#123; ...... &#125; &#125; else &#123; throw new RemoteException(\"app.thread must not be null\"); &#125; &#125; else &#123; receiver.performReceive(intent, resultCode, data, extras, ordered, sticky, sendingUser); &#125;&#125; 注释1和2表示如果广播接收者所在的应用程序进程存在并且正在运行，则执行注释3，表示用广播接收者所在的应用程序进程来接收广播，这里app.thread指的是ApplicationThread，再来查看ApplicationThread的``scheduleRegisteredReceiver()`：frameworks/base/core/java/android/app/ActivityThread.java 1234public void scheduleRegisteredReceiver(IIntentReceiver receiver, Intent intent, int resultCode, String dataStr, Bundle extras, boolean ordered, boolean sticky, int sendingUser, int processState) throws RemoteException &#123; updateProcessState(processState, false); receiver.performReceive(intent, resultCode, dataStr, extras, ordered, sticky, sendingUser); // 1&#125; 注释1，调用了IIntentReceiver类型的对象receiver的performReceiver()，这里实现receiver的类为LoadedApk.ReceiverDispatcher.InnerReceiver：frameworks/base/core/java/android/app/LoadedApk.java 1234567891011121314151617181920212223public final class LoadedApk &#123; static final class ReceiverDispatcher &#123; final static class InnerReceiver extends IIntentReceiver.Stub &#123; final WeakReference&lt;LoadedApk.ReceiverDispatcher&gt; mDispatcher; final LoadedApk.ReceiverDispatcher mStrongRef; InnerReceiver(LoadedApk.ReceiverDispatcher rd, boolean strong) &#123; mDispatcher = new WeakReference&lt;LoadedApk.ReceiverDispatcher&gt;(rd); mStrongRef = strong ? rd : null; &#125; @Override public void performReceive(Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) &#123; final LoadedApk.ReceiverDispatcher rd; ...... if (rd != null) &#123; rd.performReceive(intent, resultCode, data, extras, ordered, sticky, sendingUser); // 1 &#125; else &#123; ...... &#125; &#125; &#125; &#125;&#125; 注释1，调用了ReceiverDispatcher类型的rd对象的performReceiver()：frameworks/base/core/java/android/app/LoadedApk.java 1234567891011public void performReceive(Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) &#123; final Args args = new Args(intent, resultCode, data, extras, ordered, sticky, sendingUser); // 1 ...... if (intent == null || !mActivityThread.post(args)) &#123; // 2 if (mRegistered &amp;&amp; ordered) &#123; IActivityManager mgr = ActivityManagerNative.getDefault(); if (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG, \"Finishing sync broadcast to \" + mReceiver); args.sendFinished(mgr); &#125; &#125;&#125; 注释1，将广播的intent等信息封装为Args对象，并在注释2调用mActivityThread的post()传入Ages对象。这里的mAcvitiyThread是Handler类型，具体的指向就是H。 注释2，将Args对象通过H发送到主线程的消息队列中，Args继承了Runnable，这个消息最终会在Args重写的run()中执行：frameworks/base/core/java/android/app/LoadedApk.java 1234567891011121314151617final class Args extends BroadcastReceiver.PendingResult implements Runnable &#123; ...... public void run() &#123; ...... try &#123; ClassLoader cl = mReceiver.getClass().getClassLoader(); intent.setExtrasClassLoader(cl); intent.prepareToEnterProcess(); setExtrasClassLoader(cl); receiver.setPendingResult(this); receiver.onReceive(mContext, intent); // 1 &#125; catch (Exception e) &#123; ...... &#125; ...... &#125;&#125; 注释1，执广播接收者的onReceive()，这样注册的广播jjie接收者就能接收广播并得到intent。 剩余部分的时序图：","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://tylerLiu.top/categories/Android进阶/"},{"name":"框架层","slug":"Android进阶/框架层","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/"},{"name":"深入理解四大组件","slug":"Android进阶/框架层/深入理解四大组件","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/深入理解四大组件/"}],"tags":[{"name":"四大组件","slug":"四大组件","permalink":"https://tylerLiu.top/tags/四大组件/"}]},{"title":"Andorid深入理解四大组件 04：Service的绑定过程","slug":"Andorid深入理解四大组件-04：Service的绑定过程","date":"2019-09-03T02:56:45.000Z","updated":"2019-09-11T08:03:20.933Z","comments":true,"path":"2019/09/03/Andorid深入理解四大组件-04：Service的绑定过程/","link":"","permalink":"https://tylerLiu.top/2019/09/03/Andorid深入理解四大组件-04：Service的绑定过程/","excerpt":"","text":"前言可以通过Context的startService()来绑定Service，也可以通过Context的bindService来绑定Service。 1. ContextImpl到ActivityManagerService的调用过程可以用bindService()来绑定Service，它的实现在ContextWrapper中：frameworks/base/core/java/android/content/ContextWrapper.java 1234@Overridepublic boolean bindService(Intent service, ServiceConnection conn, int flags) &#123; return mBase.bindService(service, conn, flags);&#125; 这里的mBase具体指向就是ContextImpl，在Andorid深入理解四大组件 03：Service的启动过程中已经讲解过。下面看看ContextImpl的bindService()：frameworks/base/core/java/android/app/ContextImpl.java 12345@Overridepublic boolean bindService(Intent service, ServiceConnection conn, int flags) &#123; warnIfCallingFromSystemProcess(); return bindServiceCommon(service, conn, flags, mMainThread.getHandler(), Process.myUserHandle());&#125; 在里面return bindServiceCommon()：frameworks/base/core/java/android/app/ContextImpl.java 123456789101112131415161718192021222324252627private boolean bindServiceCommon(Intent service, ServiceConnection conn, int flags, Handler handler, UserHandle user) &#123; IServiceConnection sd; if (conn == null) &#123; throw new IllegalArgumentException(\"connection is null\"); &#125; if (mPackageInfo != null) &#123; sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), handler, flags); // 1 &#125; else &#123; throw new RuntimeException(\"Not supported in system context\"); &#125; validateServiceIntent(service); try &#123; IBinder token = getActivityToken(); if (token == null &amp;&amp; (flags&amp;BIND_AUTO_CREATE) == 0 &amp;&amp; mPackageInfo != null &amp;&amp; mPackageInfo.getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123; flags |= BIND_WAIVE_PRIORITY; &#125; service.prepareToLeaveProcess(this); // 2 int res = ActivityManagerNative.getDefault().bindService(mMainThread.getApplicationThread(), getActivityToken(), service, service.resolveTypeIfNeeded(getContentResolver()), sd, flags, getOpPackageName(), user.getIdentifier()); if (res &lt; 0) &#123; throw new SecurityException(\"Not allowed to bind to service \" + service); &#125; return res != 0; &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; 注释1，调用LoadedApk类型的对象mPackageInfo的getServiceDispatcher()，将ServiceConnection封装为IServiceConnection类型的对象sd，IServiceConnection实现了Binder机制，这样Service的绑定就支持跨进程。 注释2，调用ASM的bindService()绑定。 ContextImpl到ActivityManagerService调用过程时序图： 2. Service的绑定AMS的bindService()：frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java 123456789101112public int bindService(IApplicationThread caller, IBinder token, Intent service, String resolvedType, IServiceConnection connection, int flags, String callingPackage, int userId) throws TransactionTooLargeException &#123; enforceNotIsolatedCaller(\"bindService\"); if (service != null &amp;&amp; service.hasFileDescriptors() == true) &#123; throw new IllegalArgumentException(\"File descriptors passed in Intent\"); &#125; if (callingPackage == null) &#123; throw new IllegalArgumentException(\"callingPackage cannot be null\"); &#125; synchronized(this) &#123; return mServices.bindServiceLocked(caller, token, service, resolvedType, connection, flags, callingPackage, userId); &#125;&#125; bindService()最后会调用ActiveServices类型对象mServices的bindServiceLocked()：frameworks/base/services/core/java/com/android/server/am/ActiveServices.java 12345678910111213141516171819202122232425262728int bindServiceLocked(IApplicationThread caller, IBinder token, Intent service, String resolvedType, final IServiceConnection connection, int flags, String callingPackage, final int userId) throws TransactionTooLargeException &#123; ...... if ((flags&amp;Context.BIND_AUTO_CREATE) != 0) &#123; s.lastActivity = SystemClock.uptimeMillis(); // 1 if (bringUpServiceLocked(s, service.getFlags(), callerFg, false, permissionsReviewRequired) != null) &#123; return 0; &#125; &#125; ...... if (s.app != null &amp;&amp; b.intent.received) &#123; // 2 try &#123; c.conn.connected(s.name, b.intent.binder); // 3 &#125; catch (Exception e) &#123; ...... &#125; if (b.intent.apps.size() == 1 &amp;&amp; b.intent.doRebind) &#123; // 4 requestServiceBindingLocked(s, b.intent, callerFg, true); // 5 &#125; &#125; else if (!b.intent.requested) &#123; // 6 requestServiceBindingLocked(s, b.intent, callerFg, false); // 7 &#125; getServiceMap(s.userId).ensureNotStartingBackground(s); &#125; finally &#123; Binder.restoreCallingIdentity(origId); &#125; return 1;&#125; 注释1，在bringUpServiceLocked()中会调用realStartSewrviceLocked()，最终由ActivityThread来调用Service的onCreate()方法启动Service，这在Andorid深入理解四大组件 03：Service的启动过程中已经讲过。 注释2，s.app != null表示Service已经运行，其中s是ServiceRecord类型对象，app是ProcessRecord类型对象。b.intent.recevied表示当前应用程序进程的客户端已经接收到绑定Service时返回的Binder，这样应用程序进程的客户端就可以通过Binder来获取要绑定的Service的访问接口。 注释3，调用c.conn.connected()，其中c.conn指的是IServiceConnection，它的具体实现为ServiceDispatcher.InnerCooection，其中ServiceDispatcher是LoadedApk的内部类，InnerConnection的connected()内部会调用H的post()，向主线程发送消息，从而解决当前应该程序进程和Service跨进程通信的问题。 注释4，如果当前应用程序进程的客户端第一次与Service进行绑定，并且Service已经调用onUnBind()，就需要调用注释5的代码。 注释6，如果应用程序进程客户端没有发送过绑定Service的请求，就会调用注释7，注释7与之前注释5唯一的区别是最后一个参数rebind为fasle，表示不重新绑定。requestServiceBindingLocked()：frameworks/base/services/core/java/com/android/server/am/ActiveServices.java 12345678910111213141516private final boolean requestServiceBindingLocked(ServiceRecord r, IntentBindRecord i, boolean execInFg, boolean rebind) throws TransactionTooLargeException &#123; ...... if ((!i.requested || rebind) &amp;&amp; i.apps.size() &gt; 0) &#123; // 1 try &#123; bumpServiceExecutingLocked(r, execInFg, \"bind\"); r.app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE); r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind, r.app.repProcState); // 2 ...... &#125; catch (TransactionTooLargeException e) &#123; ...... &#125; catch (RemoteException e) &#123; ...... &#125; &#125; return true;&#125; 注释1，i.requested表示是否发送过绑定Service的请求，从前面的代码得知是没有发送过的，因此!i.requested为true。而rebind为false，那么!i.requested || rebind就是true。如果IntentBindRecord中的应用程序进程记录大于0，则会调用注释2的代码，r.app.thread的类型为IApplicationThread，它的实现是ActivityThread的内部类ApplicationThread，其scheduleBindService()如下：frameworks/base/core/java/android/app/ActivityThread.java 123456789public final void scheduleBindService(IBinder token, Intent intent, boolean rebind, int processState) &#123; updateProcessState(processState, false); BindServiceData s = new BindServiceData(); s.token = token; s.intent = intent; s.rebind = rebind; ...... sendMessage(H.BIND_SERVICE, s);&#125; 首先将Service的信息封装成BindServiceData对象，BindServiceData成员变量rebind值为fasle，后面会用到。接着将BindServiceData传入到sendMessage()中。sendMessage()向H发送消息，再来看看H中的handleMessage()，这里只看case BIND_SERVICE的处理：frameworks/base/core/java/android/app/ActivityThread.java 12345case BIND_SERVICE: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"serviceBind\"); handleBindService((BindServiceData)msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; H在接收到BIND_SERVICE类型消息时，会在里面调用handleBindService()：frameworks/base/core/java/android/app/ActivityThread.java 123456789101112131415161718192021222324private void handleBindService(BindServiceData data) &#123; Service s = mServices.get(data.token); // 1 ...... if (s != null) &#123; try &#123; data.intent.setExtrasClassLoader(s.getClassLoader()); data.intent.prepareToEnterProcess(); try &#123; if (!data.rebind) &#123; // 2 IBinder binder = s.onBind(data.intent); // 3 ActivityManagerNative.getDefault().publishService(data.token, data.intent, binder); // 4 &#125; else &#123; s.onRebind(data.intent); // 5 ActivityManagerNative.getDefault().serviceDoneExecuting(data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0); &#125; ensureJitEnabled(); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; &#125; catch (Exception e) &#123; ...... &#125; &#125;&#125; 注释1，获取要绑定的Service。 注释2，BindServiceData的rebind值为fasle，这时，就会在注释3调用Service的onBind()，这样Service就处于绑定状态了。如果rebind为true，就会调用注释5的Service的onRebind()。结合前面的bindServiceLocked()的注释4，得知当前应用程序进程的客户端第一次与Service进行绑定，并且Service已经调用过OnUnBind()，则会调用Service的onRebind()。 注释4，实际上调用的是AMSpublishService()。 这部分的时序图（不包含Service的启动过程） 下面看看AMS的publishService()：frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java 1234567891011public void publishService(IBinder token, Intent intent, IBinder service) &#123; if (intent != null &amp;&amp; intent.hasFileDescriptors() == true) &#123; throw new IllegalArgumentException(\"File descriptors passed in Intent\"); &#125; synchronized(this) &#123; if (!(token instanceof ServiceRecord)) &#123; throw new IllegalArgumentException(\"Invalid service token\"); &#125; mServices.publishServiceLocked((ServiceRecord)token, intent, service); &#125;&#125; 调用了ActiveServices类型的mServices对象的publishServiceLocked()：frameworks/base/services/core/java/com/android/server/am/ActiveServices.java 123456789101112131415161718192021222324252627void publishServiceLocked(ServiceRecord r, Intent intent, IBinder service) &#123; final long origId = Binder.clearCallingIdentity(); try &#123; ...... if (r != null) &#123; if (b != null &amp;&amp; !b.received) &#123; ...... for (int conni=r.connections.size()-1; conni&gt;=0; conni--) &#123; ArrayList&lt;ConnectionRecord&gt; clist = r.connections.valueAt(conni); for (int i=0; i&lt;clist.size(); i++) &#123; ConnectionRecord c = clist.get(i); ...... try &#123; c.conn.connected(r.name, service); // 1 &#125; catch (Exception e) &#123; ...... &#125; &#125; &#125; &#125; serviceDoneExecutingLocked(r, mDestroyingServices.contains(r), false); &#125; &#125; finally &#123; Binder.restoreCallingIdentity(origId); &#125;&#125; 注释1，c.conn指的是IServiceConnect，它的具体实现为ServiceDispatcher.InnerConnection，其中ServiceDispatcher是LoadedApk的内部类，ServiceDispatcher.InnerConnection的connected()代码如下：frameworks/base/core/java/android/app/LoadedApk.java 123456789101112131415static final class ServiceDispatcher &#123; ...... private static class InnerConnection extends IServiceConnection.Stub &#123; final WeakReference&lt;LoadedApk.ServiceDispatcher&gt; mDispatcher; InnerConnection(LoadedApk.ServiceDispatcher sd) &#123; mDispatcher = new WeakReference&lt;LoadedApk.ServiceDispatcher&gt;(sd); &#125; public void connected(ComponentName name, IBinder service) throws RemoteException &#123; LoadedApk.ServiceDispatcher sd = mDispatcher.get(); if (sd != null) &#123; sd.connected(name, service); // 1 &#125; &#125; &#125;&#125; 注释1，调用ServiceDispatcher类型的sd对象的connected()：frameworks/base/core/java/android/app/LoadedApk.java 1234567public void connected(ComponentName name, IBinder service) &#123; if (mActivityThread != null) &#123; mActivityThread.post(new RunConnection(name, service, 0)); // 1 &#125; else &#123; doConnected(name, service); &#125;&#125; 注释1，调用Handler类型的对象mActivityThread的post()方法，mActivityThread实际上指向的是H。因此，通过调用H的post()方法将RunConnection对象的内容运行在主线程中。RunConnection的定义如下：frameworks/base/core/java/android/app/LoadedApk.java 1234567891011121314151617private final class RunConnection implements Runnable &#123; RunConnection(ComponentName name, IBinder service, int command) &#123; mName = name; mService = service; mCommand = command; &#125; public void run() &#123; if (mCommand == 0) &#123; doConnected(mName, mService); &#125; else if (mCommand == 1) &#123; doDeath(mName, mService); &#125; &#125; final ComponentName mName; final IBinder mService; final int mCommand;&#125; 在RunConnection的run()方法中调用了doConnected()方法：frameworks/base/core/java/android/app/LoadedApk.java 1234567891011public void doConnected(ComponentName name, IBinder service) &#123; ...... // If there was an old service, it is not disconnected. if (old != null) &#123; mConnection.onServiceDisconnected(name); &#125; // If there is a new service, it is now connected. if (service != null) &#123; mConnection.onServiceConnected(name, service); // 1 &#125;&#125; 注释1，调用了ServiceConnection类型的对象mConnection的onServcieConnected()方法，这样在客户端中实现了ServcieConnection接口的类的onServiceConnected()方法就会被执行。至此，Service的绑定过程就分析完了。 剩余部分的时序图：","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://tylerLiu.top/categories/Android进阶/"},{"name":"框架层","slug":"Android进阶/框架层","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/"},{"name":"深入理解四大组件","slug":"Android进阶/框架层/深入理解四大组件","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/深入理解四大组件/"}],"tags":[{"name":"四大组件","slug":"四大组件","permalink":"https://tylerLiu.top/tags/四大组件/"}]},{"title":"Andorid深入理解四大组件 03：Service的启动过程","slug":"Andorid深入理解四大组件-03：Service的启动过程","date":"2019-09-03T00:59:05.000Z","updated":"2019-09-11T08:03:18.914Z","comments":true,"path":"2019/09/03/Andorid深入理解四大组件-03：Service的启动过程/","link":"","permalink":"https://tylerLiu.top/2019/09/03/Andorid深入理解四大组件-03：Service的启动过程/","excerpt":"","text":"1. ContextImpl到ActrivityManagerService的调用过程要启动Service，就要调用startService()，它的实现是在ContextWrapper中：frameworks/base/core/java/android/content/ContextWrapper.java 123456789public class ContextWrapper extends Context &#123; Context mBase; ... @Override public ComponentName startService(Intent service) &#123; return mBase.startService(service); &#125; ...&#125; 在里面调用了mBase.staretService()。mBase指的是什么呢？在Andorid深入理解四大组件 02：应用程序启动过程（下）中，ActivityThread启动Activity时会调用如下代码创建Activity的上下文环境：frameworks/base/core/java/android/app/ActivityThread.java 123456789101112131415private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; ...... try &#123; ...... if (activity != null) &#123; Context appContext = createBaseContextForActivity(r, activity); // 1 ...... activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window); ...... &#125; ...... &#125; ...... return activity;&#125; 注释1，创建了上下文对象appContext，并传入了Activity的attach()方法中，将Activity上下文对象appContext关联起来，这个appContext上下文对象具体指的是什么？再来看看createBaseContextForActivity()：frameworks/base/core/java/android/app/ActivityThread.java 12345678private Context createBaseContextForActivity(ActivityClientRecord r, final Activity activity) &#123; ...... ContextImpl appContext = ContextImpl.createActivityContext(this, r.packageInfo, r.token, displayId, r.overrideConfig); appContext.setOuterContext(activity); Context baseContext = appContext; ...... return baseContext;&#125; 可以看出，上下文对象appContext的具体类型就是ContextImpl。Activity的attach()方法中将ContextImpl赋值给ContextWrapper的成员变量mBase中，因此，mBase具体指向就是ContextImpl。 再来查看ContextImpl的startService()：frameworks/base/core/java/android/app/ContextImpl.java 123456789101112131415161718@Overridepublic ComponentName startService(Intent service) &#123; warnIfCallingFromSystemProcess(); return startServiceCommon(service, mUser);&#125;private ComponentName startServiceCommon(Intent service, UserHandle user) &#123; try &#123; validateServiceIntent(service); service.prepareToLeaveProcess(this); // 1 ComponentName cn = ActivityManagerNative.getDefault().startService(mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(getContentResolver()), getOpPackageName(), user.getIdentifier()); ...... return cn; &#125; catch (RemoteException e) &#123; ...... &#125;&#125; 注释1，调用了AMS的代理对象ActivityManagerProxy（AMP）的startService()，最终会调用AMS的satrtService()。 ContextImpl到ActivityManagerService的调用过程的时序图： 2. ActivityThread启动Service下面看看AMS的startService()：frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java 1234567891011121314151617181920@Overridepublic ComponentName startService(IApplicationThread caller, Intent service, String resolvedType, String callingPackage, int userId) throws TransactionTooLargeException &#123; enforceNotIsolatedCaller(\"startService\"); if (service != null &amp;&amp; service.hasFileDescriptors() == true) &#123; throw new IllegalArgumentException(\"File descriptors passed in Intent\"); &#125; if (callingPackage == null) &#123; throw new IllegalArgumentException(\"callingPackage cannot be null\"); &#125; synchronized(this) &#123; final int callingPid = Binder.getCallingPid(); final int callingUid = Binder.getCallingUid(); final long origId = Binder.clearCallingIdentity(); ComponentName res = mServices.startServiceLocked(caller, service, resolvedType, callingPid, callingUid, callingPackage, userId); // 1 Binder.restoreCallingIdentity(origId); return res; &#125;&#125; 注释1，调用mService.startServiceLocked()，mService的类型是ActiveServices，ActiveServices的startServiceLocked()： 1234567891011ComponentName startServiceLocked(IApplicationThread caller, Intent service, String resolvedType, int callingPid, int callingUid, String callingPackage, final int userId) throws TransactionTooLargeException &#123; ... return startServiceInnerLocked(smap, service, r, callerFg, addToStarting);&#125;ComponentName startServiceInnerLocked(ServiceMap smap, Intent service, ServiceRecord r, boolean callerFg, boolean addToStarting) throws TransactionTooLargeException &#123; ...... String error = bringUpServiceLocked(r, service.getFlags(), callerFg, false, false); ...... return r.name;&#125; startServiceLocked()中return startServiceInnerLocked()，而startServiceInnerLocked()中又调用了bringUpServiceLocked()：frameworks/base/services/core/java/com/android/server/am/ActiveServices.java 12345678910111213141516171819202122232425262728293031323334353637private String bringUpServiceLocked(ServiceRecord r, int intentFlags, boolean execInFg, boolean whileRestarting, boolean permissionsReviewRequired) throws TransactionTooLargeException &#123; ...... final String procName = r.processName; // 1 ProcessRecord app; if (!isolated) &#123; app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, false); // 2 if (app != null &amp;&amp; app.thread != null) &#123; // 3 try &#123; app.addPackage(r.appInfo.packageName, r.appInfo.versionCode, mAm.mProcessStats); realStartServiceLocked(r, app, execInFg); // 4 return null; &#125; catch (TransactionTooLargeException e) &#123; throw e; &#125; catch (RemoteException e) &#123; Slog.w(TAG, \"Exception when starting service \" + r.shortName, e); &#125; &#125; &#125; else &#123; app = r.isolatedProc; &#125; if (app == null &amp;&amp; !permissionsReviewRequired) &#123; // 5 if ((app=mAm.startProcessLocked(procName, r.appInfo, true, intentFlags, \"service\", r.name, false, isolated, false)) == null) &#123; // 6 String msg = \"Unable to launch app \" + r.appInfo.packageName + \"/\" + r.appInfo.uid + \" for service \" + r.intent.getIntent() + \": process is bad\"; Slog.w(TAG, msg); bringDownServiceLocked(r); return msg; &#125; if (isolated) &#123; r.isolatedProc = app; &#125; &#125; ...... return null;&#125; 注释1，得到ServiceRecord的processName的值，并赋值给变量procName，其中processName是用来描述Service要运行在哪个线程，默认是当前线程，可以在AndoridManifest配置文件中设置android:process属性来新开启一个进程，运行Service。 注释2，将procName和Service的uid传入AMS的getProcessRecordLocked()中，来查询是否存在一个与Service对应的ProcessRecord类型的对象app，ProcessRecord主要用来记录运行的应用程序进程的信息。 注释5，判断两个条件，一个是用来运行Service的应用程序进程不存在，另一个是应用程序之间的组件调用不需要检查权限，满足这两个条件就调用注释6的AMS的startProcessLocked()来创建对应的应用程序进程。 关于创建应用程序进程可以看Andorid深入理解四大组件 01：应用程序启动过程（上）和Andorid深入理解四大组件 02：应用程序启动过程（下）。 注释3，判断如果用来运行Service的应用程序进程存在，则调用注释4的realStartServiceLocked()：frameworks/base/services/core/java/com/android/server/am/ActiveServices.java 1234567891011121314private final void realStartServiceLocked(ServiceRecord r, ProcessRecord app, boolean execInFg) throws RemoteException &#123; ...... try &#123; ...... app.thread.scheduleCreateService(r, r.serviceInfo, mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo), app.repProcState); r.postNotification(); created = true; &#125; catch (DeadObjectException e) &#123; ...... &#125; finally &#123; ...... &#125; ......&#125; 在里面调用了app.thread的scheduleCreateService()。其中app.thread是IApplicationThread类型，它的实现是ActivityThread的内部类ApplicationThread，其中ApplicationThread继承了ApplicationThreadNative，而ApplicationThreadNative又继承了Binder并实现了IApplicationThread接口。ApplicationThread的scheduleCreateService()：frameworks/base/core/java/android/app/ActivityThread.java 12345678public final void scheduleCreateService(IBinder token, ServiceInfo info, CompatibilityInfo compatInfo, int processState) &#123; updateProcessState(processState, false); CreateServiceData s = new CreateServiceData(); s.token = token; s.info = info; s.compatInfo = compatInfo; sendMessage(H.CREATE_SERVICE, s);&#125; 首先将要启动的信息封装成CreateServiceData对象，并传到sendMessage()中，sendMessage()向H发送了CREATE_SERVICE消息。这个过程和应用程序的启动过程（根Activity启动）类似。再来看看H的handleMessage()在接收到消息后做了哪些：frameworks/base/core/java/android/app/ActivityThread.java 123456789101112public void handleMessage(Message msg) &#123; switch (msg.what) &#123; ... case CREATE_SERVICE: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (\"serviceCreate: \" + String.valueOf(msg.obj))); handleCreateService((CreateServiceData)msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; ... &#125; ...&#125; 在里面调用了handleCreateService()：frameworks/base/core/java/android/app/ActivityThread.java 1234567891011121314151617181920212223private void handleCreateService(CreateServiceData data) &#123; unscheduleGcIdler(); LoadedApk packageInfo = getPackageInfoNoCheck(data.info.applicationInfo, data.compatInfo); // 1 Service service = null; try &#123; java.lang.ClassLoader cl = packageInfo.getClassLoader(); // 2 service = (Service) cl.loadClass(data.info.name).newInstance(); // 3 &#125; catch (Exception e) &#123; ...... &#125; try &#123; if (localLOGV) Slog.v(TAG, \"Creating service \" + data.info.name); ContextImpl context = ContextImpl.createAppContext(this, packageInfo); // 4 context.setOuterContext(service); Application app = packageInfo.makeApplication(false, mInstrumentation); service.attach(context, this, data.info.name, data.token, app, ActivityManagerNative.getDefault()); // 5 service.onCreate(); // 6 mServices.put(data.token, service); // 7 ...... &#125; catch (Exception e) &#123; ...... &#125;&#125; 注释1，获取要启动Service的应用程序的LoadedApk，LoadedApk是一个APK文件的描述类。 注释2，通过调用LoadedApk的getClassLoader()获取类加载器。 注释3，根据CreateServiceData中存储的Service信息，将Service加载到内存中。 注释4，创建Service的上下文环境ComtextImpl对象。 注释5，通过Service的attach()初始化Service。 注释6，调用Service的onCreate()，启动Service。 注释7，将启动的Service加入到ActivityThread的成员变量mService中，其中mService是ArrayMap类型。 时序图：","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://tylerLiu.top/categories/Android进阶/"},{"name":"框架层","slug":"Android进阶/框架层","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/"},{"name":"深入理解四大组件","slug":"Android进阶/框架层/深入理解四大组件","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/深入理解四大组件/"}],"tags":[{"name":"四大组件","slug":"四大组件","permalink":"https://tylerLiu.top/tags/四大组件/"}]},{"title":"Andorid深入理解四大组件 02：应用程序启动过程（下）","slug":"Andorid深入理解四大组件-02：应用程序启动过程（下）","date":"2019-09-02T07:36:22.000Z","updated":"2019-09-11T08:03:16.462Z","comments":true,"path":"2019/09/02/Andorid深入理解四大组件-02：应用程序启动过程（下）/","link":"","permalink":"https://tylerLiu.top/2019/09/02/Andorid深入理解四大组件-02：应用程序启动过程（下）/","excerpt":"","text":"1. AMS到ApplicationThread的调用流程AMS的startActivity()中返回了startActivityAsUser()：frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java 12345@Overridepublic final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) &#123; enforceNotIsolatedCaller(\"startActivity\"); userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, ALLOW_FULL_ONLY, \"startActivity\", null); return mActivityStarter.startActivityMayWait(caller, -1, callingPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, profilerInfo, null, null, bOptions, false, userId, null, null); startActivityAsUaser()中返回了mActivityStarter的startActivityMayWait()：frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java 12345678910111213@Overridefinal int startActivityMayWait(IApplicationThread caller, int callingUid, String callingPackage, Intent intent, String resolvedType, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, IActivityManager.WaitResult outResult, Configuration config, Bundle bOptions, boolean ignoreTargetSecurity, int userId, IActivityContainer iContainer, TaskRecord inTask) &#123; ... int res = startActivityLocked(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity, componentSpecified, outRecord, container, inTask); ... return res;&#125; 在里面调用了startActivityLocked()：frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java 123456final int startActivityLocked(IApplicationThread caller, Intent intent, Intent ephemeralIntent, String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int realCallingPid, int realCallingUid, int startFlags, ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container, TaskRecord inTask) &#123; ... doPendingActivityLaunchesLocked(false); ... return err;&#125; 在里面主要关注doPendingActivitylaunchedLocked()：frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java 12345678910111213final void doPendingActivityLaunchesLocked(boolean doResume) &#123; while (!mPendingActivityLaunches.isEmpty()) &#123; final PendingActivityLaunch pal = mPendingActivityLaunches.remove(0); final boolean resume = doResume &amp;&amp; mPendingActivityLaunches.isEmpty(); try &#123; final int result = startActivityUnchecked(pal.r, pal.sourceRecord, null, null, pal.startFlags, resume, null, null); postStartActivityUncheckedProcessing(pal.r, result, mSupervisor.mFocusedStack.mStackId, mSourceRecord,mTargetStack); &#125; catch (Exception e) &#123; Slog.e(TAG, \"Exception during pending activity launch pal=\" + pal, e); pal.sendErrorResult(e.getMessage()); &#125; &#125;&#125; 在里面调用了startActivityUnchecked()：frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java 123456private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask) &#123; ... mSupervisor.resumeFocusedStackTopActivityLocked(); ... return START_SUCCESS;&#125; 在里面调用了ActivityStackSupervisor类型的mSopervisor的resumeFocusedStackTopActivityLocked()：frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java 12345678910boolean resumeFocusedStackTopActivityLocked(ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) &#123; if (targetStack != null &amp;&amp; isFocusedStack(targetStack)) &#123; return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions); &#125; final ActivityRecord r = mFocusedStack.topRunningActivityLocked(); if (r == null || r.state != RESUMED) &#123; mFocusedStack.resumeTopActivityUncheckedLocked(null, null); // 1 &#125; return false;&#125; 注释1，调用了ActivityStack类型的mFocusedStack的resumeTopActivityUncheckedLocked()：rameworks/base/services/core/java/com/android/server/am/ActivityStack.java 12345678910boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) &#123; ... try &#123; ... result = resumeTopActivityInnerLocked(prev, options); &#125; finally &#123; mStackSupervisor.inResumeTopActivity = false; &#125; return result;&#125; 123456private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) &#123; ... mStackSupervisor.startSpecificActivityLocked(next, true, true);&#125;if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();return true; 在里面主要调用了ActivityStackSupervisor类型mStackSupervisor的startSpecificActivityLocked()：frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java 12345678910111213141516171819void startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) &#123; ProcessRecord app = mService.getProcessRecordLocked(r.processName, r.info.applicationInfo.uid, true); r.task.stack.setLaunchTime(r); if (app != null &amp;&amp; app.thread != null) &#123; // 1 try &#123; if ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == 0 || !\"android\".equals(r.info.packageName)) &#123; app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode, mService.mProcessStats); &#125; realStartActivityLocked(r, app, andResume, checkConfig); // 2 return; &#125; catch (RemoteException e) &#123; Slog.w(TAG, \"Exception when starting activity \" + r.intent.getComponent().flattenToShortString(), e); &#125; &#125; mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0, \"activity\", r.intent.getComponent(), false, false, true);&#125; 注释1，如果在当前Activity所在的Application运行的话，会执行注释2的代码。realStartActivityLocked()：frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java 123456final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app, boolean andResume, boolean checkConfig) throws RemoteException &#123; ... app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken, System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration), new Configuration(task.mOverrideConfig), r.compat, r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results, newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo); ... return true;&#125; 这里的app.thread指的是IApplicationThread，它的实现是ActivityThread的内部类ApplicationThread，其中ApplicationThread继承了ApplicationThreadNative，而ApplicationThreadNative继承了Binder并实现了IApplicationThread接口。 AMS到ApplicationThread调用过程的时序图： 2. ActivityThread启动ActivityAndroid应用程序进程启动过程 01中提到过ActivityThread，在应用程序进程启动过程中会创建ActivityThread实例。ActivityThread是应用程序进程的核心类，它是如何启动应用程序（Activity）的呢？ 根据上文接着查看ApplicationThread的scheduleLaunchActivity：frameworks/base/core/java/android/app/ActivityThread.java 1234567891011121314151617181920212223242526272829303132333435@Overridepublic final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, Configuration overrideConfig, CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123; updateProcessState(procState, false); ActivityClientRecord r = new ActivityClientRecord(); r.token = token; r.ident = ident; r.intent = intent; r.referrer = referrer; r.voiceInteractor = voiceInteractor; r.activityInfo = info; r.compatInfo = compatInfo; r.state = state; r.persistentState = persistentState; r.pendingResults = pendingResults; r.pendingIntents = pendingNewIntents; r.startsNotResumed = notResumed; r.isForward = isForward; r.profilerInfo = profilerInfo; r.overrideConfig = overrideConfig; updatePendingConfiguration(curConfig); sendMessage(H.LAUNCH_ACTIVITY, r);&#125; 在里面会启动Activity的参数封装成ActivityClientRecord，sendMessage()会向H类发送一个名为LAUNCH_ACTIVITY的消息，并将ActivityClientRecord传递过去，sendMessage()如下：frameworks/base/core/java/android/app/ActivityThread.java 1234private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) &#123; ... mH.sendMessage(msg);&#125; mH指的就是H类，它是ActivityThread的内部类，继承了Handler：frameworks/base/core/java/android/app/ActivityThread.java 12345678910111213141516171819202122232425private class H extends Handler &#123; public static final int LAUNCH_ACTIVITY = 100; public static final int PAUSE_ACTIVITY = 101; ... public void handleMessage(Message msg) &#123; if (DEBUG_MESSAGES) Slog.v(TAG, \"&gt;&gt;&gt; handling: \" + codeToString(msg.what)); switch (msg.what) &#123; case LAUNCH_ACTIVITY: &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityStart\"); final ActivityClientRecord r = (ActivityClientRecord) msg.obj; // 1 r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo, r.compatInfo); // 2 handleLaunchActivity(r, null, \"LAUNCH_ACTIVITY\"); // 3 Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125; break; case RELAUNCH_ACTIVITY: &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityRestart\"); ActivityClientRecord r = (ActivityClientRecord)msg.obj; handleRelaunchActivity(r); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125; break; ... &#125; &#125;&#125; 查看H中handleMessage()对LAUNCH_ACTIVITY的处理，在注释1处将传过来的msg的成员变量obj转为ActivityClientRecord。 注释2，通过getPackageInfoNoCheck()获得LoadedApk类型的对象并赋值给ActivityClientRecord的成员变量packageInfo。应用程序进程要启动Activity时需要将该Activity所属的APK加载进来，而LoadedApk就是用来描述已加载的APK文件。 注释3，调用handleLaunchActivity()：frameworks/base/core/java/android/app/ActivityThread.java 1234567891011121314151617181920212223242526272829303132private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) &#123; unscheduleGcIdler(); mSomeActivitiesChanged = true; if (r.profilerInfo != null) &#123; mProfiler.setProfiler(r.profilerInfo); mProfiler.startProfiling(); &#125; handleConfigurationChanged(null, null); if (localLOGV) Slog.v( TAG, \"Handling launch of \" + r); WindowManagerGlobal.initialize(); Activity a = performLaunchActivity(r, customIntent); // 1 if (a != null) &#123; r.createdConfig = new Configuration(mConfiguration); reportSizeConfigurations(r); Bundle oldState = r.state; handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason); // 2 if (!r.activity.mFinished &amp;&amp; r.startsNotResumed) &#123; performPauseActivityIfNeeded(r, reason); if (r.isPreHoneycomb()) &#123; r.state = oldState; &#125; &#125; &#125; else &#123; try &#123; ActivityManagerNative.getDefault().finishActivity(r.token, Activity.RESULT_CANCELED, null,Activity.DONT_FINISH_TASK_WITH_ACTIVITY); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; &#125;&#125; 注释1，perfprmLaunchActivity()用来启动Activity。 注释2，用来将Activity的状态设置为Resume。如果该Activity为null，则会通知ActivityManager停止启动Activity。 perfprmLaunchActivity()：frameworks/base/core/java/android/app/ActivityThread.java 123456789101112131415161718192021222324252627282930313233343536373839private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; ActivityInfo aInfo = r.activityInfo; // 1 if (r.packageInfo == null) &#123; r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo, Context.CONTEXT_INCLUDE_CODE); // 2 &#125; ComponentName component = r.intent.getComponent(); // 3 ...... Activity activity = null; try &#123; java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent); // 4 ...... &#125; catch (Exception e) &#123; ...... &#125; try &#123; Application app = r.packageInfo.makeApplication(false, mInstrumentation); // 5 ...... if (activity != null) &#123; Context appContext = createBaseContextForActivity(r, activity); // 6 ...... // 7 activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window); ...... if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); // 8 &#125; else &#123; mInstrumentation.callActivityOnCreate(activity, r.state); &#125; ...... &#125; ...... &#125; catch (SuperNotCalledException e) &#123; throw e; &#125; catch (Exception e) &#123; ...... &#125; return activity;&#125; 注释1，获取ActivityInfo。 注释2，获取APK文件的描述类LoadedApk。 注释3，获取要启动的Activity的ComponentName类，ComponentName类中保存了该Activity的包名和类名。 注释4，根据ComponentName中存储的Activity类名，用类加载器创建该Activity的实例。 注释5，创建Application，makeApplication()内部会调用Application的onCreate()。 注释6，创建要启动Activity的上下文环境。 注释7，调用Activity的attach()初始化Activity，attach()内部会创建Window对象（PhoneWindow）并与Activity自身进行关联。 注释8，调用Instrumentation的callActivityOnCreate()来启动Activity：frameworks/base/core/java/android/app/Instrumentation.java 12345public void callActivityOnCreate(Activity activity, Bundle icicle) &#123; prePerformCreate(activity); activity.performCreate(icicle); postPerformCreate(activity);&#125; 在里面调用了activity.performCreate()：frameworks/base/core/java/android/app/Activity.java 123456final void performCreate(Bundle icicle) &#123; restoreHasCurrentPermissionRequest(icicle); onCreate(icicle); mActivityTransitionState.readState(icicle); performCreateCommon();&#125; performCreate()中会调用Activity的onCreate()，这样Activity就启动了，即应用程序启动了。 ActivityThread启动Activity的时序图：","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://tylerLiu.top/categories/Android进阶/"},{"name":"框架层","slug":"Android进阶/框架层","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/"},{"name":"深入理解四大组件","slug":"Android进阶/框架层/深入理解四大组件","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/深入理解四大组件/"}],"tags":[{"name":"四大组件","slug":"四大组件","permalink":"https://tylerLiu.top/tags/四大组件/"}]},{"title":"Andorid深入理解四大组件 01：应用程序启动过程（上）","slug":"Andorid深入理解四大组件-01：应用程序启动过程（上）","date":"2019-09-02T02:00:52.000Z","updated":"2019-09-11T08:03:12.990Z","comments":true,"path":"2019/09/02/Andorid深入理解四大组件-01：应用程序启动过程（上）/","link":"","permalink":"https://tylerLiu.top/2019/09/02/Andorid深入理解四大组件-01：应用程序启动过程（上）/","excerpt":"","text":"前言前面介绍了Android系统启动过程和应用程序进程启动过程。下面再来看看Android应用程序启动过程，即Activity的启动过程。基于Android 7.0。 1. Launch请求ActivityManagerService在Android系统启动流程 04：Launcher启动过程和系统启动流程中，讲过Launch启动后会将已安装应用程序的快捷图标显示到界面上，当点击应用程序的快捷图标时，就会调用Launcher的startActivitySafely()方法：packages/apps/Launcher3/src/com/android/launcher3/Launcher.java 12345678910public boolean startActivitySafely(View v, Intent intent, Object tag) &#123; ... try &#123; success = startActivity(v, intent, tag); &#125; catch (ActivityNotFoundException e) &#123; Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show(); Log.e(TAG, \"Unable to launch. tag=\" + tag + \" intent=\" + intent, e); &#125; return success;&#125; 在里面主要调用了startActivity()：packages/apps/Launcher3/src/com/android/launcher3/Launcher.java 1234567891011121314151617181920212223private boolean startActivity(View v, Intent intent, Object tag) &#123; intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); // 1 try &#123; ... if (user == null || user.equals(UserHandleCompat.myUserHandle())) &#123; StrictMode.VmPolicy oldPolicy = StrictMode.getVmPolicy(); try &#123; StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder().detectAll() .penaltyLog().build()); startActivity(intent, optsBundle); // 2 &#125; finally &#123; StrictMode.setVmPolicy(oldPolicy); &#125; &#125; else &#123; launcherApps.startActivityForProfile(intent.getComponent(), user, intent.getSourceBounds(), optsBundle); &#125; return true; &#125; catch (SecurityException e) &#123; ... &#125; return false;&#125; 注释1，设置Flag为Intent.FLAG_ACTIVITY_NEW_TASK，这样根Activity会在新的任务栈中启动。 注释2，调用了startActivity()：frameworks/base/core/java/android/app/Activity.java 12345678Overridepublic void startActivity(Intent intent, @Nullable Bundle options) &#123; if (options != null) &#123; startActivityForResult(intent, -1, options); &#125; else &#123; startActivityForResult(intent, -1); &#125;&#125; startActivity()会调用startActvitiyForResult()，其中第二个参数为-1，表示Launcher不需要知道Actiivty的启动结果，startActivityForResult()：frameworks/base/core/java/android/app/Activity.java 123456789101112public void startActivityForResult(@RequiresPermission Intent intent, int requestCode, @Nullable Bundle options) &#123; if (mParent == null) &#123; Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); ... &#125; else &#123; ... &#125;&#125; mParent是Activity类型的，表示当前Activtiy的父类。因为目前根Acitvity还没有创建出来，因此，mParent == null为true。接着调用Insxtrumentation的exeStartActivity()，Instrumentation主要用来监控应用程序和系统的交互，execStartActivity()：frameworks/base/core/java/android/app/Instrumentation.java 123456789101112131415161718public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) &#123; ... try &#123; intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(who); int result = ActivityManagerNative.getDefault() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); checkStartActivityResult(result, intent); &#125; catch (RemoteException e) &#123; throw new RuntimeException(\"Failure from system\", e); &#125; return null;&#125; 首先会调用ActivityManagerNative的getDefault()来获取ActivityManagerService（后面简称AMS）的代理对象，接着调用它的startActivtiy()。首先看看ActivityManagerNative的getDefault()：frameworks/base/core/java/android/app/ActivityManagerNative.java 1234567891011121314151617static public IActivityManager getDefault() &#123; return gDefault.get();&#125;private static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() &#123; protected IActivityManager create() &#123; IBinder b = ServiceManager.getService(\"activity\"); // 1 if (false) &#123; Log.v(\"ActivityManager\", \"default service binder = \" + b); &#125; IActivityManager am = asInterface(b); // 2 if (false) &#123; Log.v(\"ActivityManager\", \"default service = \" + am); &#125; return am; &#125;&#125;; getDefault()调用了gDefault的get()，gDefault是一个单例类。 注释1，得到名为&quot;activity&quot;的Service引用，也就是IBinder类型的ActivtiyManagerService的引用。 注释2，将它封装成ActivtiyManagerProxy（后面简称AMP）类型对象，并将它保存到gDefault中，此后调用ActivityManagerNative的getDefault()就会直接获得AMS的代理AMP对象。 回到Instrumentation的exeStartActivity()中，从上面得知就是调用AMP的startActivity()，其中AMP是ActivityManagerNative的内部类：frameworks/base/core/java/android/app/ActivityManagerNative.java 123456789101112131415161718192021222324252627282930313233public int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options) throws RemoteException &#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeStrongBinder(caller != null ? caller.asBinder() : null); data.writeString(callingPackage); intent.writeToParcel(data, 0); data.writeString(resolvedType); data.writeStrongBinder(resultTo); data.writeString(resultWho); data.writeInt(requestCode); data.writeInt(startFlags); if (profilerInfo != null) &#123; data.writeInt(1); profilerInfo.writeToParcel(data, Parcelable.PARCELABLE_WRITE_RETURN_VALUE); &#125; else &#123; data.writeInt(0); &#125; if (options != null) &#123; data.writeInt(1); options.writeToParcel(data, 0); &#125; else &#123; data.writeInt(0); &#125; mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0); // 1 reply.readException(); int result = reply.readInt(); reply.recycle(); data.recycle(); return result;&#125; 首先将传入的参数写入到Parcel类的data中。 注释1，通过IBinder类型对象mRemote向AMS发送一个START_ACTIVITY_TRANSACTION类型的进程间通信请求。服务端AMS就会从Binder线程池中读取客户端发送来的数据，最终调用ActivityManagerNative的toTransact()`：frameworks/base/core/java/android/app/ActivityManagerNative.java 1234567891011121314@Overridepublic boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; switch (code) &#123; case START_ACTIVITY_TRANSACTION: &#123; ... int result = startActivity(app, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, options); reply.writeNoException(); reply.writeInt(result); return true; &#125;&#125; onTransact()中会调用AMS的startActivity()：frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java 12345678@Overridepublic final int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) &#123; return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, UserHandle.getCallingUserId());&#125; Launcher到AMS调用过程的时序图。","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://tylerLiu.top/categories/Android进阶/"},{"name":"框架层","slug":"Android进阶/框架层","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/"},{"name":"深入理解四大组件","slug":"Android进阶/框架层/深入理解四大组件","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/深入理解四大组件/"}],"tags":[{"name":"四大组件","slug":"四大组件","permalink":"https://tylerLiu.top/tags/四大组件/"}]},{"title":"Android应用程序进程启动过程 02","slug":"Android应用程序进程启动过程02","date":"2019-08-31T02:42:53.000Z","updated":"2019-09-11T08:04:12.244Z","comments":true,"path":"2019/08/31/Android应用程序进程启动过程02/","link":"","permalink":"https://tylerLiu.top/2019/08/31/Android应用程序进程启动过程02/","excerpt":"","text":"前言前面讲到Android应用程序进程启动的过程，留下了一点：在应用程序进程创建过程中会启动Binder创建线程池以及在应用程序进程启动后会创建消息循环。 1. Binder线程池启动过程RuntimeInit的zygoteInit()如下： 123456789public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123; if (DEBUG) Slog.d(TAG, \"RuntimeInit: Starting application from zygote\"); Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"RuntimeInit\"); redirectLogStreams(); commonInit(); nativeZygoteInit(); // 1 applicationInit(targetSdkVersion, argv, classLoader);&#125; 注释1，在新创建的应用程序进程中创建Binder线程池，来看看nativeZygoteInit()： 1private static final native void nativeZygoteInit(); nativeZygoteInit()是一个jni方法，在AndoridRuntime.cpp中，JNINativeMethod数组中得知它对应的函数是com_android_internal_os_RuntimeInit_nativeZygoteInit：frameworks/base/core/jni/AndroidRuntime.cpp 12345678static const JNINativeMethod gMethods[] = &#123; &#123; \"nativeFinishInit\", \"()V\", (void*) com_android_internal_os_RuntimeInit_nativeFinishInit &#125;, &#123; \"nativeZygoteInit\", \"()V\", (void*) com_android_internal_os_RuntimeInit_nativeZygoteInit &#125;, &#123; \"nativeSetExitWithoutCleanup\", \"(Z)V\", (void*) com_android_internal_os_RuntimeInit_nativeSetExitWithoutCleanup &#125;,&#125;; 下面看看com_android_internal_os_RuntimeInit_nativeZygoteInit()：frameworks/base/core/jni/AndroidRuntime.cpp 123static void com_android_internal_os_RuntimeInit_nativeZygoteInit(JNIEnv* env, jobject clazz) &#123; gCurRuntime-&gt;onZygoteInit();&#125; gCurRuntime在AndoridRuntime初始化就创建了：frameworks/base/core/jni/AndroidRuntime.cpp 1234567AndroidRuntime::AndroidRuntime(char* argBlockStart, const size_t argBlockLength) : mExitWithoutCleanup(false), mArgBlockStart(argBlockStart), mArgBlockLength(argBlockLength) &#123; ... gCurRuntime = this;&#125; 在Android系统启动流程 02：zygote进程中，得知AppRuntime继承AndroidRuntime，AppRuntime创建时会调用AndroidRuntime的构造函数，gCurRuntime就会被初始化，它指向的是AppRuntime，所以下面来查看AppRunTime的onZygoteInit()，AppRuntime的实现在app_main.cpp中：frameworks/base/cmds/app_process/app_main.cpp 12345virtual void onZygoteInit() &#123; sp&lt;ProcessState&gt; proc = ProcessState::self(); ALOGV(\"App process: starting thread pool.\\n\"); proc-&gt;startThreadPool();&#125; 最后一行会调用ProcessState的startThreadPool()：frameworks/native/libs/binder/ProcessState.cpp 1234567void ProcessState::startThreadPool() &#123; AutoMutex _l(mLock); if (!mThreadPoolStarted) &#123; mThreadPoolStarted = true; spawnPooledThread(true); &#125;&#125; 支持Binder通信的进程中都有一个ProcessState类，它里面有一个mThreadPoolState变量，来表示Binder线程池是否已经被启动过，默认值为false。每次调用这个函数前会先检查这个标记，确保binder线程池只会被启动一次。如果Binder线程池未设置mThreadPoolState为true，最后会调用spawwnPooledThread()来创建线程池中的第一个线程，即线程池中的main线程。frameworks/native/libs/binder/ProcessState.cpp 12345678void ProcessState::spawnPooledThread(bool isMain) &#123; if (mThreadPoolStarted) &#123; String8 name = makeBinderThreadName(); ALOGV(\"Spawning new pooled thread, name=%s\\n\", name.string()); sp&lt;Thread&gt; t = new PoolThread(isMain); t-&gt;run(name.string()); // 1 &#125;&#125; 可以看到Binder线程为一个PoolThread。注释1，调用PoolThread的run()来启动一个新的线程。看看PoolThread类：frameworks/native/libs/binder/ProcessState.cpp 123456789class PoolThread : public Thread &#123; ... protected: virtual bool threadLoop() &#123; IPCThreadState::self()-&gt;joinThreadPool(mIsMain); // 1 return false; &#125; const bool mIsMain;&#125;; PoolThread继承了Thread。注释1，调用IPCThreadState的joinThreadPool()函数，将当前线程注册到Binder驱动程序中，这样创建的线程就加入了Binder线程池中，新创建的应用程序线程也就支持Binder线程间通信。 2. 消息循环创建过程上篇最后讲到RuntimeInit的invokeStaticMain()：frameworks/base/core/java/com/android/internal/os/RuntimeInit.java 123456private static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123; Class&lt;?&gt; cl; ... throw new ZygoteInit.MethodAndArgsCaller(m, argv);&#125; 在最后会抛出MethodAndArgsCaller()异常，这个异常会被ZygoteInit的main()捕获：frameworks/base/core/java/com/android/internal/os/ZygoteInit.java 123456789101112public static void main(String argv[]) &#123; ... try &#123; ... &#125; catch (MethodAndArgsCaller caller) &#123; caller.run(); // 1 &#125; catch (RuntimeException ex) &#123; Log.e(TAG, \"Zygote died with exception\", ex); closeServerSocket(); throw ex; &#125;&#125; 注释1，捕获MethodAndArgsCaller时会执行caler的run()：frameworks/base/core/java/com/android/internal/os/RuntimeInit.java 12345678910111213141516171819public static class MethodAndArgsCaller extends Exception implements Runnable &#123; private final Method mMethod; private final String[] mArgs; public MethodAndArgsCaller(Method method, String[] args) &#123; mMethod = method; mArgs = args; &#125; public void run() &#123; try &#123; mMethod.invoke(null, new Object[] &#123; mArgs &#125;); // 1 &#125; catch (IllegalAccessException ex) &#123; throw new RuntimeException(ex); &#125; ... throw new RuntimeException(ex); &#125; &#125;&#125; 从上一篇得知，mMethod指的就是ActivityThread的main()，mArgs指的是应用程序进程的启动参数。在注释1调用了ActivityThread的main()：frameworks/base/core/java/android/app/ActivityThread.java 123456789101112131415161718public static void main(String[] args) &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"ActivityThreadMain\"); SamplingProfilerIntegration.start(); ... Looper.prepareMainLooper(); // 1 ActivityThread thread = new ActivityThread(); // 2 thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, \"ActivityThread\")); &#125; Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); // 3 throw new RuntimeException(\"Main thread loop unexpectedly exited\");&#125; 注释1，在当前应用程序进程中创建消息循环。 注释2，创建ActivityThread。 注释3，调用Looper的loop()，是的Looper开始处理消息。 系统在应用程序进程启动完成后，就会创建一个消息循环，用来方便的使用Android消息处理机制。","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://tylerLiu.top/categories/Android进阶/"},{"name":"框架层","slug":"Android进阶/框架层","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/"},{"name":"应用进程启动流程","slug":"Android进阶/框架层/应用进程启动流程","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/应用进程启动流程/"}],"tags":[{"name":"Android系统启动","slug":"Android系统启动","permalink":"https://tylerLiu.top/tags/Android系统启动/"}]},{"title":"Android应用程序进程启动过程 01","slug":"Android应用程序进程启动过程01","date":"2019-08-30T02:44:38.000Z","updated":"2019-09-11T08:04:09.862Z","comments":true,"path":"2019/08/30/Android应用程序进程启动过程01/","link":"","permalink":"https://tylerLiu.top/2019/08/30/Android应用程序进程启动过程01/","excerpt":"","text":"1. 应用程序进程概述要启动一个应用程序，首先要保证这个应用程序所需要的应用程序进程已经启动，ActivityManagerService在启动应用程序时会先检查这个应用程序对应的进程是否已经存在，如果不存在，就请求Zygote进程将需要的应用程序进程启动。 在Android系统启动流程 02：zygote进程中，提到Zygote的Java框架中，会创建一个服务端的Socket，用来等待ActivityManagerService来请求Zygote创建一个新的应用程序进程。Zygote进程通过fock自身创建的应用程序进程，这样应用程序进程就会获得Zygote进程在启动时创建的虚拟机实例。在应用程序创建过程中，除了获取虚拟机实例，还可以获得Binder线程池和循环消息，这样运行应用程序进程中的应用程序就可以使用Binder进行进程间通信和消息处理机制。 Binder线程池如何启动和创建会在后面介绍。 应用程序进程启动过程时序图： 2. 应用程序进程创建过程2.1 发送创建应用程序进程请求ActivityManagerService会通过调用startProcessLocked()向Zygote进程发送请求：frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) &#123; ... try &#123; try &#123; final int userId = UserHandle.getUserId(app.uid); AppGlobals.getPackageManager().checkPackageStartable(app.info.packageName, userId); &#125; catch (RemoteException e) &#123; throw e.rethrowAsRuntimeException(); &#125; int uid = app.uid; // 1 int[] gids = null; int mountExternal = Zygote.MOUNT_EXTERNAL_NONE; if (!app.isolated) &#123; ... /** * 2 对gids进行创建和赋值 */ if (ArrayUtils.isEmpty(permGids)) &#123; gids = new int[2]; &#125; else &#123; gids = new int[permGids.length + 2]; System.arraycopy(permGids, 0, gids, 2, permGids.length); &#125; gids[0] = UserHandle.getSharedAppGid(UserHandle.getAppId(uid)); gids[1] = UserHandle.getUserGid(UserHandle.getUserId(uid)); &#125; ... if (entryPoint == null) entryPoint = \"android.app.ActivityThread\"; // 3 Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"Start proc: \" + app.processName); checkTime(startTime, \"startProcess: asking zygote to start proc\"); /** * 4 */ Process.ProcessStartResult startResult = Process.start(entryPoint, app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet, app.info.dataDir, entryPointArgs); ... &#125; catch (RuntimeException e) &#123; ... &#125; &#125; ...&#125; 注释1，创建应用程序进程的用户ID。 注释2，对用户组ID——gids进行创建和赋值。 注释3，如果entryPoint为null，则赋值为&quot;android.app.ActivityThread&quot;。 注释4，调用Process的start()，将此前得到的应用程序进程用户ID和用户组ID传入，第一个参数entryPoint就是前面赋值的&quot;android.app.ActivityThread&quot;，后面会介绍。 下面看看Process的start()：frameworks/base/core/java/android/os/Process.java 123456789101112131415161718public static final ProcessStartResult start(final String processClass, final String niceName, int uid, int gid, int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String[] zygoteArgs) &#123; try &#123; return startViaZygote(processClass, niceName, uid, gid, gids, debugFlags, mountExternal, targetSdkVersion, seInfo, abi, instructionSet, appDataDir, zygoteArgs); &#125; catch (ZygoteStartFailedEx ex) &#123; ... &#125;&#125; 在里面只调用了startViaZygote()：frameworks/base/core/java/android/os/Process.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private static ProcessStartResult startViaZygote(final String processClass, final String niceName, final int uid, final int gid, final int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String[] extraArgs) throws ZygoteStartFailedEx &#123; synchronized(Process.class) &#123; // 1 ArrayList&lt;String&gt; argsForZygote = new ArrayList&lt;String&gt;(); argsForZygote.add(\"--runtime-args\"); argsForZygote.add(\"--setuid=\" + uid); argsForZygote.add(\"--setgid=\" + gid); ... if (gids != null &amp;&amp; gids.length &gt; 0) &#123; StringBuilder sb = new StringBuilder(); sb.append(\"--setgroups=\"); int sz = gids.length; for (int i = 0; i &lt; sz; i++) &#123; if (i != 0) &#123; sb.append(','); &#125; sb.append(gids[i]); &#125; argsForZygote.add(sb.toString()); &#125; ... argsForZygote.add(processClass); if (extraArgs != null) &#123; for (String arg : extraArgs) &#123; argsForZygote.add(arg); &#125; &#125; return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote); &#125;&#125; 注释1，创建argsForZygote，并将启动应用程序进程的参数保存在其中。startViaZygote()最后调用了zygoteSendArgsAndGetResult()，其中第一个参数调用了openZygoteSocketIfNeeded()，第二个参数是argsForZygote。 zygoteSendArgsAndGetResult()如下：frameworks/base/core/java/android/os/Process.java 1234567891011121314151617181920212223242526272829303132private static ProcessStartResult zygoteSendArgsAndGetResult( ZygoteState zygoteState, ArrayList&lt;String&gt; args) throws ZygoteStartFailedEx &#123; try &#123; int sz = args.size(); for (int i = 0; i &lt; sz; i++) &#123; if (args.get(i).indexOf('\\n') &gt;= 0) &#123; throw new ZygoteStartFailedEx(\"embedded newlines not allowed\"); &#125; &#125; final BufferedWriter writer = zygoteState.writer; final DataInputStream inputStream = zygoteState.inputStream; writer.write(Integer.toString(args.size())); writer.newLine(); for (int i = 0; i &lt; sz; i++) &#123; String arg = args.get(i); writer.write(arg); writer.newLine(); &#125; writer.flush(); ProcessStartResult result = new ProcessStartResult(); result.pid = inputStream.readInt(); result.usingWrapper = inputStream.readBoolean(); if (result.pid &lt; 0) &#123; throw new ZygoteStartFailedEx(\"fork() failed\"); &#125; return result; &#125; catch (IOException ex) &#123; zygoteState.close(); throw new ZygoteStartFailedEx(ex); &#125;&#125; 该方法主要是将传入的argsForZygote写入到ZygoteState中，而ZygoteState是由openZygoteSocketIfNeeded()返回的：frameworks/base/core/java/android/os/Process.java 1234567891011121314151617181920212223private static ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx &#123; if (primaryZygoteState == null || primaryZygoteState.isClosed()) &#123; try &#123; primaryZygoteState = ZygoteState.connect(ZYGOTE_SOCKET); // 1 &#125; catch (IOException ioe) &#123; throw new ZygoteStartFailedEx(\"Error connecting to primary zygote\", ioe); &#125; &#125; if (primaryZygoteState.matches(abi)) &#123; // 2 return primaryZygoteState; &#125; if (secondaryZygoteState == null || secondaryZygoteState.isClosed()) &#123; try &#123; secondaryZygoteState = ZygoteState.connect(SECONDARY_ZYGOTE_SOCKET); // 3 &#125; catch (IOException ioe) &#123; throw new ZygoteStartFailedEx(\"Error connecting to secondary zygote\", ioe); &#125; &#125; if (secondaryZygoteState.matches(abi)) &#123; return secondaryZygoteState; &#125; throw new ZygoteStartFailedEx(\"Unsupported zygote ABI: \" + abi);&#125; 在Zygote进程启动过程中，Zygote的main()会创建name为&quot;zygote&quot;的服务端Socket。 注释1，调用ZygoteState的connect()与名称为ZYGOE_STOCKET的Stoccket建立连接，这里ZYGOE_STOCKET的值为zygote。 注释2，如果连接name为zygote的Socket返回的primaryZygoteState与当前的abi不匹配，则会在注释3处连接name为zygote_secondary的Socket。 这两个Socket的区别是：name为zygote的Socket是运行在64位Zygote进程中，而name为zygote_secondary的Socket是运行在32位Zygote进程中。既然应用程序进程是通过Zygote进程fock产生的，当要连接Zygote中的Socket时，也需要保证位数的一致。 2.2 接收请求并创建应用程序进程Socket进行连接成功并匹配abi后会返回ZygoteState类型对象，在zygoteSendArgsAndGetResult()中讲过，会将应用程序进程的启动参数argsForZygote写入到ZygoteState中，这样Zygote进程就会收到一个创建新的应该程序进程的请求，回到ZygoteInit的main()：frameworks/base/core/java/com/android/internal/os/ZygoteInit.java 1234567891011121314151617181920212223242526public static void main(String argv[]) &#123; ... try &#123; ... // 注册Zygote用的Socket registerZygoteSocket(socketName); // 1 ... // 预加载类和资源 preload(); // 2 ... if (startSystemServer) &#123; // 启动SystemServer进程 startSystemServer(abiList, socketName); // 3 &#125; Log.i(TAG, \"Accepting command socket connections\"); // 等待客户端请求 runSelectLoop(abiList); // 4 closeServerSocket(); &#125; catch (MethodAndArgsCaller caller) &#123; caller.run(); &#125; catch (RuntimeException ex) &#123; Log.e(TAG, \"Zygote died with exception\", ex); closeServerSocket(); throw ex; &#125;&#125; 这些内容在Android系统启动流程 02：zygote进程中已经讲过。 注释1，通过registerZygoteSocket()创建一个服务端的Socket，这个name为zygote的Socket用来等待ActivityManagerService来请求Zygote进程创建新的应用程序进程。 注释2，预加载类和资源。 注释3，启动SystemServer进程，这样系统的关键服务也会由SystemServer进程启动起来。 注释4，调用runSelectLoop()等待ActivityManagerService的请求。 现在看看runSelectLoop()：frameworks/base/core/java/com/android/internal/os/ZygoteInit.java 12345678910111213141516171819202122232425private static void runSelectLoop(String abiList) throws MethodAndArgsCaller &#123; ArrayList&lt;FileDescriptor&gt; fds = new ArrayList&lt;FileDescriptor&gt;(); ArrayList&lt;ZygoteConnection&gt; peers = new ArrayList&lt;ZygoteConnection&gt;(); // 2 fds.add(sServerSocket.getFileDescriptor()); peers.add(null); while (true) &#123; ... for (int i = pollFds.length - 1; i &gt;= 0; --i) &#123; if ((pollFds[i].revents &amp; POLLIN) == 0) &#123; continue; &#125; if (i == 0) &#123; ZygoteConnection newPeer = acceptCommandPeer(abiList); peers.add(newPeer); fds.add(newPeer.getFileDesciptor()); &#125; else &#123; boolean done = peers.get(i).runOnce(); // 1 if (done) &#123; peers.remove(i); fds.remove(i); &#125; &#125; &#125; &#125;&#125; 当有ActivityManagerService的请求数据到来时，会调用注释1的代码，结合注释2的代码，可以得知注释1的代码实际是调用ZygoteCConnection的runOnce()用来处理请求的数据：frameworks/base/core/java/com/android/internal/os/ZygoteConnection.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344boolean runOnce() throws ZygoteInit.MethodAndArgsCaller &#123; String args[]; Arguments parsedArgs = null; FileDescriptor[] descriptors; try &#123; args = readArgumentList(); // 1 descriptors = mSocket.getAncillaryFileDescriptors(); &#125; catch (IOException ex) &#123; Log.w(TAG, \"IOException on command socket \" + ex.getMessage()); closeSocket(); return true; &#125; try &#123; parsedArgs = new Arguments(args); // 2 ... /** * 3 */ pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo, parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet, parsedArgs.appDataDir); &#125; catch (ErrnoException ex) &#123; .... &#125; try &#123; if (pid == 0) &#123; // in child IoUtils.closeQuietly(serverPipeFd); serverPipeFd = null; handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr); return true; &#125; else &#123; // in parent...pid of &lt; 0 means failure IoUtils.closeQuietly(childPipeFd); childPipeFd = null; return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs); &#125; &#125; finally &#123; IoUtils.closeQuietly(childPipeFd); IoUtils.closeQuietly(serverPipeFd); &#125;&#125; 注释1，调用readArgumentList()获取应用程序进程的启动参数。 注释2，将readArgumentList()返回的字符串封装到Arguments的对象parsedArgs中。 注释3，调用Zygote的forkAndSpecialize()来创建应用程序进程，参数为paresedArgs中存储的应用程序进程启动参数，返回值为pid。forkAndSpecialize()主要是通过fork当前进程来创建一个子进程的，如果pid为0，表示在创建新的子进程中执行，就会调用handleChildProc()来启动这个子进程，即应用程序进程：frameworks/base/core/java/com/android/internal/os/ZygoteConnection.java 12345678private void handleChildProc(Arguments parsedArgs, FileDescriptor[] descriptors, FileDescriptor pipeFd, PrintStream newStderr) throws ZygoteInit.MethodAndArgsCaller &#123; ... RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, null /* classLoader */); &#125;&#125; handleChildProc()中调用了RutimeInit的zygoteInit()：frameworks/base/core/java/com/android/internal/os/RuntimeInit.java 123456789public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123; if (DEBUG) Slog.d(TAG, \"RuntimeInit: Starting application from zygote\"); Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"RuntimeInit\"); redirectLogStreams(); commonInit(); nativeZygoteInit(); // 1 applicationInit(targetSdkVersion, argv, classLoader); // 2&#125; 注释1，在新创建的应用程序进程中创建Binder线程池，这个会在后面详细介绍。 注释2，带哟applicationInit()：frameworks/base/core/java/com/android/internal/os/RuntimeInit.java 12345678910111213private static void applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123; ... final Arguments args; try &#123; args = new Arguments(argv); &#125; catch (IllegalArgumentException ex) &#123; Slog.e(TAG, ex.getMessage()); return; &#125; Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); invokeStaticMain(args.startClass, args.startArgs, classLoader); // 1&#125; 注释1，调用invlkeStaticMain()，第一个参数是args.startClass，这里指的就是文章开头的参数&quot;android.app.ActivityThread&quot;。下面卡看看invlkeStaticMain()：frameworks/base/core/java/com/android/internal/os/RuntimeInit.java 1234567891011121314151617181920private static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123; Class&lt;?&gt; cl; try &#123; cl = Class.forName(className, true, classLoader); // 1 &#125; catch (ClassNotFoundException ex) &#123; throw new RuntimeException( \"Missing class when invoking static main \" + className, ex); &#125; Method m; try &#123; m = cl.getMethod(\"main\", new Class[] &#123; String[].class &#125;); // 2 &#125; catch (NoSuchMethodException ex) &#123; throw new RuntimeException( \"Missing static main on \" + className, ex); &#125; ... throw new ZygoteInit.MethodAndArgsCaller(m, argv); // 3&#125; 注释1，通过反射得到android.app.ActivityThread类。 注释2，获得ActivityThread的main()，并将main()传入到注释3的ZygoteInit中MethodAndArgsCaller类的构造函数中，MethodAndArgsCaller类内部会通过反射，调用ActivityThread的main()，这样应用程序进程就创建完成了，并且运行了代表主线程的实例ActivityThread。","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://tylerLiu.top/categories/Android进阶/"},{"name":"框架层","slug":"Android进阶/框架层","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/"},{"name":"应用进程启动流程","slug":"Android进阶/框架层/应用进程启动流程","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/应用进程启动流程/"}],"tags":[{"name":"Android系统启动","slug":"Android系统启动","permalink":"https://tylerLiu.top/tags/Android系统启动/"}]},{"title":"Android AOSP 03：Android系统源码的整编和单编","slug":"Android-AOSP03：Android系统源码的整编和单编","date":"2019-08-29T05:51:29.000Z","updated":"2019-09-11T08:03:35.253Z","comments":true,"path":"2019/08/29/Android-AOSP03：Android系统源码的整编和单编/","link":"","permalink":"https://tylerLiu.top/2019/08/29/Android-AOSP03：Android系统源码的整编和单编/","excerpt":"","text":"前言前面已经将Android系统源码下载下来，但是往往，不止要查看源码，有时还需要： 动态调试Android系统源码 定制Android系统 将最新版本的Android系统刷入到自己的Android设备中 将系统源码导入到Android Studio中 为了实现这些需求，就需要去编译系统源码。 1. 编译系统概述需要了解的概念。 Makefile：Android平台的编译系统，其实就是用Makefile写出来的一个独立项目。它定义了编译的规则，实现“自动化编译”，不仅将分散在数百个Git库中的代码整合起来、统一编译，而且还把产物分门别类的输出到一个目录，打包成手机的ROM，还可以生成应用开发时所使用的SDK、NDK等。因此，采用Makefile编写的编译系统，也可称为Makefile编译系统。 Andorid.mk：Makefile编译系统的一部分，定义了一个模块的必要参数，使模块随着平台编译。通俗来讲就是告诉编译系统，以什么样的规则编译源代码，并生成对应的目标文件。 Ninja：是一个致力于速度的小型编译系统，如果把其他的编译系统看作高级语言，那么Ninja目标就是汇编。 Soong：使谷歌用来替代此前的Makefile编译系统的替代品，负责解析Andorid.bp文件，并将之转换为Ninja文件。 Blueprint：用来解析Andorid.bp文件翻译成Ninja语法文件。 kati：谷歌专门为Android开发的一个小项目，基于Golang和C++。目的是把Android中的Makefile转化为Ninja文件。 Android.bp：用来替代Android.mk的配置文件。 Android.mk、Ninja、Soong、kati、Andorid.bp的联系如下： Blueprint负责解析Android.bp文件内容，Blueprint类似一个处理相关语法的库文件，Soong则是定义具体如何处理相应的语法以及命令实现。通俗来讲就是Soong借助于Blueprint定义的Android.bp语法，完成Android.bp的解析，最终转化成Ninja文件。 Makefile会通过kati转化为Nanja文件。 随着Android工程越来越大，采用Makefile的编译系统花费的时间越来越长，因此谷歌在Android 7.0 开始引入Ninja来编译系统，相对于Makefile，Ninja在大的项目管理中速度和并行方面有优势。 Makefile默认文件名为Makefile或makefile，也常用.make或.mk作为文件后缀。Ninja的默认文件名为build.ninja，其他文件以.ninja为后缀。Makefile与Ninja的区别在于，Makefile是设计来给开发编写的，而Ninja设计出来是给其他程序生成的。如果Makefile是Java语言，那么Ninja就是汇编语言。 2. 编译源码的方式Android系统源码编译主要有以下几种方式： 在Linux中直接进行系统源码编译（Android官方支持） 在Mac OS中直接进行系统源码编译（Android官方支持） 使用Docker编译，支持Mac OS和Windows Docker支持的最低版本为Win7，建议在Win10下使用，因为Win7要借助Docker Toolbox和VritualBox中的容器进行通信，效率低。 本文在Linux中直接进行系统源码编译。 3. 编译环境3.1 安装jdk812sudo apt-get updatesudo apt-get install openjdk-8-jdk 3.2 使用Ubuntu 14+，需要安装以下依赖包：1sudo apt-get install git-core gnupg flex bison gperf build-essential zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z-dev ccache libgl1-mesa-dev libxml2-utils xsltproc unzip 3.3 设置处理器数量设置 –&gt; 系统 –&gt; 处理器选项，设置为6。 3.4 源码整编整编就是编译整个Android源码，整编主要有三个步骤： 3.4.1. 初始化环境：在AOSP根目录中，运行如下命令123source build/envsetup.sh// 编译前删除build文件夹A// make clobber 使用build目录中的envsetup.sh脚本初始化环境，这个脚本会引入其他的执行脚本。 3.4.2. 选择编译目标1lunch lunch命令是envsetup.sh中定义的一个命令，用来让用户选择编译目标。 会有以下信息输出： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455You&apos;re building on LinuxLunch menu... pick a combo: 1. aosp_arm-eng 2. aosp_arm64-eng 3. aosp_mips-eng 4. aosp_mips64-eng 5. aosp_x86-eng 6. aosp_x86_64-eng 7. aosp_car_arm-userdebug 8. aosp_car_arm64-userdebug 9. aosp_car_x86-userdebug 10. aosp_car_x86_64-userdebug 11. mini_emulator_arm64-userdebug 12. m_e_arm-userdebug 13. m_e_mips64-eng 14. m_e_mips-userdebug 15. mini_emulator_x86_64-userdebug 16. mini_emulator_x86-userdebug 17. uml-userdebug 18. aosp_cf_x86_auto-userdebug 19. aosp_cf_x86_phone-userdebug 20. aosp_cf_x86_tablet-userdebug 21. aosp_cf_x86_tablet_3g-userdebug 22. aosp_cf_x86_tv-userdebug 23. aosp_cf_x86_wear-userdebug 24. aosp_cf_x86_64_auto-userdebug 25. aosp_cf_x86_64_phone-userdebug 26. aosp_cf_x86_64_tablet-userdebug 27. aosp_cf_x86_64_tablet_3g-userdebug 28. aosp_cf_x86_64_tv-userdebug 29. aosp_cf_x86_64_wear-userdebug 30. cf_x86_auto-userdebug 31. cf_x86_phone-userdebug 32. cf_x86_tablet-userdebug 33. cf_x86_tablet_3g-userdebug 34. cf_x86_tv-userdebug 35. cf_x86_wear-userdebug 36. cf_x86_64_auto-userdebug 37. cf_x86_64_phone-userdebug 38. cf_x86_64_tablet-userdebug 39. cf_x86_64_tablet_3g-userdebug 40. cf_x86_64_tv-userdebug 41. cf_x86_64_wear-userdebug 42. aosp_marlin-userdebug 43. aosp_marlin_svelte-userdebug 44. aosp_sailfish-userdebug 45. aosp_walleye-userdebug 46. aosp_walleye_test-userdebug 47. aosp_taimen-userdebug 48. hikey-userdebug 49. hikey64_only-userdebug 50. hikey960-userdebugWhich would you like? [aosp_arm-eng] 意思是要选择编译目标的格式，编译目标的格式组成为BUILD_BUILDTYPE，比如aosp_arm-eng的BUILD为aosp_arm，BUILDTYPE为eng。 其中BUILD表示编译出的镜像可以运行在什么环境，aosp表示Android开源项目，arm表示系统是运行在ARM架构的处理器上。 更多可以参考官方文档。 BUILDTYPE指的是编译类型，有以下三种： user：用于正式发布到市场的版本，权限受限，如果没有root权限，不能debug，adb默认处于停用状态。 userdebug：在user版本上开放了root权限和debug权限，adb默认处于停用状态。一般用于调试真机。 eng：开发工程师版本，拥有最大的权限，具有额外调试工具的开发配置。一般用于模拟器。 如果没有Nexus设备，只想在编译完成后，在模拟器上查看，那么BUILD可以选择aosp_x86，BUILDTYPE选择eng，直接在Which would you like? [aosp_arm-eng]后面输入对应的序号（这里是5）即可。 也可以直接指定编译的目标： 1lunch aosp_x86-eng 或者（不同的系统版本，序号的对应会有差别，建议不要直接用序号） 1lunch 5 3.4.3. 开始编译通过-jN参数来设置编译的并行任务数，以提高编译速度，此前设置的CPU核心数为6，这里的N值最好在6~12之间，这里设置8： 1make -j6 编译成功后会打印如下提示： 12 由于采用的是虚拟机整编，编译速度会很慢。 最终会在out/target/product/generic_x86下生成三个重要的镜像文件：system.img、userdata.img、ramdisk.img。 system.img：系统镜像，里面包含Andorid系统主要的目录和文件，通过init.rc解析并mount挂载到/system目录下。 userdata.img：用户镜像，Android系统中存放用户数据的，通过init.rc解析并mount挂载到/data目录下。 ramdisk.img：根文件系统镜像，包含一些启动Android系统的重要文件，如init.rc。 运行模拟器 在编译完成之后，可以通过下面的命令运行Android虚拟机了： 123source build/envsetup.shlunch 5emulator 由于前面已经完成整编编译，即已经执行过source和lunch，所以这里直接执行emulator即可。 3.5 源码单编比如要编译系统的Settings应用模块，在AOSP根目录执行： 12source build/envsetup.shlunch 5 进入Settings目录： 1cd packages/apps/Settings mm，编译当前目录下的模块，不编译依赖模块： 1mm 编译成功后会提示生成文件的存放路径： 12","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://tylerLiu.top/categories/Android进阶/"},{"name":"框架层","slug":"Android进阶/框架层","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/"},{"name":"AOSP","slug":"Android进阶/框架层/AOSP","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/AOSP/"}],"tags":[{"name":"AOSP","slug":"AOSP","permalink":"https://tylerLiu.top/tags/AOSP/"}]},{"title":"Android AOSP 02：AOSP源码下载","slug":"Android-AOSP02：AOSP源码下载","date":"2019-08-29T05:35:22.000Z","updated":"2019-09-11T08:03:33.312Z","comments":true,"path":"2019/08/29/Android-AOSP02：AOSP源码下载/","link":"","permalink":"https://tylerLiu.top/2019/08/29/Android-AOSP02：AOSP源码下载/","excerpt":"","text":"1. 关于AOSPAOSP就是Andorid系统源码，通过它可以定制Andorid操作系统。国内由于不可抗力，一般使用镜像。 清华大学镜像站 中科大镜像站 本文以清华大学镜像站为例。 2. 下载repo工具Andorid包含数百个Git库，要下载这么多Git库会很麻烦，谷歌开发了trpo，用于管理Android版本库的一个工具，使用Python对Git进行了封装，简化了多个Git版本库的管理。 安装Git，在Ubuntu命令： 1sudo apt-get install git 创建bin，并添加到PATH中： 12mkdir ~/binPATH=~/bin:$PATH 安装curl库： 1sudo apt-get install curl 下载repo，并设置权限： 12curl https://mirrors.tuna.tsinghua.edu.cn/git/git-repo &gt; ~/bin/repochmod a+x ~/bin/repo 安装Python，repo初始化的时候会用到： 1sudo apt-get install python 重启虚拟机后，开始下载源码。 3. 下载源码新建工作目录： 12mkdir aospcd aosp repo的运行过程中会尝试访问官方的git源更新自己，如果想使用tuna的镜像源进行更新，可以将如下内容复制到你的~/.bashrc里，.bashrc为隐藏文件，在home下按Ctrl + h就能打开隐藏文件： 1export REPO_URL=&apos;https://mirrors.tuna.tsinghua.edu.cn/git/git-repo/&apos; 为Git添加邮箱和用户名： 12git config --global user.email &quot;piratemorgen@gmail.com&quot;git config --global user.name &quot;piratemorgen&quot; 初始化仓库： 1repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest 初始化指定源码： 1repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-9.0.0_r8 同步源码： 1repo sync 即可。","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://tylerLiu.top/categories/Android进阶/"},{"name":"框架层","slug":"Android进阶/框架层","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/"},{"name":"AOSP","slug":"Android进阶/框架层/AOSP","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/AOSP/"}],"tags":[{"name":"AOSP","slug":"AOSP","permalink":"https://tylerLiu.top/tags/AOSP/"}]},{"title":"Android AOSP 01：VM VirtualBox安装Ubuntu","slug":"Android-AOSP01：VM-VirtualBox安装Ubuntu","date":"2019-08-29T05:09:34.000Z","updated":"2019-09-11T08:03:31.315Z","comments":true,"path":"2019/08/29/Android-AOSP01：VM-VirtualBox安装Ubuntu/","link":"","permalink":"https://tylerLiu.top/2019/08/29/Android-AOSP01：VM-VirtualBox安装Ubuntu/","excerpt":"","text":"需要下载的两个文件： virtualbox Ubuntu 具体的软件安装和Ubuntu的安装不再说明，这里在配置Ubuntu的虚拟硬盘时，因为要安装AOSP，所以建议配置200GB，内存4GB。 安装增强工具方便虚拟机和主机之间的复制和粘贴。 设备 -&gt; 共享文件夹，新建一个共享文件夹，选择自动挂载和固定分配。 设备 -&gt; 安装增强功能，会在桌面生成一个VBox_GAs_6.0.10，点击运行软件，进行安装配置。 接着就会在桌面生成一个文件夹sf_share。 通过它就能和主机之间进行文件共享了。 设备 -&gt; 共享粘贴板，设备 -&gt; 拖放，都选择双向。","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://tylerLiu.top/categories/Android进阶/"},{"name":"框架层","slug":"Android进阶/框架层","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/"},{"name":"AOSP","slug":"Android进阶/框架层/AOSP","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/AOSP/"}],"tags":[{"name":"AOSP","slug":"AOSP","permalink":"https://tylerLiu.top/tags/AOSP/"}]},{"title":"Android系统启动流程 04：Launcher启动过程和系统启动流程","slug":"Android系统启动流程04：Launcher启动过程和系统启动流程","date":"2019-08-28T02:49:16.000Z","updated":"2019-09-11T08:04:03.815Z","comments":true,"path":"2019/08/28/Android系统启动流程04：Launcher启动过程和系统启动流程/","link":"","permalink":"https://tylerLiu.top/2019/08/28/Android系统启动流程04：Launcher启动过程和系统启动流程/","excerpt":"","text":"前言前面介绍了init进程、Zygote进程和SystemServer进程的启动过程，现在看看Android系统启动的最后一步：Launcher的启动流程。 1. Launcher概述Andorid系统启动的最后一步是启动一个Home应用程序，这个应用程序用来显示系统中已经安装的应用程序，这个Home程序就叫Launcher。应用程序Launcher在启动过程中会请求PackageManagerService返回系统已经安装的应用程序的信息，并将这些信息封装成一个快捷图标列表显示在系统屏幕上，这样用户就能通过点击这些图标来启动相应的应用程序。 2. Launcher启动流程SystemServer进程启动的过程中会启动PackagerManagerService，PackagerManagerService启动后会将系统中的应用程序安装完成。此前已经启动的ActivityManagerService会将Launcher启动起来。 启动Launcher的入口为ActiivtyManagerService的systemReady()：frameworks/base/services/java/com/android/server/SystemServer.java 123456789101112private void startOtherServices() &#123; ... mActivityManagerService.systemReady(new Runnable() &#123; @Override public void run() &#123; Slog.i(TAG, \"Making services ready\"); mSystemServiceManager.startBootPhase( SystemService.PHASE_ACTIVITY_MANAGER_READY); ... &#125; ...&#125; 在startOtherServices()中，会调用ActivityManagerService的systemReady()：frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java 12345678public void systemReady(final Runnable goingCallback) &#123; ... synchronized (this) &#123; ... mStackSupervisor.resumeFocusedStackTopActivityLocked(); mUserController.sendUserSwitchBroadcastsLocked(-1, currentUserId); &#125;&#125; systemReady()中调用了ActivityStackSupervisor的resumeFocusedStackTopActivityLocked()：frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java 1234567891011boolean resumeFocusedStackTopActivityLocked( ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) &#123; if (targetStack != null &amp;&amp; isFocusedStack(targetStack)) &#123; return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions); // 1 &#125; final ActivityRecord r = mFocusedStack.topRunningActivityLocked(); if (r == null || r.state != RESUMED) &#123; mFocusedStack.resumeTopActivityUncheckedLocked(null, null); &#125; return false;&#125; 注释1，调用ActivityStack的resumeTopActivityUncheckedLocked()，ActivityStack对象是用来描述Activity堆栈的。resumeTopActivityUncheckedLocked()：frameworks/base/services/core/java/com/android/server/am/ActivityStack.java 1234567891011121314151617181920boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) &#123; if (mStackSupervisor.inResumeTopActivity) &#123; // Don't even start recursing. return false; &#125; boolean result = false; try &#123; // Protect against recursion. mStackSupervisor.inResumeTopActivity = true; if (mService.mLockScreenShown == ActivityManagerService.LOCK_SCREEN_LEAVING) &#123; mService.mLockScreenShown = ActivityManagerService.LOCK_SCREEN_HIDDEN; mService.updateSleepIfNeededLocked(); &#125; result = resumeTopActivityInnerLocked(prev, options); // 1 &#125; finally &#123; mStackSupervisor.inResumeTopActivity = false; &#125; return result;&#125; 注释1，调用了resumeTopActivityInnerLocked()： 123456private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) &#123; ... return isOnHomeDisplay() &amp;&amp; mStackSupervisor.resumeHomeStackTask(returnTaskType, prev, \"prevFinished\"); ...&#125; 在里面调用了ActivityStackSupervisor的resumeHomeStackTask()：frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java 12345678boolean resumeHomeStackTask(int homeStackTaskType, ActivityRecord prev, String reason) &#123; ... if (r != null &amp;&amp; !r.finishing) &#123; mService.setFocusedActivityLocked(r, myReason); return resumeFocusedStackTopActivityLocked(mHomeStack, prev, null); &#125; return mService.startHomeActivityLocked(mCurrentUser, myReason); // 1&#125; 注释1，调用了ActivityManagerService的startHomeActivityLocked()：frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java 12345678910111213141516171819202122boolean startHomeActivityLocked(int userId, String reason) &#123; if (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL &amp;&amp; mTopAction == null) &#123; // 1 return false; &#125; Intent intent = getHomeIntent(); // 2 ActivityInfo aInfo = resolveActivityInfo(intent, STOCK_PM_FLAGS, userId); if (aInfo != null) &#123; intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName, aInfo.name)); aInfo = new ActivityInfo(aInfo); aInfo.applicationInfo = getAppInfoForUser(aInfo.applicationInfo, userId); ProcessRecord app = getProcessRecordLocked(aInfo.processName, aInfo.applicationInfo.uid, true); if (app == null || app.instrumentationClass == null) &#123; // 3 intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK); mActivityStarter.startHomeActivityLocked(intent, aInfo, reason); // 4 &#125; &#125; else &#123; Slog.wtf(TAG, \"No home screen found for \" + intent, new Throwable()); &#125; return true;&#125; 注释1，mFactoryTest表示系统的运行模式，系统的运行模式分成三种，分别是非工厂模式、低级工厂模式和高级工厂模式。mTopAction用来描述第一个被启动Activity的组件Action，它的值为Intent.ACTION_MAIN。因此，注释1的代码的意思是mFactoryTest为FactoryTest.FACTORY_TEST_LOW_LECEL（低级工厂模式），并且mTopAction == null时，直接返回false。 注释2，getHomeIntent()： 123456789Intent getHomeIntent() &#123; Intent intent = new Intent(mTopAction, mTopData != null ? Uri.parse(mTopData) : null); intent.setComponent(mTopComponent); intent.addFlags(Intent.FLAG_DEBUG_TRIAGED_MISSING); if (mFactoryTest != FactoryTest.FACTORY_TEST_LOW_LEVEL) &#123; intent.addCategory(Intent.CATEGORY_HOME); &#125; return intent;&#125; getHomeIntent()中创建了Intent，并将mTopAction和mTopData传入。mTopAction的值为Intent.ACITON_MAIN，并且如果系统运行模式不是低级工厂模式，则将Intent的Category设置为Intnent.CATEGORY_HOME。 再回到ActivityManagerService的startHomeActivityLocked()，假设系统的运行默模式不是低级工厂模式，在注释3处判断符合Action为Intent.ACTION_MAIN，Category为Intent.CATEGORY_HOME的应用程序是否已经启动，如果没有启动，则调用注释4的方法启动该应用程序。 这个被启动的应用程序就是Launcher，因为Launcher的Manifest文件中的intent-filter标签匹配了Action为Intent.ACTION_MAIN，Category为Intent.CATEGORY_HOME。Launcher的Manifest文件如下：packages/apps/Launcher3/AndroidManifest.xml 1234567891011121314151617181920212223242526272829&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.android.launcher3\"&gt; &lt;uses-sdk android:targetSdkVersion=\"23\" android:minSdkVersion=\"16\"/&gt; ... &lt;application ... &lt;activity android:name=\"com.android.launcher3.Launcher\" android:launchMode=\"singleTask\" android:clearTaskOnLaunch=\"true\" android:stateNotNeeded=\"true\" android:theme=\"@style/Theme\" android:windowSoftInputMode=\"adjustPan\" android:screenOrientation=\"nosensor\" android:configChanges=\"keyboard|keyboardHidden|navigation\" android:resumeWhilePausing=\"true\" android:taskAffinity=\"\" android:enabled=\"true\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.HOME\" /&gt; &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt; &lt;category android:name=\"android.intent.category.MONKEY\"/&gt; &lt;/intent-filter&gt; &lt;/activity&gt;... &lt;/application&gt; &lt;/manifest&gt; 这样，应用程序Launcher就被启动起来了，并执行其OnCreate()。 3. Launcher中应用图标显示流程Launcher的onCreate()代码如下：packages/apps/Launcher3/src/com/android/launcher3/Launcher.java 123456789101112131415161718192021@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; ... LauncherAppState app = LauncherAppState.getInstance(); // 1 mDeviceProfile = getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE ? app.getInvariantDeviceProfile().landscapeProfile : app.getInvariantDeviceProfile().portraitProfile; mSharedPrefs = Utilities.getPrefs(this); mIsSafeModeEnabled = getPackageManager().isSafeMode(); mModel = app.setLauncher(this); // 2 ... if (!mRestoring) &#123; if (DISABLE_SYNCHRONOUS_BINDING_CURRENT_PAGE) &#123; mModel.startLoader(PagedView.INVALID_RESTORE_PAGE); // 3 &#125; else &#123; mModel.startLoader(mWorkspace.getRestorePage()); &#125; &#125; ...&#125; 注释1，获取LauncherAppState实例，并在注释2调用其setLauncher()，将Launcher对象传入，Launcher的setLauncher()如下：packages/apps/Launcher3/src/com/android/launcher3/LauncherAppState.java 1234567LauncherModel setLauncher(Launcher launcher) &#123; getLauncherProvider().setLauncherProviderChangeListener(launcher); mModel.initialize(launcher); // 1 mAccessibilityDelegate = ((launcher != null) &amp;&amp; Utilities.ATLEAST_LOLLIPOP) ? new LauncherAccessibilityDelegate(launcher) : null; return mModel;&#125; 注释1，调用LauncherModel的initialize()： 123456public void initialize(Callbacks callbacks) &#123; synchronized (mLock) &#123; unbindItemInfosAndClearQueuedBindRunnables(); mCallbacks = new WeakReference&lt;Callbacks&gt;(callbacks); &#125;&#125; 在initialize()中，会将callbacks，即传入的Launcher封装成一个弱引用对象，。所以可以得知，mCallbacks变量指的就是封装成弱引用对象的Launcher，这个mCallbacks后面会用到。 现在在回到Launcher的onCreate()，在注释3调用了LauncherModel的startLoader()：packages/apps/Launcher3/src/com/android/launcher3/LauncherModel.java 1234567891011121314151617181920212223242526...@Thunk static final HandlerThread sWorkerThread = new HandlerThread(\"launcher-loader\"); // 1 static &#123; sWorkerThread.start(); &#125; @Thunk static final Handler sWorker = new Handler(sWorkerThread.getLooper()); // 2...public void startLoader(int synchronousBindPage, int loadFlags) &#123;s InstallShortcutReceiver.enableInstallQueue(); synchronized (mLock) &#123; synchronized (mDeferredBindRunnables) &#123; mDeferredBindRunnables.clear(); &#125; if (mCallbacks != null &amp;&amp; mCallbacks.get() != null) &#123; stopLoaderLocked(); mLoaderTask = new LoaderTask(mApp.getContext(), loadFlags); // 3 if (synchronousBindPage != PagedView.INVALID_RESTORE_PAGE &amp;&amp; mAllAppsLoaded &amp;&amp; mWorkspaceLoaded &amp;&amp; !mIsLoaderTaskRunning) &#123; mLoaderTask.runBindSynchronousPage(synchronousBindPage); &#125; else &#123; sWorkerThread.setPriority(Thread.NORM_PRIORITY); sWorker.post(mLoaderTask); // 4 &#125; &#125; &#125;&#125; 注释1，创建具有消息循环的线程HanlderThread对象。 注释2，创建Handler，并传入HandlerThread的Looper。Handler的作用就是向HandlerThread发送消息。 注释3，创建LoaderTask。 注释4，将LoaderTask作为消息，发送给HandlerThread。LoaderTask实现了Runnable接口，当LoaderTask所描述的消息被处理时，会调用它的run()： 123456789101112131415161718192021222324252627282930private class LoaderTask implements Runnable &#123; ... public void run() &#123; synchronized (mLock) &#123; if (mStopped) &#123; return; &#125; mIsLoaderTaskRunning = true; &#125; keep_running: &#123; if (DEBUG_LOADERS) Log.d(TAG, \"step 1: loading workspace\"); loadAndBindWorkspace(); // 1 if (mStopped) &#123; break keep_running; &#125; waitForIdle(); if (DEBUG_LOADERS) Log.d(TAG, \"step 2: loading all apps\"); loadAndBindAllApps(); // 2 &#125; mContext = null; synchronized (mLock) &#123; if (mLoaderTask == this) &#123; mLoaderTask = null; &#125; mIsLoaderTaskRunning = false; mHasLoaderCompletedOnce = true; &#125; &#125; ... &#125; Launcher是用工作区的形式来显示系统安装的应用程序的快捷图标，每一个工作区都是来描述一个抽象的桌面的，它是由n个屏幕组成，每个屏幕又分成n个单元格，每个单元格用来显示一个应用程序的快捷图标。 注释1，调用loadAndBindWorkspace()来加载工作区信息。 注释2，调用loadAndBindAllApps()来加载系统已经安装的应用程序的信息。 loadAndBindAllApps()： 12345678910111213141516171819202122private void loadAndBindAllApps() &#123; if (DEBUG_LOADERS) &#123; Log.d(TAG, \"loadAndBindAllApps mAllAppsLoaded=\" + mAllAppsLoaded); &#125; if (!mAllAppsLoaded) &#123; loadAllApps(); // 1 synchronized (LoaderTask.this) &#123; if (mStopped) &#123; return; &#125; &#125; updateIconCache(); synchronized (LoaderTask.this) &#123; if (mStopped) &#123; return; &#125; mAllAppsLoaded = true; &#125; &#125; else &#123; onlyBindAllApps(); &#125;&#125; 如果系统没有加载已经安装的应用程序信息，则会调用注释1的loadAllApps()： 12345678910111213141516171819private void loadAllApps() &#123; ... mHandler.post(new Runnable() &#123; public void run() &#123; final long bindTime = SystemClock.uptimeMillis(); final Callbacks callbacks = tryGetCallbacks(oldCallbacks); if (callbacks != null) &#123; callbacks.bindAllApplications(added); // 1 if (DEBUG_LOADERS) &#123; Log.d(TAG, \"bound \" + added.size() + \" apps in \" + (SystemClock.uptimeMillis() - bindTime) + \"ms\"); &#125; &#125; else &#123; Log.i(TAG, \"not binding apps: no Launcher activity\"); &#125; &#125; &#125;); ...&#125; 注释1，调用bindAllApplications()，从前面得知这个callbacks实际指向的是Launcher的弱引用，所以实际调用的是Launcher的bindAllApplications()：packages/apps/Launcher3/src/com/android/launcher3/Launcher.java 123456789101112public void bindAllApplications(final ArrayList&lt;AppInfo&gt; apps) &#123; if (waitUntilResume(mBindAllApplicationsRunnable, true)) &#123; mTmpAppsList = apps; return; &#125; if (mAppsView != null) &#123; mAppsView.setApps(apps); // 1 &#125; if (mLauncherCallbacks != null) &#123; mLauncherCallbacks.bindAllApplications(apps); &#125;&#125; 注释1，调用AllAppsContainerView的setApps()，并将包含应用信息的列表apps传进去，setApps()：packages/apps/Launcher3/src/com/android/launcher3/allapps/AllAppsContainerView.java 12345678910111213141516171819public void setApps(List&lt;AppInfo&gt; apps) &#123; mApps.setApps(apps);&#125;包含应用程序信息的列表的`apps`传递给了`AllAppsContainerView`，再看看`AllAppsContainerView`的`onFinishInflate()`：```java@Overrideprotected void onFinishInflate() &#123; super.onFinishInflate(); ... // Load the all apps recycler view mAppsRecyclerView = (AllAppsRecyclerView) findViewById(R.id.apps_list_view); // 1 mAppsRecyclerView.setApps(mApps); // 2 mAppsRecyclerView.setLayoutManager(mLayoutManager); mAppsRecyclerView.setAdapter(mAdapter); // 3 mAppsRecyclerView.setHasFixedSize(true); mAppsRecyclerView.addOnScrollListener(mElevationController); mAppsRecyclerView.setElevationController(mElevationController);...&#125; onFinishInflate()在加载完xml文件后就会调用。 注释1，得到AllAppsRecyclerView用来显示App列表。 注释2，将apps的信息列表传进去。 注释3，为AllAppsRecyclerView设置Adapter。 这样应用程序快捷图标就会显示在屏幕上。 Launcher的启动流程就结束了，下面看看Android系统启动流程。 4. Android系统启动流程结合前面的所有内容，就可以得出Android系统启动流程。 4.1 启动电源以及系统启动当按下电源时，引导芯片代码开始从预定义的地方（固化在ROM）开始执行。加载引导程序Bootloader到RAM，然后执行。 4.2 引导程序BootLoader引导程序BootLoader是在Android操作系统开始运行前的一个小程序，主要作用是把系统OS拉起并运行。 4.3 Linux内核启动内核启动时，设置缓存、被保护存储器、计划列表、加载驱动。当内核完成系统设置，它首先在系统文件中寻找init.rc文件，并启动init进程。 4.4 init进程启动初始化和启动属性服务，并启动Zygote进程。 4.5 Zygote进程启动创建Java VM并为Java VM注册JNI，创建服务端Socket，启动SystemServer进程。 4.6 SystemServer进程启动启动Binder线程池和SystemServiceManager，并启动各种系统服务。 4.7 Launcher启动被SystemServer进程启动的ActivityManagerService会启动Launcher，Launcer启动后，会将已经安装的应用的快捷图标显示在屏幕上。","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://tylerLiu.top/categories/Android进阶/"},{"name":"框架层","slug":"Android进阶/框架层","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/"},{"name":"系统启动","slug":"Android进阶/框架层/系统启动","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/系统启动/"}],"tags":[{"name":"Android系统启动","slug":"Android系统启动","permalink":"https://tylerLiu.top/tags/Android系统启动/"}]},{"title":"Android系统启动流程 03：SystemServer进程","slug":"Android系统启动流程03：SystemServer进程","date":"2019-08-27T07:45:13.000Z","updated":"2019-09-11T08:04:01.284Z","comments":true,"path":"2019/08/27/Android系统启动流程03：SystemServer进程/","link":"","permalink":"https://tylerLiu.top/2019/08/27/Android系统启动流程03：SystemServer进程/","excerpt":"","text":"前言上文知道，Zygote进程最终启动了SystemServer进程，现在就来看看SystemServer进程的启动过程。基于Android 7.0。 1. Zygote启动SystemServer进程上篇说到，在ZygoteInit.java中的startSystemServer()启动了SystemServer进程：frameworks/base/core/java/com/android/internal/os/ZygoteInit.java 123456789101112private static boolean startSystemServer(String abiList, String socketName) throws MethodAndArgsCaller, RuntimeException &#123; ... if (pid == 0) &#123; if (hasSecondZygote(abiList)) &#123; waitForSecondaryZygote(socketName); &#125; handleSystemServerProcess(parsedArgs); &#125; return true; &#125;&#125; 在里面最终通过handleSystemServerProcess()来启动了SystemServer进程。 2. SystemServer进程的启动过程handleSystemServerProcess()： 1234567891011121314151617181920212223private static void handleSystemServerProcess(ZygoteConnection.Arguments parsedArgs) throws ZygoteInit.MethodAndArgsCaller &#123; closeServerSocket(); // 1 ...... if (parsedArgs.invokeWith != null) &#123; ...... &#125; else &#123; ClassLoader cl = null; if (systemServerClasspath != null) &#123; cl = createSystemServerClassLoader(systemServerClasspath, parsedArgs.targetSdkVersion); Thread.currentThread().setContextClassLoader(cl); &#125; /* * Pass the remaining arguments to SystemServer. */ RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl); // 2 &#125;&#125; SystemServer进程复制了Zygote进程地址空间，因此也会得到Zygote进程创建的Socket，这个Socket对于SystemServer进程没有用处，因此，需要用注释1的代码关闭Socket。 注释2，调用RuntimeInit的zygoteInte()：frameworks/base/core/java/com/android/internal/os/RuntimeInit.java 1234567891011public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123; if (DEBUG) Slog.d(TAG, \"RuntimeInit: Starting application from zygote\"); Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"RuntimeInit\"); redirectLogStreams(); commonInit(); nativeZygoteInit(); // 1 applicationInit(targetSdkVersion, argv, classLoader); // 2&#125; 注释1，调用nativeZygoteInit()，在里面调用了Native层的代码。 2.1 启动Binder线程池nativeZygoteInit()对应的JNI文件：frameworks/base/core/jni/AndroidRuntime.cpp 12345678static const JNINativeMethod gMethods[] = &#123; &#123; \"nativeFinishInit\", \"()V\", (void*) com_android_internal_os_RuntimeInit_nativeFinishInit &#125;, &#123; \"nativeZygoteInit\", \"()V\", (void*) com_android_internal_os_RuntimeInit_nativeZygoteInit &#125;, &#123; \"nativeSetExitWithoutCleanup\", \"(Z)V\", (void*) com_android_internal_os_RuntimeInit_nativeSetExitWithoutCleanup &#125;,&#125;; 通过JNI的gMethods()数组，可以看出nativeZygoteInit()对应的是JNI文件AndroidRuntime.cpp的com_android_internal_os_RuntimeInit_nativeZygote()： 123456...static AndroidRuntime* gCurRuntime = NULL;...static void com_android_internal_os_RuntimeInit_nativeZygoteInit(JNIEnv* env, jobject clazz)&#123; gCurRuntime-&gt;onZygoteInit();&#125; 这里gCurRuntime是AndoridRuntime类型的指针，AndroidRuntime的子类AppRuntime在app_main.cpp中定义，下面查看AppRuntime的onZygoteInit()：frameworks/base/cmds/app_process/app_main.cpp 12345virtual void onZygoteInit()&#123; sp&lt;ProcessState&gt; proc = ProcessState::self(); ALOGV(\"App process: starting thread pool.\\n\"); proc-&gt;startThreadPool(); // 1&#125; 注释1，用来启动一个Binder线程池，这样SystemServer进程就可以使用Binder来与其他进程进行通信了。所以RuntimeInit.java的nativeZygote()主要是启动Binder线程池。 2.2 invokeStaticMain再回到RuntimeInit.java，在注释2处调用了applicationInit()：frameworks/base/core/java/com/android/internal/os/RuntimeInit.java 12345 private static void applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123; ... invokeStaticMain(args.startClass, args.startArgs, classLoader);&#125; applicationInit()最终主要调用了invokeStaticMain()： 12345678910111213141516171819202122232425262728293031323334353637private static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123; Class&lt;?&gt; cl; try &#123; cl = Class.forName(className, true, classLoader); // 1 &#125; catch (ClassNotFoundException ex) &#123; throw new RuntimeException( \"Missing class when invoking static main \" + className, ex); &#125; Method m; try &#123; m = cl.getMethod(\"main\", new Class[] &#123; String[].class &#125;); // 2 &#125; catch (NoSuchMethodException ex) &#123; throw new RuntimeException( \"Missing static main on \" + className, ex); &#125; catch (SecurityException ex) &#123; throw new RuntimeException( \"Problem getting static main on \" + className, ex); &#125; int modifiers = m.getModifiers(); if (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123; throw new RuntimeException( \"Main method is not public and static on \" + className); &#125; /* * This throw gets caught in ZygoteInit.main(), which responds * by invoking the exception's run() method. This arrangement * clears up all the stack frames that were required in setting * up the process. */ throw new ZygoteInit.MethodAndArgsCaller(m, argv); // 3&#125; 注释1，className为&quot;com.android.server.SystemServer&quot;，因此通过反射返回的cl为SystemServer类。 注释2，找到SystemServer中的main()。 注释3，将找到的main()传入到MethodAndArgsCaller()异常中，并抛出该异常。截获MethodAndArgsCaller()异常的代码在ZygoteInit.java的main()中。如下： 1234567891011public static void main(String argv[]) &#123; ... closeServerSocket(); &#125; catch (MethodAndArgsCaller caller) &#123; caller.run(); // 1 &#125; catch (RuntimeException ex) &#123; Log.e(TAG, \"Zygote died with exception\", ex); closeServerSocket(); throw ex; &#125;&#125; 注释1，调用了MethodAndArgsCaller的run()： 1234567public void run() &#123; try &#123; mMethod.invoke(null, new Object[] &#123; mArgs &#125;); &#125; catch (IllegalAccessException ex) &#123; ... &#125;&#125; 这里的mMethod指的就是SystemServer中的main()，此时main()就被动态调用起来。 3. 解析SystemServer进行下面看看SystemServer的main()：frameworks/base/services/java/com/android/server/SystemServer.java 123public static void main(String[] args) &#123; new SystemServer().run();&#125; 在里面只是调用了SystemServer的run()： 123456789101112131415161718192021private void run() &#123; ... System.loadLibrary(\"android_servers\"); // 1 ... mSystemServiceManager = new SystemServiceManager(mSystemContext); // 2 LocalServices.addService(SystemServiceManager.class, mSystemServiceManager); ... try &#123; Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, \"StartServices\"); startBootstrapServices(); // 3 startCoreServices(); // 4 startOtherServices(); // 5 &#125; catch (Throwable ex) &#123; Slog.e(\"System\", \"******************************************\"); Slog.e(\"System\", \"************ Failure starting system services\", ex); throw ex; &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER); &#125; ...&#125; 注释1，加载lib库andorid_servers.so。 注释2，创建SystemServiceManager，它会对系统的服务进行创建、启动和生命周期管理。 下面就是启动系统的各种服务。 注释3，startBootstrapServices()中使用SystemServiceManager启动了ActivityManagerService、PowerManagerService、PackageManagerService等服务。 注释4，startCoreServices()中启动了BatteryService、UsageStatesService和WebViewUpdateService。 注释5，startOtherServices()中启动了CameraService、AlarmManagerService、VrManagerService等服务。 这些服务的父类为SystemService。 从注释3、4、5可以看出，官方将服务分成三类，引导服务、核心服务和其他服务，其中其他服务是一些非紧要的和一些不需要立即启动的服务。系统服务大约有80多个，下面列举了部分服务及其作用。 引导服务 作用 Installer 系统安装APK时的一个服务类，启动完成Installer服务后，才能启动其它的系统服务 ActivtyManagerService 负责四大组件的启动、切换和调度 PowerManagerService 计算系统中和Power相关的计算，然后决策系统应该如何反应 LightsService 管理和显示背光LED DisplayManagerService 用来管理所有显示设备 UserManagerService 多用户模式管理 SensorService 为系统提供各种感应器服务 PackageManagerService 用来对APK进行安装、解析、删除、卸载等操作 核心服务 BatteryService 管理电池相关的服务 UsageStatsService 收集用户使用每一个APP的频率、使用时长 WebViewUpdateService WebView更新服务 其他服务 CameraService 摄像头相关服务 AlarmManagerService 全局定时器管理服务 InputManagerService 管理输入事件 WindowManagerService 窗口管理服务 VrManagerService VR模式管理服务 BluetoothService 蓝牙管理服务 NotificationManagerService 通知管理服务 DevicesStorageMonitorService 存储相关服务 LocationManagerService 定位管理服务 AudioService 音频管理服务 … … 假如要启动PowerManagerService，代码如下： 1mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class); SystemServiceManager的startService()启动了PowerManagerService，startService()具体如下：frameworks/base/services/core/java/com/android/server/SystemServerManager.java 12345678910111213141516171819202122232425262728293031323334353637public &lt;T extends SystemService&gt; T startService(Class&lt;T&gt; serviceClass) &#123; try &#123; final String name = serviceClass.getName(); Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, \"StartService \" + name); // Create the service. if (!SystemService.class.isAssignableFrom(serviceClass)) &#123; ...... &#125; final T service; try &#123; Constructor&lt;T&gt; constructor = serviceClass.getConstructor(Context.class); service = constructor.newInstance(mContext); // 1 &#125; catch (InstantiationException ex) &#123; ...... &#125; catch (IllegalAccessException ex) &#123; ...... &#125; catch (NoSuchMethodException ex) &#123; ...... &#125; catch (InvocationTargetException ex) &#123; ...... &#125; // Register it. mServices.add(service); // 2 // Start it. try &#123; service.onStart(); // 3 &#125; catch (RuntimeException ex) &#123; ...... &#125; return service; &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER); &#125;&#125; 注释1，创建SystemServer，这里的SystemServer就是前面传进来的PowerManagerService。 注释2，将PowerManagerService添加到mServices中，这里的mServices是一个存储SystemService类型的ArrayList。 注释3，调用传进来的PowerManagerSerivce的onStart()启动PowerManagerService并返回。 除了使用mSystemServiceManager的startService()来启动系统服务之外，还可以通知如下形式来启动系统服务，以PackageManagerService为例： 1mPackageManagerService = PackageManagerService.main(mSystemContext, installer, mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore); 直接调用了PackageManagerService的main()：frameworks/base/service/core/java/com/android/server/pm/PackageManagerService.java 123456789101112131415public static PackageManagerService main(Context context, Installer installer, boolean factoryTest, boolean onlyCore) &#123; // Self-check for initial settings. PackageManagerServiceCompilerMapping.checkProperties(); PackageManagerService m = new PackageManagerService(context, installer, factoryTest, onlyCore); // 1 m.enableSystemUserPackages(); // Disable any carrier apps. We do this very early in boot to prevent the apps from being // disabled after already being started. CarrierAppUtils.disableCarrierAppsUntilPrivileged(context.getOpPackageName(), m, UserHandle.USER_SYSTEM); ServiceManager.addService(\"package\", m); // 2 return m;&#125; 注释1，创建PackageManagerService。 注释2，将PackageManagerService注册到ServiceManager中，ServiceManager用来管理系统中的各种Service。由于系统C/S架构中的Binder机制通信：Client端要使用某个Service，则需要先到ServiceManager中查询Service的相关信息，然后根据Service的相关信息与Service进程建立通讯通路，这样Client就能使用Service了。 还有服务是直接注册到ServiceManager中的：framewokrs/base/services/java/com/android/server/SystemServer.java 12telephonyRegistry = new TelephonyRegistry(context);ServiceManager.addService(\"telephony.registry\", telephonyRegistry); 4. 总结SystemServer主要做了以下的工作： 启动Binder线程池，这样就可以与其他进程进行通信； 创建SystemServiceManager用于对系统服务进行创建、启动和生命周期的管理； 启动各种系统服务。","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://tylerLiu.top/categories/Android进阶/"},{"name":"框架层","slug":"Android进阶/框架层","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/"},{"name":"系统启动","slug":"Android进阶/框架层/系统启动","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/系统启动/"}],"tags":[{"name":"Android系统启动","slug":"Android系统启动","permalink":"https://tylerLiu.top/tags/Android系统启动/"}]},{"title":"Android系统启动流程 02：zygote进程","slug":"Android系统启动流程02：zygote进程","date":"2019-08-27T01:46:23.000Z","updated":"2019-09-11T08:04:03.671Z","comments":true,"path":"2019/08/27/Android系统启动流程02：zygote进程/","link":"","permalink":"https://tylerLiu.top/2019/08/27/Android系统启动流程02：zygote进程/","excerpt":"","text":"前言前面说到init进程的启动过程主要做了三件事，其中一件就是创建zygote进程，那么zygote进程做了什么？ 1. zygote简介在Android系统中，DVM（Dalvik虚拟机）、应用程序进程以及运行系统的关键服务的SystemServer进程都由zygote进程来创建的，称为孵化器。它通过fork（复制进程）的形式来创建应用进程和SystemServer进程，由于zygote进程在启动时，会创建DVM，因此通过fork创建的应用程序和SystemServer进程可以在内部获取一个DVM的实例拷贝。 这里主要分析Android 7.0中zygote的启动流程。 2. AppRuntime分析上文得知，init启动zygote时主要是调用app_main.cpp的main函数中的AppRuntime的start来启动zygote进程的，所以从app_main.cpp的main函数开始分析：frameworks/base/cmds/app_process/app_main.cpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546int main(int argc, char* const argv[])&#123; ... AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv)); ... Vector&lt;String8&gt; args; if (!className.isEmpty()) &#123; args.add(application ? String8(\"application\") : String8(\"tool\")); runtime.setClassNameAndArgs(className, argc - i, argv + i); &#125; else &#123; // We're in zygote mode. maybeCreateDalvikCache(); if (startSystemServer) &#123; args.add(String8(\"start-system-server\"));// 1 &#125; char prop[PROP_VALUE_MAX]; if (property_get(ABI_LIST_PROPERTY, prop, NULL) == 0) &#123; LOG_ALWAYS_FATAL(\"app_process: Unable to determine ABI list from property %s.\", ABI_LIST_PROPERTY); return 11; &#125; String8 abiFlag(\"--abi-list=\"); abiFlag.append(prop); args.add(abiFlag); for (; i &lt; argc; ++i) &#123; args.add(String8(argv[i])); &#125; &#125; if (!niceName.isEmpty()) &#123; runtime.setArgv0(niceName.string()); set_process_name(niceName.string()); &#125; if (zygote) &#123; runtime.start(\"com.android.internal.os.ZygoteInit\", args, zygote);// 2 &#125; else if (className) &#123; runtime.start(\"com.android.internal.os.RuntimeInit\", args, zygote); &#125; else &#123; fprintf(stderr, \"Error: no class name or --zygote supplied.\\n\"); app_usage(); LOG_ALWAYS_FATAL(\"app_process: no class name or --zygote supplied.\"); return 10; &#125;&#125; 注释1，如果startSystemServer为true的话（默认为true），将&quot;start_system_server&quot;放入启动的参数args。 注释2，调用runtime的start()函数来启动zygote进程，并将args传入，这样，启动zygote进程后，zygote进程就会将SystemServer进程启动。这里的runtime指的就是AppRuntime，Appruntime声明也在app_main.cpp中，它继承AndroidRuntime，所以调用start实际上就是调用AndroidRuntime的start函数：frameworks/base/core/jni/AndroidRuntime.cpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758void AndroidRuntime::start(const char* className, const Vector&lt;String8&gt;&amp; options, bool zygote)&#123; ... /* start the virtual machine */ JniInvocation jni_invocation; jni_invocation.Init(NULL); JNIEnv* env; if (startVm(&amp;mJavaVM, &amp;env, zygote) != 0) &#123;// 1 return; &#125; onVmCreated(env); if (startReg(env) &lt; 0) &#123;// 2 ALOGE(\"Unable to register all android natives\\n\"); return; &#125; jclass stringClass; jobjectArray strArray; jstring classNameStr; stringClass = env-&gt;FindClass(\"java/lang/String\"); assert(stringClass != NULL); // 创建数组 strArray = env-&gt;NewObjectArray(options.size() + 1, stringClass, NULL); assert(strArray != NULL); // 从app_main的main函数得知className为com.android.internal.os.ZygoteInit classNameStr = env-&gt;NewStringUTF(className); assert(classNameStr != NULL); env-&gt;SetObjectArrayElement(strArray, 0, classNameStr); for (size_t i = 0; i &lt; options.size(); ++i) &#123; jstring optionsStr = env-&gt;NewStringUTF(options.itemAt(i).string()); assert(optionsStr != NULL); env-&gt;SetObjectArrayElement(strArray, i + 1, optionsStr); &#125; char* slashClassName = toSlashClassName(className); jclass startClass = env-&gt;FindClass(slashClassName); if (startClass == NULL) &#123; ALOGE(\"JavaVM unable to locate class '%s'\\n\", slashClassName); /* keep going */ &#125; else &#123; // 找到ZygoteInit的main函数 jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, \"main\", \"([Ljava/lang/String;)V\");// 3 if (startMeth == NULL) &#123; ALOGE(\"JavaVM unable to find main() in '%s'\\n\", className); /* keep going */ &#125; else &#123; // 通过JNI调用ZygoteInit的main函数 env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);// 4#if 0 if (env-&gt;ExceptionCheck()) threadExitUncaughtException(env);#endif &#125; &#125; ...&#125; 注释1，调用startVm创建JavaVM，即DVM。 注释2，调用startReg为DVM注册JNI。 注释3，用来找到ZygoteInit的main函数，其中startClass从app_main.cpp的main函数得知为com.android.internal.os.ZygoteInit。 注释4，通过JNIi调用ZygoteInit的main函数，因为ZygoteInit是用Java编写的，所以要通过JNI调用。 3. ZygoteInit的Java框架层frameworks/base/core/java/com/android/internal/os/ZygoteInit.java 1234567891011121314151617181920212223242526public static void main(String argv[]) &#123; ... try &#123; ... // 注册Zygote用的Socket registerZygoteSocket(socketName);// 1 ... // 预加载类和资源 preload();// 2 ... if (startSystemServer) &#123; // 启动SystemServer进程 startSystemServer(abiList, socketName);// 3 &#125; Log.i(TAG, \"Accepting command socket connections\"); // 等待客户端请求 runSelectLoop(abiList);// 4 closeServerSocket(); &#125; catch (MethodAndArgsCaller caller) &#123; caller.run(); &#125; catch (RuntimeException ex) &#123; Log.e(TAG, \"Zygote died with exception\", ex); closeServerSocket(); throw ex; &#125; &#125; 注释1，通过registerSygoteSocket()来创建一个Server端的Socket，这个name为&quot;zygote&quot;的Socket用来等待ActivityManagerService来请求Zygote来创建新的应用程序进程。 注释2，用来预加载类和资源。 注释3，启动SystemServer进程，这样系统的关键服务也会由SystemServer进程启动起来。 注释4，调用runSelectLoop()来等待客户端请求。 所以，ZygoteInit的main函数主要做了4件事，下面来一一分析。 3.1 registerZygoteSocket1234567891011121314151617181920private static void registerZygoteSocket(String socketName) &#123; if (sServerSocket == null) &#123; int fileDesc; final String fullSocketName = ANDROID_SOCKET_PREFIX + socketName; try &#123; String env = System.getenv(fullSocketName); fileDesc = Integer.parseInt(env); &#125; catch (RuntimeException ex) &#123; throw new RuntimeException(fullSocketName + \" unset or invalid\", ex); &#125; try &#123; FileDescriptor fd = new FileDescriptor(); fd.setInt$(fileDesc); sServerSocket = new LocalServerSocket(fd);// 1 &#125; catch (IOException ex) &#123; throw new RuntimeException( \"Error binding to local socket '\" + fileDesc + \"'\", ex); &#125; &#125;&#125; 注释1，创建LocalServerStocket，就是服务端的Stocke。当Zygote进程将SystemServer进程启动后，就会在这个服务端的Stocket上等待ActivityManagerService请求Zygote进程来创建新的应用程序进程。 3.2 启动SystemServer进程下面看看startSystemServer()： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354private static boolean startSystemServer(String abiList, String socketName) throws MethodAndArgsCaller, RuntimeException &#123; ...... /* Containers run without this capability, so avoid setting it in that case */ if (!SystemProperties.getBoolean(PROPERTY_RUNNING_IN_CONTAINER, false)) &#123; capabilities |= posixCapabilitiesAsBits(OsConstants.CAP_BLOCK_SUSPEND); &#125; /* Hardcoded command line to start the system server */ // 1 String args[] = &#123; \"--setuid=1000\", \"--setgid=1000\", \"--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1032,3001,3002,3003,3006,3007,3009,3010\", \"--capabilities=\" + capabilities + \",\" + capabilities, \"--nice-name=system_server\", \"--runtime-args\", \"com.android.server.SystemServer\", &#125;; ZygoteConnection.Arguments parsedArgs = null; int pid; try &#123; // 2 parsedArgs = new ZygoteConnection.Arguments(args); ZygoteConnection.applyDebuggerSystemProperty(parsedArgs); ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs); /* Request to fork the system server process */ // 3 pid = Zygote.forkSystemServer( parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, null, parsedArgs.permittedCapabilities, parsedArgs.effectiveCapabilities); &#125; catch (IllegalArgumentException ex) &#123; throw new RuntimeException(ex); &#125; /* For child process */ if (pid == 0) &#123; if (hasSecondZygote(abiList)) &#123; waitForSecondaryZygote(socketName); &#125; handleSystemServerProcess(parsedArgs);// 4 &#125; return true;&#125; 注释1，创建args数组，用来保存启动SystemServer的参数，可以看出SystemServer进程的用户id和用户组id被设置为1000；并且拥有用户组10011010，1018、1021、1032、30013010的权限；进程名为system_server；启动的类名为com.android.server.SystemServer。 注释2，将args数组封装成Arguments对象并供注释3的forkSystemServer()调用。 注释3，调用Sygote的forkSystemServer()，主要是通过fork()函数在当前进程创建一个子进程，如果返回的pid为0，表示在新创建的子进程中执行的，则会执行注释4处的handleSystemServerProcess来启动SystemServer进程。 3.3 runSelectLoop启动SystemServer进程后，最后进入runSelectLoop()。 12345678910111213141516171819202122232425262728293031323334353637private static void runSelectLoop(String abiList) throws MethodAndArgsCaller &#123; ArrayList&lt;FileDescriptor&gt; fds = new ArrayList&lt;FileDescriptor&gt;(); ArrayList&lt;ZygoteConnection&gt; peers = new ArrayList&lt;ZygoteConnection&gt;(); fds.add(sServerSocket.getFileDescriptor()); // 1 peers.add(null); while (true) &#123; StructPollfd[] pollFds = new StructPollfd[fds.size()]; for (int i = 0; i &lt; pollFds.length; ++i) &#123; // 2 pollFds[i] = new StructPollfd(); pollFds[i].fd = fds.get(i); pollFds[i].events = (short) POLLIN; &#125; try &#123; Os.poll(pollFds, -1); &#125; catch (ErrnoException ex) &#123; throw new RuntimeException(\"poll failed\", ex); &#125; for (int i = pollFds.length - 1; i &gt;= 0; --i) &#123; // 3 if ((pollFds[i].revents &amp; POLLIN) == 0) &#123; continue; &#125; if (i == 0) &#123; ZygoteConnection newPeer = acceptCommandPeer(abiList); // 4 peers.add(newPeer); fds.add(newPeer.getFileDesciptor()); &#125; else &#123; boolean done = peers.get(i).runOnce();// 5 if (done) &#123; peers.remove(i); fds.remove(i); &#125; &#125; &#125; &#125;&#125; 注释1，sServerStocket就是在registerZygoteStocket()中创建的服务端Stocket，调用sServerStocket.getFileDescriptor()用来获得该Stocket字段的值并添加到fd列表fds中。然后使用无限循环用来等待ActivtiyManagerService请求Zygote进程创建新的应用程序进程。 注释2，通过遍历将fds存储的信息转移到pollFds数组中。 注释3，遍历pollFds，如果i == 0，表示服务端Socket与客户端已经连上，即，当前Zygote进程与ActivityManagerService建立了连接。 注释4，通过acceptCommabdPeer()得到``ZygoteConnection对象，并添加到Stocket连接列表peer中，接着将该ZygoteConnection添加到fd列表fds中，以便可以收到ActivityManagerService发送过来的请求。如果i的值大于0，说明ActivityManagerService向Zytoge进程发送了一个创建应用进程的请求，则在注释5调用ZygoteConnection的runOnce()创建一个新的应用程序进程。并在成功创建后，将这个连接从Socket连接列表peers和fd列表fds`中清除。 4. 总结Zygote进程主要做了以下几件事： 创建AppRuntime，并调用其start()，启动Zygote进程； 创建DVM并为DVM注册JNI； 通过JNI调用Zygote的main()，进入Zygote的Java框架层； 通过registerZygoteSocket()创建服务端Socket，并通过runSelectLoop()等待ActivityManagerService的请求来创建新的应用程序进程。 启动SystemServer进程。 参考资料 《Android系统源代码情景分析》 《深入理解Android卷1》 《深入理解Android系统》","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://tylerLiu.top/categories/Android进阶/"},{"name":"框架层","slug":"Android进阶/框架层","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/"},{"name":"系统启动","slug":"Android进阶/框架层/系统启动","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/系统启动/"}],"tags":[{"name":"Android系统启动","slug":"Android系统启动","permalink":"https://tylerLiu.top/tags/Android系统启动/"}]},{"title":"Android系统启动流程 01：init进程","slug":"Android系统启动流程01：init进程","date":"2019-08-24T07:49:27.000Z","updated":"2019-09-11T08:04:01.235Z","comments":true,"path":"2019/08/24/Android系统启动流程01：init进程/","link":"","permalink":"https://tylerLiu.top/2019/08/24/Android系统启动流程01：init进程/","excerpt":"","text":"1. 简介init进程是Android系统中用户空间的第一个进程。有很多重要职责，如，创建zygote(孵化器)和属性服务等。 init进程由多个源文件共同组成，这些文件位于源码目录system/core/init中。 本文将基于Android 7.0分析init进程。 2. 引入init进程Android系统启动流程： 启动电源以及系统启动：当按下电源键时，引导芯片代码开始从预定义的地方（固化在ROM）开始执行。加载引导程序Bootloader到RAM，然后执行。 引导程序Bootloader：引导程序是在Android操作系统开始运行前的一个小程序，主要作用是把系统OS拉起并运行。 Linux内核启动：内核启动时，设置缓存、被保护存储器、计划列表，加载启动。当内核完成系统设置，首先在系统文件中寻找init文件，然后启动root进程或者系统的第一个进程。 init进程启动 3. init入口函数iniy的入口函数为main()，代码如下：system/core/init/init.cpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970int main(int argc, char** argv) &#123; if (!strcmp(basename(argv[0]), \"ueventd\")) &#123; return ueventd_main(argc, argv); &#125; if (!strcmp(basename(argv[0]), \"watchdogd\")) &#123; return watchdogd_main(argc, argv); &#125; umask(0); add_environment(\"PATH\", _PATH_DEFPATH); bool is_first_stage = (argc == 1) || (strcmp(argv[1], \"--second-stage\") != 0); // 创建文件并挂载 if (is_first_stage) &#123; mount(\"tmpfs\", \"/dev\", \"tmpfs\", MS_NOSUID, \"mode=0755\"); mkdir(\"/dev/pts\", 0755); mkdir(\"/dev/socket\", 0755); mount(\"devpts\", \"/dev/pts\", \"devpts\", 0, NULL); #define MAKE_STR(x) __STRING(x) mount(\"proc\", \"/proc\", \"proc\", 0, \"hidepid=2,gid=\" MAKE_STR(AID_READPROC)); mount(\"sysfs\", \"/sys\", \"sysfs\", 0, NULL); &#125; open_devnull_stdio(); klog_init(); klog_set_level(KLOG_NOTICE_LEVEL); NOTICE(\"init %s started!\\n\", is_first_stage ? \"first stage\" : \"second stage\"); if (!is_first_stage) &#123; // Indicate that booting is in progress to background fw loaders, etc. close(open(\"/dev/.booting\", O_WRONLY | O_CREAT | O_CLOEXEC, 0000)); // 初始化属性相关资源 property_init();// 1 process_kernel_dt(); process_kernel_cmdline(); export_kernel_boot_props(); &#125; ... // 启动属性服务 start_property_service();// 2 const BuiltinFunctionMap function_map; Action::set_function_map(&amp;function_map); Parser&amp; parser = Parser::GetInstance(); parser.AddSectionParser(\"service\",std::make_unique&lt;ServiceParser&gt;()); parser.AddSectionParser(\"on\", std::make_unique&lt;ActionParser&gt;()); parser.AddSectionParser(\"import\", std::make_unique&lt;ImportParser&gt;()); // 解析init.rc配置文件 parser.ParseConfig(\"/init.rc\");// 3 ... while (true) &#123; if (!waiting_for_exec) &#123; am.ExecuteOneCommand(); restart_processes(); &#125; int timeout = -1; if (process_needs_restart) &#123; timeout = (process_needs_restart - gettime()) * 1000; if (timeout &lt; 0) timeout = 0; &#125; if (am.HasMoreCommands()) &#123; timeout = 0; &#125; bootchart_sample(&amp;timeout); epoll_event ev; int nr = TEMP_FAILURE_RETRY(epoll_wait(epoll_fd, &amp;ev, 1, timeout)); if (nr == -1) &#123; ERROR(\"epoll_wait failed: %s\\n\", strerror(errno)); &#125; else if (nr == 1) &#123; ((void (*)()) ev.data.ptr)(); &#125; &#125; return 0;&#125; init的main()方法中做了很多事情，主要有以下几点： 注释1调用property_init()对属性进行初始化 注释2调用start_property_service()启动属性服务 注释3使用parser.ParserConfig(&quot;init.rc&quot;)用来解析init.rc。解析init.rc的文件为system/core/init/init_parse.cpp。 下面看看init.rc里面做了什么。 4. init.rcinit.rc是一个配置文件，内部由Android初始化语言（Android Init Language）编写的脚本，主要包含五种类型语句：Action、Commands、Services、Options和Inport。 init.rc配置代码如下：system/core/rootdir/init.rc 123456789101112131415on init sysclktz 0 # Mix device-specific information into the entropy pool copy /proc/cmdline /dev/urandom copy /default.prop /dev/urandom...on boot # basic network init ifup lo hostname localhost domainname localdomain # set RLIMIT_NICE to allow priorities from 19 to -20 setrlimit 13 40 40... on init和on boot是Action语句，格式为： 123on &lt;trigger&gt; [&amp;&amp; &lt;trigger&gt;]* // 设置触发器 &lt;command&gt; &lt;command&gt; // 动作触发之后要执行的命令 为了分析如何创建zygote，主要看Services类型的语句，格式如下： 123service &lt;name&gt; &lt;pathname&gt; [&lt;argument&gt;]* // &lt;service的名字&gt;&lt;执行程序路径&gt;&lt;传递参数&gt; &lt;option&gt; // option是service的修饰词，影响什么时候，如何启动services &lt;option&gt; 注意：Android 7.0中对init.rc进行了拆分，每个服务一个rc文件。要分析的zygote服务的启动脚本在init.zygoteXX.rc中，这里以64位处理器为例，init.zygote64.rc代码如下：system/core/rootdir/init.zygote64.rc 12345678910service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server class main socket zygote stream 660 root system onrestart write /sys/android_power/request_state wake onrestart write /sys/power/state on onrestart restart audioserver onrestart restart cameraserver onrestart restart media onrestart restart netd writepid /dev/cpuset/foreground/tasks /dev/stune/foreground/tasks 其中service用于通知init进程创建名为zygote的进程，这个zygote进程执行程序的路径为/system/bin/app_process64，后面的是要传给app_process64的参数。class main指zygote的calss name为main，后面会用到。 5. 解析service解析service会用到两个函数： ParseSection：解析service的rc文件，比如前面的init.zygote64.rc，主要用来搭建service的架子 ParselineSection：用于解析子项 代码如下：system/core/init/service.cpp 123456789101112131415161718192021bool ServiceParser::ParseSection(const std::vector&lt;std::string&gt;&amp; args, std::string* err) &#123; if (args.size() &lt; 3) &#123; *err = \"services must have a name and a program\"; return false; &#125; const std::string&amp; name = args[1]; if (!IsValidName(name)) &#123; *err = StringPrintf(\"invalid service name '%s'\", name.c_str()); return false; &#125; std::vector&lt;std::string&gt; str_args(args.begin() + 2, args.end()); service_ = std::make_unique&lt;Service&gt;(name, \"default\", str_args);// 1 return true;&#125;bool ServiceParser::ParseLineSection(const std::vector&lt;std::string&gt;&amp; args, const std::string&amp; filename, int line, std::string* err) const &#123; return service_ ? service_-&gt;HandleLine(args, err) : false;&#125; 注释1，根据参数构造出一个service对象，其classname为&quot;default&quot;。当解析完毕时会调用EndSection()： 12345void ServiceParser::EndSection() &#123; if (service_) &#123; ServiceManager::GetInstance().AddService(std::move(service_)); &#125;&#125; 在AddService()中： 123456789void ServiceManager::AddService(std::unique_ptr&lt;Service&gt; service) &#123; Service* old_service = FindServiceByName(service-&gt;name()); if (old_service) &#123; ERROR(\"ignored duplicate definition of service '%s'\", service-&gt;name().c_str()); return; &#125; services_.emplace_back(std::move(service));// 1&#125; 注释1，将service对象添加到services链表中。 总的来说就是根据参数创建出service对象，然后根据选项域的内容填充service对象，最后将service对象添加到vector类型的services链表中。 6. init启动zygote了解完service，下面看看init是如何启动service，这里主要讲启动zygote的这个service。在zygote的启动脚本中得知zygote的class name为main，在init.rc有如下配置代码：system/core/rootdir/init.rc 1234567...on nonencrypted # A/B update verifier that marks a successful boot. exec - root -- /system/bin/update_verifier nonencrypted class_start main class_start late_start ... 其中class_start是一个COMMAND，对应的函数为do_class_start。因为main指的是zygote，因此class_start main就是用来启动zygote。do_class_start是定义在builtins.cpp中的，如下：system/core/init/builtins.cpp 123456789static int do_class_start(const std::vector&lt;std::string&gt;&amp; args) &#123; /* Starting a class does not start services * which are explicitly disabled. They must * be started individually. */ ServiceManager::GetInstance(). ForEachServiceInClass(args[1], [] (Service* s) &#123; s-&gt;StartIfNotDisabled(); &#125;); return 0;&#125; 在里面最终调用了StartIfNotDisabled：systme/core/init/service.cpp 12345678bool Service::StartIfNotDisabled() &#123; if (!(flags_ &amp; SVC_DISABLED)) &#123; return Start(); &#125; else &#123; flags_ |= SVC_DISABLED_START; &#125; return true;&#125; 再来看看里面的Start()方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354bool Service::Start() &#123; flags_ &amp;= (~(SVC_DISABLED|SVC_RESTARTING|SVC_RESET|SVC_RESTART|SVC_DISABLED_START)); time_started_ = 0; if (flags_ &amp; SVC_RUNNING) &#123;// 如果Service已经运行，则不启动 return false; &#125; bool needs_console = (flags_ &amp; SVC_CONSOLE); if (needs_console &amp;&amp; !have_console) &#123; ERROR(\"service '%s' requires console\\n\", name_.c_str()); flags_ |= SVC_DISABLED; return false; &#125; // 判断需要启动的Service的对应的执行文件是否存在，不存在则不启动该Service struct stat sb; if (stat(args_[0].c_str(), &amp;sb) == -1) &#123; ERROR(\"cannot find '%s' (%s), disabling '%s'\\n\", args_[0].c_str(), strerror(errno), name_.c_str()); flags_ |= SVC_DISABLED; return false; &#125; ... // 1.fork函数创建子进程 pid_t pid = fork(); if (pid == 0) &#123;// 运行在子进程中 umask(077); for (const auto&amp; ei : envvars_) &#123; add_environment(ei.name.c_str(), ei.value.c_str()); &#125; for (const auto&amp; si : sockets_) &#123; int socket_type = ((si.type == \"stream\" ? SOCK_STREAM : (si.type == \"dgram\" ? SOCK_DGRAM : SOCK_SEQPACKET))); const char* socketcon = !si.socketcon.empty() ? si.socketcon.c_str() : scon.c_str(); int s = create_socket(si.name.c_str(), socket_type, si.perm, si.uid, si.gid, socketcon); if (s &gt;= 0) &#123; PublishSocket(si.name, s); &#125; &#125;... // 2.通过execve执行程序 if (execve(args_[0].c_str(), (char**) &amp;strs[0], (char**) ENV) &lt; 0) &#123; ERROR(\"cannot execve('%s'): %s\\n\", args_[0].c_str(), strerror(errno)); &#125; _exit(127); &#125;... return true;&#125; 通过注释1和注释2的代码，得知在Start()方法中，调用fork()函数来创建子线程，并在子线程中调用execve()执行system/bin/app_process，这样就会进入frameworks/base/cmds/app_progress/app_main.cpp中的main()函数，如下： 1234567891011121314int main(int argc, char* const argv[])&#123; ... if (zygote) &#123; runtime.start(\"com.android.internal.os.ZygoteInit\", args, zygote);// 1 &#125; else if (className) &#123; runtime.start(\"com.android.internal.os.RuntimeInit\", args, zygote); &#125; else &#123; fprintf(stderr, \"Error: no class name or --zygote supplied.\\n\"); app_usage(); LOG_ALWAYS_FATAL(\"app_process: no class name or --zygote supplied.\"); return 10; &#125;&#125; 注释1可以看到，调用runntime(AppRuntime)的start()来启动zygote。 7. 属性服务Windows上有一个注册管理表，注册管理表的内容是采用键值对的形式来记录用户、软件的一些使用信息。即使系统或者软件重启，它还是能根据之前在注册表中的记录，进行相应的初始化工作。 Android中也有一个类似的机制，叫做属性服务。 文章开始提到的在init.cpp代码中和属性服务相关的代码有： 1234// 初始化属性服务配置property_init();// 启动属性服务start_property_service(); 7.1 属性服务的初始化与启动property_init()具体实现如下：system/core/init/property_service.cpp 123456void property_init() &#123; if (__system_property_area_init()) &#123; ERROR(\"Failed to initialize property area\\n\"); exit(1); &#125;&#125; _system_property_are_init()是用来初始化属性内存区域。 下面看看start_property_service()的具体实现： 12345678910void start_property_service() &#123; property_set_fd = create_socket(PROP_SERVICE_NAME, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK, 0666, 0, 0, NULL);// 1 if (property_set_fd == -1) &#123; ERROR(\"start_property_service socket creation failed: %s\\n\", strerror(errno)); exit(1); &#125; listen(property_set_fd, 8);// 2 register_epoll_handler(property_set_fd, handle_property_set_fd);// 3&#125; 注释1，创建非阻塞的socket。 注释2，调用listen()对property_set_fd进行监听，这样创建的socket就成为了server，也就是属性服务；listen()函数的第二个参数设置成8，意味着属性服务最多可以同时为8个试图设置属性的用户提供服务。 注释3，将property_set_fd放到epoll()句柄中，用epoll()来监听property_set_fd：当property_set_fd中有数据到来时，init进程将用handle_property_set_fd()函数进行处理。 在linux新的内核中，epoll()用来替换select()，epoll()的最大好处是它不会随着监听fd数量的增加而降低效率。因为内核中select()的实现采用的是轮询处理，轮询的fd数量多了，耗时就多。 7.2 属性服务处理请求从上文得知，属性服务接收到客户端的请求时，会调用handle_property_set_fd函数进行处理：system/core/init/property_service.cpp 1234567891011121314151617181920212223242526272829static void handle_property_set_fd()&#123; ... if(memcmp(msg.name,\"ctl.\",4) == 0) &#123; close(s); if (check_control_mac_perms(msg.value, source_ctx, &amp;cr)) &#123; handle_control_message((char*) msg.name + 4, (char*) msg.value); &#125; else &#123; ERROR(\"sys_prop: Unable to %s service ctl [%s] uid:%d gid:%d pid:%d\\n\", msg.name + 4, msg.value, cr.uid, cr.gid, cr.pid); &#125; &#125; else &#123; // 检查客户端进程权限 if (check_mac_perms(msg.name, source_ctx, &amp;cr)) &#123;// 1 property_set((char*) msg.name, (char*) msg.value);// 2 &#125; else &#123; ERROR(\"sys_prop: permission denied uid:%d name:%s\\n\", cr.uid, msg.name); &#125; close(s); &#125; freecon(source_ctx); break; default: close(s); break; &#125;&#125; 注释1，用来检查客户端进程权限 注释2，调用property_set函数对属性进行修改，代码如下： 1234567int property_set(const char* name, const char* value) &#123; int rc = property_set_impl(name, value); if (rc == -1) &#123; ERROR(\"property_set(\\\"%s\\\", \\\"%s\\\") failed\\n\", name, value); &#125; return rc;&#125; property_set函数注意调用了property_set_impl()函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647static int property_set_impl(const char* name, const char* value) &#123; size_t namelen = strlen(name); size_t valuelen = strlen(value); if (!is_legal_property_name(name, namelen)) return -1; if (valuelen &gt;= PROP_VALUE_MAX) return -1; if (strcmp(\"selinux.reload_policy\", name) == 0 &amp;&amp; strcmp(\"1\", value) == 0) &#123; if (selinux_reload_policy() != 0) &#123; ERROR(\"Failed to reload policy\\n\"); &#125; &#125; else if (strcmp(\"selinux.restorecon_recursive\", name) == 0 &amp;&amp; valuelen &gt; 0) &#123; if (restorecon_recursive(value) != 0) &#123; ERROR(\"Failed to restorecon_recursive %s\\n\", value); &#125; &#125; // 从属性存储空间查找该属性 prop_info* pi = (prop_info*) __system_property_find(name); // 如果属性存在 if(pi != 0) &#123; // 如果属性以\"ro.\"开头，则表示是只读，不能修改，直接返回 if(!strncmp(name, \"ro.\", 3)) return -1; // 更新属性值 __system_property_update(pi, value, valuelen); &#125; else &#123; // 如果属性不存在则添加该属性 int rc = __system_property_add(name, namelen, value, valuelen); if (rc &lt; 0) &#123; return rc; &#125; &#125; /* If name starts with \"net.\" treat as a DNS property. */ if (strncmp(\"net.\", name, strlen(\"net.\")) == 0) &#123; if (strcmp(\"net.change\", name) == 0) &#123; return 0; &#125; // 以net.开头的属性名称更新后，需要将属性名称写入net.change中 property_set(\"net.change\", name); &#125; else if (persistent_properties_loaded &amp;&amp; strncmp(\"persist.\", name, strlen(\"persist.\")) == 0) &#123; /* * Don't write properties to disk until after we have read all default properties * to prevent them from being overwritten by default values. */ write_persistent_property(name, value); &#125; property_changed(name, value); return 0;&#125; property_set_impl函数主要用来对属性进行修改，并对ro、net和persist开头的属性进行相应的处理。 8. init进程总结init进程主要做了三件事： 创建一些文件夹并挂载设备 初始化和启动属性服务 解析init.rc配置文件并启动zygote进程 参考资料： 《深入理解Android系统》 《深入理解Android卷I》","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://tylerLiu.top/categories/Android进阶/"},{"name":"框架层","slug":"Android进阶/框架层","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/"},{"name":"系统启动","slug":"Android进阶/框架层/系统启动","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/系统启动/"}],"tags":[{"name":"Android系统启动","slug":"Android系统启动","permalink":"https://tylerLiu.top/tags/Android系统启动/"}]},{"title":"Android系统架构与系统源码目录","slug":"Android系统架构与系统源码目录","date":"2019-08-24T02:19:25.000Z","updated":"2019-09-11T08:03:54.433Z","comments":true,"path":"2019/08/24/Android系统架构与系统源码目录/","link":"","permalink":"https://tylerLiu.top/2019/08/24/Android系统架构与系统源码目录/","excerpt":"","text":"1. Android系统架构Android系统架构分成五层，从上到下依次为：应用层、应用框架层、系统运行层、硬件抽象层和Linux内核层。 1.1 应用层系统内置的应用程序以及非系统级的应用程序都属于应用层。负责与用户进行直接交互。该层主要由Java代码编写，现在已经扩充到Kotlin和Flutter。 1.2 应用框架层为开发者提供了可以开发应用程序所需的API，通常开发应用程序所调用的API都属于该层，也包括系统的应用。该层由Java编写，也称Java FragmeWork。该层的主要组件由： 名称 功能描述 Activity Manager 活动管理器 管理各个应用程序生命周期以及通常的导航回退功能 Location Manager 位置管理器 提供地理位置以及定位功能服务 Package Manager 包管理器 管理所有安装在Android系统中的应用程序 Notification Manager 通知管理器 使得应用程序可以在状态栏中显示自定义的提示信息 Resource Manager 资源管理器 提供应用程序使用的各种非代码资源，如本地化字符串、图片、布局文件、颜色文件等 Telephone Manager 电话管理器 管理所有的移动设备功能 Window Manager 窗口管理器 管理所有开启的窗口程序 Content Provider 内容提供器 使得不同的应用程序之间可以共享数据 View System 视图系统 构建应用程序的基本组件 1.3 系统运行层（Native）系统运行层分成两个部分：C/C++程序库、Android运行时库。 1.3.1 C/C++程序库C/C++程序库能被Android系统中的不同组件所使用，并通过应用程序框架为开发者提供服务，主要的C/C++程序库如下： 名称 功能描述 OpenGL ES 3D绘图函数库 Libc 从BSD继承来的标准C系统函数库，专门为基于嵌入式Linux的设备定制 Media Framework 多媒体库，支持多种常用的音频，视频格式录制和回放 SQLite 轻型的关系型数据库引擎 SGL 底层的2D图形渲染引擎 SSL 安全嵌套层，是为了网络通信提供安全及数据完整性的一种安全协议 FreeType 可移植的字体引擎，提供了统一的接口来访问多种字体格式文件 1.3.2 Android运行时库分为核心库和ART。核心库提供Java语言核心库的大多数功能，这样就能使用Java编写Android应用。相较于JVM，Dalvik虚拟机是专门为移动设备定制的，允许在有限的内存中同时运行多个虚拟机的实例，并且每个Dalvik应用作为一个独立的Linux进程执行。 独立的进程可以防止在虚拟机崩溃时所有程序都关闭。而替代Dalvik虚拟机的ART的机制与Dalvik不同。 在Dalvik中，应用每次运行的时候，字节码都需要通过即时编译器转换为机器码，这样运行效率很慢，而在ART环境下，应用在第一次安装的时候，字节码就会预编译成机器码，使其成为真正的本地应用。 1.4 硬件抽象层（HAL）HAL是位于操作系统内核与硬件电路之间的接口层，其目的在于将硬件抽象化，为了保护硬件厂商知识产权，它隐藏了特定平台的硬件接口细节，为操作系统提供虚拟的硬件平台，使其可以在多种平台上移植。 从软硬件测试的角度来看，软硬件的测试工作都可分别基于硬件抽象层来完成，使得软硬件测试工作的并行成为可能。通俗来讲，就是将控制硬件的工作放在硬件抽象层中。 1.5 Linux内核层Android的核心系统服务是基于Linux内核，在此基础上添加了部分Android专用的驱动。系统的安全性、内存管理、进程管理、网络协议栈和驱动模型等都依赖于该内核。 2. Android系统源码目录在线查看源码：http://androidxref.com/ 下载查看：源码的详细安装可以查看AOSP的内容 谷歌下载网站：https://source.android.google.cn/source/downloading 清华大学镜像：https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/ 2.1 整体结构各个版本的源码结构类似，编译后会多出一个out文件夹，用来存储编译产生的文件。以Android 7.0为例，根目录结构如下： Android源码根目录 描述 abi 应用程序二进制接口 art ART运行环境 bionic 系统C库 bootable 启动引导相关代码 build 存放系统编译规则以及generic等基础开发包设置 cts Android兼容性测试套件标准 dalvik Dalvik虚拟机 developers 开发者目录 development 应用程序开发相关 devices 设备相关配置 docs 参考文档目录 external 开源模组相关文件 frameworks 应用程序框架，Android系统核心部分，由Java和C++编写 hardware 主要是硬件抽象层的代码 libcore 核心库相关文件 libnativehelper 动态库，实现JNI库的基础 ndk NDK相关代码，帮助开发者在应用程序中嵌入C/C++代码 out 编译完成后的代码存放的文件夹 packages Plug Development Kit的缩写，本地开发套件 platform_testing 平台测试 prebuilts X86和ARM架构下预编译的一些资源 sdk SDK和模拟器 system 底层文件系统库、应用和组件 toolchain 工具链文件 tools 工具文件 Makefile 全局Makefile文件，用来定义编译规则 2.2 应用层部分：/packages文件夹应用层位于整个Android系统的最上层，开发的应用程序和系统内置的应用程序都在应用层。源码根目录中的packages目录对应着系统的应用层。 /packages目录 描述 apps 核心应用程序 experimental 第三方应用程序 inputmethods 输入法目录 providers 内容提供者目录 screensavers 屏幕保护 services 通信服务 wallpapers 壁纸 2.3 应用框架层部分：/frameworks文件夹应用框架层，一方面向上提供接口给应用层调用，另一方面向下与C/C++程序库以及硬件抽象层等进行衔接。应用框架层的代码主要在/frameworks/base和/framework/av目录下。 /frameworks/base目录 描述 /frameworks/base目录 描述 api 定义API cmds 重要命令：am、app_proce等 core 核心库 data 字体和声音等数据文件 docs 文档 graphics 图形图像相关 include 头文件 keystore 和数字签名证书相关 libs 库 location 地理位置相关库 media 多媒体相关库 native 本地库 nfc-extras NFC相关 obex 蓝牙传输 opengl 2D/3D图形API packages 设置、TTS、VPN程序 sax XML解析器 services 系统服务 telephone 电话通讯管理 test-runner 测试工具相关 tests 测试相关 tools 工具 wifi WIFI无限网络 2.4 系统运行层：C/C++程序库部分系统运行层（Native）中的C/C++程序库的类型繁多，功能强大，C/C++程序库不在一个目录中，这里列举几个常用和重要的C/C++程序库所在的目录。 目录位置 描述 bionic/ 谷歌开发的系统C库，以BSD许可形式开源 /frameworks/av/media 系统媒体库 /frameworks/native/opengl 第三方图形渲染库 /fframeorks/native/services/surfaceflinger 图形显示库，主要负责图形的渲染、叠加和绘制等功能 external/sqlite 轻量型关系数据库SQLite的C++实现 2.5 其他Android运行时库就在根目录下的art文件夹中。 硬件抽象层在根目录下的hardware文件夹中，该部分是手机厂商改动最大的部分，根据手机终端所采用的硬件平台不同，会有不同的实现。","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://tylerLiu.top/categories/Android进阶/"},{"name":"框架层","slug":"Android进阶/框架层","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/"},{"name":"系统启动","slug":"Android进阶/框架层/系统启动","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/系统启动/"}],"tags":[{"name":"Android系统启动","slug":"Android系统启动","permalink":"https://tylerLiu.top/tags/Android系统启动/"}]},{"title":"Android RxJava应用：联想搜索优化","slug":"Android-RxJava应用：联想搜索优化","date":"2019-08-23T08:07:12.000Z","updated":"2019-08-23T08:48:32.124Z","comments":true,"path":"2019/08/23/Android-RxJava应用：联想搜索优化/","link":"","permalink":"https://tylerLiu.top/2019/08/23/Android-RxJava应用：联想搜索优化/","excerpt":"","text":"1. 需求场景背景：每当用户输入一个字符，即显示与当前输入框内字符相关的搜索结果。 基本实现流程： 通过EditText.addTextChangedListener()监听输入框的变化 当输入框发生变化后，回调afterTextChanged()，将当前输入框内的文字向服务器发送请求 服务器返回与该搜索文字关联的结果 问题：当用户搜索需求明确的情况下（体现为连续输入），可能会发起不必要的请求。如 用户搜索需求明确为abc，即连续输入abc 按照上面的逻辑，客户端会向服务器发起a、ab、abc三次请求 多发起了a、ab两次不必要的请求 解决方案：通过根据时间过滤事件的过滤操作符debounce()实现。 2. 功能说明实现原理：通过根据指定时间过滤事件的过滤操作符debounce()实现，防止不必要的网络请求。 功能逻辑：当输入框发生变化时，不会立刻将当前输入框内的文字发送给服务器，而是等待一段时间，在这段时间内，如果输入框不再有文字输入（无变化），就发送输入框内的文字给服务器，如果有文字输入（有变化），则继续等待该段时间，循环该过程。 3. Demo布局文件： 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:gravity=\"center\" android:orientation=\"vertical\"&gt; &lt;EditText android:id=\"@+id/et\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:hint=\"输入搜索字段\" /&gt; &lt;TextView android:id=\"@+id/tv\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt;&lt;/LinearLayout&gt; 代码： 123456789101112131415161718192021222324252627282930313233public class FilterUsageActivity extends AppCompatActivity &#123; private static final String TAG = \"RxJava\"; @SuppressLint(\"CheckResult\") @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_filter_usage); EditText et = findViewById(R.id.et); final TextView tv = findViewById(R.id.tv); // 1. 这里使用RxBinding：RxTextView.textChanges(name)对对控件数据变更进行监听（功能类似TextWatcher） // 2. 传入EditText控件，输入字符时都会发送数据事件（此处不会马上发送，因为使用了debounce()） // 3. 采用skip(1)原因：跳过第1次请求，即初始输入框的空字符状态 RxTextView.textChanges(et) .debounce(1, TimeUnit.SECONDS).skip(1) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;CharSequence&gt;() &#123; @SuppressLint(\"SetTextI18n\") @Override public void accept(CharSequence charSequence) throws Exception &#123; tv.setText(\"发送给服务器的字符 = \" + charSequence.toString()); &#125; &#125;, new Consumer&lt;Throwable&gt;() &#123; @Override public void accept(Throwable throwable) throws Exception &#123; Log.d(TAG, \"对Error事件作出响应\"); &#125; &#125;); &#125;&#125; Demo地址：Allen_Demo_Rx","categories":[{"name":"Android","slug":"Android","permalink":"https://tylerLiu.top/categories/Android/"},{"name":"RxJava","slug":"Android/RxJava","permalink":"https://tylerLiu.top/categories/Android/RxJava/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"https://tylerLiu.top/tags/RxJava/"}]},{"title":"Android RxJava应用：功能防抖","slug":"Android-RxJava应用：功能防抖","date":"2019-08-23T07:33:33.000Z","updated":"2019-08-23T08:03:18.945Z","comments":true,"path":"2019/08/23/Android-RxJava应用：功能防抖/","link":"","permalink":"https://tylerLiu.top/2019/08/23/Android-RxJava应用：功能防抖/","excerpt":"","text":"1. 需求场景背景：用户只需要使用功能一次 问题：如果多次触发功能，就会导致出现冗余功能操作，如： 用户只需要使用网络请求功能一次（点击按钮） 但由于网络不好，点击一次后，用户发现没有响应 于是就多次点击按钮，就会导致发送多次网络请求 解决方法：功能防抖，通过根据指定时间过滤事件的过滤操作符实现，防止功能抖动 2. 功能说明功能防抖：即用户同规定时间内多次触发功能，仅会响应第一次的触发操作。 原理：使用根据指定时间过滤事件的过滤操作符实现，throttleFirst()操作符。 3. Demo12345678910111213141516171819202122232425262728293031323334public class AntiShakeActivity extends AppCompatActivity &#123; private static final String TAG = \"RxJava\"; @SuppressLint(\"CheckResult\") @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_anti_shake); Button button = findViewById(R.id.button); // 1. 此处采用了RxBinding：RxView.clicks(button)控件点击进行监听， // 需要引入依赖：implementation 'com.jakewharton.rxbinding2:rxbinding:2.0.0' // 2. 传入Button控件，点击时，都会发送数据事件， // 但由于使用了throttleFirst()操作符，所以只会发送该段时间内的第1次点击事件 RxView.clicks(button) // 2s内第1次点击按钮的事件才发送 .throttleFirst(2, TimeUnit.SECONDS) .subscribe(new Consumer&lt;Object&gt;() &#123; @Override public void accept(Object o) throws Exception &#123; Log.d(TAG, \"发送了网络请求\"); &#125; &#125;, new Consumer&lt;Throwable&gt;() &#123; @Override public void accept(Throwable throwable) throws Exception &#123; // 获取异常错误信息 Log.d(TAG, \"对Error事件作出响应\" + throwable.getMessage()); &#125; &#125;); &#125;&#125; Demo地址：Allen_Demo_Rx","categories":[{"name":"Android","slug":"Android","permalink":"https://tylerLiu.top/categories/Android/"},{"name":"RxJava","slug":"Android/RxJava","permalink":"https://tylerLiu.top/categories/Android/RxJava/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"https://tylerLiu.top/tags/RxJava/"}]},{"title":"Android RxJava应用：网络请求出错重连","slug":"Android-RxJava应用：网络请求出错重连","date":"2019-08-23T06:54:33.000Z","updated":"2019-08-23T07:32:15.851Z","comments":true,"path":"2019/08/23/Android-RxJava应用：网络请求出错重连/","link":"","permalink":"https://tylerLiu.top/2019/08/23/Android-RxJava应用：网络请求出错重连/","excerpt":"","text":"1. 需求场景背景：发送网络请求问题：发送网络请求过程中，出现错误时，导致该次网络请求不成功解决方案：当发生错误使得网络请求不成功时，自动重新发送网络请求，即差错自动重试机制 2. 功能说明功能描述：当发送错误时，使得网络请求不成功时，自动重新发送网络请求实现原理：采用RxJava中的retryWhen()操作符具体说明：根据错误类型判断实现需要重连，所有网络错误异常都属于IOException，其余异常都不在重试范围内。若要重试，设置退避策略，即，为请求重试设置一个合理的退避算法，而不是一出现错误马上就重试。合理的退避算法： 遇到错误时，等待一段时间后再重试 若遇到的异常次数越多，等待时间应该越长 即，设置等待时间，会随着错误异常次数增多而可变 限制可重试次数，避免无限重试 即，设置重试次数 3. Demo采用GET方法对金山词霸API进行网络请求： 通过判断网络连接模拟网络异常错误（即回复网络即可发送请求） 限制重试次数为10次 采用Gson进行数据解析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102public class RxJavafixRxjavaActivity3 extends AppCompatActivity &#123; private static final String TAG = \"RxJava\"; /** * 可重试次数 */ private int mMaxConnectCount = 10; /** * 当前已重试次数 */ private int mCurrentRetryCount = 0; /** * 重试等待时间 */ private int mWaitRetryTime = 0; @SuppressLint(\"CheckResult\") @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_rx_javafix_rxjava3); Retrofit retrofit = new Retrofit.Builder() .baseUrl(\"http://fy.iciba.com/\") .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .build(); GetRequest_Interface request = retrofit.create(GetRequest_Interface.class); Observable&lt;Translation&gt; observable = request.getCall(); // 主要异常才会回调retryWhen()进行重试 observable.retryWhen(new Function&lt;Observable&lt;Throwable&gt;, ObservableSource&lt;?&gt;&gt;() &#123; @Override public ObservableSource&lt;?&gt; apply(Observable&lt;Throwable&gt; throwableObservable) throws Exception &#123; // Observable&lt;Throwable&gt;中的泛型为上游操作符抛出的异常，可以通过该条件判断异常的类型 return throwableObservable.flatMap(new Function&lt;Throwable, ObservableSource&lt;?&gt;&gt;() &#123; @Override public ObservableSource&lt;?&gt; apply(Throwable throwable) throws Exception &#123; // 输出异常信息 Log.d(TAG, \"发生异常 = \" + throwable.toString()); // 需求1：根据异常类型选择是否重试 if (throwable instanceof IOException) &#123; Log.d(TAG, \"属于IOException，需重试\"); // 需求2：设置重试次数 if (mCurrentRetryCount &lt; mMaxConnectCount) &#123; // 记录重试次数 mCurrentRetryCount++; Log.d(TAG, \"重试次数 = \" + mCurrentRetryCount); // 需求2：实现重试 // 通过返回的Observable发送的事件，即Next事件，使得retryWhen()重新订阅，实现重试功能 // 需求3：延迟重试 // 使用delay()操作符 // 需求4：遇到的异常次数越多，时间越长 // 设置delay()操作符的等待时间，每重试一次，增加延迟重试时间1s // 设置等待时间 mWaitRetryTime = 1000 + mCurrentRetryCount * 1000; Log.d(TAG, \"等待时间 =\" + mWaitRetryTime); return Observable.just(1).delay(mWaitRetryTime, TimeUnit.MILLISECONDS); &#125; else &#123; // 若重试次数已 ＞ 设置重试次数，则不重试 // 通过发送error来停止重试（可在观察者的onError()中获取信息） return Observable.error(new Throwable(\"重试次数已超过设置次数 = \" + mCurrentRetryCount + \"，即，不再重试\")); &#125; &#125; // 若发生的异常不属于I/O异常，则不重试 // 通过返回的Observable发送的Error事件，实现（可在观察者的onError()中获取信息） else &#123; return Observable.error(new Throwable(\"发生了非网络异常（非I/O异常）\")); &#125; &#125; &#125;); &#125; &#125;).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;Translation&gt;() &#123; @Override public void accept(Translation translation) throws Exception &#123; // 接收服务器返回的数据 Log.d(TAG, \"发送成功\"); translation.show(); &#125; &#125;, new Consumer&lt;Throwable&gt;() &#123; @Override public void accept(Throwable throwable) throws Exception &#123; // 获取停止重试的信息 Log.d(TAG, throwable.getMessage()); &#125; &#125;); &#125;&#125; 123456789101112131415161718D/RxJava: 发生异常 = java.net.UnknownHostException: Unable to resolve host &quot;fy.iciba.com&quot;: No address associated with hostnameD/RxJava: 属于IOException，需重试D/RxJava: 重试次数 = 1D/RxJava: 等待时间 =2000D/RxJava: 发生异常 = java.net.UnknownHostException: Unable to resolve host &quot;fy.iciba.com&quot;: No address associated with hostnameD/RxJava: 属于IOException，需重试D/RxJava: 重试次数 = 2D/RxJava: 等待时间 =3000D/RxJava: 发生异常 = java.net.UnknownHostException: Unable to resolve host &quot;fy.iciba.com&quot;: No address associated with hostnameD/RxJava: 属于IOException，需重试D/RxJava: 重试次数 = 3D/RxJava: 等待时间 =4000D/RxJava: 发生异常 = java.net.UnknownHostException: Unable to resolve host &quot;fy.iciba.com&quot;: No address associated with hostnameD/RxJava: 属于IOException，需重试D/RxJava: 重试次数 = 4D/RxJava: 等待时间 =5000D/RxJava: 发送成功D/RxJava: 嗨世界 Demo地址：Allen_Demo_Rx","categories":[{"name":"Android","slug":"Android","permalink":"https://tylerLiu.top/categories/Android/"},{"name":"RxJava","slug":"Android/RxJava","permalink":"https://tylerLiu.top/categories/Android/RxJava/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"https://tylerLiu.top/tags/RxJava/"}]},{"title":"Android RxJava应用：网络请求轮询（有条件）","slug":"Android-RxJava应用：网络请求轮询（有条件）","date":"2019-08-23T05:01:55.000Z","updated":"2019-08-23T06:52:39.912Z","comments":true,"path":"2019/08/23/Android-RxJava应用：网络请求轮询（有条件）/","link":"","permalink":"https://tylerLiu.top/2019/08/23/Android-RxJava应用：网络请求轮询（有条件）/","excerpt":"","text":"1. 需求场景背景：实现轮询，也称pull。客户端隔固定时间主动向服务器发送请求获取信息，可根据服务器返回信息停止轮询，即，有条件轮询。解决方案：使用RxJava的repeatWhen()操作符 2. 功能说明采用GET，对金山词霸API按规定时间重复发送网络请求，模拟轮询。 停止轮询的条件：当轮询到第四次时 采用Gson解析数据 3. 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class RxJavafixRxjavaActivity2 extends AppCompatActivity &#123; private static final String TAG = \"RxJava\"; /** * 模拟轮询服务器次数 */ private int i = 0; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_rx_javafix_rxjava2); Retrofit retrofit = new Retrofit.Builder() .baseUrl(\"http://fy.iciba.com/\") .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .build(); GetRequest_Interface request = retrofit.create(GetRequest_Interface.class); Observable&lt;Translation&gt; observable = request.getCall(); observable.repeatWhen(new Function&lt;Observable&lt;Object&gt;, ObservableSource&lt;?&gt;&gt;() &#123; // 在Function函数中，必须对输入的 Observable&lt;Object&gt;进行处理，此处使用flatMap()操作符接收上游的数据 @Override public ObservableSource&lt;?&gt; apply(Observable&lt;Object&gt; objectObservable) throws Exception &#123; // 将原始Observable停止发送事件的标识（Complete()/Error()）转换成一个Object类型数据传递给一个新的Observable， // 以此决定是否重新订阅并发送原来的Observable，即轮询 // 此处由两种情况： // 1. 若返回一个Complete()/Error()事件，则不重新订阅并发送原来的Observable，即轮询结束 // 2. 若返回其余事件，则重新订阅并发送原来的Observable，即继续轮询 return objectObservable.flatMap(new Function&lt;Object, ObservableSource&lt;?&gt;&gt;() &#123; @Override public ObservableSource&lt;?&gt; apply(Object o) throws Exception &#123; // 加入判断条件，当轮询次数为5次时，停止轮询 if (i &gt; 3) &#123; // 此处选择发送onError()事件以结束轮询，因为可触发下游观察者的onError()方法回调 return Observable.error(new Throwable(\"轮询结束\")); &#125; // 若轮询次数 ＜ 4，发送一个Next事件继续轮询 return Observable.just(1).delay(2, TimeUnit.SECONDS); &#125; &#125;); &#125; &#125;).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;Translation&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Translation translation) &#123; // e.接收服务器返回的数据 translation.show(); i++; &#125; @Override public void onError(Throwable e) &#123; // 获取轮询结束信息 Log.d(TAG, e.toString()); &#125; @Override public void onComplete() &#123; &#125; &#125;); &#125;&#125; 12345614:46:35.250 3950-3950/com.ly.allendemorx D/RxJava: 嗨世界14:46:37.240 3950-3950/com.ly.allendemorx D/RxJava: 嗨世界14:46:39.554 3950-3950/com.ly.allendemorx D/RxJava: 嗨世界14:46:42.787 3950-3950/com.ly.allendemorx D/RxJava: 嗨世界14:46:44.929 3950-3950/com.ly.allendemorx D/RxJava: 嗨世界14:46:44.971 3950-3950/com.ly.allendemorx D/RxJava: java.lang.Throwable: 轮询结束 Demo地址：Allen_Demo_Rx","categories":[{"name":"Android","slug":"Android","permalink":"https://tylerLiu.top/categories/Android/"},{"name":"RxJava","slug":"Android/RxJava","permalink":"https://tylerLiu.top/categories/Android/RxJava/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"https://tylerLiu.top/tags/RxJava/"}]},{"title":"Android RxJava应用：联合判断多个事件","slug":"Android-RxJava应用：联合判断多个事件","date":"2019-08-22T08:46:29.000Z","updated":"2019-08-22T09:22:59.912Z","comments":true,"path":"2019/08/22/Android-RxJava应用：联合判断多个事件/","link":"","permalink":"https://tylerLiu.top/2019/08/22/Android-RxJava应用：联合判断多个事件/","excerpt":"","text":"1. 需求场景同时对多个事件进行联合判断。如，填写表单时，需要表里的所有信息（姓名、年龄、职业等）都被填写后，才能点击提交按钮。 2. 功能说明此处采用 填写表单 作为联合判断功能展示，即，表单里所有信息（姓名、年龄、职业等）都被填写后，才允许点击 “提交” 按钮。 3. 实现采用combineLatest()操作符。 12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;EditText android:id=\"@+id/name\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:hint=\"请填写姓名\" /&gt; &lt;EditText android:id=\"@+id/age\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:hint=\"请填写年龄\" /&gt; &lt;EditText android:id=\"@+id/job\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:hint=\"请填写职业\" /&gt; &lt;Button android:id=\"@+id/list\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:enabled=\"false\" android:text=\"提交\" /&gt;&lt;/LinearLayout&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class CombineJudgeActivity extends AppCompatActivity &#123; private EditText mName, mAge, mJob; private Button mButton; @SuppressLint(\"CheckResult\") @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_combine_judge); mName = findViewById(R.id.name); mAge = findViewById(R.id.age); mJob = findViewById(R.id.job); mButton = findViewById(R.id.list); // 为每个EditText设置被观察者，用于发送监听事件 // 说明： // 1. 这里使用RxBinding的RxTextView.textChanges(name)是对对控件数据变更进行监听 // （功能类似TextWatcher），需要引入依赖：implementation 'com.jakewharton.rxbinding2:rxbinding:2.0.0' // 2. 传入EditText控件，点击任一个EditText撰写时，都会发送数据事件 = Function3（）的返回值（下面会详细说明） // 3. 采用skip(1)原因：跳过 一开始EditText无任何输入时的空值 Observable&lt;CharSequence&gt; nameObservable = RxTextView.textChanges(mName).skip(1); Observable&lt;CharSequence&gt; ageObservable = RxTextView.textChanges(mAge).skip(1); Observable&lt;CharSequence&gt; jobObservable = RxTextView.textChanges(mJob).skip(1); // 通过combineLatest()合并事件并联合判断 Observable.combineLatest(nameObservable, ageObservable, jobObservable, new Function3&lt;CharSequence, CharSequence, CharSequence, Boolean&gt;() &#123; @Override public Boolean apply(CharSequence charSequence, CharSequence charSequence2, CharSequence charSequence3) throws Exception &#123; // 规定表单输入信息不能为空 boolean isNameEmpty = !TextUtils.isEmpty(mName.getText()); boolean isAgeEmpty = !TextUtils.isEmpty(mAge.getText()); boolean isJobEmpty = !TextUtils.isEmpty(mJob.getText()); return isNameEmpty &amp;&amp; isAgeEmpty &amp;&amp; isJobEmpty; &#125; &#125;).subscribe(new Consumer&lt;Boolean&gt;() &#123; @Override public void accept(Boolean aBoolean) throws Exception &#123; // 返回结果 &amp; 设置按钮可点击样式 mButton.setEnabled(aBoolean); &#125; &#125;); &#125;&#125; Demo地址：Allen_Demo_Rx","categories":[{"name":"Android","slug":"Android","permalink":"https://tylerLiu.top/categories/Android/"},{"name":"RxJava","slug":"Android/RxJava","permalink":"https://tylerLiu.top/categories/Android/RxJava/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"https://tylerLiu.top/tags/RxJava/"}]},{"title":"Android RxJava应用：从磁盘/内存缓存中获取数据","slug":"Android-RxJava应用：从磁盘-内存缓存中获取数据","date":"2019-08-22T08:13:41.000Z","updated":"2019-08-22T08:44:49.142Z","comments":true,"path":"2019/08/22/Android-RxJava应用：从磁盘-内存缓存中获取数据/","link":"","permalink":"https://tylerLiu.top/2019/08/22/Android-RxJava应用：从磁盘-内存缓存中获取数据/","excerpt":"","text":"1. 需求场景背景：从服务器获取数据问题：每次获取数据都通过网络请求向服务器获取会浪费很多资源，包括流量和时间解决方案：从缓存中读取数据，即，当需要获取数据时，先从本地的磁盘/内存缓存中获取所需数据，如果缓存中没有数据，再通过网络请求向服务器获取数据实现原理：组合操作符concat()和过滤操作符firstElement() 2. 功能说明 3. 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class CacheDemoActivity extends AppCompatActivity &#123; private static final String TAG = \"RxJava\"; /** * 模拟内存缓存和磁盘缓存 */ String memoryCache = null; String diskCache = \"从磁盘缓存中获取的数据\"; @SuppressLint(\"CheckResult\") @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_cache_demo); // 设置第一个Observable，检查内存缓存是否由该数据的缓存 Observable&lt;String&gt; memory = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123; // 判断内存缓存有无数据 if (memoryCache != null) &#123; // 若有该数据，则发送 emitter.onNext(memoryCache); &#125; else &#123; // 若没有，直接发送结束事件 emitter.onComplete(); &#125; &#125; &#125;); // 设置第二个Observable，检查磁盘缓存是否由该数据的缓存 Observable&lt;String&gt; disk = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123; // 判断磁盘缓存有无数据 if (diskCache != null) &#123; // 若有该数据，则发送 emitter.onNext(diskCache); &#125; else &#123; // 若没有，直接发送结束事件 emitter.onComplete(); &#125; &#125; &#125;); // 设置第三个Observable：通过网络获取数据 Observable&lt;String&gt; network = Observable.just(\"从网络获取数据\"); // 使用concat()和firstElement()实现缓存功能 // 1. 通过concat()合并三个被观察者的事件，并将它们按顺序串成队列 Observable.concat(memory, disk, network) // 通过firstElement()，从队列中取出并发送第一个有效事件，即依次判断检查三个Observable // 即本例的逻辑为： // a. firstElement()取出第一个事件memory，即先判断内存缓存中有无数据缓存； // 由于memoryCache = null，即内存缓存中无数据，所以发送结束事件（视为无效事件） // b. firstElement()继续取出第二个事件disk，即判断磁盘缓存中有无数据缓存： // 由于diskCache ≠ null，即磁盘缓存中有数据，所以发送Next事件（有效事件） // c. 即firstElement()已发出第一个有效事件（disk事件），所以停止判断。 .firstElement() // 3. 订阅 .subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; Log.d(TAG, \"最终获取的数据来源 = \" + s); &#125; &#125;); &#125;&#125; 1D/RxJava: 最终获取的数据来源 = 从磁盘缓存中获取的数据","categories":[{"name":"Android","slug":"Android","permalink":"https://tylerLiu.top/categories/Android/"},{"name":"RxJava","slug":"Android/RxJava","permalink":"https://tylerLiu.top/categories/Android/RxJava/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"https://tylerLiu.top/tags/RxJava/"}]},{"title":"Android RxJava应用：合并数据源并展示","slug":"Android-RxJava应用：合并数据源并展示","date":"2019-08-22T07:47:34.000Z","updated":"2019-08-22T08:12:03.604Z","comments":true,"path":"2019/08/22/Android-RxJava应用：合并数据源并展示/","link":"","permalink":"https://tylerLiu.top/2019/08/22/Android-RxJava应用：合并数据源并展示/","excerpt":"","text":"1. 需求场景背景：获取数据并统一展示到客户端冲突：数据来源不同，网络和本地，即，数据源多样解决方案：采用RxJava操作符，这里使用merge()和zip()演示。 2. 功能说明获取数据并统一展示到客户端 3. 实现 merge()：实现从（网络和本地）获取数据并统一展示 zip()：结合Retrofit和RxJava，实现合并两个网络请求，向两个服务器获取数据并统一展示。 3.1 merge()1234567891011121314151617181920212223242526272829303132333435363738394041424344public class MergeDemoActivity extends AppCompatActivity &#123; private static final String TAG = \"RxJava\"; /** * 用于存放最终展示的数据 */ String result = \"数据源来自 = \"; Observable&lt;String&gt; network = Observable.just(\"网络\"); Observable&lt;String&gt; file = Observable.just(\"本地文件\"); @SuppressLint(\"CheckResult\") @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_merge_demo); Observable.merge(network, file) .subscribe(new Observer&lt;String&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(String value) &#123; Log.d(TAG, \"数据源有： \" + value); result += value + \"+\"; &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, \"对Error事件作出响应\"); &#125; // 接收合并事件后，统一展示 @Override public void onComplete() &#123; Log.d(TAG, \"获取数据完成\"); Log.d(TAG, result); &#125; &#125;); &#125;&#125; 1234D/RxJava: 数据源有： 网络D/RxJava: 数据源有： 本地文件D/RxJava: 获取数据完成D/RxJava: 数据源来自 = 网络+本地文件+ 3.2 zip() 从不同数据源（两个服务器）获取数据，并合并 统一显示结果 两个接收服务器数据的类： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Translation1 &#123; private int status; private ContentBean content; private static class ContentBean &#123; private String from; private String to; private String vendor; private String out; private String ciba_use; private String ciba_out; private int err_no; &#125; /** * 定义输出返回数据的方法 */ public String show() &#123; return (\"第1次翻译=\" + content.out); &#125;&#125;public class Translation2 &#123; private int status; private ContentBean content; private static class ContentBean &#123; private String from; private String to; private String vendor; private String out; private String ciba_use; private String ciba_out; private int err_no; &#125; /** * 定义输出返回数据的方法 */ public String show() &#123; return (\"第2翻译=\" + content.out); &#125;&#125; 在Activity中的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class ZipDemoActivity extends AppCompatActivity &#123; private static final String TAG = \"Rxjava\"; /** * 定义Observable接口类型的网络请求对象 */ Observable&lt;Translation1&gt; mObservable1; Observable&lt;Translation2&gt; mObservable2; @SuppressLint(\"CheckResult\") @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_zip_demo); // 步骤1：创建Retrofit对象 Retrofit retrofit = new Retrofit.Builder() .baseUrl(\"http://fy.iciba.com/\") .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .build(); // 步骤2：创建网络请求接口的实例 GetRequest_Interface request = retrofit.create(GetRequest_Interface.class); // 步骤3：对两个网络请求进行封装 mObservable1 = request.getCall_1().subscribeOn(Schedulers.io()); mObservable2 = request.getCall_2().subscribeOn(Schedulers.io()); // 步骤4：通过使用zip()对两个网络请求进行合并再发送 Observable.zip(mObservable1, mObservable2, new BiFunction&lt;Translation1, Translation2, String&gt;() &#123; @Override public String apply(Translation1 translation1, Translation2 translation2) throws Exception &#123; return translation1.show() + \" &amp; \" + translation2.show(); &#125; &#125;).observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; // 结合显示2个网络请求的数据结果 Log.d(TAG, \"最终接收到的数据是：\" + s); &#125; &#125;, new Consumer&lt;Throwable&gt;() &#123; @Override public void accept(Throwable throwable) throws Exception &#123; Log.d(TAG, \"登录失败\"); &#125; &#125;); &#125;&#125; 1D/Rxjava: 最终接收到的数据是：第1次翻译=HI寄存器 &amp; 第2翻译=嗨登录","categories":[{"name":"Android","slug":"Android","permalink":"https://tylerLiu.top/categories/Android/"},{"name":"RxJava","slug":"Android/RxJava","permalink":"https://tylerLiu.top/categories/Android/RxJava/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"https://tylerLiu.top/tags/RxJava/"}]},{"title":"Android RxJava应用：网络请求嵌套回调","slug":"Android-RxJava应用：网络请求嵌套回调","date":"2019-08-22T05:46:45.000Z","updated":"2019-08-22T07:38:19.517Z","comments":true,"path":"2019/08/22/Android-RxJava应用：网络请求嵌套回调/","link":"","permalink":"https://tylerLiu.top/2019/08/22/Android-RxJava应用：网络请求嵌套回调/","excerpt":"","text":"1. 需求场景1.1 背景需要进行嵌套网络请求，即，在第一个网络请求成功后，再继续进行一次网络请求。 如先进行注册的网路请求，等注册成功后，再进行登录的网路请求。 1.2 冲突嵌套实现网路请求较为复杂。 123456789101112131415161718192021222324252627282930313233343536373839// 发送注册网络请求的函数方法private void register() &#123; api.register(new RegisterRequest()) // 在IO线程进行网络请求 .subscribeOn(Schedulers.io()) // 回到主线程去处理请求结果 .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;RegisterResponse&gt;() &#123; @Override public void accept(RegisterResponse registerResponse) throws Exception &#123; Toast.makeText(MainActivity.this, \"注册成功\", Toast.LENGTH_SHORT).show(); // 注册成功, 调用登录的方法 login(); &#125; &#125;, new Consumer&lt;Throwable&gt;() &#123; @Override public void accept(Throwable throwable) throws Exception &#123; Toast.makeText(MainActivity.this, \"注册失败\", Toast.LENGTH_SHORT).show(); &#125; &#125;);&#125;// 发送登录网络请求的函数方法private void login() &#123; api.login(new LoginRequest()) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;LoginResponse&gt;() &#123; @Override public void accept(LoginResponse loginResponse) throws Exception &#123; Toast.makeText(MainActivity.this, \"登录成功\", Toast.LENGTH_SHORT).show(); &#125; &#125;, new Consumer&lt;Throwable&gt;() &#123; @Override public void accept(Throwable throwable) throws Exception &#123; Toast.makeText(MainActivity.this, \"登录失败\", Toast.LENGTH_SHORT).show(); &#125; &#125;);&#125; 1.3 解决方案结合RxJava中的变换操作符flatMap()实现嵌套网路请求。Android RxJava：变换操作符 2. 功能说明实现功能：发送嵌套网络请求（将英文翻译成中文，翻译两次）Demo：先翻译注册，再翻译登录。 3. 具体实现步骤和前面的相同，这里列出不同的部分。 为了演示两个网络请求，这里设置两个接收服务器的数据类： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Translation1 &#123; private int status; private ContentBean content; private static class ContentBean &#123; private String from; private String to; private String vendor; private String out; private String ciba_use; private String ciba_out; private int err_no; &#125; /** * 定义输出返回数据的方法 */ public void show() &#123; Log.d(\"RxJava\", \"翻译内容 = \" + content.out); &#125;&#125;public class Translation2 &#123; private int status; private ContentBean content; private static class ContentBean &#123; private String from; private String to; private String vendor; private String out; private String ciba_use; private String ciba_out; private int err_no; &#125; /** * 定义输出返回数据的方法 */ public void show() &#123; Log.d(\"RxJava\", \"翻译内容 = \" + content.out); &#125;&#125; 创建用于描述网络请求的接口 12345678910111213public interface GetRequest_Interface &#123; /** * 网络请求1 */ @GET(\"ajax.php?a=fy&amp;f=auto&amp;t=auto&amp;w=hi%20register\") Observable&lt;Translation1&gt; getCall_1(); /** * 网络请求2 */ @GET(\"ajax.php?a=fy&amp;f=auto&amp;t=auto&amp;w=hi%20login\") Observable&lt;Translation2&gt; getCall_2();&#125; 在Activity中的实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package com.ly.allendemorx;import android.annotation.SuppressLint;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;import com.jakewharton.retrofit2.adapter.rxjava2.RxJava2CallAdapterFactory;import io.reactivex.Observable;import io.reactivex.ObservableSource;import io.reactivex.android.schedulers.AndroidSchedulers;import io.reactivex.functions.Consumer;import io.reactivex.functions.Function;import io.reactivex.schedulers.Schedulers;import retrofit2.Retrofit;import retrofit2.converter.gson.GsonConverterFactory;/** * RxJava实现嵌套网络请求 * * @author Liuyang * @date 2019/8/22 */public class Main8Activity extends AppCompatActivity &#123; private static final String TAG = \"Rxjava\"; /** * 定义Observable接口类型的网络请求对象 */ Observable&lt;Translation1&gt; mObservable1; Observable&lt;Translation2&gt; mObservable2; @SuppressLint(\"CheckResult\") @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main8); // 步骤1：创建Retrofit对象 Retrofit retrofit = new Retrofit.Builder() .baseUrl(\"http://fy.iciba.com/\") .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .build(); // 步骤2：创建网络请求接口实例 GetRequest_Interface request = retrofit.create(GetRequest_Interface.class); // 步骤3：对两个网络请求进行封装 mObservable1 = request.getCall_1(); mObservable2 = request.getCall_2(); mObservable1 // 在IO线程进行第一次网络请求 .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .doOnNext(new Consumer&lt;Translation1&gt;() &#123; @Override public void accept(Translation1 translation1) throws Exception &#123; Log.d(TAG, \"第1次网络请求成功\"); translation1.show(); &#125; &#125;) // 切换到IO线程进行第二次网络请求 // 因为flatMap()是对初始被观察者作变换，所以对于旧的被观察者，它是新的观察者， // 所以使用observeOn()进行线程切换，但是对于初始观察者，它就是新的被观察者。 .observeOn(Schedulers.io()) .flatMap(new Function&lt;Translation1, ObservableSource&lt;Translation2&gt;&gt;() &#123; @Override public ObservableSource&lt;Translation2&gt; apply(Translation1 translation1) throws Exception &#123; // 将网络请求1转换成网络请求2，即发送网络请求2 return mObservable2; &#125; &#125;) // 初始观察者切换到主线程，处理网络请求2的结果 .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;Translation2&gt;() &#123; @Override public void accept(Translation2 translation2) throws Exception &#123; Log.d(TAG, \"第2次网络请求成功\"); translation2.show(); &#125; &#125;, new Consumer&lt;Throwable&gt;() &#123; @Override public void accept(Throwable throwable) throws Exception &#123; Log.d(TAG, \"登录失败\"); &#125; &#125;); &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"https://tylerLiu.top/categories/Android/"},{"name":"RxJava","slug":"Android/RxJava","permalink":"https://tylerLiu.top/categories/Android/RxJava/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"https://tylerLiu.top/tags/RxJava/"}]},{"title":"Android RxJava应用：网络请求轮询（无条件）","slug":"Android-RxJava应用：网络轮询请求","date":"2019-08-22T03:17:01.000Z","updated":"2019-08-23T05:03:32.464Z","comments":true,"path":"2019/08/22/Android-RxJava应用：网络轮询请求/","link":"","permalink":"https://tylerLiu.top/2019/08/22/Android-RxJava应用：网络轮询请求/","excerpt":"","text":"1. 需求场景 背景：实现轮询请求，即，客户端固定时间主动向服务器发送请求，获取信息，也称pull。 冲突：通过Handler和Timer定时器 的实现方式较为复杂，可扩展性差。 解决方案：采用RxJava的延时创建操作符 interval()：无限次轮询 intervalRange()：有限次轮询 2. 功能说明采用GET方法对金山词霸API按规定时间重复发送网络请求，模拟轮询需求。采用Gson进行数据解析。 3. 具体实现3.1 步骤说明 添加依赖 创建接收服务器返回的数据的类 创建用于描述网络请求的接口 创建Retrofit实例 创建网络请求接口实例，配置网络请求参数 发送网络请求 对返回的数据进行处理 前面的步骤在Android RxJava：线程控制中已经讲解，这里主要分析轮询部分的实现。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * RxJava实现轮询 * * @author Liuyang * @date 2019/8/22 */public class RxJavafixRxjavaActivity extends AppCompatActivity &#123; private static final String TAG = \"Rxjava\"; @SuppressLint(\"CheckResult\") @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_rx_javafix_rxjava); // 步骤1：采用interval()延迟发送 // 注：此处主要展示无限轮询，要实现有限轮询，使用intervalRange()即可 Observable.interval(2, 1, TimeUnit.SECONDS) // 步骤2：每次发送数字前发送一次网络请求（doOnNext()在执行Next事件前调用） // 即每隔1秒产生一个数字前，就发送一次网络请求，实现轮询 .doOnNext(new Consumer&lt;Long&gt;() &#123; @Override public void accept(Long aLong) throws Exception &#123; Log.d(TAG, \"第 \" + aLong + \" 次轮询\"); // 步骤3：通过Retrofit实现网络请求 Retrofit retrofit = new Retrofit.Builder() .baseUrl(\"http://fy.iciba.com/\") .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .build(); GetRequest_Interface request = retrofit.create(GetRequest_Interface.class); Observable&lt;Translation&gt; observable = request.getCall(); observable.subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;Translation&gt;() &#123; @Override public void accept(Translation translation) throws Exception &#123; if (translation != null) &#123; Log.d(TAG, \"结果 from：\" + translation.getContent().getFrom()); Log.d(TAG, \"结果 to：\" + translation.getContent().getTo()); Log.d(TAG, \"结果 vendor：\" + translation.getContent().getVendor()); Log.d(TAG, \"结果 out：\" + translation.getContent().getOut()); Log.d(TAG, \"结果 ciba_use：\" + translation.getContent().getCiba_use()); Log.d(TAG, \"结果 ciba_out：\" + translation.getContent().getCiba_out()); Log.d(TAG, \"结果 err_no：\" + translation.getContent().getErr_no()); &#125; &#125; &#125;); &#125; &#125;).subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(Long aLong) throws Exception &#123; Log.d(TAG, \"接收到的事件：\" + aLong); &#125; &#125;, new Consumer&lt;Throwable&gt;() &#123; @Override public void accept(Throwable throwable) throws Exception &#123; Log.d(TAG, \"对Error事件作出响应\"); &#125; &#125;); &#125;&#125; 1234567891011121314151617181920212223242526272829D/Rxjava: 第 0 次轮询D/Rxjava: 接收到的事件：0D/Rxjava: 第 1 次轮询D/Rxjava: 接收到的事件：1D/Rxjava: 第 2 次轮询D/Rxjava: 接收到的事件：2D/Rxjava: 结果 from：en-EUD/Rxjava: 结果 to：zh-CND/Rxjava: 结果 vendor：tencentD/Rxjava: 结果 out：嗨世界D/Rxjava: 结果 ciba_use：来自机器翻译。D/Rxjava: 结果 ciba_out：D/Rxjava: 结果 err_no：0D/Rxjava: 第 3 次轮询D/Rxjava: 接收到的事件：3D/Rxjava: 结果 from：en-EUD/Rxjava: 结果 to：zh-CND/Rxjava: 结果 vendor：tencentD/Rxjava: 结果 out：嗨世界D/Rxjava: 结果 ciba_use：来自机器翻译。D/Rxjava: 结果 ciba_out：D/Rxjava: 结果 err_no：0D/Rxjava: 结果 from：en-EUD/Rxjava: 结果 to：zh-CND/Rxjava: 结果 vendor：tencentD/Rxjava: 结果 out：嗨世界D/Rxjava: 结果 ciba_use：来自机器翻译。D/Rxjava: 结果 ciba_out：D/Rxjava: 结果 err_no：0","categories":[{"name":"Android","slug":"Android","permalink":"https://tylerLiu.top/categories/Android/"},{"name":"RxJava","slug":"Android/RxJava","permalink":"https://tylerLiu.top/categories/Android/RxJava/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"https://tylerLiu.top/tags/RxJava/"}]},{"title":"Android RxJava：背压策略","slug":"Android-RxJava：背压策略","date":"2019-08-20T02:43:13.000Z","updated":"2019-08-22T03:14:05.339Z","comments":true,"path":"2019/08/20/Android-RxJava：背压策略/","link":"","permalink":"https://tylerLiu.top/2019/08/20/Android-RxJava：背压策略/","excerpt":"","text":"1. 引言1.1 背景观察者和被观察者之间存在两种订阅关系：同步、异步。 同步订阅： 观察者和被观察者工作在同一个线程 被观察者每发送一个事件，必须等到观察者接收且处理后，才能继续发送下一个事件。 异步订阅 观察者和被观察者工作不在同一线程 被观察者不需要等待观察者接收和处理后才能继续发送下一个事件，而是不断发送，直到发送事件完毕 此时的事件并不会直接发送到观察者处，而是先发送到缓存区，等观察者从缓存区取出事件来处理 对于异步订阅关系，存在被观察者发送事件的速度与观察者接收事件的速度不匹配的情况： 发送和接收事件速度就是单位时间内发送和接收事件的数量 大部分情况是，被观察者发送事件速度 &gt; 观察者接收事件速度 1.2 问题被观察者发送事件速度太快，观察者来不及接收所有事件，导致观察者无法及时响应/处理所有发送过来的事件，最终导致缓存区溢出、事件丢失或OOM问题。 点击按钮事件：连续快速点击按钮，则只会造成点击两次的效果。 原因：因为点击速度太快，按钮来不及响应。 例子：被观察者发送事件速度为10ms/个，观察者接收事件速度为5s/个，即发送和接收速度严重不匹配。 123456789101112131415161718192021222324252627Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; for (int i = 0; ; i++) &#123; Log.d(TAG, \"发送了事件\" + i); Thread.sleep(10); // 发送事件速度：10ms / 个 emitter.onNext(i); &#125; &#125;&#125;) // 设置被观察者在IO线程中进行 .subscribeOn(Schedulers.io()) // 设置观察者在主线程中进行 .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; try &#123; // 接收事件速度：5s / 个 Thread.sleep(5000); Log.d(TAG, \"接收到了事件\" + integer); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); 1.3 解决方案背压策略。 2. 背压策略简介2.1 定义一种控制事件流速的策略。 2.2 作用在异步订阅关系中，控制事件发送和接收的速度。 2.3 解决的问题解决因为被观察者发送事件速度和观察者接收事件速度不匹配，导致的观察者无法及时响应/处理所有被观察者发送事件的问题。 2.4 应用场景被观察者发送事件速度与观察者接收事件速度不匹配的场景。具体场景取决于该事件的类型，如：网络请求，具体场景：有很多网络请求需要执行，但执行者的执行速度没有那么快，此时就需要使用背压策略来控制。 3. 背压策略的原理RxJava实现背压策略Backpressure的原理： 避免出现事件发送和接收流速不匹配的情况： a. 控制观察者接收事件的速度：响应式拉拉取，响应式拉取，即观察者根据自身实际情况按需接收事件 b. 控制被观察者发送事件的速度：反馈控制，即被观察者根据观察者接收事件能力l来控制发送事件的速度 当出现事件发送和接收流速不匹配时的解决方案：采用背压策略模式，使用缓存区，对超出缓存区大小的事件进行丢弃、保留和报错的措施 示意图如下： 与RxJava 1.0 中的Observable相比： 在RxJava 2.0中的Flowable是什么呢？它其实是RxJava 2.0中被观察者的一种新的实现，同时也是背压策略实现的承载着。 4. 背压策略的具体实现：Flowable在RxJava 2.0中，采用Flowable来实现背压策略。 准确来说，是非阻塞式背压策略 4.1 Flowable介绍定义：在RxJava 2.0中，Observable的一种新实现。作用：实现非阻塞式背压策略。 4.2 Flowable特点 对应的Observer变为Subscriber：被观察者Flowable——观察者Subscriber 所有的操作符强制支持背压：Flowable中的操作符大多与旧有的Observable类似 缓存区存放策略：按发送的顺序保存在缓存区：即先发送先进入缓存区，先进入缓存区的事件先取出 默认的缓存区（队列）大小为128 下面是1.0与2.0观察者模型的对比图：实际上RxJava 2.0也保留了Observable——Observer的观察者模型。 4.3 与RxJava 1.0中被观察者的旧实现Observable的关系 为什么要采用Flowable实现背压，而不采用旧的Observable呢？原因：Observable无法很好解决背压问题。 背景：在RxJava 1.0中，Observable内部采用队列存储事件，在Android中，默认缓存大小为16 冲突：若发送事件速度 &gt; 接收事件速度时，队列中的数目可能会超过16个，从而导致Observable有很多事件不能被正确背压，最终抛出MissingBackpressureException。在RxJava 1.0也有解决背压的方案：手动减少被观察者发送的事件，降低被观察者发送事件的速度（采用延迟方式），但效果并不好，还是会出现丢失的可能性。 解决方案：采用RxJava 2.0被观察者的新实现Flowable来实现背压。 4.4 Flowable的基础使用使用方式类似于Observable。 1234567891011121314151617181920212223242526272829303132333435363738394041// 创建被观察者FlowableFlowable&lt;Integer&gt; upstream = Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; // 传入背压参数 @Override public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception &#123; emitter.onNext(1); emitter.onNext(2); emitter.onNext(3); emitter.onComplete(); &#125;&#125;, BackpressureStrategy.ERROR);// 创建观察者SubscriberSubscriber&lt;Integer&gt; downstream = new Subscriber&lt;Integer&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; // 对比Observable传入的Disposable参数，Subscriber这里传入的参数为Subscription // 相同点：Subscription具备Disposable参数的作用，可以通过调用Subscription.cancel()切断连接 // 不同点：Subscription增加了void request(long n) Log.d(TAG, \"onSubscribe\"); s.request(Long.MAX_VALUE); &#125; @Override public void onNext(Integer integer) &#123; Log.d(TAG, \"onNext: \" + integer); &#125; @Override public void onError(Throwable t) &#123; Log.w(TAG, \"onError: \", t); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"onComplete\"); &#125;&#125;;// 建立订阅关系upstream.subscribe(downstream); 12345D/MainActivity6: onSubscribeD/MainActivity6: onNext: 1D/MainActivity6: onNext: 2D/MainActivity6: onNext: 3D/MainActivity6: onComplete 更优雅的链式调用： 12345678910111213141516171819202122232425262728293031323334Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception &#123; Log.d(TAG, \"发送事件 1\"); emitter.onNext(1); Log.d(TAG, \"发送事件 2\"); emitter.onNext(2); Log.d(TAG, \"发送事件 3\"); emitter.onNext(3); Log.d(TAG, \"发送完成\"); emitter.onComplete(); &#125;&#125;, BackpressureStrategy.ERROR).subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; Log.d(TAG, \"onSubscribe\"); s.request(3); &#125; @Override public void onNext(Integer integer) &#123; Log.d(TAG, \"接收到了事件\" + integer); &#125; @Override public void onError(Throwable t) &#123; Log.w(TAG, \"onError: \", t); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"onComplete\"); &#125;&#125;); 5. 背压策略的使用前面说到，使用背压的场景一般是在异步订阅关系下的，所以下面主要讲解异步订阅关系场景，即被观察者和观察者工作在不同线程，但是，由于在同步订阅场景中也有可能出现流速不匹配的问题，所以会以同讲解一下。 5.1 控制观察者接收事件的速度5.1.1 异步订阅情况面向对象：观察者原理：响应式拉取，观察者根据自身实际情况按需接收事件。虽然观察者是响应式拉取接收事件，但被观察者还是一次性发送完毕。实现方式：Subscriber.Subscription.request()。 1234567891011121314151617181920212223242526272829303132333435363738394041Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception &#123; // 一共发送4个事件 Log.d(TAG, \"发送事件 1\"); emitter.onNext(1); Log.d(TAG, \"发送事件 2\"); emitter.onNext(2); Log.d(TAG, \"发送事件 3\"); emitter.onNext(3); Log.d(TAG, \"发送事件 4\"); emitter.onNext(4); Log.d(TAG, \"发送完成\"); emitter.onComplete(); &#125;&#125;, BackpressureStrategy.ERROR) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; // 观察者能够接收多少个事件 // 官方默认推荐使用Long.MAX_VALUE，即s.request(Long.MAX_VALUE); s.request(3); &#125; @Override public void onNext(Integer integer) &#123; Log.d(TAG, \"接收到了事件\" + integer); &#125; @Override public void onError(Throwable t) &#123; Log.w(TAG, \"onError: \", t); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"onComplete\"); &#125; &#125;); 12345678D/MainActivity6: 发送事件 1D/MainActivity6: 发送事件 2D/MainActivity6: 发送事件 3D/MainActivity6: 发送事件 4D/MainActivity6: 发送完成D/MainActivity6: 接收到了事件1D/MainActivity6: 接收到了事件2D/MainActivity6: 接收到了事件3 特别注意： 结论：对于异步订阅情况，若观察者没有设置Subscription.request(long n)，说明观察者不接受事件。此时被观察者仍能继续发送事件（存放在缓存区），等观察者需要时再取出。 解释：不设置Subscription.request(long n)，观察者虽然不能接收事件，但是由于异步订阅关系中存在缓存区（大小为128），所以被观察者仍然能继续发送事件并暂时存放到缓存区。当缓存区满（128个事件）时，就会溢出报错。只有当观察者有需求时，才调用request()从缓存区按需取出事件。 额外：缓存区大小默认为128个事件，由Flowable的bufferSize决定。 代码演示1：观察者不接收事件的情况下，被观察者继续发送事件并存到缓存区，再按需取出。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class Main7Activity extends AppCompatActivity &#123; private static final String TAG = \"MainActivity7\"; /** * 该按钮用于调用Subscription.request() */ private Button btn; /** * 用于保存Subscription对象 */ private Subscription mSubscription; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main7); btn = findViewById(R.id.button); btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; mSubscription.request(2); &#125; &#125;); Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception &#123; Log.d(TAG, \"发送事件 1\"); emitter.onNext(1); Log.d(TAG, \"发送事件 2\"); emitter.onNext(2); Log.d(TAG, \"发送事件 3\"); emitter.onNext(3); Log.d(TAG, \"发送事件 4\"); emitter.onNext(4); Log.d(TAG, \"发送完成\"); emitter.onComplete(); &#125; &#125;, BackpressureStrategy.ERROR) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; Log.d(TAG, \"onSubscribe\"); // 保存Subscription对象，等待点击按钮时（调用request(2)）观察者再接收事件 mSubscription = s; &#125; @Override public void onNext(Integer integer) &#123; Log.d(TAG, \"接收到了事件\" + integer); &#125; @Override public void onError(Throwable t) &#123; Log.w(TAG, \"onError: \", t); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"onComplete\"); &#125; &#125;); &#125;&#125; 12345678D/MainActivity7: onSubscribeD/MainActivity7: 发送事件 1D/MainActivity7: 发送事件 2D/MainActivity7: 发送事件 3D/MainActivity7: 发送事件 4D/MainActivity7: 发送完成D/MainActivity7: 接收到了事件1D/MainActivity7: 接收到了事件2 代码演示2：观察者不接收事件的情况下，被观察者连续发送事件，直到超出缓存区大小（128）。 1234567891011121314151617181920212223242526272829303132333435Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception &#123; // 一共发送129个事件，即超出了缓存区的大小 for (int i = 0; i &lt; 129; i++) &#123; Log.d(TAG, \"发送了事件\" + i); emitter.onNext(i); &#125; emitter.onComplete(); &#125;&#125;, BackpressureStrategy.ERROR) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; Log.d(TAG, \"onSubscribe\"); // 默认不设置可接收事件大小 &#125; @Override public void onNext(Integer integer) &#123; Log.d(TAG, \"接收到了事件\" + integer); &#125; @Override public void onError(Throwable t) &#123; Log.w(TAG, \"onError: \", t); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"onComplete\"); &#125; &#125;); 123456789101112131415162019-08-21 15:43:16.479 4703-4703/com.ly.allendemorx W/MainActivity7: onError: io.reactivex.exceptions.MissingBackpressureException: create: could not emit value due to lack of requests at io.reactivex.internal.operators.flowable.FlowableCreate$ErrorAsyncEmitter.onOverflow(FlowableCreate.java:438) at io.reactivex.internal.operators.flowable.FlowableCreate$NoOverflowBaseAsyncEmitter.onNext(FlowableCreate.java:406) at com.ly.allendemorx.Main7Activity$3.subscribe(Main7Activity.java:55) at io.reactivex.internal.operators.flowable.FlowableCreate.subscribeActual(FlowableCreate.java:71) at io.reactivex.Flowable.subscribe(Flowable.java:14827) at io.reactivex.Flowable.subscribe(Flowable.java:14774) at io.reactivex.internal.operators.flowable.FlowableSubscribeOn$SubscribeOnSubscriber.run(FlowableSubscribeOn.java:82) at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:66) at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:57) at java.util.concurrent.FutureTask.run(FutureTask.java:237) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:272) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1133) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:607) at java.lang.Thread.run(Thread.java:761) 5.1.2 同步订阅情况与异步订阅的区别： 同步订阅中，被观察者和观察者工作于同一线程 同步订阅中，没有缓存区 被观察者再发送一个事件后，必须等待观察者接收后，才能继续发送下一个事件。 1234567891011121314151617181920212223242526272829303132333435Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception &#123; // 发送3个事件 Log.d(TAG, \"发送了事件1\"); emitter.onNext(1); Log.d(TAG, \"发送了事件2\"); emitter.onNext(2); Log.d(TAG, \"发送了事件3\"); emitter.onNext(3); emitter.onComplete(); &#125;&#125;, BackpressureStrategy.ERROR) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; Log.d(TAG, \"onSubscribe\"); s.request(3); &#125; @Override public void onNext(Integer integer) &#123; Log.d(TAG, \"接收到了事件\" + integer); &#125; @Override public void onError(Throwable t) &#123; Log.w(TAG, \"onError: \", t); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"onComplete\"); &#125; &#125;); 12345678D/MainActivity7: onSubscribeD/MainActivity7: 发送了事件1D/MainActivity7: 接收到了事件1D/MainActivity7: 发送了事件2D/MainActivity7: 接收到了事件2D/MainActivity7: 发送了事件3D/MainActivity7: 接收到了事件3D/MainActivity7: onComplete 所以，同步订阅不会出现被观察者发送事件速度 ＞ 观察者接收事件速度的情况，而是会出现被观察者发送事件数量 ＞ 观察者接收事件数量的问题。 如：观察者子还能接收三个事件，被观察者发送了四个事件。 12345678910111213141516171819202122232425262728293031323334353637Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception &#123; // 被观察者发送事件数量 = 4个 Log.d(TAG, \"发送了事件1\"); emitter.onNext(1); Log.d(TAG, \"发送了事件2\"); emitter.onNext(2); Log.d(TAG, \"发送了事件3\"); emitter.onNext(3); Log.d(TAG, \"发送了事件4\"); emitter.onNext(4); emitter.onComplete(); &#125;&#125;, BackpressureStrategy.ERROR) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; Log.d(TAG, \"onSubscribe\"); s.request(3); &#125; @Override public void onNext(Integer integer) &#123; Log.d(TAG, \"接收到了事件\" + integer); &#125; @Override public void onError(Throwable t) &#123; Log.w(TAG, \"onError: \", t); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"onComplete\"); &#125; &#125;); 12345678910111213141516171819202122232425262728292019-08-21 15:52:30.381 5179-5179/com.ly.allendemorx D/MainActivity7: onSubscribe2019-08-21 15:52:30.388 5179-5179/com.ly.allendemorx D/MainActivity7: 发送了事件12019-08-21 15:52:30.388 5179-5179/com.ly.allendemorx D/MainActivity7: 接收到了事件12019-08-21 15:52:30.388 5179-5179/com.ly.allendemorx D/MainActivity7: 发送了事件22019-08-21 15:52:30.388 5179-5179/com.ly.allendemorx D/MainActivity7: 接收到了事件22019-08-21 15:52:30.388 5179-5179/com.ly.allendemorx D/MainActivity7: 发送了事件32019-08-21 15:52:30.388 5179-5179/com.ly.allendemorx D/MainActivity7: 接收到了事件32019-08-21 15:52:30.388 5179-5179/com.ly.allendemorx D/MainActivity7: 发送了事件42019-08-21 15:52:30.391 5179-5179/com.ly.allendemorx W/MainActivity7: onError: io.reactivex.exceptions.MissingBackpressureException: create: could not emit value due to lack of requests at io.reactivex.internal.operators.flowable.FlowableCreate$ErrorAsyncEmitter.onOverflow(FlowableCreate.java:438) at io.reactivex.internal.operators.flowable.FlowableCreate$NoOverflowBaseAsyncEmitter.onNext(FlowableCreate.java:406) at com.ly.allendemorx.Main7Activity$3.subscribe(Main7Activity.java:60) at io.reactivex.internal.operators.flowable.FlowableCreate.subscribeActual(FlowableCreate.java:71) at io.reactivex.Flowable.subscribe(Flowable.java:14827) at io.reactivex.Flowable.subscribe(Flowable.java:14777) at com.ly.allendemorx.Main7Activity.onCreate(Main7Activity.java:64) at android.app.Activity.performCreate(Activity.java:6692) at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1118) at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2621) at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2729) at android.app.ActivityThread.-wrap12(ActivityThread.java) at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1480) at android.os.Handler.dispatchMessage(Handler.java:102) at android.os.Looper.loop(Looper.java:154) at android.app.ActivityThread.main(ActivityThread.java:6169) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:891) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:781) 5.2 控制被观察者发送事件的速度面向对象：被观察者原理：反馈控制，被观察者根据观察者接收事件的能力控制发送事件的速度，观察者预先告知被观察者其事件接收的能力。实现方式：FlowableEmitter.requested() 1234567891011public interface FlowableEmitter&lt;T&gt; extends Emitter&lt;T&gt; &#123;// FlowableEmitter = 1个接口，继承自Emitter// Emitter接口方法包括：onNext(),onComplete() &amp; onError long requested(); // 作用：返回当前线程中request（a）中的a值 // 该request（a）则是措施1中讲解的方法，作用 = 设置 ....// 仅贴出关键代码&#125; 每个线程中的requested()的返回值为该线程中request(a)的a值。 5.2.1 同步订阅情况在同步订阅中，被观察者通过FlowableEmitter.requested()获得观察者自身接收事件能力，从而根据该信息控制事件发送速度，从而达到观察者反向控制被观察者的效果。 例子：被观察者根据观察者自身接收能力（10事件），从而进发送10个事件。 12345678910111213141516171819202122232425262728293031323334353637Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception &#123; // 获取当前观察者接收事件的能力 long l = emitter.requested(); Log.d(TAG, \"观察者可接收事件\" + l); // 根据获得的值，控制发送事件的数量 for (int i = 0; i &lt; l; i++) &#123; Log.d(TAG, \"发送了事件\" + i); emitter.onNext(i); &#125; &#125;&#125;, BackpressureStrategy.ERROR) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; Log.d(TAG, \"onSubscribe\"); // 设置观察者接收事件的能力 s.request(10); &#125; @Override public void onNext(Integer integer) &#123; Log.d(TAG, \"接收到了事件\" + integer); &#125; @Override public void onError(Throwable t) &#123; Log.w(TAG, \"onError: \", t); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"onComplete\"); &#125; &#125;); 12345678910111213141516171819202122D/MainActivity7: onSubscribeD/MainActivity7: 观察者可接收事件10D/MainActivity7: 发送了事件0D/MainActivity7: 接收到了事件0D/MainActivity7: 发送了事件1D/MainActivity7: 接收到了事件1D/MainActivity7: 发送了事件2D/MainActivity7: 接收到了事件2D/MainActivity7: 发送了事件3D/MainActivity7: 接收到了事件3D/MainActivity7: 发送了事件4D/MainActivity7: 接收到了事件4D/MainActivity7: 发送了事件5D/MainActivity7: 接收到了事件5D/MainActivity7: 发送了事件6D/MainActivity7: 接收到了事件6D/MainActivity7: 发送了事件7D/MainActivity7: 接收到了事件7D/MainActivity7: 发送了事件8D/MainActivity7: 接收到了事件8D/MainActivity7: 发送了事件9D/MainActivity7: 接收到了事件9 特别注意：在同步订阅时，使用FlowableEmitter.requested()时，要注意以下使用特性。 可叠加性：观察者可连续要求接收事件，被观察者会进行叠加，一起发送。 实时更新性：每次发送事件后，FlowableEmitter.requested()的返回值会实时更新观察者能接收的事件。 异常： 当FlowableEmitter.requested()返回0时，代表观察者已经不能接收事件，此时被观察者若继续发送事件，会抛出MissingBackpressureException 若观察者中没有设置可接收事件数量，即，没有调用Subscription.request()，那么被观察者默认观察者可接收事件为0，因为同步订阅中没有缓存区。 可叠加性观察者可连续要求接收事件，被观察者会进行叠加，一起发送。 1234Subscription.request（a1）；Subscription.request（a2）；FlowableEmitter.requested()的返回值 = a1 + a2 代码演示： 1234567891011121314151617181920212223242526272829303132Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception &#123; // 调用emitter.requested()获取当前观察者需要接收的事件数量 Log.d(TAG, \"观察者可接收事件\" + emitter.requested()); &#125;&#125;, BackpressureStrategy.ERROR) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; Log.d(TAG, \"onSubscribe\"); // 第1次设置观察者每次能接受10个事件 s.request(10); // 第2次设置观察者每次能接受20个事件 s.request(20); &#125; @Override public void onNext(Integer integer) &#123; Log.d(TAG, \"接收到了事件\" + integer); &#125; @Override public void onError(Throwable t) &#123; Log.w(TAG, \"onError: \", t); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"onComplete\"); &#125; &#125;); 12D/MainActivity7: onSubscribeD/MainActivity7: 观察者可接收事件30 实时更新性每次发送事件后，FlowableEmitter.requested()的返回值会实时更新观察者能接收的事件。 即一开始观察者可接收事件的数量为10，发送一个后，会实时更新为9。 仅计算Next事件，Complete和Error事件不算。 代码演示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception &#123; // 1. 调用emitter.requested()获取当前观察者需要接收的事件数量 Log.d(TAG, \"观察者可接收事件数量 = \" + emitter.requested()); // 2. 每次发送事件后，emitter.requested()会实时更新观察者能接受的事件 // 即一开始观察者要接收10个事件，发送了1个后，会实时更新为9个 Log.d(TAG, \"发送了事件 1\"); emitter.onNext(1); Log.d(TAG, \"发送了事件1后, 还需要发送事件数量 = \" + emitter.requested()); Log.d(TAG, \"发送了事件 2\"); emitter.onNext(2); Log.d(TAG, \"发送事件2后, 还需要发送事件数量 = \" + emitter.requested()); Log.d(TAG, \"发送了事件 3\"); emitter.onNext(3); Log.d(TAG, \"发送事件3后, 还需要发送事件数量 = \" + emitter.requested()); emitter.onComplete(); &#125;&#125;, BackpressureStrategy.ERROR) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; Log.d(TAG, \"onSubscribe\"); s.request(10); &#125; @Override public void onNext(Integer integer) &#123; Log.d(TAG, \"接收到了事件\" + integer); &#125; @Override public void onError(Throwable t) &#123; Log.w(TAG, \"onError: \", t); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"onComplete\"); &#125; &#125;); 123456789101112D/MainActivity7: onSubscribeD/MainActivity7: 观察者可接收事件数量 = 10D/MainActivity7: 发送了事件 1D/MainActivity7: 接收到了事件1D/MainActivity7: 发送了事件1后, 还需要发送事件数量 = 9D/MainActivity7: 发送了事件 2D/MainActivity7: 接收到了事件2D/MainActivity7: 发送事件2后, 还需要发送事件数量 = 8D/MainActivity7: 发送了事件 3D/MainActivity7: 接收到了事件3D/MainActivity7: 发送事件3后, 还需要发送事件数量 = 7D/MainActivity7: onComplete 异常当FlowableEmitter.requested()减到0时，则代表观察者已经不可接收事件，此时被观察者若继续发送事件，则会抛出MissingBackpressureException。代码演示： 1234567891011121314151617181920212223242526272829303132333435363738394041Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception &#123; // 1. 调用emitter.requested()获取当前观察者需要接收的事件数量 Log.d(TAG, \"观察者可接收事件数量 = \" + emitter.requested()); // 2. 每次发送事件后，emitter.requested()会实时更新观察者能接受的事件 // 即一开始观察者要接收10个事件，发送了1个后，会实时更新为9个 Log.d(TAG, \"发送了事件 1\"); emitter.onNext(1); Log.d(TAG, \"发送了事件1后, 还需要发送事件数量 = \" + emitter.requested()); Log.d(TAG, \"发送了事件 2\"); emitter.onNext(2); Log.d(TAG, \"发送事件2后, 还需要发送事件数量 = \" + emitter.requested()); emitter.onComplete(); &#125;&#125;, BackpressureStrategy.ERROR) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; Log.d(TAG, \"onSubscribe\"); s.request(1); &#125; @Override public void onNext(Integer integer) &#123; Log.d(TAG, \"接收到了事件\" + integer); &#125; @Override public void onError(Throwable t) &#123; Log.w(TAG, \"onError: \", t); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"onComplete\"); &#125; &#125;); 123456789101112131415161718192021222324252627282019-08-21 17:23:57.540 6023-6023/com.ly.allendemorx D/MainActivity7: onSubscribe2019-08-21 17:23:57.547 6023-6023/com.ly.allendemorx D/MainActivity7: 观察者可接收事件数量 = 12019-08-21 17:23:57.547 6023-6023/com.ly.allendemorx D/MainActivity7: 发送了事件 12019-08-21 17:23:57.547 6023-6023/com.ly.allendemorx D/MainActivity7: 接收到了事件12019-08-21 17:23:57.547 6023-6023/com.ly.allendemorx D/MainActivity7: 发送了事件1后, 还需要发送事件数量 = 02019-08-21 17:23:57.547 6023-6023/com.ly.allendemorx D/MainActivity7: 发送了事件 22019-08-21 17:23:57.551 6023-6023/com.ly.allendemorx W/MainActivity7: onError: io.reactivex.exceptions.MissingBackpressureException: create: could not emit value due to lack of requests at io.reactivex.internal.operators.flowable.FlowableCreate$ErrorAsyncEmitter.onOverflow(FlowableCreate.java:438) at io.reactivex.internal.operators.flowable.FlowableCreate$NoOverflowBaseAsyncEmitter.onNext(FlowableCreate.java:406) at com.ly.allendemorx.Main7Activity$3.subscribe(Main7Activity.java:62) at io.reactivex.internal.operators.flowable.FlowableCreate.subscribeActual(FlowableCreate.java:71) at io.reactivex.Flowable.subscribe(Flowable.java:14827) at io.reactivex.Flowable.subscribe(Flowable.java:14777) at com.ly.allendemorx.Main7Activity.onCreate(Main7Activity.java:68) at android.app.Activity.performCreate(Activity.java:6692) at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1118) at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2621) at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2729) at android.app.ActivityThread.-wrap12(ActivityThread.java) at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1480) at android.os.Handler.dispatchMessage(Handler.java:102) at android.os.Looper.loop(Looper.java:154) at android.app.ActivityThread.main(ActivityThread.java:6169) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:891) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:781)2019-08-21 17:23:57.551 6023-6023/com.ly.allendemorx D/MainActivity7: 发送事件2后, 还需要发送事件数量 = 0 5.2.2 异步订阅情况由于二者不在同一线程，所以被观察者无法通过FlowableEmitter.requested()获取观察者接收事件的能力。 1234567891011121314151617181920212223242526272829303132Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception &#123; Log.d(TAG, \"观察者可接收事件数量 = \" + emitter.requested()); &#125;&#125;, BackpressureStrategy.ERROR) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; Log.d(TAG, \"onSubscribe\"); // 该设置仅影响观察者线程中的requested，却不会影响的被观察者中的FlowableEmitter.requested()的返回值 // 因为FlowableEmitter.requested()的返回值 取决于RxJava内部调用request(n)，而该内部调用会在一开始就调用request(128) s.request(150); &#125; @Override public void onNext(Integer integer) &#123; Log.d(TAG, \"接收到了事件\" + integer); &#125; @Override public void onError(Throwable t) &#123; Log.w(TAG, \"onError: \", t); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"onComplete\"); &#125; &#125;); 12D/MainActivity7: onSubscribeD/MainActivity7: 观察者可接收事件数量 = 128 在异步订阅中，反向控制的原理是：通过RxJava内部固定调用被观察者线程中的request(n)，从而方向控制被观察者的发送事件速度。 那么该在什么时候调用被观察者线程中的request(n)，n的值该是多少呢？ 关于RxJava内部调用request(n)（n = 128、96、0）的逻辑如下： 至于为什么调用request(128)、request(96)、request(0)，可以查看Flowable的源码 代码演示：被观察者一共需要发送500个事件，但真正开始发送事件的前提为FlowableEmtter.requested()的返回值不为0；观察者每次接收48个事件（点击按钮接收事件）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class Main7Activity extends AppCompatActivity &#123; private static final String TAG = \"MainActivity7\"; /** * 该按钮用于调用Subscription.request() */ private Button btn; /** * 用于保存Subscription对象 */ private Subscription mSubscription; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main7); btn = findViewById(R.id.button); // 点击按钮接收事件，每次接收48个事件 btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; mSubscription.request(48); &#125; &#125;); Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception &#123; Log.d(TAG, \"观察者可接收事件数量 = \" + emitter.requested()); //设置标记位控制 boolean flag; // 被观察者一共需要发送500个事件 for (int i = 0; i &lt; 500; i++) &#123; flag = false; // 若requested() == 0，则不发送 while (emitter.requested() == 0) &#123; if (!flag) &#123; Log.d(TAG, \"不再发送\"); flag = true; &#125; &#125; // requested() ≠ 0 才发送 Log.d(TAG, \"发送了事件\" + i + \"，观察者可接收事件数量 = \" + emitter.requested()); emitter.onNext(i); &#125; &#125; &#125;, BackpressureStrategy.ERROR) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; Log.d(TAG, \"onSubscribe\"); // 初始状态 = 不接收事件；通过点击按钮接收事件 mSubscription = s; &#125; @Override public void onNext(Integer integer) &#123; Log.d(TAG, \"接收到了事件\" + integer); &#125; @Override public void onError(Throwable t) &#123; Log.w(TAG, \"onError: \", t); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"onComplete\"); &#125; &#125;); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181D/MainActivity7: onSubscribeD/MainActivity7: 观察者可接收事件数量 = 128D/MainActivity7: 发送了事件0，观察者可接收事件数量 = 128D/MainActivity7: 发送了事件1，观察者可接收事件数量 = 127D/MainActivity7: 发送了事件2，观察者可接收事件数量 = 126D/MainActivity7: 发送了事件3，观察者可接收事件数量 = 125D/MainActivity7: 发送了事件4，观察者可接收事件数量 = 124D/MainActivity7: 发送了事件5，观察者可接收事件数量 = 123D/MainActivity7: 发送了事件6，观察者可接收事件数量 = 122D/MainActivity7: 发送了事件7，观察者可接收事件数量 = 121D/MainActivity7: 发送了事件8，观察者可接收事件数量 = 120D/MainActivity7: 发送了事件9，观察者可接收事件数量 = 119D/MainActivity7: 发送了事件10，观察者可接收事件数量 = 118D/MainActivity7: 发送了事件11，观察者可接收事件数量 = 117D/MainActivity7: 发送了事件12，观察者可接收事件数量 = 116D/MainActivity7: 发送了事件13，观察者可接收事件数量 = 115D/MainActivity7: 发送了事件14，观察者可接收事件数量 = 114D/MainActivity7: 发送了事件15，观察者可接收事件数量 = 113D/MainActivity7: 发送了事件16，观察者可接收事件数量 = 112D/MainActivity7: 发送了事件17，观察者可接收事件数量 = 111D/MainActivity7: 发送了事件18，观察者可接收事件数量 = 110D/MainActivity7: 发送了事件19，观察者可接收事件数量 = 109D/MainActivity7: 发送了事件20，观察者可接收事件数量 = 108D/MainActivity7: 发送了事件21，观察者可接收事件数量 = 107D/MainActivity7: 发送了事件22，观察者可接收事件数量 = 106D/MainActivity7: 发送了事件23，观察者可接收事件数量 = 105D/MainActivity7: 发送了事件24，观察者可接收事件数量 = 104D/MainActivity7: 发送了事件25，观察者可接收事件数量 = 103D/MainActivity7: 发送了事件26，观察者可接收事件数量 = 102D/MainActivity7: 发送了事件27，观察者可接收事件数量 = 101D/MainActivity7: 发送了事件28，观察者可接收事件数量 = 100D/MainActivity7: 发送了事件29，观察者可接收事件数量 = 99D/MainActivity7: 发送了事件30，观察者可接收事件数量 = 98D/MainActivity7: 发送了事件31，观察者可接收事件数量 = 97D/MainActivity7: 发送了事件32，观察者可接收事件数量 = 96D/MainActivity7: 发送了事件33，观察者可接收事件数量 = 95D/MainActivity7: 发送了事件34，观察者可接收事件数量 = 94D/MainActivity7: 发送了事件35，观察者可接收事件数量 = 93D/MainActivity7: 发送了事件36，观察者可接收事件数量 = 92D/MainActivity7: 发送了事件37，观察者可接收事件数量 = 91D/MainActivity7: 发送了事件38，观察者可接收事件数量 = 90D/MainActivity7: 发送了事件39，观察者可接收事件数量 = 89D/MainActivity7: 发送了事件40，观察者可接收事件数量 = 88D/MainActivity7: 发送了事件41，观察者可接收事件数量 = 87D/MainActivity7: 发送了事件42，观察者可接收事件数量 = 86D/MainActivity7: 发送了事件43，观察者可接收事件数量 = 85D/MainActivity7: 发送了事件44，观察者可接收事件数量 = 84D/MainActivity7: 发送了事件45，观察者可接收事件数量 = 83D/MainActivity7: 发送了事件46，观察者可接收事件数量 = 82D/MainActivity7: 发送了事件47，观察者可接收事件数量 = 81D/MainActivity7: 发送了事件48，观察者可接收事件数量 = 80D/MainActivity7: 发送了事件49，观察者可接收事件数量 = 79D/MainActivity7: 发送了事件50，观察者可接收事件数量 = 78D/MainActivity7: 发送了事件51，观察者可接收事件数量 = 77D/MainActivity7: 发送了事件52，观察者可接收事件数量 = 76D/MainActivity7: 发送了事件53，观察者可接收事件数量 = 75D/MainActivity7: 发送了事件54，观察者可接收事件数量 = 74D/MainActivity7: 发送了事件55，观察者可接收事件数量 = 73D/MainActivity7: 发送了事件56，观察者可接收事件数量 = 72D/MainActivity7: 发送了事件57，观察者可接收事件数量 = 71D/MainActivity7: 发送了事件58，观察者可接收事件数量 = 70D/MainActivity7: 发送了事件59，观察者可接收事件数量 = 69D/MainActivity7: 发送了事件60，观察者可接收事件数量 = 68D/MainActivity7: 发送了事件61，观察者可接收事件数量 = 67D/MainActivity7: 发送了事件62，观察者可接收事件数量 = 66D/MainActivity7: 发送了事件63，观察者可接收事件数量 = 65D/MainActivity7: 发送了事件64，观察者可接收事件数量 = 64D/MainActivity7: 发送了事件65，观察者可接收事件数量 = 63D/MainActivity7: 发送了事件66，观察者可接收事件数量 = 62D/MainActivity7: 发送了事件67，观察者可接收事件数量 = 61D/MainActivity7: 发送了事件68，观察者可接收事件数量 = 60D/MainActivity7: 发送了事件69，观察者可接收事件数量 = 59D/MainActivity7: 发送了事件70，观察者可接收事件数量 = 58D/MainActivity7: 发送了事件71，观察者可接收事件数量 = 57D/MainActivity7: 发送了事件72，观察者可接收事件数量 = 56D/MainActivity7: 发送了事件73，观察者可接收事件数量 = 55D/MainActivity7: 发送了事件74，观察者可接收事件数量 = 54D/MainActivity7: 发送了事件75，观察者可接收事件数量 = 53D/MainActivity7: 发送了事件76，观察者可接收事件数量 = 52D/MainActivity7: 发送了事件77，观察者可接收事件数量 = 51D/MainActivity7: 发送了事件78，观察者可接收事件数量 = 50D/MainActivity7: 发送了事件79，观察者可接收事件数量 = 49D/MainActivity7: 发送了事件80，观察者可接收事件数量 = 48D/MainActivity7: 发送了事件81，观察者可接收事件数量 = 47D/MainActivity7: 发送了事件82，观察者可接收事件数量 = 46D/MainActivity7: 发送了事件83，观察者可接收事件数量 = 45D/MainActivity7: 发送了事件84，观察者可接收事件数量 = 44D/MainActivity7: 发送了事件85，观察者可接收事件数量 = 43D/MainActivity7: 发送了事件86，观察者可接收事件数量 = 42D/MainActivity7: 发送了事件87，观察者可接收事件数量 = 41D/MainActivity7: 发送了事件88，观察者可接收事件数量 = 40D/MainActivity7: 发送了事件89，观察者可接收事件数量 = 39D/MainActivity7: 发送了事件90，观察者可接收事件数量 = 38D/MainActivity7: 发送了事件91，观察者可接收事件数量 = 37D/MainActivity7: 发送了事件92，观察者可接收事件数量 = 36D/MainActivity7: 发送了事件93，观察者可接收事件数量 = 35D/MainActivity7: 发送了事件94，观察者可接收事件数量 = 34D/MainActivity7: 发送了事件95，观察者可接收事件数量 = 33D/MainActivity7: 发送了事件96，观察者可接收事件数量 = 32D/MainActivity7: 发送了事件97，观察者可接收事件数量 = 31D/MainActivity7: 发送了事件98，观察者可接收事件数量 = 30D/MainActivity7: 发送了事件99，观察者可接收事件数量 = 29D/MainActivity7: 发送了事件100，观察者可接收事件数量 = 28D/MainActivity7: 发送了事件101，观察者可接收事件数量 = 27D/MainActivity7: 发送了事件102，观察者可接收事件数量 = 26D/MainActivity7: 发送了事件103，观察者可接收事件数量 = 25D/MainActivity7: 发送了事件104，观察者可接收事件数量 = 24D/MainActivity7: 发送了事件105，观察者可接收事件数量 = 23D/MainActivity7: 发送了事件106，观察者可接收事件数量 = 22D/MainActivity7: 发送了事件107，观察者可接收事件数量 = 21D/MainActivity7: 发送了事件108，观察者可接收事件数量 = 20D/MainActivity7: 发送了事件109，观察者可接收事件数量 = 19D/MainActivity7: 发送了事件110，观察者可接收事件数量 = 18D/MainActivity7: 发送了事件111，观察者可接收事件数量 = 17D/MainActivity7: 发送了事件112，观察者可接收事件数量 = 16D/MainActivity7: 发送了事件113，观察者可接收事件数量 = 15D/MainActivity7: 发送了事件114，观察者可接收事件数量 = 14D/MainActivity7: 发送了事件115，观察者可接收事件数量 = 13D/MainActivity7: 发送了事件116，观察者可接收事件数量 = 12D/MainActivity7: 发送了事件117，观察者可接收事件数量 = 11D/MainActivity7: 发送了事件118，观察者可接收事件数量 = 10D/MainActivity7: 发送了事件119，观察者可接收事件数量 = 9D/MainActivity7: 发送了事件120，观察者可接收事件数量 = 8D/MainActivity7: 发送了事件121，观察者可接收事件数量 = 7D/MainActivity7: 发送了事件122，观察者可接收事件数量 = 6D/MainActivity7: 发送了事件123，观察者可接收事件数量 = 5D/MainActivity7: 发送了事件124，观察者可接收事件数量 = 4D/MainActivity7: 发送了事件125，观察者可接收事件数量 = 3D/MainActivity7: 发送了事件126，观察者可接收事件数量 = 2D/MainActivity7: 发送了事件127，观察者可接收事件数量 = 1D/MainActivity7: 不再发送D/MainActivity7: 接收到了事件0D/MainActivity7: 接收到了事件1D/MainActivity7: 接收到了事件2D/MainActivity7: 接收到了事件3D/MainActivity7: 接收到了事件4D/MainActivity7: 接收到了事件5D/MainActivity7: 接收到了事件6D/MainActivity7: 接收到了事件7D/MainActivity7: 接收到了事件8D/MainActivity7: 接收到了事件9D/MainActivity7: 接收到了事件10D/MainActivity7: 接收到了事件11D/MainActivity7: 接收到了事件12D/MainActivity7: 接收到了事件13D/MainActivity7: 接收到了事件14D/MainActivity7: 接收到了事件15D/MainActivity7: 接收到了事件16D/MainActivity7: 接收到了事件17D/MainActivity7: 接收到了事件18D/MainActivity7: 接收到了事件19D/MainActivity7: 接收到了事件20D/MainActivity7: 接收到了事件21D/MainActivity7: 接收到了事件22D/MainActivity7: 接收到了事件23D/MainActivity7: 接收到了事件24D/MainActivity7: 接收到了事件25D/MainActivity7: 接收到了事件26D/MainActivity7: 接收到了事件27D/MainActivity7: 接收到了事件28D/MainActivity7: 接收到了事件29D/MainActivity7: 接收到了事件30D/MainActivity7: 接收到了事件31D/MainActivity7: 接收到了事件32D/MainActivity7: 接收到了事件33D/MainActivity7: 接收到了事件34D/MainActivity7: 接收到了事件35D/MainActivity7: 接收到了事件36D/MainActivity7: 接收到了事件37D/MainActivity7: 接收到了事件38D/MainActivity7: 接收到了事件39D/MainActivity7: 接收到了事件40D/MainActivity7: 接收到了事件41D/MainActivity7: 接收到了事件42D/MainActivity7: 接收到了事件43D/MainActivity7: 接收到了事件44D/MainActivity7: 接收到了事件45D/MainActivity7: 接收到了事件46D/MainActivity7: 接收到了事件47 5.3 采用背压策略模式：BackpressureStrategy5.3.1 背压模式介绍在Flowable中要求传入背压模式参数。 面向对象：针对缓存区。作用：当缓存区存满、被观察者仍然继续发送下一个事件时，如何处理的策略方式。 5.3.2 背压模式类型： 需要解决的问题：流速不匹配，发送事件速度 ＞ 接收事件速度，具体表现为当缓存区存满时，被观察者仍然继续发送下一个事件。 类型： BackpressureStrategy.ERROR：直接抛出异常MissingBackpressureException BackpressureStrategy.MISSING：友好提示，缓存区满了 BackpressureStrategy.BUFFER：将缓存区大小设置成无限大，即，被观察者可以无限发送事件到缓存区 BackpressureStrategy.DROP：超过缓存区大小（128）的事件丢弃 BackpressureStrategy.LATEST：只保存最新（最后）事件，超过缓存区大小（128）的事件丢弃 5.3.3 特别注意使用背压策略模式时，有一点要注意： 背景Flowable可以通过自己创建，或者通过其他方式自动创建，如interval操作符。 interval操作符简介 作用：每间隔一段时间产生一个数字（Long类型），从0开始、一次递增1，直至无穷大 默认运行在一个新的线程上 与timer()操作符区别：timer()操作符可结束发送 冲突对于手动创建Flowable的情况，可以通过传入背压模式参数选择背压策略，但是对于自动创建Flowable，就无法手动传入背压模式参数，这时，出现流速不匹配的情况，该如何处理？ 1234567891011121314151617181920212223242526272829303132333435363738// 通过interval自动创建被观察者Flowable// 每隔1ms将当前数字（从0开始）加1，并发送出去// interval操作符会默认开启一个新的工作线程Flowable.interval(1, TimeUnit.MILLISECONDS) // 观察者同样工作在一个新的线程 .observeOn(Schedulers.newThread()) .subscribe(new Subscriber&lt;Long&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; Log.d(TAG, \"onSubscribe\"); mSubscription = s; // 默认可以接收Long.MAX_VALUE个事件 s.request(Long.MAX_VALUE); &#125; @Override public void onNext(Long aLong) &#123; Log.d(TAG, \"onNext: \" + aLong); try &#123; // 每延迟一秒再接收事件 Thread.sleep(1000); // 因为发送事件为延时1ms，接收事件为延时1s，出现了发送速度与接收速度不匹配的问题 // 缓存区很快就存满了128个事件，从而抛出MissingBackpressureException &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onError(Throwable t) &#123; Log.w(TAG, \"onError: \", t); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"onComplete\"); &#125; &#125;); 解决方案RxJava 2.0内部提供了封装背压策略模式的方法： onBackpressureBuffer() onBackpressureDrop() onBackpressureLatest() 默认采用了BackpressureStrategy.ERROR模式。 代码演示： 1234567891011121314151617181920212223242526272829303132333435Flowable.interval(1, TimeUnit.MILLISECONDS) // 添加背压策略模式 .onBackpressureBuffer() // 观察者同样工作在一个新的线程 .observeOn(Schedulers.newThread()) .subscribe(new Subscriber&lt;Long&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; Log.d(TAG, \"onSubscribe\"); mSubscription = s; // 默认可以接收Long.MAX_VALUE个事件 s.request(Long.MAX_VALUE); &#125; @Override public void onNext(Long aLong) &#123; Log.d(TAG, \"onNext: \" + aLong); try &#123; // 每延迟一秒再接收事件 Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onError(Throwable t) &#123; Log.w(TAG, \"onError: \", t); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"onComplete\"); &#125; &#125;); Demo地址：Allen_Demo_Rx","categories":[{"name":"Android","slug":"Android","permalink":"https://tylerLiu.top/categories/Android/"},{"name":"RxJava","slug":"Android/RxJava","permalink":"https://tylerLiu.top/categories/Android/RxJava/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"https://tylerLiu.top/tags/RxJava/"}]},{"title":"Android RxJava：条件/布尔操作符","slug":"Android-RxJava：条件-布尔操作符","date":"2019-08-20T00:36:27.000Z","updated":"2019-08-22T03:14:24.539Z","comments":true,"path":"2019/08/20/Android-RxJava：条件-布尔操作符/","link":"","permalink":"https://tylerLiu.top/2019/08/20/Android-RxJava：条件-布尔操作符/","excerpt":"","text":"1. 作用通过设置函数，判断Obsevable发送的事件是否符合条件。 2. 类型 3. 详解3.1 all()作用：判断发送的每项数据是否都满足设置的函数条件。若满足，返回true；否则，返回false。 12345678910111213Observable.just(1, 2, 3, 4, 5, 6) .all(new Predicate&lt;Integer&gt;() &#123; @Override public boolean test(Integer integer) throws Exception &#123; // 判断发送的所有数据是否都≤10 return integer &lt;= 10; &#125; &#125;).subscribe(new Consumer&lt;Boolean&gt;() &#123; @Override public void accept(Boolean aBoolean) throws Exception &#123; Log.d(TAG, \"result is \" + aBoolean); &#125;&#125;); 1D/MainActivity5: result is true 3.2 takeWhile()作用：判断发送的每项数据是否满足设置函数的条件。若发送的数据满足条件，则发送该项数据，否则不发送。 123456789101112Observable.interval(1, TimeUnit.SECONDS) .takeWhile(new Predicate&lt;Long&gt;() &#123; @Override public boolean test(Long aLong) throws Exception &#123; return aLong &lt;= 5; &#125; &#125;).subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(Long aLong) throws Exception &#123; Log.d(TAG, \"发送了事件 \" + aLong); &#125;&#125;); 123456D/MainActivity5: 发送了事件 0D/MainActivity5: 发送了事件 1D/MainActivity5: 发送了事件 2D/MainActivity5: 发送了事件 3D/MainActivity5: 发送了事件 4D/MainActivity5: 发送了事件 5 3.3 skipWhile()作用：判断发送的每项数据是否满足设置的函数条件。直到该判断条件为false时，才开始发送Observable的数据。 12345678910111213Observable.interval(1, TimeUnit.SECONDS) .skipWhile(new Predicate&lt;Long&gt;() &#123; @Override public boolean test(Long aLong) throws Exception &#123; // 直到发射的数据≥5时，才开始发送 return aLong &lt; 5; &#125; &#125;).subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(Long aLong) throws Excaeption &#123; Log.d(TAG, \"发送了事件 \" + aLong); &#125;&#125;); 1234567D/MainActivity5: 发送了事件 5D/MainActivity5: 发送了事件 6D/MainActivity5: 发送了事件 7D/MainActivity5: 发送了事件 8D/MainActivity5: 发送了事件 9D/MainActivity5: 发送了事件 10D/MainActivity5: 发送了事件 11 3.4 takeUtil()作用：执行到某个条件时，停止发送事件。 12345678910111213Observable.interval(1, TimeUnit.SECONDS) .takeUntil(new Predicate&lt;Long&gt;() &#123; @Override public boolean test(Long aLong) throws Exception &#123; // 直到发射的数据＞3时，停止发送事件 return aLong &gt; 3; &#125; &#125;).subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(Long aLong) throws Exception &#123; Log.d(TAG, \"发送了事件 \" + aLong); &#125;&#125;); 12345D/MainActivity5: 发送了事件 0D/MainActivity5: 发送了事件 1D/MainActivity5: 发送了事件 2D/MainActivity5: 发送了事件 3D/MainActivity5: 发送了事件 4 该判断条件也可以是Observable，即等到takeUtil()传入的Observable开始发送函数，（原始）第一个Observable的数据停止发送数据。 12345678910111213141516171819202122232425// 原始第一个Observable，每个1s发送一个数据Observable.interval(1, TimeUnit.SECONDS) // 第二个Observable，延迟5s后开始发送第一个数据 .takeUntil(Observable.timer(5, TimeUnit.SECONDS)) .subscribe(new Observer&lt;Long&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, \"开始采用subscribe连接\"); &#125; @Override public void onNext(Long aLong) &#123; Log.d(TAG, \"接收到了事件\" + aLong); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, \"对Error事件作出响应\"); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"对Complete事件作出响应\"); &#125; &#125;); 当第5s时，第二个Observable开始发送数据，于是（原始）第一个Observable停止发送数据。 123456D/MainActivity5: 开始采用subscribe连接D/MainActivity5: 接收到了事件0D/MainActivity5: 接收到了事件1D/MainActivity5: 接收到了事件2D/MainActivity5: 接收到了事件3D/MainActivity5: 对Complete事件作出响应 3.5 skipUtil()作用：等到skipUtil()传入的Observable开始发送数据，（原始）第一个Observable才开始发送数据。 12345678910// （原始）第1个ObservableObservable.interval(1, TimeUnit.SECONDS) // 第2个Observable，延迟5s后开始发送型数据 .skipUntil(Observable.timer(5, TimeUnit.SECONDS)) .subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(Long aLong) throws Exception &#123; Log.d(TAG, \"接收到了事件\" + aLong); &#125; &#125;); 1234567D/MainActivity5: 接收到了事件4D/MainActivity5: 接收到了事件5D/MainActivity5: 接收到了事件6D/MainActivity5: 接收到了事件7D/MainActivity5: 接收到了事件8D/MainActivity5: 接收到了事件9D/MainActivity5: 接收到了事件10 3.6 sequenceEqual()作用：判断两个Observable需要发送的数据是否相同。若相同，返回true，反之，返回false。 123456789Observable.sequenceEqual( Observable.just(1, 3, 5), Observable.just(1, 3, 5)).subscribe(new Consumer&lt;Boolean&gt;() &#123; @Override public void accept(Boolean aBoolean) throws Exception &#123; Log.d(TAG, \"2个Observable是否相同：\" + aBoolean); &#125;&#125;); 1D/MainActivity5: 2个Observable是否相同：true 3.7 contains()作用：判断发送的数据中是否包含指定数据。若包含，返回true，反之，返回false。在其内部实现了exists()。 12345678Observable.just(1, 2, 3, 4, 5) .contains(3) .subscribe(new Consumer&lt;Boolean&gt;() &#123; @Override public void accept(Boolean aBoolean) throws Exception &#123; Log.d(TAG, \"result is \" + aBoolean); &#125; &#125;); 1D/MainActivity5: result is true 3.8 isEmpty()作用：判断发送的数据是否为空。若为空，返回true，反之，返回false。 12345678Observable.just(1, 2, 3, 4, 5) .isEmpty() .subscribe(new Consumer&lt;Boolean&gt;() &#123; @Override public void accept(Boolean aBoolean) throws Exception &#123; Log.d(TAG, \"result is \" + aBoolean); &#125; &#125;); 1D/MainActivity5: result is false 3.9 amb()作用：当需要发送多个Observable时，只发送先发送数据的Observable的数据，而其余Observable则被丢弃。 123456789101112131415// 设置两个需要发送的Observable，并放到集合中List&lt;ObservableSource&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();// 第一个Observable，延迟一秒发送数据list.add(Observable.just(1, 2, 3).delay(1, TimeUnit.SECONDS));// 第二个Observable，正常发送数据list.add(Observable.just(4, 5, 6));// 使用amba()，这样仅发送先发送数据的Observable，即第二个Observable，第一个因为延迟，被丢弃Observable.amb(list) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, \"接收到了事件 \" + integer); &#125; &#125;); 123D/MainActivity5: 接收到了事件 4D/MainActivity5: 接收到了事件 5D/MainActivity5: 接收到了事件 6 3.10 defaultEmpty()作用：在不发送任何有效事件（Next事件）、仅发送Complete事件的前提下，发送一个默认值。 123456789101112131415Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; // 不发送任何事件，仅发送Complete事件 emitter.onComplete(); &#125;&#125;) // 仅发送Complete事件时，默认发送10 .defaultIfEmpty(10) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, \"接收到了事件\" + integer); &#125; &#125;); 1D/MainActivity5: 接收到了事件10 Demo地址：Allen_Demo_Rx","categories":[{"name":"Android","slug":"Android","permalink":"https://tylerLiu.top/categories/Android/"},{"name":"RxJava","slug":"Android/RxJava","permalink":"https://tylerLiu.top/categories/Android/RxJava/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"https://tylerLiu.top/tags/RxJava/"}]},{"title":"Android RxJava：过滤操作符","slug":"Android-RxJava：过滤操作符","date":"2019-08-19T03:27:09.000Z","updated":"2019-08-22T03:14:18.537Z","comments":true,"path":"2019/08/19/Android-RxJava：过滤操作符/","link":"","permalink":"https://tylerLiu.top/2019/08/19/Android-RxJava：过滤操作符/","excerpt":"","text":"1. 作用过滤/筛选Observable发送的事件和Observer接收的事件。 2. 类型RxJava中，过滤操作符的类型包括： 根据指定条件过滤事件：Filter()、ofType()、skip()、skipLast()、distinct()、distinctUntilChanged() 根据指定事件数量过滤事件：take()、takeLast() 根据指定事件过滤：throttleFirst()、throttleLast()、sample()、throttleWithTimeout()、debounce() 根据指定事件位置过滤事件：firstElement()、lastElement()、elementAt()、emelentAtOrErorr() 3. 讲解3.1 根据指定条件过滤作用：通过设置指定的过滤条件，当且仅当该事件满足条件时，就将该事件过滤（即不发送）。 操作符：Filter()作用：过滤特定条件的事件。 原理： 123456789101112131415161718192021222324252627282930313233343536373839404142Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; // 1. 发送5个事件 emitter.onNext(1); emitter.onNext(2); emitter.onNext(3); emitter.onNext(4); emitter.onNext(5); &#125;&#125;) // 采用filter()变换操作符 .filter(new Predicate&lt;Integer&gt;() &#123; // 根据test()的返回值，对被观察者发送的事件进行过滤并筛选 // a. 返回true，则继续发送 // b. 返回false，则不发送（过滤） @Override public boolean test(Integer integer) throws Exception &#123; // 过滤≤3的事件 return integer &gt; 3; &#125; &#125;).subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, \"开始采用subscribe连接\"); &#125; @Override public void onNext(Integer value) &#123; Log.d(TAG, \"过滤后得到的事件是：\" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, \"对Error事件作出响应\"); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"对Complete事件作出响应\"); &#125;&#125;); 123D/MainActivity4: 开始采用subscribe连接D/MainActivity4: 过滤后得到的事件是：4D/MainActivity4: 过滤后得到的事件是：5 操作符：ofType()作用：过滤特定数据类型的事件。 123456789Observable.just(1, \"Allen\", 3, \"liu\", 5) // 筛选出整型 .ofType(Integer.class) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, \"获取到的整型事件元素是： \" + integer); &#125; &#125;); 123D/MainActivity4: 获取到的整型事件元素是： 1D/MainActivity4: 获取到的整型事件元素是： 3D/MainActivity4: 获取到的整型事件元素是： 5 操作符：skip()和skipLast()作用：跳过某个事件 1234567891011121314151617181920212223242526// 使用1：根据顺序跳过数据项Observable.just(1, 2, 3, 4, 5) // 跳过正序的前一项 .skip(1) // 跳过正序的后两项 .skipLast(2) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, \"获取到的整型事件元素是： \" + integer); &#125; &#125;);// 使用2：根据时间跳过数据项// 发送数据0-5，每间隔1s发送一次，每次递增1，第一次发送延迟0sObservable.intervalRange(0, 5, 0, 1, TimeUnit.SECONDS) // 跳过第1s发送的数据 .skip(1, TimeUnit.SECONDS) // 跳过最后1s发送的数据 .skipLast(1, TimeUnit.SECONDS) .subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(Long aLong) throws Exception &#123; Log.d(TAG, \"获取到的整型事件元素是： \" + aLong); &#125; &#125;); 12345D/MainActivity4: 获取到的整型事件元素是： 2D/MainActivity4: 获取到的整型事件元素是： 3D/MainActivity4: 获取到的整型事件元素是： 1D/MainActivity4: 获取到的整型事件元素是： 2D/MainActivity4: 获取到的整型事件元素是： 3 操作符：distinct()和distinctUntilChanged()作用：过滤事件序列中重复的事件/连续重复的事件。 1234567891011121314151617181920// 使用1：过滤事件序列中重复的事件Observable.just(1, 2, 3, 1, 2) .distinct() .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, \"不重复的整型事件元素是： \" + integer); &#125; &#125;);// 使用2：过滤事件序列中 连续重复的事件// 下面序列中，连续重复的事件 = 3、4Observable.just(1, 2, 3, 1, 2, 3, 3, 4, 4) .distinctUntilChanged() .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, \"不连续重复的整型事件元素是： \" + integer); &#125; &#125;); 12345678910D/MainActivity4: 不重复的整型事件元素是： 1D/MainActivity4: 不重复的整型事件元素是： 2D/MainActivity4: 不重复的整型事件元素是： 3D/MainActivity4: 不连续重复的整型事件元素是： 1D/MainActivity4: 不连续重复的整型事件元素是： 2D/MainActivity4: 不连续重复的整型事件元素是： 3D/MainActivity4: 不连续重复的整型事件元素是： 1D/MainActivity4: 不连续重复的整型事件元素是： 2D/MainActivity4: 不连续重复的整型事件元素是： 3D/MainActivity4: 不连续重复的整型事件元素是： 4 3.2 根据指定事件数量过滤事件作用：通过设置指定的事件数量，仅发送特定数量的事件。 操作符：take()作用：指定观察者最多能接收到的事件数量原理： 123456789101112131415161718Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; // 发送5个事件 emitter.onNext(1); emitter.onNext(2); emitter.onNext(3); emitter.onNext(4); emitter.onNext(5); &#125;&#125;) // 采用take()操作符，指定观察者只能接收2个事件 .take(2).subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, \"过滤后得到的事件是：\" + integer); &#125;&#125;); 实际上，被观察者还是发送了5个事件，只是因为操作符的存在，拦截了3个事件，最终， 观察者只接收到了2个事件。 12D/MainActivity4: 过滤后得到的事件是：1D/MainActivity4: 过滤后得到的事件是：2 操作符：takeLast()作用：指定观察者只能接收到被观察者发送的最后几个事件。 123456789Observable.just(1, 2, 3, 4, 5) //指定观察者只能接受被观察者发送的3个事件 .takeLast(3) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, \"过滤后得到的事件是：\" + integer); &#125; &#125;); 123D/MainActivity4: 过滤后得到的事件是：3D/MainActivity4: 过滤后得到的事件是：4D/MainActivity4: 过滤后得到的事件是：5 3.3 根据指定事件过滤事件作用：通过设置指定的时间，仅发送在该时间内的事件。 操作符：throttleFirst()和throttlelast()作用：在某段时间内，只发送该段时间内第一次事件/最后一次事件。如，一段时间内连续点击按钮，但只执行第一次的点击事件。原理： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// 在某段时间内，只发送该段时间内第1次事件Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; // 隔段事件发送时间 e.onNext(1); Thread.sleep(500); e.onNext(2); Thread.sleep(400); e.onNext(3); Thread.sleep(300); e.onNext(4); Thread.sleep(300); e.onNext(5); Thread.sleep(300); e.onNext(6); Thread.sleep(400); e.onNext(7); Thread.sleep(300); e.onNext(8); Thread.sleep(300); e.onNext(9); Thread.sleep(300); e.onComplete(); &#125;&#125;) //每1秒中采用数据 .throttleFirst(1, TimeUnit.SECONDS) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, \"接收到了事件\" + integer); &#125; &#125;);// 在某段时间内，只发送该段时间内最后1次事件Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; // 隔段事件发送时间 e.onNext(1); Thread.sleep(500); e.onNext(2); Thread.sleep(400); e.onNext(3); Thread.sleep(300); e.onNext(4); Thread.sleep(300); e.onNext(5); Thread.sleep(300); e.onNext(6); Thread.sleep(400); e.onNext(7); Thread.sleep(300); e.onNext(8); Thread.sleep(300); e.onNext(9); Thread.sleep(300); e.onComplete(); &#125;&#125;) // 每1秒中采用数据 .throttleLast(1, TimeUnit.SECONDS) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, \"接收到了事件\" + integer); &#125; &#125;); 123456D/MainActivity4: 接收到了事件throttleFirst = 1D/MainActivity4: 接收到了事件throttleFirst = 4D/MainActivity4: 接收到了事件throttleFirst = 7D/MainActivity4: 接收到了事件throttleLast = 3D/MainActivity4: 接收到了事件throttleLast = 6D/MainActivity4: 接收到了事件throttleLast = 9 操作符：sample()作用：在某段时间内，只发送该段时间内最新一次事件，与throttleLast()操作符类似。使用方法就是把上文的throttleLast()改成sample()操作符即可。 操作符：throttleWithTimeOut()/debounce()作用：发送数据事件时，若2次发送事件的间隔 &lt; 指定时间，就会丢弃前一次的数据，直到指定时间内都没有新数据发射时才会发送后一次的数据。 12345678910111213141516171819202122232425262728293031323334Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; // 隔段事件发送时间 emitter.onNext(1); Thread.sleep(500); // 1和2之间的间隔小于指定时间1s，所以前1次数据（1）会被抛弃，2会被保留 emitter.onNext(2); Thread.sleep(1500); // 因为2和3之间的间隔大于指定时间1s，所以之前被保留的2事件将发出 emitter.onNext(3); Thread.sleep(1500); // 因为3和4之间的间隔大于指定时间1s，所以3事件将发出 emitter.onNext(4); Thread.sleep(500); // 因为4和5之间的间隔小于指定时间1s，所以前1次数据（4）会被抛弃，5会被保留 emitter.onNext(5); Thread.sleep(500); // 因为5和6之间的间隔小于指定时间1s，所以前1次数据（5）会被抛弃，6会被保留 emitter.onNext(6); Thread.sleep(1500); // 因为6和Complete实践之间的间隔大于指定时间1s，所以之前被保留的6事件将发出 emitter.onComplete(); &#125;&#125;) // 每1秒采用数据 .throttleWithTimeout(1, TimeUnit.SECONDS) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, \"接收到了事件\" + integer); &#125; &#125;); 123D/MainActivity4: 接收到了事件2D/MainActivity4: 接收到了事件3D/MainActivity4: 接收到了事件6 3.4 根据指定事件位置过滤事件作用：通过设置指定的位置，过滤在该位置的事件。 操作符：firstElement()/lastElement()作用：仅选取第一个元素/最后一个元素。 12345678910111213141516171819// 获取第1个元素Observable.just(1, 2, 3, 4, 5) .firstElement() .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, \"获取到的第一个事件是： \" + integer); &#125; &#125;);// 获取最后1个元素Observable.just(1, 2, 3, 4, 5) .lastElement() .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, \"获取到的最后1个事件是： \" + integer); &#125; &#125;); 12D/MainActivity4: 获取到的第一个事件： 1D/MainActivity4: 获取到的最后一个事件： 5 操作符：elementAt()作用：指定接收某个元素（通过索引值确定）。 允许越界，即获取的位置索引 &gt; 发送事件序列长度 1234567891011121314151617181920// 使用1：获取位置索引为2的元素// 位置索引从0开始Observable.just(1, 2, 3, 4, 5) .elementAt(2) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, \"使用1获取到的事件元素是： \" + integer); &#125; &#125;);// 使用2：获取的位置索引 ＞ 发送事件序列长度时，设置默认参数Observable.just(1, 2, 3, 4, 5) .elementAt(6, 10) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, \"使用2获取到的事件元素是： \" + integer); &#125; &#125;); 12D/MainActivity4: 使用1获取到的事件元素是： 3D/MainActivity4: 使用2获取到的事件元素是： 10 操作符：elementAtOrError()作用：在elementAt()的基础上，当出现越界情况（即获取的位置索引 &gt; 发送事件序列长度）时，抛出异常。 12345678Observable.just(1, 2, 3, 4, 5) .elementAtOrError(6) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept( Integer integer) throws Exception &#123; Log.d(TAG,\"获取到的事件元素是： \"+ integer); &#125; &#125;); 4. 实际开发需求在实际开发中，常见的过滤操作符实际需求场景有：功能防抖和联想搜索请求优化 4.1 功能防抖 背景：用户只需要使用功能1次 冲突：由于外部原因，多次触发了功能，导致出现冗余功能操作。 用户只需要使用网络请求功能一次（点击按钮）， 但由于外部网络不好，点击一次后用户发现无响应， 于是多次点击按钮，最终导致发出了多个网络请求。 解决方案：功能防抖，通过根据指定时间过滤事件的过滤操作符实现，防止功能的抖动。 具体使用可以看看后面的实例详解。 4.2 联想搜索优化 背景：实现联想搜索功能，即每当用户输入一个字符，即显示与当前输入框内字符相关的搜索结果。最基本的实现流程： 通过EditText.addTextChangedListener()监听输入框变化 当输入框发生变化后，回调afterTextChanged()将当前输入框的文字像服务器发起请求 服务器返回与该搜索文字关联的结果 冲突：在用户搜索需求明确的情况下（体现为连续输入），可能会发起一些不必要的网络请求。例子： 用户搜索需求明确 = abc，即连续输入了abc 按上面的实现，客户端会向服务器发起a、ab、abc三个网络请求 即，多发起了a、ab两个不必要的网络请求 解决方案：通过根据指定时间过滤事件的过滤操作符（debounce）实现，防止不必要的网络请求。原理： 当输入框发生变化时，不会立刻将当前输入框内的文字发送给服务器，而是等待一段时间； 若在这段时间内，输入框不再有文字输入（无发生变化），那么才发送输入框内的文字给服务器； 若在这段时间内，输入框有文字输入（有变化），则继续等待该段时间，循环上述过程。 具体使用可以看看后面的实例详解。 Demo地址：Allen_Demo_Rx","categories":[{"name":"Android","slug":"Android","permalink":"https://tylerLiu.top/categories/Android/"},{"name":"RxJava","slug":"Android/RxJava","permalink":"https://tylerLiu.top/categories/Android/RxJava/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"https://tylerLiu.top/tags/RxJava/"}]},{"title":"Android RxJava：线程控制","slug":"Android-RxJava：线程控制","date":"2019-08-17T09:23:39.000Z","updated":"2019-08-22T03:14:28.843Z","comments":true,"path":"2019/08/17/Android-RxJava：线程控制/","link":"","permalink":"https://tylerLiu.top/2019/08/17/Android-RxJava：线程控制/","excerpt":"","text":"1. 作用指定Observable/Observer的工作线程类型。 2. 原因2.1 背景在RxJava模型中，Observable/Observer的工作线程就是创建时所在的线程。如果创建Observable/Observer在主线程，则生产事件/接收和响应事件都发生在主线程。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class MainActivity extends AppCompatActivity &#123; private static final String TAG = \"Rxjava\"; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 步骤1：创建被观察者 Observable &amp; 发送事件 // 在主线程创建被观察者 Observable 对象 // 所以生产事件的线程是：主线程 Observable&lt;Integer&gt; observable = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; Log.d(TAG, \" 被观察者 Observable的工作线程是: \" + Thread.currentThread().getName()); // 打印验证 emitter.onNext(1); emitter.onComplete(); &#125; &#125;); // 步骤2：创建观察者 Observer 并 定义响应事件行为 // 在主线程创建观察者 Observer 对象 // 所以接收 &amp; 响应事件的线程是：主线程 Observer&lt;Integer&gt; observer = new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, \"开始采用subscribe连接\"); Log.d(TAG, \" 观察者 Observer的工作线程是: \" + Thread.currentThread().getName()); &#125; @Override public void onNext(Integer value) &#123; Log.d(TAG, \"对Next事件\"+ value +\"作出响应\" ); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, \"对Error事件作出响应\"); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"对Complete事件作出响应\"); &#125; &#125;; // 步骤3：通过订阅（subscribe）连接观察者和被观察者 observable.subscribe(observer); &#125;&#125; 2.2 冲突一般情况下，需要在子线程中去实现耗时操作，然后回到主线程实现UI操作。对应RxJava，可以理解为： Observable要在子线程中生产事件（如实现耗时操作等） Observer在主线程接收和响应事件（如实现UI操作） 2.3 解决方法为了解决上面的冲突，实现异步操作，就需要对RxJava进行线程控制（切换/调度） 3. 实现方式采用RxJava内置的线程调度器Scheduler，即通过功能型操作符subscribeOn()和observeOn()来实现。 3.1 subscribeOn和observeOn简介作用：线程控制，即指定被观察者Obserable和观察者Observer的工作线程类型 线程类型： 类型 含义 应用场景 Schedulers.immediate() 当前线程，不指定线程 默认 AndroidSchedulers.mainThread() Android主线程 操作UI Schedulers.newThread() 常规新线程 耗时等操作 Schedulers.io() IO操作线程 网络请求、读写文件等UI密集型操作 Schedulers.computation() CPU计算操作线程 大量计算操作 注：RxJava内部使用线程池来维护这些线程，所以线程的调度效率非常高。 3.2 具体使用具体是在（上面步骤3）通过订阅subscribe连接观察者和被观察者中实现： 123456789101112// 使用说明// Observable.subscribeOn（Schedulers.Thread）：指定被观察者 发送事件的线程（传入RxJava内置的线程类型）// Observable.observeOn（Schedulers.Thread）：指定观察者 接收 &amp; 响应事件的线程（传入RxJava内置的线程类型）// 实例使用// 步骤3：通过订阅（subscribe）连接观察者和被观察者// 1. 指定被观察者 生产事件的线程observable.subscribeOn(Schedulers.newThread()) // 2. 指定观察者接收和响应事件的线程 .observeOn(AndroidSchedulers.mainThread()) // 3. 最后再通过订阅（subscribe）连接观察者和被观察者 .subscribe(observer); 特别注意： 若Observable.subscribeOn()多次指定被观察者生产事件的线程，则只有第一次指定有效，其余的指定线程无效。 1234567observable // 第一次指定被观察者线程为新线程，有效 .subscribeOn(Schedulers.newThread()) // 第二次指定被观察者线程为主线程，无效 .subscribeOn(AndroidSchedulers.mainThread()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(observer); 若Observable.observeOn()多次指定Observer接收和响应事件的线程，则每次指定均有效，即没指定一次，就进行一次线程切换。 1234567891011121314observable.subscribeOn(Schedulers.newThread()) // 第一次指定观察者线程为主线程 .observeOn(AndroidSchedulers.mainThread()) // 生产事件 .doOnNext(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, \"第一次观察者Observer的工作线程是： \" + Thread.currentThread().getName()); &#125;&#125;) // 第二次指定观察者线程为新的工作线程 .observeOn(Schedulers.newThread()) // 生产事件 .subscribe(observer); 注： 整体方法调用顺序：观察者.onSubscribe() &gt; 被观察者.subscribe() &gt; 观察者.doOnNext() 观察者.onSubscribe()固定在主线程进行 4. Demo下面，采用Retrofit + RxJava实现网络请求功能，说明RxJava的线程控制的具体应用。 4.1 功能说明实现功能：将中文翻译成英文，并显示到界面实现方案：采用GET方法对金山词霸API发送网络请求 4.2 步骤说明 添加依赖 创建接收服务器返回数据的类 创建用于描述网络请求的接口（区别于传统形式） 创建Retrofit实例 创建网络请求接口实例并配置网络请求参数（区别于传统形式） 发送网络请求（区别于传统形式） 对返回数据进行处理 4.3 具体实现4.3.1 添加依赖1234567891011121314// Android 支持 RxJava// 此处一定要注意使用RxJava2的版本implementation 'io.reactivex.rxjava2:rxjava:2.2.7'implementation 'io.reactivex.rxjava2:rxandroid:2.1.0'// Android 支持 Retrofitimplementation 'com.squareup.retrofit2:retrofit:2.5.0'// 衔接 Retrofit &amp; RxJava// 此处一定要注意使用RxJava2的版本implementation 'com.jakewharton.retrofit:retrofit2-rxjava2-adapter:1.0.0'// 支持Gson解析implementation 'com.squareup.retrofit2:converter-gson:2.5.0' 权限： 1&lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt; 4.3.2 创建接收服务器返回数据的类金山词霸API数据格式说明： 1234567891011// URL模板http://fy.iciba.com/ajax.php// URL实例http://fy.iciba.com/ajax.php?a=fy&amp;f=auto&amp;t=auto&amp;w=hello%20world// 参数说明：// a：固定值 fy// f：原文内容类型，日语取 ja，中文取 zh，英语取 en，韩语取 ko，德语取 de，西班牙语取 es，法语取 fr，自动则取 auto// t：译文内容类型，日语取 ja，中文取 zh，英语取 en，韩语取 ko，德语取 de，西班牙语取 es，法语取 fr，自动则取 auto// w：查询内容 示例： 123456789101112&#123; \"status\": 1, \"content\": &#123; \"from\": \"en-EU\", \"to\": \"zh-CN\", \"vendor\": \"ciba_cnn\", \"out\": \"\\u4f60\\u597d\\u4e16\\u754c\", \"ciba_use\": \"\\u6765\\u81ea\\u673a\\u5668\\u7ffb\\u8bd1\\u3002\", \"ciba_out\": \"\", \"err_no\": 0 &#125;&#125; 创建的类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package com.ly.allendemorx;public class Translation &#123; /** * status : 1 * content : &#123;\"from\":\"en-EU\",\"to\":\"zh-CN\",\"vendor\":\"ciba_cnn\",\"out\":\"你好世界\",\"ciba_use\":\"来自机器翻译。\",\"ciba_out\":\"\", * \"err_no\":0&#125; */ private int status; private ContentBean content; public int getStatus() &#123; return status; &#125; public void setStatus(int status) &#123; this.status = status; &#125; public ContentBean getContent() &#123; return content; &#125; public void setContent(ContentBean content) &#123; this.content = content; &#125; public static class ContentBean &#123; /** * from : en-EU * to : zh-CN * vendor : ciba_cnn * out : 你好世界 * ciba_use : 来自机器翻译。 * ciba_out : * err_no : 0 */ private String from; private String to; private String vendor; private String out; private String ciba_use; private String ciba_out; private int err_no; public String getFrom() &#123; return from; &#125; public void setFrom(String from) &#123; this.from = from; &#125; public String getTo() &#123; return to; &#125; public void setTo(String to) &#123; this.to = to; &#125; public String getVendor() &#123; return vendor; &#125; public void setVendor(String vendor) &#123; this.vendor = vendor; &#125; public String getOut() &#123; return out; &#125; public void setOut(String out) &#123; this.out = out; &#125; public String getCiba_use() &#123; return ciba_use; &#125; public void setCiba_use(String ciba_use) &#123; this.ciba_use = ciba_use; &#125; public String getCiba_out() &#123; return ciba_out; &#125; public void setCiba_out(String ciba_out) &#123; this.ciba_out = ciba_out; &#125; public int getErr_no() &#123; return err_no; &#125; public void setErr_no(int err_no) &#123; this.err_no = err_no; &#125; &#125;&#125; 4.3.3 创建用于描述网络请求的接口采用注解 + Observable接口描述网络请求参数。 12345678910111213package com.ly.allendemorx;import io.reactivex.Observable;import retrofit2.http.GET;public interface GetRequest_Interface &#123; /** * 注解中传入网络请求部分的URL地址 * Retrofit将网络请求的URL分成两个部分：一是放在Retrofit对象里，另一是放在网络请求接口里 */ @GET(\"ajax.php?a=fy&amp;f=auto&amp;t=auto&amp;w=hi%20world\") Observable&lt;Translation&gt; getCall();&#125; 4.3.4 后面的步骤均可在Activity中实现，详见代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.ly.allendemorx;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.util.Log;import com.jakewharton.retrofit2.adapter.rxjava2.RxJava2CallAdapterFactory;import io.reactivex.Observable;import io.reactivex.Observer;import io.reactivex.android.schedulers.AndroidSchedulers;import io.reactivex.disposables.Disposable;import io.reactivex.schedulers.Schedulers;import retrofit2.Retrofit;import retrofit2.converter.gson.GsonConverterFactory;/** * @author Liuyang * @date 2019/8/19 */public class Main3Activity extends AppCompatActivity &#123; private static final String TAG = \"Allen\"; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main3); // 步骤4：创建Retrofit对象 Retrofit retrofit = new Retrofit.Builder() // 设置网络请求URL .baseUrl(\"http://fy.iciba.com/\") // 设置使用GSON解析 .addConverterFactory(GsonConverterFactory.create()) // 设置支持RxJava .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .build(); // 步骤5：创建网络请求接口实例 final GetRequest_Interface request = retrofit.create(GetRequest_Interface.class); // 步骤6：采用Observable&lt;...&gt;形式对网络请求进行封装 Observable&lt;Translation&gt; observable = request.getCall(); // 步骤7：发送网络请求 observable // 在IO线程进行网络请求 .subscribeOn(Schedulers.io()) // 回到主线程 处理请求结果 .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;Translation&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, \"开始采用subscribe连接\"); &#125; @Override public void onNext(Translation translation) &#123; // 步骤8：对返回的数据进行处理 if (translation != null) &#123; Log.d(TAG, \"结果 from：\" + translation.getContent().getFrom()); Log.d(TAG, \"结果 to：\" + translation.getContent().getTo()); Log.d(TAG, \"结果 vendor：\" + translation.getContent().getVendor()); Log.d(TAG, \"结果 out：\" + translation.getContent().getOut()); Log.d(TAG, \"结果 ciba_use：\" + translation.getContent().getCiba_use()); Log.d(TAG, \"结果 ciba_out：\" + translation.getContent().getCiba_out()); Log.d(TAG, \"结果 err_no：\" + translation.getContent().getErr_no()); &#125; &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, \"请求失败\"); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"请求成功\"); &#125; &#125;); &#125;&#125; 123456789D/Allen: 开始采用subscribe连接D/Allen: 结果 from：en-EUD/Allen: 结果 to：zh-CND/Allen: 结果 vendor：tencentD/Allen: 结果 out：嗨世界D/Allen: 结果 ciba_use：来自机器翻译。D/Allen: 结果 ciba_out：D/Allen: 结果 err_no：0D/Allen: 请求成功 地址：Allen_Demo_Rx 5. 程序崩溃问题背景：在发送网络请求时，退出当前Activity。冲突：此时如果回到主线程更新UI，APP会崩溃解决方案：当Activity退出时，调用Disposiable.dispose()切断观察者和被观察者之间的订阅，使得观察者无法接收到事件和响应事件。 当出现多个Disposiable时，可以采用RxJava内置容器CompositeDisposable进行统一管理。 12345// 添加Disposable到CompositeDisposable容器CompositeDisposable.add()// 清空CompositeDisposable容器CompositeDisposable.clear()","categories":[{"name":"Android","slug":"Android","permalink":"https://tylerLiu.top/categories/Android/"},{"name":"RxJava","slug":"Android/RxJava","permalink":"https://tylerLiu.top/categories/Android/RxJava/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"https://tylerLiu.top/tags/RxJava/"}]},{"title":"Android RxJava：功能性操作符","slug":"Android-RxJava：功能性操作符","date":"2019-08-16T06:48:26.000Z","updated":"2019-08-22T03:14:14.587Z","comments":true,"path":"2019/08/16/Android-RxJava：功能性操作符/","link":"","permalink":"https://tylerLiu.top/2019/08/16/Android-RxJava：功能性操作符/","excerpt":"","text":"1. 作用辅助被观察者Observable在发送事件时实现一些功能性需求，如错误处理、线程调度等。 2. 类型常用的功能性操作符： 连接被观察者和观察者：subscribe()，订阅 线程调度：subscribeOn()、observeOn() 延迟操作：delay() 在事件的生命周期中操作：do() 错误处理：即遇到错误时的机制，onErrorReturn()、onErrorResumeNext()、onExceptionResumeNext()、retry()、retryUntil()、retryWhen() 重复发起操作：repeat()、repeatWhen() 3. 详细说明3.1 连接被观察者和观察者作用：使被观察者和观察者形成订阅关系。 操作符：subscribe()具体例子看前面的就可以了。 3.2 线程调度作用：快速、方便指定和控制被观察者及观察者的工作线程。该部分在下一篇详细看看。 3.3 延迟操作：作用：使得被观察者延迟一段时间再发送事件。里面有多个重载方法： 12345678910111213141516// 指定延迟时间// @param delay 时间// @param unit 时间单位delay(long delay, TimeUnit unit)// 指定延迟时间和错误延迟// 如果出现Error事件，则先正常执行，执行结束之后，再抛出异常// @param delayError 错误延迟参数delay(long delay, TimeUnit unit, boolean delayError)// 指定延迟时间和调度器// @param scheduler 线程调度器delay(long delay, TimeUnit unit, Scheduler scheduler)// 指定延迟时间、调度器和错误延迟参数delay(long delay, TimeUnit unit, Scheduler scheduler, boolean delayError) 3.4 在事件的生命周期中操作作用：在事件发送和接收的整个生命周期过程中进行操作。如发送事件前的初始化、发送事件后的回调请求等。 操作符：do()作用：在某个事件的生命周期中调用。do()操作符包含以下： 当Observable每发送一次数据事件，就会调用一次。doOnEach()，含onNext()、onError()和onComplete() Next事件 执行Next事件前调用：doOnNext() 执行Next事件后调用：doAfterNext() 发送事件完毕后调用 发送错误事件时：doOnError() 正常发送事件完毕后：doOnCompleted() 无论正常发送/异常终止：doOnTeriminate() 最后执行：doFinaly() 订阅相关 观察者订阅时调用：doOnSubscribe() 观察者取消订阅时调用：doOnUnsubscribe() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; emitter.onNext(1); emitter.onNext(2); emitter.onNext(3); emitter.onError(new Throwable(\"发生错误\")); &#125;&#125;) // 当Observable每发送一次数据事件，就调用一次 .doOnEach(new Consumer&lt;Notification&lt;Integer&gt;&gt;() &#123; @Override public void accept(Notification&lt;Integer&gt; integerNotification) throws Exception &#123; Log.d(TAG, \"doOnEach: \" + integerNotification.getValue()); &#125; &#125;) // 执行Next事件前执行 .doOnNext(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, \"doOnNext: \" + integer); &#125; &#125;) // 执行Next事件后执行 .doAfterNext(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, \"doAfterNext: \" + integer); &#125; &#125;) // Observable正常发送事件结束后调用 .doOnComplete(new Action() &#123; @Override public void run() throws Exception &#123; Log.d(TAG, \"doOnComplete: \"); &#125; &#125;) // Observable发送错误事件时调用 .doOnError(new Consumer&lt;Throwable&gt;() &#123; @Override public void accept(Throwable throwable) throws Exception &#123; Log.d(TAG, \"doOnError: \" + throwable.getMessage()); &#125; &#125;) // 观察者订阅时调用 .doOnSubscribe(new Consumer&lt;Disposable&gt;() &#123; @Override public void accept(Disposable disposable) throws Exception &#123; Log.d(TAG, \"doOnSubscribe: \"); &#125; &#125;) // Observable发送事件结束后调用，无论正常发送完毕还是异常终止 .doAfterTerminate(new Action() &#123; @Override public void run() throws Exception &#123; Log.d(TAG, \"doAfterTerminate: \"); &#125; &#125;) // 最后执行 .doFinally(new Action() &#123; @Override public void run() throws Exception &#123; Log.d(TAG, \"doFinally: \"); &#125; &#125;).subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Integer integer) &#123; Log.d(TAG, \"接收到了事件\" + integer); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, \"对Error事件作出响应\"); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"对Complete事件作出响应\"); &#125;&#125;); 3.5 错误处理作用：发送事件过程中，遇到错误时的处理机制。 常用的操作符： 发送数据 发送一个特殊的事件并正常终止：onErrorReturn() 发送一个新的Observable：onErrorResumeNext()、onExceptionResumeNext() 重试 重试：retry() 让Observable重新订阅：retryUntil() 将错误传递给另一个Observable，来决定是否要重新订阅该Observable：retryWhen() 操作符：onErrorReturn()作用：遇到错误时，发送一个特殊事件并正常终止，可以捕获在它之前发生的异常。 123456789101112131415161718192021222324252627282930313233343536Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; emitter.onNext(1); emitter.onNext(2); emitter.onError(new Throwable(\"发生错误了\")); &#125;&#125;).onErrorReturn(new Function&lt;Throwable, Integer&gt;() &#123; @Override public Integer apply(Throwable throwable) throws Exception &#123; // 捕捉错误异常 Log.e(TAG, \"在onErrorReturn处理了错误: \" + throwable.toString()); // 发生错误事件后，发送一个\"666\"事件，最终正常结束 return 666; &#125;&#125;).subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Integer value) &#123; Log.d(TAG, \"接收到了事件\" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, \"对Error事件作出响应\"); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"对Complete事件作出响应\"); &#125;&#125;); 操作符：onErrorResumeNext()作用：遇到错误时，发送一个新的Observable。 注： onErrorResumeNext()拦截的错误为Throwable；若需拦截Exception，要用onExceptionResumeNext() 若onErrorResumeNext()拦截的错误为Exception，则会将错误传递给观察者的onError()方法 123456789101112131415161718192021222324252627282930313233343536373839Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onError(new Throwable(\"发生错误了\")); &#125;&#125;).onErrorResumeNext(new Function&lt;Throwable, ObservableSource&lt;? extends Integer&gt;&gt;() &#123; @Override public ObservableSource&lt;? extends Integer&gt; apply(@NonNull Throwable throwable) throws Exception &#123; // 1. 捕捉错误异常 Log.e(TAG, \"在onErrorReturn处理了错误: \" + throwable.toString()); // 2. 发生错误事件后，发送一个新的被观察者 &amp; 发送事件序列 return Observable.just(11, 22); &#125;&#125;).subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Integer value) &#123; Log.d(TAG, \"接收到了事件\" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, \"对Error事件作出响应\"); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"对Complete事件作出响应\"); &#125;&#125;); 操作符：onExceptionResumeNext()作用：遇到错误时，发送一个新的Observable。 注： onExceptionResumeNext()拦截的错误为Exception；若需拦截Throwable，要用onErrorResumeNext() 若onExceptionResumeNext()拦截的错误为Throwable，则会将错误传递给观察者的onError()方法 1234567891011121314151617181920212223242526272829303132333435Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onError(new Exception(\"发生错误了\")); &#125;&#125;).onExceptionResumeNext(new Observable&lt;Integer&gt;() &#123; @Override protected void subscribeActual(Observer&lt;? super Integer&gt; observer) &#123; observer.onNext(11); observer.onNext(22); observer.onComplete(); &#125;&#125;).subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Integer value) &#123; Log.d(TAG, \"接收到了事件\" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, \"对Error事件作出响应\"); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"对Complete事件作出响应\"); &#125;&#125;); 操作符：retry()作用：重试，当出现错误时，让被观察者oBservable重新发送数据 接收到onError()时，重新订阅并发送事件 Throwable和Exception都可拦截 12345678910111213141516171819// 出现错误时，让被观察者重新发送数据，若一直出现错误，就一直重新发送retry()// 出现错误时，让被观察者重新发送数据，有重试次数限制// @param times 重试次数retry(long times)// 出现错误时，判断是否需要重新发送数据，若需要重新发送，且持续遇到错误，则持续重试// @param predicate 判断逻辑retry(Predicate&lt;? super Throwable&gt; predicate)// 出现错误时，判断是否需要重新发送数据，若需要重新发送，且持续遇到错误，则持续重试// @param predicate 判断逻辑，传入当前重试次数和异常错误信息retry(BiPredicate&lt;? super Integer, ? super Throwable&gt; predicate)// 出现错误时，判断是否需要重新发送数据，若需要重新发送，且持续遇到错误，则持续重试// @param times 重试次数// @param predicate 判断逻辑retry(long times, Predicate&lt;? super Throwable&gt; predicate) 前面的三个方法很简单，看看后面两个方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; emitter.onNext(1); emitter.onNext(2); emitter.onError(new Exception(\"发生错误了\")); emitter.onNext(3); &#125;&#125;) // 拦截错误后，判断是否需要重新发送请求 .retry(new BiPredicate&lt;Integer, Throwable&gt;() &#123; @Override public boolean test(Integer integer, Throwable throwable) throws Exception &#123; // 捕获异常 Log.e(TAG, \"异常错误 = \" + throwable.toString()); // 获取当前重试次数 Log.e(TAG, \"当前重试次数 = \" + integer); //返回false：不重新重新发送数据 &amp; 调用观察者的onError结束 //返回true：重新发送请求（若持续遇到错误，就持续重新发送） return true; &#125; &#125;).subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Integer value) &#123; Log.d(TAG, \"接收到了事件\" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, \"对Error事件作出响应\"); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"对Complete事件作出响应\"); &#125;&#125;);Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onError(new Exception(\"发生错误了\")); e.onNext(3); &#125;&#125;) // 拦截错误后，判断是否需要重新发送请求 .retry(3, new Predicate&lt;Throwable&gt;() &#123; @Override public boolean test(@NonNull Throwable throwable) throws Exception &#123; // 捕获异常 Log.e(TAG, \"retry错误: \" + throwable.toString()); //返回false：不重新重新发送数据 &amp; 调用观察者的onError（）结束 //返回true：重新发送请求（最多重新发送3次） return true; &#125; &#125;).subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Integer value) &#123; Log.d(TAG, \"接收到了事件\" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, \"对Error事件作出响应\"); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"对Complete事件作出响应\"); &#125;&#125;); 操作符：retryUntil()作用：出现错误后，判断是否需要重新发送数据 若需要重新发送，且持续遇到错误，则持续重试 作用类似于：retry(Predicate predicate) 具体使用类似于retry(Predicate predicate)，唯一区别是：返回true，则不重新发送数据事件。 操作符：retryWhen()作用：遇到错误时，将发生的错误传递给一个新的被观察者Observable，并决定是否需要重新订阅原始被观察者并发送事件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onError(new Exception(\"发生错误了\")); e.onNext(3); &#125;&#125;) // 遇到Error事件才会回调 .retryWhen(new Function&lt;Observable&lt;Throwable&gt;, ObservableSource&lt;?&gt;&gt;() &#123; @Override public ObservableSource&lt;?&gt; apply(Observable&lt;Throwable&gt; throwableObservable) throws Exception &#123; // 参数Observable&lt;Throwable&gt;中的泛型为上游操作抛出的异常，可通过该条件来判断异常的类型 // 返回ObservableSource&lt;?&gt;，为新的被观察者Observable，可以是任意类型的 // 这里有两种处理方式： // 1. 若新的Observable发送的事件为Error事件，那么原始Observable则不重新发送事件 // 2. 若新的Observable发送的事件为Next事件，那么原始Observable则重新发送事件 return throwableObservable.flatMap(new Function&lt;Throwable, ObservableSource&lt;?&gt;&gt;() &#123; @Override public ObservableSource&lt;?&gt; apply(Throwable throwable) throws Exception &#123; // 1. 若返回的Observable发送事件为Error事件，那么原始的Observable则不重新发送事件. // 该异常错误信息可以在观察者中的onError()中获得 return Observable.error(new Throwable(\"retryWhen终止\")); // 2. 若新的Observable发送的事件为Next事件，那么原始Observable则重新发送事件， // 若持续遇到错误，则持续重试 // return Observable.just(1); &#125; &#125;); &#125; &#125;).subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Integer value) &#123; Log.d(TAG, \"接收到了事件\" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, \"对Error事件作出响应\" + e.toString()); // 获取异常错误信息 &#125; @Override public void onComplete() &#123; Log.d(TAG, \"对Complete事件作出响应\"); &#125;&#125;); 情况1： 情况2： 3.6 重复发送作用：重复不断地发送被观察者事件操作符：repeat和repeatWhen() 操作符：repeat()作用：无条件、重复发送被观察者事件，具备重载方法，可设置重复创建次数。 123456789101112131415161718192021222324Observable.just(1, 2, 3, 4) // 重复创建3次 .repeat(3) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, \"开始采用subscribe连接\"); &#125; @Override public void onNext(Integer value) &#123; Log.d(TAG, \"接收到了事件\" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, \"对Error事件作出响应\"); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"对Complete事件作出响应\"); &#125; &#125;); 注： 接收到onComplete(0事件后，触发重新订阅和发送 默认运行在一个新的线程上 操作符：repeatWhen()作用：有条件地、重复发送被观察者事件原理：将原始Observable停止发送事件的标识（Complete()/Error()）转换成一个Object类型数据传递给一个新的Observable，以此决定是否重新订阅和发送原来的Observable。 如果新的Observable返回一个Complete/Error事件，则不重新订阅和发送原来的Observable 如果新的Observable返回其余事件时，则重新订阅并发送原来的Observable 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950Observable.just(1, 2, 4).repeatWhen(new Function&lt;Observable&lt;Object&gt;, ObservableSource&lt;?&gt;&gt;() &#123; @Override // 在Function函数中，必须对输入的 Observable&lt;Object&gt;进行处理，这里使用的是flatMap操作符接收上游的数据 public ObservableSource&lt;?&gt; apply(@NonNull Observable&lt;Object&gt; objectObservable) throws Exception &#123; // 将原始Observable停止发送事件的标识（Complete()/Error()）转换成一个Object类型数据传递给一个新的Observable // 以此决定是否重新订阅和发送原来的Observable // 此处有2种情况： // 1. 若新的Observable返回一个Complete()/Error()事件，则不重新订阅和发送原来的Observable // 2. 若新的Observable返回其余事件，则重新订阅并发送原来的Observable return objectObservable.flatMap(new Function&lt;Object, ObservableSource&lt;?&gt;&gt;() &#123; @Override public ObservableSource&lt;?&gt; apply(@NonNull Object throwable) throws Exception &#123; // 1. 若新的Observable返回一个Complete()/Error()事件，则不重新订阅和发送原来的Observable // Observable.empty()则发送Complete事件，但不会回调观察者的onComplete() return Observable.empty(); // 返回Error事件则回调onError()事件，并接收传过去的错误信息 // return Observable.error(new Throwable(\"不再重新订阅事件\")); // 2. 若新的Observable返回其余事件，则重新订阅并发送原来的Observable // 仅仅是作为一个触发重新订阅被观察者的通知，发送的是什么数据并不重要，只要不是Complete()/Error()事件 // return Observable.just(1); &#125; &#125;); &#125;&#125;).subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, \"开始采用subscribe连接\"); &#125; @Override public void onNext(Integer value) &#123; Log.d(TAG, \"接收到了事件\" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, \"对Error事件作出响应：\" + e.toString()); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"对Complete事件作出响应\"); &#125;&#125;); 4. 实际开发需求 线程操作，如切换/调度/控制 轮询 发送网络请求时的差错重试机制 4.1 线程操作详细请看下一篇。 4.2 轮询实例讲解中会有一篇结合Retrofit，实现轮询。 4.3 发送网络请求时的差错重试机制实例讲解中会有一篇结合Retrofit，实现该功能。","categories":[{"name":"Android","slug":"Android","permalink":"https://tylerLiu.top/categories/Android/"},{"name":"RxJava","slug":"Android/RxJava","permalink":"https://tylerLiu.top/categories/Android/RxJava/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"https://tylerLiu.top/tags/RxJava/"}]},{"title":"Android RxJava：组合/合并操作符","slug":"Android-RxJava：组合-合并操作符","date":"2019-08-15T07:51:51.000Z","updated":"2019-08-22T03:14:33.096Z","comments":true,"path":"2019/08/15/Android-RxJava：组合-合并操作符/","link":"","permalink":"https://tylerLiu.top/2019/08/15/Android-RxJava：组合-合并操作符/","excerpt":"","text":"1. 作用组合多个被观察者Observable，合并需要发送的事件。 2. 类型RxJava中常见的组合/合并操作符： 组合多个被观察者 按发送顺序：concat()、concatArray() 按时间：merge()、mergeArray() 错误处理：concatDelatError()、mergeDelayError() 合并多个事件 按数量：zip() 按时间：combineLatest()、combineLatestError() 合并成一个事件发送：reduce()、collect() 发送事件前追加发送事件：startWith()、startWithArray() 统计发送事件数量：count() 3. 详细说明3.1 组合多个被观察者该类型操作符的作用：组合多个被观察者。 concat()/concatArray()作用：组合多个被观察者一起发送数据，合并后按发送顺序串行执行。二者区别：组合被观察者的数量不同，concat()为≤4和，concatArray()为＞4个。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152Observable.concat(Observable.just(1, 2, 3), Observable.just(4, 5, 6), Observable.just(7, 8, 9), Observable.just(10, 11, 12)) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Integer value) &#123; Log.d(TAG, \"接收到了事件\" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, \"对Error事件作出响应\"); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"对Complete事件作出响应\"); &#125; &#125;);Observable.concatArray(Observable.just(1, 2, 3), Observable.just(4, 5, 6), Observable.just(7, 8, 9), Observable.just(10, 11, 12), Observable.just(13, 14, 15)) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Integer value) &#123; Log.d(TAG, \"接收到了事件\" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, \"对Error事件作出响应\"); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"对Complete事件作出响应\"); &#125; &#125;); merge()/mergeArray()作用：组合多个被观察者一起发送数据，合并后按时间线并行执行。二者区别：组合被观察者的数量不同，merge()为≤4和，mergeArray()为＞4个。与concat()的区别：合并后执行的方式不同。 123456789101112131415161718192021222324Observable.merge( Observable.intervalRange(0, 3, 1, 1, TimeUnit.SECONDS), Observable.intervalRange(2, 3, 1, 1, TimeUnit.SECONDS)).subscribe(new Observer&lt;Long&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Long value) &#123; Log.d(TAG, \"接收到了事件\" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, \"对Error事件作出响应\"); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"对Complete事件作出响应\"); &#125;&#125;); 操作符：concatDelayError()/megerDelayError()作用： 背景：使用concat()和meger()操作符时，若其中一个b被观察者发出onError()事件，则会马上终止其他被观察者继续发送事件，造成冲突。 解决方案：若希望onError()事件推迟到其他被观察者发送事件结束之后触发，需要使用对用的concatDelayError()或megerDelayError()。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768Observable.concat( Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; emitter.onNext(1); emitter.onNext(2); emitter.onNext(3); // 发送Error事件，因为无使用concatDelayError，所以第2个Observable将不会发送事件 emitter.onError(new NullPointerException()); emitter.onComplete(); &#125; &#125;), Observable.just(4, 5, 6)) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Integer value) &#123; Log.d(TAG, \"接收到了事件\" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, \"对Error事件作出响应\"); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"对Complete事件作出响应\"); &#125; &#125;);Observable.concatArrayDelayError( Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; emitter.onNext(1); emitter.onNext(2); emitter.onNext(3); // 发送Error事件，因为使用了concatDelayError，所以第2个Observable将会发送事件，等发送完毕后，再发送错误事件 emitter.onError(new NullPointerException()); emitter.onComplete(); &#125; &#125;), Observable.just(4, 5, 6)) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Integer value) &#123; Log.d(TAG, \"接收到了事件\" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, \"对Error事件作出响应\"); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"对Complete事件作出响应\"); &#125; &#125;); 3.2 合并多个事件该类型的操作符主要是对多个被观察者中的事件进行合并处理。 操作符：zip()作用：合并多个被观察者Observable发送的事件，生成一个新的事件序列（即组合之后的事件序列），并发送。 原理： 特别注意： 事件组合方式：严格按照原先事件序列进行对位合并 最终合并的事件数量：多个被观察者Observable中数量最少的数量 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// 创建1个被观察者Observable&lt;Integer&gt; observable1 = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; Log.d(TAG, \"被观察者1发送了事件1\"); emitter.onNext(1); // 为了方便展示效果，所以在发送事件后加入2s的延迟 Thread.sleep(1000); Log.d(TAG, \"被观察者1发送了事件2\"); emitter.onNext(2); Thread.sleep(1000); Log.d(TAG, \"被观察者1发送了事件3\"); emitter.onNext(3); Thread.sleep(1000); emitter.onComplete(); &#125;&#125;) // 设置被观察者1在工作线程1中工作 .subscribeOn(Schedulers.io());// 创建第2个被观察者Observable&lt;String&gt; observable2 = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123; Log.d(TAG, \"被观察者2发送了事件A\"); emitter.onNext(\"A\"); Thread.sleep(1000); Log.d(TAG, \"被观察者2发送了事件B\"); emitter.onNext(\"B\"); Thread.sleep(1000); Log.d(TAG, \"被观察者2发送了事件C\"); emitter.onNext(\"C\"); Thread.sleep(1000); Log.d(TAG, \"被观察者2发送了事件D\"); emitter.onNext(\"D\"); Thread.sleep(1000); emitter.onComplete(); &#125;&#125;) // 设置被观察者2在工作线程2中工作 .subscribeOn(Schedulers.newThread());// 如果不做线程控制，两个被观察者会在同一个线程上工作，即发送事件存在先后顺序，而不是通同时发送。// 使用zip操作符进行事件合并// 创建BiFunction对象传入的第三个参数为合并后数据的数据类型Observable.zip(observable1, observable2, new BiFunction&lt;Integer, String, String&gt;() &#123; @Override public String apply(Integer integer, String s) throws Exception &#123; return integer + s; &#125;&#125;).subscribe(new Observer&lt;String&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, \"onSubscribe\"); &#125; @Override public void onNext(String value) &#123; Log.d(TAG, \"最终接收到的事件 = \" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, \"onError\"); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"onComplete\"); &#125;&#125;); 特别注意： 尽管被观察者2的事件D没有合并，但是还是会继续发送； 如果在被观察者1和被观察者2的事件序列最后发送onComplete()事件，则被观察者2的事件D也不会发送。 zip()总结： 定义：属于RxJava2中的组合/合并操作符 作用： 合并多个被观察者Observable发送的事件 生成一个新的事件序列，并发送 原理： 事件组合方式：严格按照原先事件序列进行对位合并 最终合并的事件数量：多个被观察者Observable中数量最少的数量 应用场景： 当需要展示的信息需要从多个地方获取，且要统一结合后再展示 如合并互联网请求的发送，并统一显示结果：Retrofit结合RxJava 操作符：combineLatest()作用：当两个Observable中的任何一个发送数据之后，将先发送数据的Observable的最新（最后）一个数据与另一个Observable发送的每个数据结合，最后基于该函数的结果发送数据。 与zip()的区别：zip()是按个数合并，一对一的合并；combineLatest()是按时间合并，即再同一个时间点上合并。 123456789101112131415161718Observable.combineLatest(Observable.just(1L, 2L, 3L), Observable.intervalRange(0, 3, 1, 1, TimeUnit.SECONDS), new BiFunction&lt;Long, Long, Long&gt;() &#123; @Override public Long apply(Long aLong1, Long aLong2) throws Exception &#123; // aLong1：第1个Observable发送的最新（最后）1个数据 // aLong2：第2个Observable发送的每1个数据 Log.e(TAG, \"合并的数据是： \" + aLong1 + \" \" + aLong2); // 合并的逻辑：相加 // 即第一个Observable发送的最后一个数据与第二个Observable发送的每个数据相加 return aLong1 + aLong2; &#125; &#125;).subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(Long s) throws Exception &#123; Log.e(TAG, \"合并的结果是： \" + s); &#125;&#125;); 操作符：combingLatestDelayError()类似concatDelayError()和mergeDelayError()，即错误处理，这里不再多做讲解。 操作符：reduce()作用：将被观察者需要发送的事件聚合成一个事件发送。 聚合的逻辑根据需求编写，但本质都是前两个数据聚合，然后与后一个数据继续进行聚合，依次类推。 12345678910111213141516Observable.just(1, 2, 3, 4) .reduce(new BiFunction&lt;Integer, Integer, Integer&gt;() &#123; // 在复写方法中加入聚合逻辑 @Override public Integer apply(Integer integer1, Integer integer2) throws Exception &#123; Log.e(TAG, \"本次计算的数据是： \" + integer1 + \" 乘 \" + integer2); // 本次聚合的逻辑是：全部数据相乘起来 // 原理：第1次取前2个数据相乘，之后每次获取到的数据 = 返回的数据x原始下1个数据每 return integer1 * integer2; &#125; &#125;).subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.e(TAG, \"最终计算的结果是： \" + integer); &#125;&#125;); 操作符：collect()作用：将被观察者Observable发送的数据事件收集到一个数据结构里。 1234567891011121314151617181920Observable.just(1, 2, 3, 4, 5, 6).collect( // 创建数据结构（容器），用于收集被观察者发送的数据 new Callable&lt;ArrayList&lt;Integer&gt;&gt;() &#123; @Override public ArrayList&lt;Integer&gt; call() throws Exception &#123; return new ArrayList&lt;&gt;(); &#125; &#125;, // 对发送的数据进行收集 new BiConsumer&lt;ArrayList&lt;Integer&gt;, Integer&gt;() &#123; @Override public void accept(ArrayList&lt;Integer&gt; integers, Integer integer) throws Exception &#123; integers.add(integer); &#125; &#125;).subscribe(new Consumer&lt;ArrayList&lt;Integer&gt;&gt;() &#123; @Override public void accept(ArrayList&lt;Integer&gt; integers) throws Exception &#123; Log.e(TAG, \"本次发送的数据是： \" + integers); &#125;&#125;); 3.3 发送事件前追加发送事件操作符：startWith()/startWithArray()作用：在一个被观察者发送事件之前，追加发送一些数据或者一个新的被观察者。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 在一个被观察者发送事件之前，追加发送一些数据// 注：追加数据顺序为后调用先追加Observable.just(4, 5, 6) .startWith(0) .startWithArray(1, 2, 3) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Integer value) &#123; Log.d(TAG, \"接收到了事件\" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, \"对Error事件作出响应\"); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"对Complete事件作出响应\"); &#125; &#125;);// 在一个被观察者发送事件之前，追加发送一个被观察者并发送Observable.just(4, 5, 6) .startWith(Observable.just(1, 2, 3)) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Integer value) &#123; Log.d(TAG, \"接收到了事件\" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, \"对Error事件作出响应\"); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"对Complete事件作出响应\"); &#125; &#125;); 3.4 统计发送事件数量操作符：count()作用：统计被观察者发送事件的数量。 123456789// 注：返回结果 = Long类型Observable.just(1, 2, 3, 4) .count() .subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(Long aLong) throws Exception &#123; Log.e(TAG, \"发送的事件数量 = \" + aLong); &#125; &#125;);","categories":[{"name":"Android","slug":"Android","permalink":"https://tylerLiu.top/categories/Android/"},{"name":"RxJava","slug":"Android/RxJava","permalink":"https://tylerLiu.top/categories/Android/RxJava/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"https://tylerLiu.top/tags/RxJava/"}]},{"title":"Android RxJava：变换操作符","slug":"Android-RxJava：变换操作符","date":"2019-08-15T03:06:52.000Z","updated":"2019-08-22T03:14:09.001Z","comments":true,"path":"2019/08/15/Android-RxJava：变换操作符/","link":"","permalink":"https://tylerLiu.top/2019/08/15/Android-RxJava：变换操作符/","excerpt":"","text":"1. 作用对事件序列中的事件/整个事件序列进行加工处理（即变换），使得其转变成不同的事件/整个事件序列。 基础原理： 使用变换操作符（针对事件）： 使用变换操作符（针对事件序列）： 2. 类型常见的变换操作符： Map() FlatMap() ContactMap() Buffer() 3. 详细说明3.1 Map()作用：对被观察者发送的每个事件都通过指定函数处理，从而变成另一个事件。即，将被观察者发送的事件转换为任意类型的事件。 应用场景：数据类型转换 12345678910111213141516171819202122Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; // 被观察者发送事件：整型 emitter.onNext(1); emitter.onNext(2); emitter.onNext(3); &#125;&#125;) // 使用Mapj变换操作符中的Function函数，对被观察者发送的事件进行统一变换，整型变成字符串类型 .map(new Function&lt;Integer, String&gt;() &#123; @Override public String apply(Integer integer) throws Exception &#123; return \"使用Map变换操作符，将事件\" + integer + \"的参数从整型\" + integer + \" 变换成字符串类型\" + integer; &#125; &#125;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; // 被观察者接收事件时，是接收到变换后的事件 Log.i(TAG, s); &#125;&#125;); 3.2 FlatMap()作用：将被观察者发送的事件序列进行拆分和单独转换，再合并成一个新的事件序列，最后再进行发送。 原理： 为事件序列中的每个事件都创建一个Observable对象 将对每个原始事件转换后的新事件都放入到对应的Observable对象 将新建的每个Observable都合并到一个新建的、总的Observable对象 新建的、总的Observable对象将新合并的事件序列发送给观察者Observer 应用场景：无序的将被观察者发送的整个事件序列进行变换 1234567891011121314151617181920212223242526Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; emitter.onNext(1); emitter.onNext(2); emitter.onNext(3); &#125;&#125;) // 采用flatMap（）变换操作符 .flatMap(new Function&lt;Integer, ObservableSource&lt;String&gt;&gt;() &#123; @Override public ObservableSource&lt;String&gt; apply(Integer integer) throws Exception &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int j = 0; j &lt; 3; j++) &#123; // 通过flatMap中将被观察者生成的事件序列先进行拆分，再将每个事件转换为一个新的发送三个String事件 // 最终合并，再发送给被观察者 list.add(\"我是事件 \" + integer + \"拆分后的子事件\" + i); &#125; return Observable.fromIterable(list); &#125; &#125;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; Log.d(TAG, s); &#125;&#125;); 注：新合并的事件序列顺序是无序的，与旧序列发送事件的顺序无关。 3.3 ContactMap()作用：与FlatMap()类似，区别在于：拆分及重新合并生成的事件序列的顺序就是被观察者旧序列生产的序列。 应用场景：有序的将被观察者发送的整个事件序列进行变换。 1234567891011121314151617181920212223242526Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; emitter.onNext(1); emitter.onNext(2); emitter.onNext(3); &#125;&#125;) // 采用concatMap()变换操作符 .concatMap(new Function&lt;Integer, ObservableSource&lt;String&gt;&gt;() &#123; @Override public ObservableSource&lt;String&gt; apply(Integer integer) throws Exception &#123; final List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 3; i++) &#123; // 通过concatMap中将被观察者生产的事件序列先进行拆分，再将每个事件转换为一个新的发送三个String事件 // 最终合并，再发送给被观察者 list.add(\"我是事件 \" + integer + \"拆分后的子事件\" + i); &#125; return Observable.fromIterable(list); &#125; &#125;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; Log.d(TAG, s); &#125;&#125;); 注：新合并的事件序列顺序是有序的，即严格按照旧序列发送事件的顺序。 3.4 Buffer()作用：定期从被观察者Observable需要发送的事件中获取一定数量的事件并放到缓存区中，最终发送。 原理： 应用场景：缓存被观察者发送的事件 Bufer()每次获取多少个事件放到缓存区中呢？下面看一个例子： 12345678910111213141516171819202122232425262728293031// 被观察者需要发送5个数字Observable.just(1, 2, 3, 4, 5) // 设置缓存区大小和步长 // 缓存区大小：每次从被观察者中获取的事件数量 // 步长：每次获取新事件的数量 .buffer(3, 1) .subscribe(new Observer&lt;List&lt;Integer&gt;&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(List&lt;Integer&gt; stringList) &#123; // Log.d(TAG, \" 缓存区里的事件数量 = \" + stringList.size()); for (Integer value : stringList) &#123; Log.d(TAG, \" 事件 = \" + value); &#125; &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, \"对Error事件作出响应\"); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"对Complete事件作出响应\"); &#125; &#125;); 过程解释： Demo地址：Allen_Demo_Rx","categories":[{"name":"Android","slug":"Android","permalink":"https://tylerLiu.top/categories/Android/"},{"name":"RxJava","slug":"Android/RxJava","permalink":"https://tylerLiu.top/categories/Android/RxJava/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"https://tylerLiu.top/tags/RxJava/"}]},{"title":"香煎土豆片","slug":"香煎土豆片","date":"2019-08-13T03:11:28.000Z","updated":"2019-08-13T03:14:07.585Z","comments":true,"path":"2019/08/13/香煎土豆片/","link":"","permalink":"https://tylerLiu.top/2019/08/13/香煎土豆片/","excerpt":"","text":"食材土豆一个、豆瓣酱一勺、食用盐少许、生抽一勺、白芝麻一勺、孜然粉少许、香菜一根、小葱一根、蒜3瓣 步骤 土豆削皮洗净，切成均匀的片，不要太薄 把切好的土豆片放在清水中泡一下，去掉一部分淀粉，热量更低，将泡好的土豆片水沥干，或者用厨房用纸擦去表面的水分 将蒜、香菜切碎 锅里放油，把土豆片两面煎黄 将煎好的土豆片盛出备用 锅里留少许油，放入辣椒酱、大蒜爆炒出香味 加入土豆片 加入生抽、加适量清水焖煮土豆片能使其嫩香、熟透，并且稀释残留淀粉 最后加入孜然粉、白芝麻，小葱、香菜翻炒均匀 喜欢吃麻辣的，多加一些辣椒和花椒，鲜香麻辣，非常下饭","categories":[{"name":"美食","slug":"美食","permalink":"https://tylerLiu.top/categories/美食/"}],"tags":[{"name":"美食","slug":"美食","permalink":"https://tylerLiu.top/tags/美食/"}]},{"title":"绝味手撕鸡","slug":"绝味手撕鸡","date":"2019-08-13T03:06:42.000Z","updated":"2019-08-13T03:10:10.845Z","comments":true,"path":"2019/08/13/绝味手撕鸡/","link":"","permalink":"https://tylerLiu.top/2019/08/13/绝味手撕鸡/","excerpt":"","text":"食材三黄鸡、香菜、小葱、大蒜、生姜、小米椒、麻油、生抽、豉油 步骤 将生姜切片，小葱洗净打结放入盘底 鸡清洗干净沥干放上盘，如果能放下整只鸡就不用切块，直接将生姜片和葱结放入鸡肚子就好 锅里放水，放上蒸架后，将整盘鸡放入锅中蒸30分钟左右 在蒸制的时候开始准备调料，将小米椒切圈，香菜切碎，蒜姜切末备用 倒入生抽、豉油、糖、香油，搅拌均匀 热锅入油，将蒜姜末和辣椒放入锅中煎至飘香 将煎好的蒜姜辣椒，趁烫倒入调好的酱汁中搅拌均匀 等鸡蒸好后从锅里拿出，用凉水冲去浮末，之后用厨房纸擦干，开始手撕鸡的过程，最好是连皮带肉地撕 最后将调好的酱汁，倒入撕好的鸡肉中搅拌均匀，在现有调料的基础上，还可以倒点香醋","categories":[{"name":"美食","slug":"美食","permalink":"https://tylerLiu.top/categories/美食/"}],"tags":[{"name":"美食","slug":"美食","permalink":"https://tylerLiu.top/tags/美食/"}]},{"title":"芋头焖排骨","slug":"芋头焖排骨","date":"2019-08-13T02:58:22.000Z","updated":"2019-08-13T03:03:21.745Z","comments":true,"path":"2019/08/13/芋头焖排骨/","link":"","permalink":"https://tylerLiu.top/2019/08/13/芋头焖排骨/","excerpt":"","text":"1. 材料排骨、芋头、葱、蒜、盐、糖、料酒、酱油、油 2. 步骤 排骨切块，加盐、糖、料酒、酱油，腌制1小时。 芋头切块，放入炒锅，煎至表面金黄，然后盛起备用。 热锅入油，加入蒜爆炒，再加入排骨炒至上色，加入清水烧开。 加入芋头、酱油和盐，焖30分钟。 大火收汁","categories":[{"name":"美食","slug":"美食","permalink":"https://tylerLiu.top/categories/美食/"}],"tags":[{"name":"美食","slug":"美食","permalink":"https://tylerLiu.top/tags/美食/"}]},{"title":"Android RxJava：创建操作符","slug":"Android-RxJava：创建操作符","date":"2019-08-12T07:40:55.000Z","updated":"2019-08-15T03:04:22.652Z","comments":true,"path":"2019/08/12/Android-RxJava：创建操作符/","link":"","permalink":"https://tylerLiu.top/2019/08/12/Android-RxJava：创建操作符/","excerpt":"","text":"1. 作用创建被观察者Observable对象，发送事件。 2. 类型创建操作符包括： 3. 介绍及应用场景3.1 基本创建操作符：create()场景：完整的创建被观察者对象，RxJava中创建被观察者对象最基本的操作符。 123456789101112131415161718192021// 1. 创建被观察者Observable对象Observable&lt;Integer&gt; observable1 = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; // create()是RxJava最基本的创建事件序列的方法 // 此处传入一个OnSubscribe对象参数 // 当observable被订阅时，OnSubscribe的call()方法会自动被调用，即事件序列就会按照设定次序依次被触发 // 即观察者会依次调用对应事件的复写方法从而响应事件 // 从而实现被观察者调用了观察者的回调方法并由被观察者向观察者的事件传递，即观察者模式 // 2. 在复写的subscribe()中定义需要发送的事件 @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; // 通过ObservableEmitter类对象产生事件并通知观察者 // ObservableEmitter类介绍： // a. 定义：事件发射器 // b. 作用：定义需要发送的事件，并向观察者发送事件 emitter.onNext(1); emitter.onNext(2); emitter.onNext(3); emitter.onComplete(); &#125;&#125;); 采用链式调用：在补充示例地址中也可以看到示例。 3.2 快速创建和发送事件操作符：just()场景：快速的创建被观察者对象，发送事件的特点为直接发送传入的事件，最多只能发送10个参数。 12345678910111213141516171819202122232425262728// 创建时传入整型1,2,3,4// 在创建后就会发送这些对象，相当于执行了onNext(1)、onNext(2)、onNext(3)、onNext(4)Observable.just(1, 2, 3, 4) // 至此，已经创建一个完整的Observable对象 // 2. 通过通过订阅（subscribe）连接观察者和被观察者 // 3. 创建观察者，定义响应事件的行为 .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, \"开始采用subscribe连接\"); &#125; @Override public void onNext(Integer value) &#123; Log.d(TAG, \"接收到了事件\" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, \"对Error事件作出响应\"); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"对Complete事件作出响应\"); &#125; &#125;); 操作符：fromArray()场景：快速创建被观察者Observable对象，以数组形式发送10个以上的事件，通过数组遍历元素。特点是直接发送传入的数组数据，在数组元素遍历时，会将数组中的数据转成Observable对象。 1234567891011121314151617181920212223242526272829// 1. 设置需要传入的数组Integer[] items = &#123;0, 1, 2, 3, 4, 5&#125;;// 2. 创建被观察者对象时传入数组// 在创建后会将该数组中的元素转成Observable对象，并发送对象中的所有数据Observable.fromArray(items) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, \"开始采用subscribe连接\"); Log.d(TAG, \"数组遍历\"); &#125; @Override public void onNext(Integer integer) &#123; Log.d(TAG, \"接收到了事件\" + integer); Log.d(TAG, \"数组中的元素 = \"+ integer ); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, \"对Error事件作出响应\"); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"对Complete事件作出响应\"); &#125; &#125;); 操作符：fromIterable()场景：快速创建被观察者Observable对象，并以集合的形式发送10以上事件。特点是直接发送集合list数据，通过集合元素遍历，会将集合中的数据转成Observable对象。 123456789101112131415161718192021222324252627282930// 1. 设置一个集合List&lt;Integer&gt; list = new ArrayList&lt;&gt;();list.add(0);list.add(1);list.add(2);list.add(3);// 2. 通过fromIterable()将集合中的对象/数据发送出去Observable.fromIterable(list) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, \"开始采用subscribe连接\"); &#125; @Override public void onNext(Integer integer) &#123; Log.d(TAG, \"接收到了事件\" + integer); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, \"对Error事件作出响应\"); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"对Complete事件作出响应\"); &#125; &#125;); 其他方法：以下方法一般用于测试： empty()：该方法创建的被观察者对象发送事件的特点：仅发送Complete事件，即观察者接收后直接调用onComplete()。 error()：特点是仅发送Error事件，直接通知异常，可以自定义异常，即观察者接收后直接调用onError()。 never()：特点是不发送任何事件，即观察者接收后什么都不调用。 3.3 延迟创建操作符：defer()场景：定时操作，在经过x秒后，自动执行y操作；周期性操作，每隔x秒后，自动执行y操作。 直到有观察者Observer订阅时，才动态创建被观察者对象Observable，并发送事件。 通过Osbervable工厂方法创建被观察者对象Observable 每次订阅后，都会得到一个刚创建的最新的Observable对象，这可以确保Observable对象里的数据是最新的。 1234567891011121314151617181920212223242526272829303132333435363738394041// 第一次对i赋值Integer i = 0;private void dodefer() &#123; // 通过defer()定义被观察者对象 // 注：此时被观察者还未被创建 Observable&lt;Integer&gt; observable = Observable.defer(new Callable&lt;ObservableSource&lt;? extends Integer&gt;&gt;() &#123; @Override public ObservableSource&lt;? extends Integer&gt; call() throws Exception &#123; return Observable.just(i); &#125; &#125;); // 第二次对i赋值 i = 15; // 观察者开始订阅 // 此时，才会调用defer()创建被观察者对象 observable.subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, \"开始采用subscribe连接\"); &#125; @Override public void onNext(Integer integer) &#123; Log.d(TAG, \"接收到的整数是\" + integer); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, \"对Error事件作出响应\"); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"对Complete事件作出响应\"); &#125; &#125;);&#125; 因为在订阅时Observable才创建，所以i只会取第二次的赋值。 操作符：timer()场景：延迟指定时间，发送一个0，一般用于检测。快速创建一个Observable，特点是延迟指定时间后，发送一个数值0（Long类型），其本质就是延迟指定时间后，调用一次onNext(0)。 延迟指定事件，发送一个0，一般用于检测。 1234567891011121314151617181920212223// 延迟2秒后，发送一个long类型数值Observable.timer(2, TimeUnit.SECONDS) .subscribe(new Observer&lt;Long&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, \"开始采用subscribe连接\"); &#125; @Override public void onNext(Long aLong) &#123; Log.d(TAG, \"接收到了事件\" + aLong); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, \"对Error事件作出响应\"); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"对Complete事件作出响应\"); &#125; &#125;); 操作符：interval()场景：快速创建一个被观察者对象Observable，发送事件的特点：每隔指定时间就发送事件。发送事件的序列为，从0开始，无限递增1的整数序列。 1234567891011121314151617181920212223242526272829// 参数说明：// 参数1：第1次延迟时间// 参数2：间隔时间数字// 参数3：时间单位Observable.interval(3, 1, TimeUnit.SECONDS) // 该例子发送的事件序列特点：延迟3s后发送事件，每隔1秒产生1个数字（从0开始递增1，无限个） .subscribe(new Observer&lt;Long&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, \"开始采用subscribe连接\"); &#125; // 默认最先调用复写的 onSubscribe（） @Override public void onNext(Long aLong) &#123; Log.d(TAG, \"接收到了事件\" + aLong); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, \"对Error事件作出响应\"); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"对Complete事件作出响应\"); &#125; &#125;); 注：interval默认在computation调度器上执行，也可以自定义指定线程调度器（第三个参数）：interval(long, TimeUnit, Scheduler)。 操作符：intervalRange()场景：快速创建一个被观察者对象Observable，发送事件的特点：每隔指定时间就发送事件，可指定发送的数据的数量。发送的事件序列为从0开始，无限递增1的整数序列，作用类似interval()，不同的是intervalRange()可以指定发送数据的数量。 123456789101112131415161718192021222324252627282930313233// 参数说明：// 参数1:事件序列起始点// 参数2:事件数量// 参数3:第1次事件延迟发送时间// 参数4:间隔时间数字// 参数5:时间单位Observable.intervalRange(3, 10, 2, 1, TimeUnit.SECONDS) // 该例子发送的事件序列特点： // 1. 从3开始，一共发送10个事件； // 2. 第1次延迟2s发送，之后每隔2秒产生1个数字（从0开始递增1，无限个） .subscribe(new Observer&lt;Long&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, \"开始采用subscribe连接\"); &#125; // 默认最先调用复写的 onSubscribe（） @Override public void onNext(Long value) &#123; Log.d(TAG, \"接收到了事件\" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, \"对Error事件作出响应\"); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"对Complete事件作出响应\"); &#125; &#125;); 操作符：range()场景：快速创建一个被观察者对象Observable，发送事件的特点：连续发送一个事件序列，可指定范围。发送的事件序列为从0开始、无限递增1的的整数序列，作用类似于intervalRange()，区别在于，无延迟发送事件。 1234567891011121314151617181920212223242526272829// 参数说明：// 参数1：事件序列起始点// 参数2：事件数量// 注：若设置为负数，则会抛出异常Observable.range(3, 10) // 该例子发送的事件序列特点：从3开始发送，每次发送事件递增1，一共发送10个事件 .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, \"开始采用subscribe连接\"); &#125; // 默认最先调用复写的 onSubscribe（） @Override public void onNext(Integer value) &#123; Log.d(TAG, \"接收到了事件\" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, \"对Error事件作出响应\"); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"对Complete事件作出响应\"); &#125; &#125;); 操作符：rangeLong()场景：作用类似于range()，区别在于该方法支持数据类型Long。使用与range()类似。 Demo地址：Allen_Demo_Rx","categories":[{"name":"Android","slug":"Android","permalink":"https://tylerLiu.top/categories/Android/"},{"name":"RxJava","slug":"Android/RxJava","permalink":"https://tylerLiu.top/categories/Android/RxJava/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"https://tylerLiu.top/tags/RxJava/"}]},{"title":"Android RxJava：入门","slug":"Android-RxJava：入门","date":"2019-08-12T01:43:32.000Z","updated":"2019-08-12T07:38:50.264Z","comments":true,"path":"2019/08/12/Android-RxJava：入门/","link":"","permalink":"https://tylerLiu.top/2019/08/12/Android-RxJava：入门/","excerpt":"","text":"前言RxJava是基于事件流的链式调用、逻辑简单且使用简单。 GitHub链接： RxJava RxAndroid 基于RxJava 2.0 在xJava 1.0上增加了一些新特性，基本原理和使用基本相同 后面还会介绍原理、操作符、应用场景、背压等 1. 定义在GitHub上的介绍： RxJava – Reactive Extensions for the JVM – a library for composing asynchronous and event-based programs using observable sequences for the Java VM.一个在Java JVM上使用可观测的序列来组成异步的、基于事件的程度的库。 总结：RxJava是基于事件流、实现异步操作的库 2. 作用实现异步操作，类似Andorid中的AsyncTask、Handler的作用。 3. 特点由于RxJava的使用方式是基于事件流的链式调用，所以RxJava： 逻辑简洁 实现优雅 使用简单 4. 原理顾客到饭店点菜吃饭： RxJava原理基于一种扩展的观察者模式，其中包含四个角色： 角色 作用 类比 被观察者Observable 产生事件 顾客 观察者Observer 接收事件并给出响应动作 厨房 订阅Subscribe 连接被观察者和观察者 服务员 事件Event 被观察者和观察者沟通的载体 菜式 总结：被观察者Observable通过订阅Subscribe按顺序发送事件Event给观察者Observer，观察者Observer按顺序接收事件并作出对应的响应。 5. 基本使用使用方式有两种： 分步骤实现：该方法主要是为了深入说明RxJava的原理和使用，用于演示 基于事件流的链式调用，用于实际开发 5.1 分步骤实现5.1.1 使用步骤 创建被观察者Observable并生产事件，对应顾客进入饭店-坐下-点菜 创建观察者Observer并定义响应事件的行为，即厨房确定对应菜式 通过订阅Subscribe连接观察者和被观察者，即顾客找到服务员-服务员下单到厨房-厨房烹制 5.1.2 步骤详解步骤1：创建被观察者Observable并生产事件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class RxJavaActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_rx_java); // 1. 创建被观察者Observable对象 Observable&lt;Integer&gt; observable1 = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; // create()是RxJava最基本的创建事件序列的方法 // 此处传入一个OnSubscribe对象参数 // 当observable被订阅时，OnSubscribe的call()方法会自动被调用，即事件序列就会按照设定次序依次被触发 // 即观察者会依次调用对应事件的复写方法从而响应事件 // 从而实现被观察者调用了观察者的回调方法并由被观察者向观察者的事件传递，即观察者模式 // 2. 在复写的subscribe()中定义需要发送的事件 @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; // 通过ObservableEmitter类对象产生事件并通知观察者 // ObservableEmitter类介绍： // a. 定义：事件发射器 // b. 作用：定义需要发送的事件，并向观察者发送事件 emitter.onNext(1); emitter.onNext(2); emitter.onNext(3); emitter.onComplete(); &#125; &#125;); // 扩展：RxJava提供了其他方法用于创建被观察者Observable // 方法1：just()：直接将传入的参数依次发送出来 Observable observable2 = Observable.just(\"A\", \"B\", \"C\"); // 将会依次调用： // onNext(\"A\"); // onNext(\"B\"); // onNext(\"C\"); // onCompleted(); // 方法2：from(T []) / from(Iterable&lt;? extends T&gt;)：将传入的数组 / Iterable拆分成具体对象后，依次发送出来 String[] words = &#123;\"A\", \"B\", \"C\"&#125;; Observable observable3 = Observable.fromArray(words); // 将会依次调用： // onNext(\"A\"); // onNext(\"B\"); // onNext(\"C\"); // onCompleted(); &#125;&#125; 步骤2：创建观察者Observer并定义响应事件的行为发生的事件类型包括：Next事件、Complete事件、Error事件。 Next：onNext()，普通事件，用于向观察者发送需要响应事件的信号，被观察者可发送无限个Next事件，观察者可以接收无限个Next事件。 Complete：onCompleted()，事件队列完结事件，RxJava把所有事件当做队列处理，标志被观察者不再发送普通事件Next。当被观察者发送一个Complete事件后，被观察者在Complete事件后的事件将会继续发送，但观察者收到Complete之后将不会再接收任何事件；被观察者可以不发送Complete事件。 Error：onError()，事件队列异常事件，标志事件处理过程中出现异常，此时队列自动终止，不允许事件发出。当被观察者发送一个Error事件后，被观察者在Error事件后的事件将会继续发送，但观察者收到Error事件后将不再继续接收任何事件；被观察者可以不发送Error事件。 在一个正确运行的事件序列中，onCompleted()和onError()互斥，二者只能有一个。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 方式1：采用Observer接口// 1. 创建观察者Observer对象Observer&lt;Integer&gt; observer1 = new Observer&lt;Integer&gt;() &#123; // 2. 创建对象时通过对应复写对应事件方法 从而 响应对应事件 // 观察者接收事件前，默认最先调用复写onSubscribe() @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, \"开始采用subscribe连接\"); &#125; // 当被观察者生产Next事件，观察者接收到时，会调用该复写方法 @Override public void onNext(Integer integer) &#123; Log.d(TAG, \"对Next事件作出响应\" + integer); &#125; // 当被观察者生产Error事件，观察者接收到时，会调用该复写方法 @Override public void onError(Throwable e) &#123; Log.d(TAG, \"对Error事件作出响应\"); &#125; // 当被观察者生产Complete事件，观察者接收到时，会调用该复写方法 @Override public void onComplete() &#123; Log.d(TAG, \"对Complete事件作出响应\"); &#125;&#125;;// 方式2：采用Subscriber抽象类，没有找到，可能已经删除// Subscriber类是RxJava内置的一个实现了Observer的抽象类，对Observer接口进行了扩展// 1. 创建观察者Observer对象Subscriber&lt;Integer&gt; observer2 = new Subscriber&lt;Integer&gt;() &#123; // 2. 创建对象时通过对应复写对应事件方法，从而响应对应事件 @Override public void onSubscribe(Subscription s) &#123; Log.d(TAG, \"开始采用subscribe连接\"); &#125; @Override public void onNext(Integer integer) &#123; Log.d(TAG, \"对Next事件作出响应\" + integer); &#125; @Override public void onError(Throwable t) &#123; Log.d(TAG, \"对Error事件作出响应\"); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"对Complete事件作出响应\"); &#125;&#125;; 两种方式的对比：相同点： 使用方式完全一致，实际上，在RxJava的subscribe()中，Observer会先转换成Subscriber后再使用。 不同点：Subscriber抽象类对Observer接口进行了扩展，新增了两个方法， onStart()：在还未响应事件前调用，用于做一些初始化操作 unsubscribe()：取消订阅、该方法被调用后，观察者将不再接收和响应事件。调用前，先使用isUnsubscribed()判断状态，确定被观察者Observable是否还持有观察者Subscriber的引用，如果引用不能及时释放，会造成内存泄露。 步骤3：通过订阅Subscribe连接观察者和被观察者1observable.subscribe(observer); 5.2 基于事件流的链式调用123456789101112131415161718192021222324252627282930313233// RxJava的链式操作Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; // 1. 创建被观察者，生产事件 @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; emitter.onNext(1); emitter.onNext(2); emitter.onNext(3); emitter.onComplete(); &#125;&#125;).subscribe(new Observer&lt;Integer&gt;() &#123; // 2. 通过订阅subscribe连接观察者和被观察者 // 3. 创建观察者，定义响应事件的行为 @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, \"开始采用subscribe连接\"); &#125; @Override public void onNext(Integer integer) &#123; Log.d(TAG, \"对Next事件\" + integer + \"作出响应\"); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, \"对Error事件作出响应\"); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"对Complete事件作出响应\"); &#125;&#125;); 整体方法调用顺序：观察者.onSubscribe() -&gt; 被观察者.subscribe() -&gt; 观察者.onNext() -&gt; 观察者.onComplete()。 RxJava 2.X提供了多个函数式接口，用于实现观察者模式： 以Customer为例： 1234567Observable.just(\"hello\").subscribe(new Consumer&lt;String&gt;() &#123; // 每次接收到Observable的事件都会调用Consumer.accept（） @Override public void accept(String s) throws Exception &#123; Log.d(TAG, s); &#125; &#125;); 6. 额外说明使用Disposable.dispose()切断观察者和被观察者之间的连接，即观察者无法继续接收被观察者的事件，但被观察者可以继续发送事件。 12345678910111213141516171819202122232425262728293031Observer&lt;Integer&gt; observer = new Observer&lt;Integer&gt;() &#123; // 定义Disposable private Disposable mDisposable; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, \"开始采用subscribe连接\"); // 对disposable赋值 mDisposable = d; &#125; @Override public void onNext(Integer integer) &#123; Log.d(TAG, \"对Next事件\" + integer + \"作出响应\"); if (integer == 2) &#123; // 设置在接收到第二个事件后切换观察者和被观察者的连接 mDisposable.dispose(); Log.d(TAG, \"已经切断了连接：\" + mDisposable.isDisposed()); &#125; &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, \"对Error事件作出响应\"); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"对Complete事件作出响应\"); &#125; &#125;;","categories":[{"name":"Android","slug":"Android","permalink":"https://tylerLiu.top/categories/Android/"},{"name":"RxJava","slug":"Android/RxJava","permalink":"https://tylerLiu.top/categories/Android/RxJava/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"https://tylerLiu.top/tags/RxJava/"}]},{"title":"Android Jetpack：WorkManager","slug":"Android-Jetpack-WorkManager","date":"2019-08-09T00:45:17.000Z","updated":"2019-08-22T03:14:00.492Z","comments":true,"path":"2019/08/09/Android-Jetpack-WorkManager/","link":"","permalink":"https://tylerLiu.top/2019/08/09/Android-Jetpack-WorkManager/","excerpt":"","text":"这里的数据不是从网络请求获取的，而是从assets目录下的json读取出来的，通常，从文件读取数据不会放在主线程中执行，这里使用了WorkManager，使能够在后台线程进行数据初始化。 1. 介绍官方文档：WorkMangerWorkManger介绍视频：中文官方介绍视频 1.1 定义官方介绍： The WorkManager API makes it easy to schedule deferrable, asynchronous tasks that are expected to run even if the app exits or device restarts.直译：WorkManager API使调度可延迟的异步任务变得很容易，即使应用程序退出或设备重启，这些任务也会运行。 1.2 选择WorkManager的理由Android中处理后台任务的选择很多，如Service、DownloadManager、AlarmManager、JobScheduler等， 为什么还要有WorkManager？ 兼容性更强，可以兼容到API 14 可以指定约束条件，比如可以选择必须在有网络的条件下执行 可以定时执行，也可以单次执行 监听和管理任务状态 多个任务可以使用任务链 保证任务执行，如当前执行条件不满足或者APP进程被杀死，它会等到下次条件满足或者APP进行打开后执行 支持省电模式 1.3 多线程任务如何选择？后台任务会消耗设备的系统资源，若处理不当，可能会造成设备电量的消耗，给用户带来不好的体验。所以，选择正确的后台处理方式很重要，下面是官方给出的选择方式： 关于后台的的知识，需要补充阅读：[译]从Service到WorkManager。 2. Demo实现：选取一张图片，做模糊处理，然后显示在头像上。 2.1 添加依赖1implementation \"androidx.work:work-runtime-ktx:2.2.0-rc01\" 2.2 自定义Worker自定义worker之前，先看看WorkerManager中几个重要的类： Worker：需要继承Worker，并复写doWork()方法，在里面写入需要在后台执行的代码 WorkRequest：指后台工作的请求，可以在后台工作的请求中添加约束条件 WorkManager：真正让Worker在后台执行的类 WorkerManager的执行流程： WorkRequest生成以后，Internal TaskExecutor将它存入WorkManager的数据库中，这也是为什么即使在程序退出之后，WorkManager也能保证后台任务在下次启动后条件满足的情况下执行。 当约束条件满足的情况下，Internal TaskExecutor告诉WorkFactory生成Worker。 后台执行Worker任务。 下面自定义一个Worker，目标是生成一张模糊图片，包含：清除之前的缓存路径，、图片模糊处理和图片的生成。将这三个步骤分成三个后台任务，三个后台任务分别涉及到无变量的情况、往外传参数和读取参数三种情况。 2.2.1 清除缓存路径：无变量情况（通常情况）12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 清理临时文件的Worker * * @author Liuyang * @date 2019/8/9 */class CleanUpWorker(context: Context, params: WorkerParameters) : Worker(context, params) &#123; private val TAG by lazy &#123; this::class.java.simpleName &#125; override fun doWork(): Result &#123; // Makes a notification when the work starts and slows down the work so that // it's easier to see each WorkRequest start, even on emulated devices makeStatusNotification(\"Cleaning up old temporary files\", applicationContext) // sleep() return try &#123; // 删除逻辑 val outputDir = File(applicationContext.filesDir, BaseConstant.OUTPUT_PATH) if (outputDir.exists()) &#123; val entries = outputDir.listFiles() if (entries != null) &#123; for (entry in entries) &#123; val name = entry.name if (name.isNotEmpty() &amp;&amp; name.endsWith(\".png\")) &#123; val deleted = entry.delete() Log.i(TAG, String.format(\"Deleted %s - %s\", name, deleted)) &#125; &#125; &#125; &#125; // 成功 Result.success() &#125; catch (exception: Exception) &#123; Log.e(TAG, \"Error cleaning up\", exception) // 失败 Result.failure() &#125; &#125;&#125; 2.2.2 图片模糊处理：往外传参数（输出参数）123456789101112131415161718192021222324252627282930313233343536373839/** * 模糊处理的worker * * @author Liuyang * @date 2019/8/11 */class BlurWorker(context: Context, params: WorkerParameters) : Worker(context, params) &#123; private var TAG: String = this::class.java.simpleName override fun doWork(): Result &#123; val context = applicationContext val resultUri = inputData.getString(BaseConstant.KEY_IMAGE_URI) // 通知开始处理图片 makeStatusNotification(\"Blurring image\", context) return try &#123; // 图片处理逻辑 if (TextUtils.isEmpty(resultUri)) &#123; Log.e(TAG, \"Invalid input uri\") throw IllegalArgumentException(\"Invalid input uri\") &#125; val resolver = context.contentResolver val picture = BitmapFactory.decodeStream(resolver.openInputStream(Uri.parse(resultUri))) // 创建Bitmap文件 val output = blurBitmap(picture, context) // 存入路径 val outputUri = writeBitmapToFile(context, output) // 输出路径 val outputData = workDataOf(BaseConstant.KEY_IMAGE_URI to outputUri.toString()) makeStatusNotification(\"Output is $outputUri\", context) Result.success(outputData) &#125; catch (throwable: Throwable) &#123; Log.e(TAG, \"Error applying blur\", throwable) Result.failure() &#125; &#125;&#125; 2.2.3 图片生成：读取参数1234567891011121314151617181920212223242526272829303132333435363738394041/** * 存储照片的worker * * @author Liuyang * @date 2019/8/11 */class SaveImageToFileWorker(context: Context, parameters: WorkerParameters) : Worker(context, parameters) &#123; private val TAG by lazy &#123; SaveImageToFileWorker::class.java.simpleName &#125; private val title = \"Blurred Image\" private val dateFormatter = SimpleDateFormat(\"yyyy.MM.dd 'at' HH:mm:ss z\", Locale.getDefault()) override fun doWork(): Result &#123; // Makes a notification when the work starts and slows down the work so that // it's easier to see each WorkRequest start, even on emulated devices makeStatusNotification(\"Saving image\", applicationContext) // sleep() val resolver = applicationContext.contentResolver return try &#123; // 获取从外部传入的参数 val resourceUri = inputData.getString(BaseConstant.KEY_IMAGE_URI) val bitmap = BitmapFactory.decodeStream(resolver.openInputStream(Uri.parse(resourceUri))) val imageUrl = MediaStore.Images.Media.insertImage(resolver, bitmap, title, dateFormatter.format(Date())) if (!imageUrl.isNullOrEmpty()) &#123; val output = workDataOf(BaseConstant.KEY_IMAGE_URI to imageUrl) Result.success() &#125; else &#123; Log.e(TAG, \"Writing to MediaStore failed\") Result.failure() &#125; &#125; catch (exception: Exception) &#123; Log.e(TAG, \"Unable to save image to Gallery\", exception) Result.failure() &#125; &#125;&#125; 2.3 创建WorkManager在model中单例获取： 123class MeModel(private val userRepository: UserRepository) : ViewModel() &#123; private val workManager = WorkManager.getInstance()&#125; 2.4 构建WorkRequestWorkRequest可以分为两类： PeriodicWorkRequest：Periodic，周期；多次、定时执行任务请求，不支持任务链 OneTimeWorkRequest：只执行一次的任务请求，支持任务链 执行一个任务以OneTimeWorkRequest为例，如果只有一个任务请求： 12val request = OneTimeWorkRequest.from(CleanUpWorker::class.java)workManager.enqueue(request) 执行多个任务例子中有三个Worker，并且里面有先后执行的顺序，所以可以使用任务链： 12345678// 多任务按顺序执行workManager.beginWith( mutableListOf( OneTimeWorkRequest.from(CleanUpWorker::class.java) )) .then(OneTimeWorkRequestBuilder&lt;BlurWorker&gt;().setInputData(createInputDataForUri()).build()) .then(OneTimeWorkRequestBuilder&lt;SaveImageToFileWorker&gt;().build()) .enqueue() 假设多次点击图片更换头像，提交多次请求，由于网络原因（Demo中没有网络请求部分），最后返回的很可能不是最后一次请求的图片，这显然是有问题的，WorkManager可能满足这样的需求，保证任务的唯一性： 12345678910// 多任务按顺序执行workManager.beginUniqueWork( IMAGE_MANIPULATION_WORK_NAME, // 任务名称 ExistingWorkPolicy.REPLACE, // 任务相同的执行策略 分为REPLACE，KEEP，APPEND mutableListOf( OneTimeWorkRequest.from(CleanUpWorker::class.java) )) .then(OneTimeWorkRequestBuilder&lt;BlurWorker&gt;().setInputData(createInputDataForUri()).build()) .then(OneTimeWorkRequestBuilder&lt;SaveImageToFileWorker&gt;().build()) .enqueue() 无顺序多任务 如果并行执行没有顺序的多个任务，无论是beginUniqueWork还是beginWith方法都可以接收一个List&lt;OneTimeWorkRequest&gt;。 使用约束假设需要将生成的图片上传到服务器，并且需要将图片同时保存到本地，这是就需要设备联网并且由足够的存储空间，这时，就可以给WorkRequest指明约束条件：12345678910111213// 构建约束条件val constraints = Constraints.Builder() .setRequiresBatteryNotLow(true)// 非电池低电量 .setRequiredNetworkType(NetworkType.CONNECTED)// 网络连接的情况 .setRequiresStorageNotLow(true)// 存储空间充足 .build()// 存储照片val save = OneTimeWorkRequestBuilder&lt;SaveImageToFileWorker&gt;() .setConstraints(constraints) .addTag(BaseConstant.TAG_OUTPUT) .build()continuation = continuation.then(save) 可以指明的约束条件有：电池电量、充电、网络、存储和延迟等。 下面是Demo中的具体使用： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class MeModel(private val userRepository: UserRepository) : ViewModel() &#123; private var imageUri: Uri? = null private var outPutUri: Uri? = null var outPutWorkInfo: LiveData&lt;List&lt;WorkInfo&gt;&gt; private val workManager = WorkManager.getInstance() val use = userRepository.findUserById(AppPrefsUtils.getLong(BaseConstant.SP_USER_ID)) init &#123; outPutWorkInfo = workManager.getWorkInfosByTagLiveData(BaseConstant.TAG_OUTPUT) &#125; internal fun applyBlur(blurLevel: Int) &#123; var continuation = workManager.beginUniqueWork( BaseConstant.IMAGE_MANIPULATION_WORK_NAME, ExistingWorkPolicy.REPLACE, OneTimeWorkRequest.from(CleanUpWorker::class.java) ) for (i in 0 until blurLevel) &#123; val builder = OneTimeWorkRequestBuilder&lt;BlurWorker&gt;() if (i == 0) &#123; builder.setInputData(createInputDataForUri()) &#125; continuation = continuation.then(builder.build()) &#125; // 构建约束条件 val constraints = Constraints.Builder() .setRequiresBatteryNotLow(true)// 非电池低电量 .setRequiredNetworkType(NetworkType.CONNECTED)// 网络连接的情况 .setRequiresStorageNotLow(true)// 存储空间充足 .build() // 存储照片 val save = OneTimeWorkRequestBuilder&lt;SaveImageToFileWorker&gt;() .setConstraints(constraints) .addTag(BaseConstant.TAG_OUTPUT) .build() continuation = continuation.then(save) continuation.enqueue() &#125; private fun createInputDataForUri(): Data &#123; val builder = Data.Builder() imageUri?.let &#123; builder.putString(BaseConstant.KEY_IMAGE_URI, imageUri.toString()) &#125; return builder.build() &#125; private fun uriOrNull(uriString: String?): Uri? &#123; return if (!uriString.isNullOrEmpty()) &#123; Uri.parse(uriString) &#125; else null &#125; internal fun setImageUri(uri: String?) &#123; imageUri = uriOrNull(uri) &#125; internal fun setOutputUri(uri: String?) &#123; outPutUri = uriOrNull(uri) val value = use.value value?.headImage = uri!! if (value != null) &#123; viewModelScope.launch &#123; userRepository.updateUser(value) &#125; &#125; &#125; fun cancelWork() &#123; workManager.cancelUniqueWork(BaseConstant.IMAGE_MANIPULATION_WORK_NAME) &#125;&#125; 2.5 取消任务如果要取消任务workManager.cancelAllWork()，如果要取消上面执行的唯一任务，需要上面唯一的任务名： 123fun cancelWork() &#123; workManager.cancelUniqueWork(BaseConstant.IMAGE_MANIPULATION_WORK_NAME)&#125; 2.6 观察任务状态任务状态的变化过程： 其中，SUCCESS、FAILED、CALCELLED都属于任务已经完成。观察任务状态需要使用到LiveData： 1234567891011class MeModel(private val userRepository: UserRepository) : ViewModel() &#123; private var imageUri: Uri? = null private var outPutUri: Uri? = null var outPutWorkInfo: LiveData&lt;List&lt;WorkInfo&gt;&gt; private val workManager = WorkManager.getInstance() val use = userRepository.findUserById(AppPrefsUtils.getLong(BaseConstant.SP_USER_ID)) init &#123; outPutWorkInfo = workManager.getWorkInfosByTagLiveData(BaseConstant.TAG_OUTPUT) &#125;&#125; 当图片处理时，程序弹出加载框，图片处理完成，程序会将图片路径保存到User里的headImage并存储到数据库中，任务状态观测参见MeFragment中的onSubscribeUi()中： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107/** * 我的界面 * * @author Liuyang * @date 2019/8/11 */class MeFragment : Fragment() &#123; private val TAG by lazy &#123; MeFragment::class.java.simpleName &#125; // Model懒加载 private val meModel: MeModel by viewModels &#123; CustomViewModelProvider.providerMeModel(requireContext()) &#125; // 选择图片的标识 private val REQUEST_CODE_IMAGE = 100 // 加载框 private val sweetAlertDialog: SweetAlertDialog by lazy &#123; SweetAlertDialog(requireContext(), SweetAlertDialog.PROGRESS_TYPE) .setTitleText(&quot;头像&quot;) .setContentText(&quot;更新中......&quot;)// .setCancelButton(&quot;取消&quot;) &#123;// meModel.cancelWork()// sweetAlertDialog.dismiss()// &#125; &#125; override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? &#123; val binding: FragmentMeBinding = FragmentMeBinding.inflate(inflater, container, false) initListener(binding) onSubscribeUi(binding) return binding.root &#125; /** * 初始化监听器 */ private fun initListener(binding: FragmentMeBinding) &#123; binding.ivHead.setOnClickListener &#123; // 选择处理的图片 val chooseIntent = Intent(Intent.ACTION_PICK, MediaStore.Images.Media.EXTERNAL_CONTENT_URI) startActivityForResult(chooseIntent, REQUEST_CODE_IMAGE) &#125; &#125; /** * binding绑定 */ private fun onSubscribeUi(binding: FragmentMeBinding) &#123; meModel.use.observe(this, Observer &#123; binding.user = it &#125;) // 任务状态的监测 meModel.outPutWorkInfo.observe(this, Observer &#123; if (it.isNullOrEmpty()) return@Observer val state = it[0] if (state.state.isFinished) &#123; // 更新头像 val outputImageUri = state.outputData.getString(BaseConstant.KEY_IMAGE_URI) if (!outputImageUri.isNullOrEmpty()) &#123; meModel.setOutputUri(outputImageUri) &#125; sweetAlertDialog.dismiss() &#125; &#125;) &#125; /** * 图片选择完成的回调 */ override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) &#123; if (resultCode == Activity.RESULT_OK) &#123; when (requestCode) &#123; REQUEST_CODE_IMAGE -&gt; data?.let &#123; handleImageRequestResult(data) &#125; else -&gt; Log.d(TAG, &quot;Unknown request code.&quot;) &#125; &#125; else &#123; Log.e(TAG, String.format(&quot;Unexpected Result code %s&quot;, resultCode)) &#125; &#125; /** * 图片处理 */ private fun handleImageRequestResult(data: Intent) &#123; val imageUri: Uri? = data.clipData?.let &#123; it.getItemAt(0).uri &#125; ?: data.data if (imageUri == null) &#123; Log.e(TAG, &quot;Invalid input image Uri.&quot;) return &#125; sweetAlertDialog.dismiss() // 图片模糊处理 meModel.setImageUri(imageUri.toString()) meModel.applyBlur(3) &#125;&#125; 3. 其他选择适合的Worker 谷歌提供了四种Worker： 自动运行在后台线程的Worker 结合协程的CoroutineWorker 结合RxJava的RxWorker 以上三个类的基类ListenableWorker 这里以CoroutineWorker为例，简单介绍，使用ShoeWorker从文中读取鞋子的数据并完成数据库的插入工作： 1234567891011121314151617181920212223242526272829303132333435class ShoeWorker(context: Context, workerParameters: WorkerParameters) : CoroutineWorker(context, workerParameters) &#123; private val TAG by lazy &#123; ShoeWorker::class.java.simpleName &#125; // 指定Dispatchers override val coroutineContext: CoroutineDispatcher get() = Dispatchers.IO override suspend fun doWork(): Result = coroutineScope &#123; try &#123; applicationContext.assets.open(\"shoes.json\").use &#123; JsonReader(it.reader()).use &#123; val shoeType = object : TypeToken&lt;List&lt;Shoe&gt;&gt;() &#123;&#125;.type val shoeList: List&lt;Shoe&gt; = Gson().fromJson(it, shoeType) val shoeDao = RepositoryProvider.providerShoeRepository(applicationContext) shoeDao.insertShoes(shoeList) for (i in 0..2) &#123; for (shoe in shoeList) &#123; shoe.id += shoeList.size &#125; shoeDao.insertShoes(shoeList) &#125; Result.success() &#125; &#125; &#125; catch (e: Exception) &#123; Log.e(TAG, \"Error seeding database\", e) Result.failure() &#125; &#125;&#125; 延伸：Android Jetpack - 使用 WorkManager 管理后台任务","categories":[{"name":"Android","slug":"Android","permalink":"https://tylerLiu.top/categories/Android/"},{"name":"Jetpack","slug":"Android/Jetpack","permalink":"https://tylerLiu.top/categories/Android/Jetpack/"}],"tags":[{"name":"Jetpack","slug":"Jetpack","permalink":"https://tylerLiu.top/tags/Jetpack/"}]},{"title":"你的儿女","slug":"你的儿女","date":"2019-08-08T06:22:49.000Z","updated":"2019-08-08T06:27:27.318Z","comments":true,"path":"2019/08/08/你的儿女/","link":"","permalink":"https://tylerLiu.top/2019/08/08/你的儿女/","excerpt":"","text":"你的儿女———— 纪伯伦（Khalil Gibran）Your children are not your children.你的子女，其实不是你的子女。 They are the sons and daughters of Life’s longing for itself.他们是生命对于自身渴望而诞生的孩子。 They come through you but not from you,他们借助你来到这个世界，却非因你而来， And though they are with you, yet they belong not to you.他们陪伴你，却并不属于你。 You may give them your love but not your thoughts,你可以给予他们你的爱，却不是你的想法， For they have their own thoughts.因为他们有自己的思想。 You may house their bodies but not their souls,你可以庇护的是他们的身体，却不是他们的灵魂， For their souls dwell in the house of tomorrow, which you cannot visit, not even in your dreams.因为他们的灵魂属于明天，属于你在梦境中也无法达到的明天。 You may strive to be like them, but seek not to make them like you,你可以拼尽全力，变得像他们一样，却不要让他们变得和你一样， For life goes not backward nor tarries with yesterday.因为生命不会后退，也不在过去停留。 You are the bows from which your children as living arrows are sent forth.你是弓，儿女是从你那里射出的箭。 The archer sees the mark upon the path of the infinite,弓箭手遥望未来之路上的箭靶， and He bends you with His might that His arrows may go swift and far.用尽力气将你拉开，使箭射得又快又远。 Let your bending in the archer’s hand be for gladness,怀着快乐的心情，在弓箭手的手中弯曲吧， For even as he loves the arrow that flies, so He loves also the bow that is stable.因为他爱一路飞翔的箭，也爱无比稳定的弓。","categories":[{"name":"美文","slug":"美文","permalink":"https://tylerLiu.top/categories/美文/"}],"tags":[{"name":"美文","slug":"美文","permalink":"https://tylerLiu.top/tags/美文/"}]},{"title":"Android Jetpack：Paging","slug":"Android-Jetpack-Paging","date":"2019-08-05T08:43:24.000Z","updated":"2019-08-22T03:13:38.094Z","comments":true,"path":"2019/08/05/Android-Jetpack-Paging/","link":"","permalink":"https://tylerLiu.top/2019/08/05/Android-Jetpack-Paging/","excerpt":"","text":"在遇到RecyclerView加载大量数据的情况，如果是在数据库请求，需要消耗数据库资源并且需要花费较多的时间，同意，如果是发送网络请求，则需要消耗宽带和更多的时间，无论哪种情形，对于用户的体验都是糟糕的。这时，可以采用分段加载来缩短时间，给带来良好的体验，目前，对于加载大量数据的处理方式有两种： 借助刷新控件来实现用户手动请求数据 数据达到边界自动请求加载 谷歌的Android Jetpack也实现了自己的分页库——Paging。 1. 介绍官方文档：Paging官方Demo：网络方式，数据库方式 官方介绍： The Paging Library helps you load and display small chunks of data at a time. Loading partial data on demand reduces usage of network bandwidth and system resources.直译：分页库帮助您每次加载和显示小块数据。按需加载部分数据会减少网络带宽和系统资源的使用。 Paging架构： PagedList：一个可以以分页形式异步加载数据的容器，可以跟RecyclerView结合 DataSource或DataSource.Factory：数据源，DataSource将数据转变成PagedList，DataSource.Factory则用来创建DataSource LivePagedListBuilder：用来生成LiveData&lt;PagedList&gt;，需要DataSource.Factory参数 BoundaryCallback：数据达到边界的回调 PagedListAdapter：一种RecyclerView适配器 优点： RxJava以及Android Jetpack的支持，如LiveData、Room等 自定义分页策略 异步处理数据 结合RecyclerView等 2. Demo2.1 添加依赖：1234dependencies &#123; // paging implementation \"androidx.paging:paging-runtime:2.1.0\"&#125; 2.2 创建数据源 非Room数据库如果没有使用Room数据库，就需要自定义实现DataSource，通常实现DataSource有三种方式，分别继承三种抽象类，它们分别是： 名称 使用场景 PageKeyedDataSource&lt;Key, Value&gt; 分页请求数据的场景 ItemKeyedDataSource&lt;Key, Value&gt; 以表的某个列为Key，加载其后的N个数据 PositionalDataSource&lt;T&gt; 当数据源总数特定，根据指定位置请求数据的场景 这里以PageKeyedDataSource&lt;Key, Value&gt;为例，虽然这里的数据库使用的是Room，但查询数据以返回List代表着通常数据库的使用方式： 12345package com.ly.allendemojetpack.db.repositoryclass ShoeRepository private constructor(private val shoeDao: ShoeDao) &#123; fun getPageShoes(startIndex: Long, endIndex: Long): List&lt;Shoe&gt; = shoeDao.findShoesByIndexRange(startIndex, endIndex)&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.ly.allendemojetpack.db.datasourceimport android.util.Logimport androidx.paging.PageKeyedDataSourceimport com.ly.allendemojetpack.common.BaseConstantimport com.ly.allendemojetpack.db.data.Shoeimport com.ly.allendemojetpack.db.repository.ShoeRepository/** * 自定义PageKeyedDataSource * 演示Paging库的使用 */class CustomPageDataSource(private val shoeRepository: ShoeRepository) : PageKeyedDataSource&lt;Int, Shoe&gt;() &#123; private val TAG: String by lazy &#123; this::class.java.simpleName &#125; /** * 第一次加载时调用 */ override fun loadInitial(params: LoadInitialParams&lt;Int&gt;, callback: LoadInitialCallback&lt;Int, Shoe&gt;) &#123; val startIndex = 0L val endIndex: Long = 0L + params.requestedLoadSize val shoe = shoeRepository.getPageShoes(startIndex, endIndex) callback.onResult(shoe, null, 2) &#125; /** * 每次分页加载时调用 */ override fun loadAfter(params: LoadParams&lt;Int&gt;, callback: LoadCallback&lt;Int, Shoe&gt;) &#123; Log.e(TAG, \"startPage:$&#123;params.key&#125;, size:$&#123;params.requestedLoadSize&#125;\") val startPage = params.key val startIndex = ((startPage - 1) * BaseConstant.SINGLE_PAGE_SIZE).toLong() + 1 val endIndex = startIndex + params.requestedLoadSize - 1 val shoes = shoeRepository.getPageShoes(startIndex, endIndex) callback.onResult(shoes, params.key + 1) &#125; override fun loadBefore(params: LoadParams&lt;Int&gt;, callback: LoadCallback&lt;Int, Shoe&gt;) &#123; Log.e(TAG, \"endPage:$&#123;params.key&#125;, size:$&#123;params.requestedLoadSize&#125;\") val endPage = params.key val endIndex = ((endPage - 1) * BaseConstant.SINGLE_PAGE_SIZE).toLong() + 1 var startIndex = endIndex - params.requestedLoadSize startIndex = if (startIndex &lt; 0) &#123; 0L &#125; else &#123; startIndex &#125; val shoe = shoeRepository.getPageShoes(startIndex, endIndex) callback.onResult(shoe, params.key + 1) &#125;&#125; DataSource创建好了，再创建一个DataSource.Factory，返回对应的DataSource实例： 1234567891011121314package com.ly.allendemojetpack.db.datasourceimport androidx.paging.DataSourceimport com.ly.allendemojetpack.db.data.Shoeimport com.ly.allendemojetpack.db.repository.ShoeRepository/** * 构建CustomPageDataSource的工厂类 */class CustomPageDataSourceFactory(private val shoeRepository: ShoeRepository) : DataSource.Factory&lt;Int, Shoe&gt;() &#123; override fun create(): DataSource&lt;Int, Shoe&gt; &#123; return CustomPageDataSource(shoeRepository) &#125;&#125; Room数据库如果使用Room与Paging结合使用，可以直接在Room的Dao层使用：12345@Daointerface ShoeDao &#123; @Query(\"SELECT * FROM shoe\") fun getAllShoesLD(): DataSource.Factory&lt;Int, Shoe&gt;&#125; 使用起来简单很多。 2.3 构建LiveData &lt;PagedList&gt;要想获得LiveData&lt;PagedList&gt;，需要先创建LivePagedListBuilder，LivePagedListbuilder有设分页数量和配置参数两种构造方法，设置分页数量比较简单，直接查看API即可，下面看看配置参数使用： 123456789101112class ShoeModel constructor(repository: ShoeRepository) : ViewModel() &#123; /** * 鞋子集合的观察类 */ val shoes: LiveData&lt;PagedList&lt;Shoe&gt;&gt; = LivePagedListBuilder&lt;Int, Shoe&gt;( CustomPageDataSourceFactory(repository), PagedList.Config.Builder() .setPageSize(10) .setEnablePlaceholders(false) .setInitialLoadSizeHint(10) .build() ).build() 2.4 创建PagedListAdapterPagedListAdapter是一个特殊的RecyclerView的RecyclerAdapter，使用方法类似，这里使用Data Binding： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.ly.allendemojetpack.ui.adapterimport android.content.Contextimport android.content.Intentimport android.view.LayoutInflaterimport android.view.Viewimport android.view.ViewGroupimport androidx.paging.PagedListAdapterimport androidx.recyclerview.widget.RecyclerViewimport com.ly.allendemojetpack.common.BaseConstantimport com.ly.allendemojetpack.databinding.ItemShoeBindingimport com.ly.allendemojetpack.db.data.Shoeimport com.ly.allendemojetpack.ui.activity.DetailActivity/** * 鞋子的适配器，配合Data Binding使用 * * @author Liuyang * @date 2019/8/3 */class ShoeAdapter constructor(val context: Context) : PagedListAdapter&lt;Shoe, ShoeAdapter.ViewHolder&gt;(ShoeDiffCallback()) &#123; override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder &#123; return ViewHolder(ItemShoeBinding.inflate(LayoutInflater.from(parent.context), parent, false)) &#125; override fun onBindViewHolder(holder: ViewHolder, position: Int) &#123; val shoe = getItem(position) holder.apply &#123; bind(onCreateListener(shoe!!.id), shoe) itemView.tag = shoe &#125; &#125; /** * Holder的点击事件 */ private fun onCreateListener(id: Long): View.OnClickListener &#123; return View.OnClickListener &#123; val intent = Intent(context, DetailActivity::class.java) intent.putExtra(BaseConstant.DETAIL_SHOE_ID, id) context.startActivity(intent) &#125; &#125; class ViewHolder(private val binding: ItemShoeBinding) : RecyclerView.ViewHolder(binding.root) &#123; fun bind(listener: View.OnClickListener, item: Shoe) &#123; binding.apply &#123; this.listener = listener this.shoe = item executePendingBindings() &#125; &#125; &#125;&#125; 1234567891011121314package com.ly.allendemojetpack.ui.adapterimport androidx.recyclerview.widget.DiffUtilimport com.ly.allendemojetpack.db.data.Shoeclass ShoeDiffCallback : DiffUtil.ItemCallback&lt;Shoe&gt;() &#123; override fun areItemsTheSame(oldItem: Shoe, newItem: Shoe): Boolean &#123; return oldItem.id == newItem.id &#125; override fun areContentsTheSame(oldItem: Shoe, newItem: Shoe): Boolean &#123; return oldItem == newItem &#125;&#125; 2.5 监听数据同样使用Data Binding，ShoeFragment： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.ly.allendemojetpack.ui.fragment.mainimport android.os.Bundleimport android.view.LayoutInflaterimport android.view.Viewimport android.view.ViewGroupimport androidx.fragment.app.Fragmentimport androidx.fragment.app.viewModelsimport androidx.lifecycle.Observerimport androidx.lifecycle.ViewModelProvidersimport com.ly.allendemojetpack.databinding.FragmentShoeBindingimport com.ly.allendemojetpack.ui.adapter.ShoeAdapterimport com.ly.allendemojetpack.viewmodel.CustomViewModelProviderimport com.ly.allendemojetpack.viewmodel.ShoeModel/** * 鞋子的Fragment * * @author Liuyang * @date 2019/8/3 */class ShoeFragment : Fragment() &#123; // by viewModels 需要依赖 \"androidx.navigation:navigation-ui-ktx:$rootProject.navigationVersion\" private val viewModel: ShoeModel by viewModels &#123; CustomViewModelProvider.providerShoeModel(requireContext()) &#125; override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? &#123; val binding: FragmentShoeBinding = FragmentShoeBinding.inflate(inflater, container, false) context ?: return binding.root // 适配器 val adapter = ShoeAdapter(context!!) binding.recycler.adapter = adapter onSubscribeUi(adapter) return binding.root &#125; /** * 鞋子数据更新的通知 */ private fun onSubscribeUi(adapter: ShoeAdapter) &#123; viewModel.shoes.observe(viewLifecycleOwner, Observer &#123; if (it != null) &#123; adapter.submitList(it) &#125; &#125;) &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"https://tylerLiu.top/categories/Android/"},{"name":"Jetpack","slug":"Android/Jetpack","permalink":"https://tylerLiu.top/categories/Android/Jetpack/"}],"tags":[{"name":"Jetpack","slug":"Jetpack","permalink":"https://tylerLiu.top/tags/Jetpack/"}]},{"title":"Android Jetpack：Room","slug":"Android-Jetpack-Room","date":"2019-08-05T03:27:04.000Z","updated":"2019-08-22T03:13:47.387Z","comments":true,"path":"2019/08/05/Android-Jetpack-Room/","link":"","permalink":"https://tylerLiu.top/2019/08/05/Android-Jetpack-Room/","excerpt":"","text":"1. 介绍官方网址：Room 官方介绍： The Room persistence library provides an abstraction layer over SQLite to allow for more robust database access while harnessing the full power of SQLite. 简单来说，Room是一个基于SQLite的强大数据库框架。 优点： 使用编译时注解，能够对@Query和@Entity里面的SQL语句进行验证 与SQL语句的使用更加贴近，能够降低学习成本 对RxJava2支持，对LiveData支持 @Embedded能减少表的创建 2. Demo目标结构： 三张表：用户表、鞋表和收藏记录表，用户表和鞋表存在多对多的关系。 2.1 步骤1：添加依赖在model的build.gradel添加： 1234567891011apply plugin: 'kotlin-kapt'dependencies &#123; ...... // room implementation \"androidx.room:room-runtime:2.2.0-alpha01\" implementation \"androidx.room:room-ktx:2.2.0-alpha01\" kapt \"androidx.room:room-compiler:2.2.0-alpha01\" androidTestImplementation \"androidx.room:room-testing:2.2.0-alpha01\"&#125; 2.2 步骤2：创建表（实体）用户表： 1234567891011121314151617181920212223package com.ly.allendemojetpack.db.dataimport android.location.Addressimport androidx.room.*/** * 用户表 * * @author Liuyang * @date 2019/8/3 */@Entity(tableName = \"user\")data class User( @ColumnInfo(name = \"user_account\") val account: String,// 账号 @ColumnInfo(name = \"user_pwd\") val pwd: String,// 摩玛 @ColumnInfo(name = \"user_name\") val name: String, @Embedded val address: Address,// 地址 @Ignore val state: Int) &#123; @PrimaryKey(autoGenerate = true) @ColumnInfo(name = \"id\") var id: Long = 0&#125; 收藏记录表： 12345678910111213141516171819202122232425262728package com.ly.allendemojetpack.db.dataimport androidx.room.ColumnInfoimport androidx.room.Entityimport androidx.room.ForeignKeyimport androidx.room.PrimaryKeyimport java.util.*/** * 喜欢的鞋 表 * * @author Liuyang * @date 2019/8/3 */@Entity( tableName = \"fav_shoe\", foreignKeys = [ForeignKey(entity = Shoe::class, parentColumns = [\"id\"], childColumns = [\"shoe_id\"]), ForeignKey(entity = User::class, parentColumns = [\"id\"], childColumns = [\"user_id\"])])data class FavouriteShoe( @ColumnInfo(name = \"shoe_id\") val shoeId: Long,// 外键 鞋子的id @ColumnInfo(name = \"user_id\") val userId: Long,// 外键 用户的id @ColumnInfo(name = \"fav_date\") val date: Date// 创建日期) &#123; @PrimaryKey(autoGenerate = true) @ColumnInfo(name = \"id\") var id: Long = 0&#125; 对于其中注解的解释： @Entity：声明这是一个表（实体），主要参数：tableName表名、foreignKeys外键、indices索引 ColumnInfo：主要用来修改在数据库中的字段名 PrimaryKey：声明该字段为主键，可以声明是否自动创建 Ignore：声明某个字段只是临时用，不存储在数据库中 Embedded：用于嵌套，里面的字段同样会存储在数据库中 最后一个，在User表中有一个变量address，它是一个Address类： 12345678package com.ly.allendemojetpack.db.data/** * 地址 */data class Address( val street: String, val state: String, val city: String, val postCode: String) 通常，如果想这些字段存储在数据库中，有两种方法： 重新创建一个表，进行一对一的关联，但是多创建一个表显得麻烦 在用户表中增加字段，但是这样映射出来的对象显得 不面向对象 @Embedded就是为了解决上面你的第2个问题，即不多创建一个表，又能将数据库中映射的对象看上去面向对象。 Shoe表： 123456789101112131415161718192021222324package com.ly.allendemojetpack.db.dataimport androidx.room.ColumnInfoimport androidx.room.Entityimport androidx.room.PrimaryKey/** * 鞋子表 * * @author Liuyang * @date 2019/8/3 */@Entity(tableName = \"shoe\")data class Shoe( @ColumnInfo(name = \"shoe_name\") val name: String, @ColumnInfo(name = \"shoe_description\") val description: String, @ColumnInfo(name = \"shoe_price\") val price: Float, @ColumnInfo(name = \"shoe_brand\") val brand: String, @ColumnInfo(name = \"shoe_imgUrl\") val imgUrl: String) &#123; @PrimaryKey(autoGenerate = true) @ColumnInfo(name = \"id\") var id: Long = 0&#125; 2.3 步骤3：创建Dao数据处理的方法，就是数据的增删改查。在抽象类或接口加一个@Dao注解即可。 2.3.1 增@Insert注解，声明当前的方法为新增的方法，并且可以设置当新增冲突的时候处理的方法。 1234567891011121314151617181920212223242526272829303132333435363738/** * 鞋子表的方法 * * @author Liuyang * @date 2019/8/3 */@Daointerface ShoeDao &#123; /** * 选择所有的鞋 */ @Query(\"SELECT * FROM shoe\") fun getAllShoes(): LiveData&lt;List&lt;Shoe&gt;&gt; /** * 通过id查找鞋子 */ @Query(\"SELECT * FROM shoe WHERE id = :id\") fun findShoeById(id: Long): LiveData&lt;Shoe&gt; /** * 通过品牌找鞋子 */ @Query(\"SELECT * FROM shoe WHERE shoe_brand = :brand\") fun findShoeByBrand(brand: String): LiveData&lt;List&lt;Shoe&gt;&gt; /** * 插入一种鞋子 */ @Insert(onConflict = OnConflictStrategy.REPLACE) fun insertShoe(shoe: Shoe) /** * 插入多种鞋子 */ @Insert(onConflict = OnConflictStrategy.REPLACE) fun insertShoe(shoes: List&lt;Shoe&gt;)&#125; 2.3.2 删@Delete注解，声明当前的方法是一个删除方法。 2.3.3 改@Update注解，声明当前方法是一个更新方法 2.3.4 查@Query注解，不仅可以声明这是一个查询语句，也能用来删除和修改，不能用来新增。 简单查询除了简单查询，还能配合LiveData和RxJava。这里使用的是implementation &#39;io.reactivex.rxjava2:rxjava:2.2.3&#39;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.ly.allendemojetpack.db.daoimport androidx.lifecycle.LiveDataimport androidx.room.Daoimport androidx.room.Insertimport androidx.room.OnConflictStrategyimport androidx.room.Queryimport com.ly.allendemojetpack.db.data.Shoeimport io.reactivex.Flowable/** * 鞋子表的方法 * * @author Liuyang * @date 2019/8/3 */@Daointerface ShoeDao &#123; /** * 通过id查找鞋子 */ @Query(\"SELECT * FROM shoe WHERE id = :id\") fun findShoeById(id: Long): Shoe? /** * 通过品牌找鞋子 */ @Query(\"SELECT * FROM shoe WHERE shoe_brand = :brand\") fun findShoeByBrand(brand: String): List&lt;Shoe&gt; /** * 模糊查询 排序 同名鞋名查询鞋 */ @Query(\"SELECT * FROM shoe WHERE shoe_name LIKE :name ORDER BY shoe_brand ASC\") fun findShoesByName(name: String): List&lt;Shoe&gt; /** * 配合LiveData，返回所有鞋子 */ @Query(\"SELECT * FROM shoe\") fun getAllShoesLD(): LiveData&lt;List&lt;Shoe&gt;&gt; /** * 配合LiveData，通过id查找鞋子 */ @Query(\"SELECT * FROM shoe WHERE id = :id\") fun findShoeByIdLD(id: Long): LiveData&lt;Shoe&gt; /** * 配合RxJava，通过id查询单款鞋子 */ @Query(\"SELECT * FROM shoe WHERE id=:id\") fun findShoeByIdRx(id: Long): Flowable&lt;Shoe&gt;&#125; 查询多个的时候，可以返回List和数组，还可以配合LiveData和RxJava。 复合查询12345678910/** * 根据收藏结合，查询用户喜欢的鞋的集合 */@Query( \"SELECT shoe.id,shoe.shoe_name,shoe.shoe_description,shoe.shoe_price,shoe.shoe_brand,shoe.shoe_imgUrl \" + \"FROM shoe \" + \"INNER JOIN fav_shoe ON fav_shoe.shoe_id = shoe.id \" + \"WHERE fav_shoe.user_id = :userId\")fun findShoesByUserId(userId: Long): LiveData&lt;List&lt;Shoe&gt;&gt; 2.4 步骤4：创建数据库创建一个数据库对象非常消耗资源，使用单例模式可以避免更多的资源消耗。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.ly.allendemojetpack.dbimport android.content.Contextimport androidx.room.Databaseimport androidx.room.Roomimport androidx.room.RoomDatabaseimport androidx.sqlite.db.SupportSQLiteDatabaseimport androidx.work.OneTimeWorkRequestBuilderimport androidx.work.WorkManagerimport com.ly.allendemojetpack.db.dao.FavouriteShoeDaoimport com.ly.allendemojetpack.db.dao.ShoeDaoimport com.ly.allendemojetpack.db.dao.UserDaoimport com.ly.allendemojetpack.db.data.Shoeimport com.ly.allendemojetpack.db.data.Userimport com.ly.allendemojetpack.utils.ShoeWorker/** * 数据库文件 * * @author Liuyang * @date 2019/8/2 */@Database(entities = [User::class, Shoe::class], version = 1, exportSchema = false)abstract class AppDataBase : RoomDatabase() &#123; abstract fun userDao(): UserDao abstract fun shoeDao(): ShoeDao abstract fun favouriteShoeDao(): FavouriteShoeDao companion object &#123; @Volatile private var instance: AppDataBase? = null fun getInstance(context: Context): AppDataBase &#123; return instance ?: synchronized(this) &#123; instance ?: buildDataBase(context) .also &#123; instance = it &#125; &#125; &#125; private fun buildDataBase(context: Context): AppDataBase &#123; return Room.databaseBuilder(context, AppDataBase::class.java, \"jetpack_db\") .addCallback(object : RoomDatabase.Callback() &#123; override fun onCreate(db: SupportSQLiteDatabase) &#123; super.onCreate(db) // 读取鞋的集合 val request = OneTimeWorkRequestBuilder&lt;ShoeWorker&gt;().build() WorkManager.getInstance(context).enqueue(request) &#125; &#125; ) .build() &#125; &#125;&#125; @Database注解声明当前是一个数据库文件，注解中entities变量声明数据库中的表（实体），以及版本等变量。同时，获取的Dao也必须在数据库类中。完成之后，make project一下工程，系统后自动创建AppDataBase和xxxDao的实现类。 2.5 步骤5：简单封装在不使用LiveData和RxJava前提下，Room的操作不能放在主线程中。这里看看UserRepository： 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.ly.allendemojetpack.db.repositoryimport com.ly.allendemojetpack.db.dao.UserDaoimport com.ly.allendemojetpack.db.data.Userimport kotlinx.coroutines.Dispatchers.IOimport kotlinx.coroutines.withContextclass UserRepository private constructor(private val userDao: UserDao) &#123; /** *用户登录 */ fun login(account: String, pwd: String) = userDao.login(account, pwd) /** * 用户注册 */ suspend fun register(email: String, account: String, pwd: String): Long &#123; return withContext(IO) &#123; userDao.insertUser(User(account, pwd, email)) &#125; &#125; /** * 获取所有用户 */ fun getAllUsers() = userDao.getAllUsers() /** * 通过id获取用户 */ fun findUserById(id: Long) = userDao.findUserById(id) companion object &#123; @Volatile private var instance: UserRepository? = null fun getInstance(userDao: UserDao): UserRepository = instance ?: synchronized(this) &#123; instance ?: UserRepository(userDao).also &#123; instance = it &#125; &#125; &#125;&#125; register()是一个普通方法，所以需要在子线程中使用，这里通过协程实现。login()是配合LiveData使用的， 不需要额外创建子线程，但是其核心数据库操作还在子线程中实现的。 这时，就可以操作本地数据库了。 3. 其他3.1 类型转换器SQLite支持的类型有：NULL、INTEGER、REAL、TEXT和BLOB，对于Data类，SQLite还可以将其转化为TEXT、REAL或者INTEGER，如果是Calendar类呢？Room提供了这一解决方法，使用@TypeConverter注解，谷歌官方示例：android-sunflower： 123456class Converters &#123; @TypeConverter fun calendarToDatestamp(calendar: Calendar): Long = calendar.timeInMillis @TypeConverter fun datestampToCalendar(value: Long): Calendar = Calendar.getInstance().apply &#123; timeInMillis = value &#125;&#125; 然后在数据库声明的时候，加上@TypeConverter(COnverter::class)即可： 12345@Database(...)@TypeConverters(Converters::class)abstract class AppDatabase : RoomDatabase() &#123; //...&#125; 3.2 数据库迁移：这个还需要查找资料Android Room 框架学习","categories":[{"name":"Android","slug":"Android","permalink":"https://tylerLiu.top/categories/Android/"},{"name":"Jetpack","slug":"Android/Jetpack","permalink":"https://tylerLiu.top/categories/Android/Jetpack/"}],"tags":[{"name":"Jetpack","slug":"Jetpack","permalink":"https://tylerLiu.top/tags/Jetpack/"}]},{"title":"Android Jetpack：ViewModel&LiveData","slug":"Android-Jetpack-ViewModel-LiveData","date":"2019-08-02T05:40:06.000Z","updated":"2019-08-22T03:13:54.375Z","comments":true,"path":"2019/08/02/Android-Jetpack-ViewModel-LiveData/","link":"","permalink":"https://tylerLiu.top/2019/08/02/Android-Jetpack-ViewModel-LiveData/","excerpt":"","text":"在Android-Jetpack-DataBinding中，讨论了MVVM模式和Data Binding组件，这里继续学习跟MVVM有关的Android Jetpack组件——ViewModel和LiveData。 1. LiveData官方文档：LiveData 先来看看LiveData和ViewMOdel的作用： 从上图可以看出，LiveData和ViewModel在整个MVVM中担任数据驱动的职责，这也是MVVM中ViewMoel层的作用。 1.1 介绍官网介绍： LiveData is an observable data holder class. Unlike a regular observable, LiveData is lifecycle-aware, meaning it respects the lifecycle of other app components, such as activities, fragments, or services. This awareness ensures LiveData only updates app component observers that are in an active lifecycle state.直译：LiveData是一个可观察的数据持有者类。与常规的可观察对象不同，LiveData是生命周期感知的，这意味着它尊重其他应用程序组件的生命周期，比如活动、片段或服务。这种意识确保LiveData只更新处于活动生命周期状态的应用程序组件观察者。 可以看出LiveData作用和RxJava类似，是观察数据的类，相比RxJava，LiveData能在Activity、Fragment和Service中正确处理声明周期。LiveData的优点： 数据变更时更新UI 没有内存泄露 不会因为停止Activity崩溃 无需手动处理生命周期 共享资源 1.2 使用方式常用的API： observe(@NotNull LifeCycleOwner owner, @NotNull Observe&lt;? super T&gt; observer)：最常用的方法，需要提供Observer数据变更后的处理。LifeCycleOwner是能够正确处理生命周期的关键 setValue(T value)：设置数据 getValue():T：获取数据 postValue(T value)：在主线程更新数据 1.3 使用场景配合Android Jetpack的其他组件使用，如ViewModel和Room。 2. ViewModel官方文档：ViewModel MVVM中ViewModel层是用来逻辑处理的，Android Jetpack中的ViewModel是否一样呢？ 2.1 介绍官网介绍： The ViewModel class is designed to store and manage UI-related data in a lifecycle conscious way. The ViewModel class allows data to survive configuration changes such as screen rotations. ViewModel同样具有生命周期，用来处理跟UI相关的数据，并且，当设备的一些配置信息改变（如屏幕旋转）时，它的数据不会消失。通常，如果不做特殊处理，当屏幕旋转时，数据会消失，ViewModel管理数据为什么不会消失？因为ViewModel的生命周期： ViewModel的另一个特点就是实现Actiivty和Framgent之间的数据共享。 2.2 使用方法继承ViewMoel即可。 2.3 Demo2.3.1 步骤1：添加依赖12345// liveDataimplementation \"androidx.lifecycle:lifecycle-livedata-ktx:2.2.0-alpha02\"// viewModelimplementation \"androidx.lifecycle:lifecycle-viewmodel-ktx:2.2.0-alpha02\"implementation \"androidx.lifecycle:lifecycle-extensions:2.2.0-alpha02\" 2.3.2 步骤2：创建Model继承ViewModel，分别创建品牌名的观察对象brand:MutableliveData&lt;String&gt;和对鞋子集合的观察对象shose:LiveData&lt;List&lt;Shoe&gt;&gt;： 1234567891011121314151617181920212223242526272829303132package com.ly.allendemojetpack.viewmodelimport androidx.lifecycle.*import com.ly.allendemojetpack.db.data.Shoeimport com.ly.allendemojetpack.db.repository.ShoeRepositoryclass ShoeModel constructor(repository: ShoeRepository) : ViewModel() &#123; companion object &#123; private const val ALL = \"所有\" &#125; /** * 品牌的观察对象，默认观察所有的品牌 */ private val brand = MutableLiveData&lt;String&gt;().apply &#123; value = ALL &#125; /** * 鞋子集合的观察类 */ val shoes: LiveData&lt;List&lt;Shoe&gt;&gt; = brand.switchMap &#123; // Room数据库查询，只要知道返回的是LiveData&lt;List&lt;Shoe&gt;&gt;即可 if (it == ALL) &#123; repository.getAllShoes() &#125; else &#123; repository.getShoeByBrand(it) &#125; &#125; ......&#125; 2.3.3 步骤3：获取ViewModel 无构造参数获取：构造函数没有参数的情况下，获取ShoeModel很简单，ViewModelProvider.of(this).get(ShoeModel::class.java)就能返回需要的ShoeModel。 有构造参数获取：上面的ShoeModel需要传入一个参数ShoeRepository，这时，就需要自定义实现Factory：1234567891011121314package com.ly.allendemojetpack.viewmodel.factoryimport androidx.lifecycle.ViewModelimport androidx.lifecycle.ViewModelProviderimport com.ly.allendemojetpack.db.repository.ShoeRepositoryimport com.ly.allendemojetpack.viewmodel.ShoeModelclass ShoeModelFactory( private val repository: ShoeRepository) : ViewModelProvider.NewInstanceFactory() &#123; override fun &lt;T : ViewModel?&gt; create(modelClass: Class&lt;T&gt;): T &#123; return ShoeModel(repository) as T &#125;&#125; 为了方便使用，这里写了一个统一的工具类CustomViewModelProvider： 12345678910111213141516171819202122232425package com.ly.allendemojetpack.viewmodelimport android.content.Contextimport androidx.navigation.NavControllerimport com.ly.allendemojetpack.db.RepositoryProviderimport com.ly.allendemojetpack.db.repository.ShoeRepositoryimport com.ly.allendemojetpack.db.repository.UserRepositoryimport com.ly.allendemojetpack.viewmodel.factory.LoginModelFactoryimport com.ly.allendemojetpack.viewmodel.factory.RegisterModelFactoryimport com.ly.allendemojetpack.viewmodel.factory.ShoeModelFactory/** * ViewModel提供者 * * @author Liuyang * @date 2019/8/3 */object CustomViewModelProvider &#123; ...... fun providerShoeModel(context: Context): ShoeModelFactory &#123; val repository: ShoeRepository = RepositoryProvider.providerShoeRepository(context) return ShoeModelFactory(repository) &#125;&#125; 最后就能在ShoeFragemnt中获取ShoeModel： 1234// by viewModels 需要依赖 \"androidx.navigation:navigation-ui-ktx:$rootProject.navigationVersion\"private val viewModel: ShoeModel by viewModels &#123; CustomViewModelProvider.providerShoeModel(requireContext())&#125; 2.3.4 步骤4：使用ViewModelViewModel的使用需要结合具体的业务，这里的ShoeModel在ShoeFragment中的使用如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.ly.allendemojetpack.ui.fragment.mainimport android.os.Bundleimport android.view.LayoutInflaterimport android.view.Viewimport android.view.ViewGroupimport androidx.fragment.app.Fragmentimport androidx.fragment.app.viewModelsimport androidx.lifecycle.Observerimport androidx.lifecycle.ViewModelProvidersimport com.ly.allendemojetpack.databinding.FragmentShoeBindingimport com.ly.allendemojetpack.ui.adapter.ShoeAdapterimport com.ly.allendemojetpack.viewmodel.CustomViewModelProviderimport com.ly.allendemojetpack.viewmodel.ShoeModel/** * 鞋子的Fragment * * @author Liuyang * @date 2019/8/3 */class ShoeFragment : Fragment() &#123; // by viewModels 需要依赖 \"androidx.navigation:navigation-ui-ktx:$rootProject.navigationVersion\" private val viewModel: ShoeModel by viewModels &#123; CustomViewModelProvider.providerShoeModel(requireContext()) &#125; override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? &#123; val binding: FragmentShoeBinding = FragmentShoeBinding.inflate(inflater, container, false) context ?: return binding.root ViewModelProviders.of(this).get(ShoeModel::class.java) // 适配器 val adapter = ShoeAdapter() binding.recycler.adapter = adapter onSubscribeUi(adapter) return binding.root &#125; /** * 鞋子数据更新的通知 */ private fun onSubscribeUi(adapter: ShoeAdapter) &#123; viewModel.shoes.observe(viewLifecycleOwner, Observer &#123; if (it != null) &#123; adapter.submitList(it) &#125; &#125;) &#125;&#125; 在onSubscribeUi()中，使用ShoeModel的LiveData进行观察通知，当鞋子集合更新数据时，就会更新到当前的适配器中。 布局文件framgent_shoe.xml很简单，虽然使用了Data Binding，但是没有变量，只有一个RecyclerView。 Demo地址：Allen_Demo_Jetpack 3. 其他3.1 LiveData数据变换LiveData中数据变换方法有map()和switchMap()，switchMap()在上面已经看到了： 1234567891011121314151617181920212223242526272829303132333435363738394041// 本地数据仓库class ShoeRepository private constructor(private val shoeDao: ShoeDao) &#123; fun getAllShoes() = shoeDao.getAllShoes() /** * 通过品牌查询鞋子，返回LiveData&lt;List&lt;Shoe&gt;&gt; */ fun getShoeByBrand(brand: String) = shoeDao.findShoeByBrand(brand) /** * 插入鞋子的集合，返回LiveData&lt;List&lt;Shoe&gt;&gt; */ fun insertShoes(shoes: List&lt;Shoe&gt;) = shoeDao.insertShoe(shoes) ......&#125;class ShoeModel constructor(repository: ShoeRepository) : ViewModel() &#123; companion object &#123; private const val ALL = \"所有\" &#125; /** * 品牌的观察对象，默认观察所有的品牌 */ private val brand = MutableLiveData&lt;String&gt;().apply &#123; value = ALL &#125; /** * 鞋子集合的观察类 */ val shoes: LiveData&lt;List&lt;Shoe&gt;&gt; = brand.switchMap &#123; // Room数据库查询，只要知道返回的是LiveData&lt;List&lt;Shoe&gt;&gt;即可 if (it == ALL) &#123; repository.getAllShoes() &#125; else &#123; repository.getShoeByBrand(it) &#125; &#125;&#125; map()的使用借用官方的例子： 1234val userLiveData: LiveData&lt;User&gt; = UserLiveData()val userName: LiveData&lt;String&gt; = Transformations.map(userLiveData) &#123; user -&gt; \"$&#123;user.name&#125; $&#123;user.lastName&#125;\"&#125; 可以看到，map()也可以实现将A变成B，二者有什么区别呢？ map()中只有一个LiveData&lt;A&gt;，它在LiveData&lt;A&gt;发送数据的时候将A变成B switchMap()中同时存在LiveData&lt;A&gt;和LiveData&lt;B&gt;，LiveData&lt;A&gt;更新之后，通知LiveData&lt;B&gt;更新。 3.2 LiveData如何共享数据如果有这样的需求：注册页需要记录信息，注册完成跳转到登录页，并将账号和密码显示在登录页。这时，可以定义一个类然后继承LiveData，并使用单例模式即可： 123456789package com.ly.allendemojetpack.common.livedata/** * 登录信息 * * @author Liuyang * @date 2019/8/3 */data class LoginInfo constructor(val account: String, val pwd: String, val email: String) 12345678910111213141516171819202122package com.ly.allendemojetpack.common.livedataimport androidx.annotation.MainThreadimport androidx.lifecycle.LiveData/** * 自定义单例LiveData * * @author Liuyang * @date 2019/8/3 */class LoginLiveData : LiveData&lt;LoginInfo&gt;() &#123; companion object &#123; private lateinit var sInstance: LoginLiveData @MainThread fun get(): LoginLiveData &#123; sInstance = if (::sInstance.isInitialized) sInstance else LoginLiveData() return sInstance &#125; &#125;&#125; 3.3 使用ViewModel在同一个Activity中的Fragment之间共享数据要想利用ViewModel实现Fragment之间数据共享，前提是Fragment中的FragmentActivity要相同，这里看看官方示例： 123456789101112131415161718192021222324252627282930313233343536373839class SharedViewModel : ViewModel() &#123; val selected = MutableLiveData&lt;Item&gt;() fun select(item: Item) &#123; selected.value = item &#125;&#125;class MasterFragment : Fragment() &#123; private lateinit var itemSelector: Selector private lateinit var model: SharedViewModel override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) model = activity?.run &#123; ViewModelProviders.of(this).get(SharedViewModel::class.java) &#125; ?: throw Exception(\"Invalid Activity\") itemSelector.setOnClickListener &#123; item -&gt; // Update the UI &#125; &#125;&#125;class DetailFragment : Fragment() &#123; private lateinit var model: SharedViewModel override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) model = activity?.run &#123; ViewModelProviders.of(this).get(SharedViewModel::class.java) &#125; ?: throw Exception(\"Invalid Activity\") model.selected.observe(this, Observer&lt;Item&gt; &#123; item -&gt; // Update the UI &#125;) &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"https://tylerLiu.top/categories/Android/"},{"name":"Jetpack","slug":"Android/Jetpack","permalink":"https://tylerLiu.top/categories/Android/Jetpack/"}],"tags":[{"name":"Jetpack","slug":"Jetpack","permalink":"https://tylerLiu.top/tags/Jetpack/"}]},{"title":"Android Jetpack：DataBinding","slug":"Android-Jetpack-DataBinding","date":"2019-07-31T08:34:26.000Z","updated":"2019-08-22T03:13:22.417Z","comments":true,"path":"2019/07/31/Android-Jetpack-DataBinding/","link":"","permalink":"https://tylerLiu.top/2019/07/31/Android-Jetpack-DataBinding/","excerpt":"","text":"Android Jetpack一系类的内容，适合使用MVVM，这里先看看MVVM。 1. 介绍1.1 MVVM介绍MVVM，全称Model-View-ViewModel，和MVC和MVP一样，是逻辑分层解耦的模式。 1.1.1 结构图 MVVM三要素： View层：xml、Activity、Framgent、Adapter和View等 Model层：数据源（包括本地数据和网络数据等） ViewModel层：View层处理数据以及逻辑处理 1.2 Data Binding介绍MVVM是一种架构模式，Data Binding是一种实现数据和UI绑定的框架，是构建MVVM模式的一个工具。 官方文档：Data Binding 官方Demo地址：android-databinding 2. Demo这里会在前一篇Android-Jetpack-Navigation的基础上进行扩展，如果要查看之前的可以使用git进行版本回退，本文会在注册和登录模块上进行修改。 2.1 步骤1：在module的build.gradle中添加如下：1234567android &#123; ...... dataBinding &#123; enabled true &#125;&#125; 2.2 步骤2：构建LoginModel创建登录的LoginModel，主要负责登录逻辑的处理以及两个输入框内容改变时数据的更新： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.ly.allendemojetpack.viewmodelimport android.content.Contextimport android.content.Intentimport android.text.Editableimport android.widget.EditTextimport android.widget.Toastimport androidx.databinding.BindingAdapterimport androidx.databinding.ObservableFieldimport com.ly.allendemojetpack.MainActivityimport com.ly.allendemojetpack.common.Constantimport com.ly.allendemojetpack.common.listener.SimpleWatcherclass LoginModel constructor(name: String, pwd: String, context: Context) &#123; val n = ObservableField&lt;String&gt;(name) val p = ObservableField&lt;String&gt;(pwd) val context: Context = context /** * 用户名改变时的回调 */ fun onNameChanged(s: CharSequence) &#123; n.set(s.toString()) &#125; /** * 密码改变时的回调 */ fun onPwdChanged(s: CharSequence, start: Int, before: Int, count: Int) &#123; p.set(s.toString()) &#125; /** * 登录的逻辑 */ fun login() &#123; if (n.get().equals(Constant.USERNAME) &amp;&amp; p.get().equals(Constant.PASSWORD)) &#123; Toast.makeText(context, \"账号密码正确\", Toast.LENGTH_SHORT).show() val intent = Intent(context, MainActivity::class.java) context.startActivity(intent) &#125; &#125; val nameWatcher = object : SimpleWatcher() &#123; override fun afterTextChanged(s: Editable) &#123; super.afterTextChanged(s) n.set(s.toString()) &#125; &#125; val pwdWatcher = object : SimpleWatcher() &#123; override fun afterTextChanged(s: Editable) &#123; super.afterTextChanged(s) p.set(s.toString()) &#125; &#125; @BindingAdapter(\"addTextChangedListener\") fun addTextChangedListener(editText: EditText, simpleWatcher: SimpleWatcher) &#123; editText.addTextChangedListener(simpleWatcher) &#125;&#125; ObservableField是一个可观察的域，通过泛型来使用，可以使用的方法有三个： ObservableField(T value)：构造函数，设置可观察的域 T get()：获取可观察的域的内容，可以使用UI控件监测它的值 set(T value)：设置可观察的域，设置成功后，会通知UI控件进行更新 再来看看LoginModel，里面包含了用来观察name和pws的两个成员变量n和p，以及一个登录的逻辑处理方法。 2.3 步骤3：创建布局文件使用Data Binding之后的布局文件和之前的会有很大不同，里面包含了一些新的标签： layout：布局根节点，只能包裹一个View标签，且不能包裹merge标签。 data：Data Binding的数据，只能存放一个data标签。 variable：在data标签中使用，数据的变量标签。type属性指明变量的类。name属性指明变量的名字，方便布局中使用。 import：在data标签中使用，需要使用静态方法和静态常量，如果需要使用view.visible属性的时候，需要导入&lt;import type=&quot;android.view.View&quot;/&gt;。type属性指明类的路径，如果两个import标签带入的类名相同，可以使用alias属性声明别名，使用时直接用别名即可。 来看看LoginFragment的布局文件fragment_login.xml： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\"&gt; &lt;data&gt; &lt;!--ViewModel，通过mBinding.vm=mViewMode注入--&gt; &lt;variable name=\"model\" type=\"com.ly.allendemojetpack.viewmodel.LoginModel\"/&gt; &lt;variable name=\"activity\" type=\"androidx.fragment.app.FragmentActivity\"/&gt; &lt;/data&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;TextView android:id=\"@+id/txt_cancel\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:onClick=\"@&#123;()-&gt; activity.onBackPressed()&#125;\" ...... /&gt; &lt;TextView android:id=\"@+id/txt_title\" app:layout_constraintTop_toTopOf=\"parent\" ...... /&gt; &lt;EditText android:id=\"@+id/et_account\" android:layout_width=\"0dp\" android:layout_height=\"0dp\" android:text=\"@&#123;model.n.get()&#125;\" android:onTextChanged=\"@&#123;(text, start, before, count)-&gt;model.onNameChanged(text)&#125;\" ...... /&gt; &lt;EditText android:id=\"@+id/et_pwd\" android:layout_width=\"0dp\" android:layout_height=\"0dp\" android:text=\"@&#123;model.p.get()&#125;\" android:onTextChanged=\"@&#123;model::onPwdChanged&#125;\" ...... /&gt; &lt;Button android:id=\"@+id/btn_login\" android:layout_width=\"0dp\" android:layout_height=\"0dp\" android:onClick=\"@&#123;()-&gt; model.login()&#125;\" android:enabled=\"@&#123;(model.p.get().isEmpty()||model.n.get().isEmpty()) ? false : true&#125;\" ...... /&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;&lt;/layout&gt; variable有了两个： model：类型为com.ly.allendemojetpack.viewmodel.LoginModel，绑定用户名。 activity：类型为androidx.fragment.app.FragmentActivity，主要用来处理返回按钮事件。 知识点讲解： 属性的引用如果想使用ViewModel中成员变量，直接使用model.p即可。 事件绑定事件绑定包括方法引用和监听绑定： 方法引用：参数类型和返回类型要一致，参考et_pwd的android:onTextChanged引用 监听绑定：要求没有方法引用高，可以使用自定义函数，参考et_account的android:onTextChanged引用。 表达式btn_login按钮在账号或密码为空的时候，是灰色的： 这是因为在代码中设置了android:enabled=&quot;@{(model.p.get().isEmpty()||model.n.get().isEmpty()) ? false : true}&quot;，意思是用户名或密码为空时，设置android:enable属性设置为flase，这是一个三元表达式，除了上面的||和三元表达式，Data Binding还支持： 运算符 + - / * % 字符串连接 + 逻辑与或 &amp;&amp; || 二进制 &amp; | ^ 一元 + - ! ~ 移位 &gt;&gt; &gt;&gt;&gt; &lt;&lt; 比较 == &gt; &lt; &gt;= &lt;= (Note that &lt; needs to be escaped as &lt;) instanceof Grouping () Literals - character, String, numeric, null Cast 方法调用 域访问 数组访问 三元操作符 除了上述，Data Binding还新增了空合并操作符??，例如androud:text=&quot;@{user.displayName ?? user.lastName}&quot;等价于android:text=&quot;@{user.displayName != null ? user.displayName : user.lastName}&quot; 2.4 生成绑定类创建完布局文件之后，点击Make Project按钮，系统会自动生成绑定类： 下面只需要在LoginFragment中完成绑定操作即可，既可以使用生成的FragmentLoginBinding，也可以使用自带的BindingUtil。 使用BindingUtilBindingUtil常用的API： setContentView()：进行Activity下面的绑定 inflate：进行Fragment下面的绑定 bind：进行View的绑定 LoginFragemnt绑定代码如下： 12345678910override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? &#123; val binding: FragmentLoginBinding = DataBindingUtil.inflate( inflater, R.layout.fragment_login, container, false ) loginModel = LoginModel(\"\", \"\", context!!) binding.model = loginModel binding.activity = activity return binding.root&#125; 使用生产的FragmentLoginBinding使用方法与DataBindingUtil类似：1234567override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? &#123; val binding = FragmentLoginBinding.inflate(inflater, container, false) loginModel = LoginModel(\"\", \"\", context!!) binding.model = loginModel binding.activity = activity return binding.root&#125; 3. Data Binding的一些其他功能3.1 布局中属性的设置3.1.1 有属性有setter如果一个XXXView类中有成员变量borderColor，并且XXXView类中有setBorderColor(int color)方法，那么在布局文件中，可以借助Data Binding直接使用app:borderColor属性。 3.1.2 没有setter，但有相关方法以XXXView为例，内有有成员变量borderColor，这次设置borderColor的方法是setBorder()（或者其他，总之不是标准的set方法，setBorderColor()），还使用app:borderColor肯定不行的。这时，可以通过BindingMethods注解实现app:borderColor的使用，如下： 12345@BindingMethods(value = [ BindingMethod( type = 包名.XXXView::class, attribute = \"app:borderColor\", method = \"setBColor\")]) 3.1.3 自定义属性现在不仅没有setter方法，甚至成员变量都没有。例如现在要给EditText添加文本监听器，这样，现在LoginModel中自定义个监听器，并使用@BindingAdapter注解： 123456789101112val nameWatcher = object : SimpleWatcher() &#123; override fun afterTextChanged(s: Editable) &#123; super.afterTextChanged(s) n.set(s.toString()) &#125;&#125;@BindingAdapter(\"addTextChangedListener\")fun addTextChangedListener(editText: EditText, simpleWatcher: SimpleWatcher) &#123; editText.addTextChangedListener(simpleWatcher)&#125; 这样就可以在布局文件中使用app:addTextChangedListener属性了： 123456&lt;EditText android:id=\"@+id/et_account\" android:text=\"@&#123;model.n.get()&#125;\" app:addTextChangedListener=\"@&#123;model.nameWatcher&#125;\" ... /&gt; 效果和之前的一样。 3.2 数据双向绑定数据双向绑定可以分为两种情况：数据刷新视图和视图刷新数据。 3.2.1 数据刷新视图需要数据变化时视图也跟着变化。有了两种实现方式： 自定义继承BaseObservable 使用ObservableField 继承BaseObservable123456789101112131415161718192021222324252627282930313233package com.ly.allendemojetpack;import androidx.databinding.BaseObservable;import androidx.databinding.Bindable;public class ObservableUser extends BaseObservable &#123; private String firstName; private String lastName; /** * 注解才会自动在build目录BR类中生成entry, 要求方法名必须以get开头 */ @Bindable public String getFirstName() &#123; return firstName; &#125; @Bindable public String getLastName() &#123; return lastName; &#125; public void setFirstName(String firstName) &#123; this.firstName = firstName; // 手动刷新 notifyPropertyChanged(BR.firstName); &#125; public void setLastName(String lastName) &#123; this.lastName = lastName; notifyPropertyChanged(BR.lastName); &#125;&#125; BaseObservable和Observable的区别： BaseObservable是实现了Observable的类，帮助实现监听器的线程安全问题； BaseObservable使用了addPropertyChangeRegistry()来执行OnPropertyChangedCallback()； 不建议直接实现Observable。 使用ObservableFieldData Binding默认实现了一系列Observable接口的字段：123456789101112BaseObservable,ObservableBoolean,ObservableByte,ObservableChar,ObservableDouble,ObservableField&lt;T&gt;,ObservableFloat,ObservableInt,ObservableLong,ObservableParcelable&lt;T extends Parcelable&gt;,ObservableShort,ViewDataBinding 示例： 12345public class PlainUser &#123; public final ObservableField&lt;String&gt; firstName = new ObservableField&lt;&gt;(); public final ObservableField&lt;String&gt; lastName = new ObservableField&lt;&gt;(); public final ObservableInt age = new ObservableInt();&#125; 对于集合类型，可以使用ObservableArryMap、ObservableArryList、ObservableMap等集合类型： 1234ObservableArrayMap&lt;String, Object&gt; user = new ObservableArrayMap&lt;&gt;();user.put(\"firstName\", \"Google\");user.put(\"lastName\", \"Inc.\");user.put(\"age\", 17); 使用 12345678910111213&lt;data&gt; &lt;import type=\"android.databinding.ObservableMap\"/&gt; &lt;variable name=\"user\" type=\"ObservableMap&lt;String, Object&gt;\"/&gt;&lt;/data&gt;…&lt;TextView android:text='@&#123;user[\"lastName\"]&#125;' android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"/&gt;&lt;TextView android:text='@&#123;String.valueOf(1 + (Integer)user[\"age\"])&#125;' android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"/&gt; 还支持ObservableParcelable&lt;Object&gt;序列化数据类型； ObservableField同样可以使用addPropertyChangedCallback监听属性变化。 3.2.2 视图刷新数据通过使用表达式@=就可以在视图刷新时自动刷新数据，但是要求数据实现以下 两种方式修改才会触发刷新： 12345&lt;EditText android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:inputType=\"textNoSuggestions\" android:text=\"@=&#123;model.name&#125;\"/&gt; 这种双向绑定会存在一个死循环的问题，即数据变化（回调监听器）触发了视图变化，视图变化又会触发数据变化（再次回调监听），一直循环，设置相同的数据也会视为数据变化。 所以需要判断当前变化的数据是否等于旧数据： 123456789101112131415161718192021222324252627282930313233343536373839package com.ly.allendemojetpack;import android.widget.TextView;import androidx.databinding.BindingAdapter;public class CustomBindingAdapter &#123; @BindingAdapter(\"android:text\") public static void setText(TextView view, CharSequence text) &#123; CharSequence oldText = view.getText(); if (!haveContentChanged(text, oldText)) &#123; // 数据没有变化时，不进行视图刷新 return; &#125; view.setText(text); &#125; /** * 本方法使用的是官方源码 */ private static boolean haveContentChanged(CharSequence str1, CharSequence str2) &#123; if ((str1 == null) != (str2 == null)) &#123; return true; &#125; else if (str1 == null) &#123; return false; &#125; final int length = str1.length(); if (length != str2.length()) &#123; return true; &#125; for (int i = 0; i &lt; length; i++) &#123; if (str1.charAt(i) != str2.charAt(i)) &#123; return true; &#125; &#125; return false; &#125;&#125; 下面这种判断是无效的，因为String参数传递属于引用类型变量，不是常量，需要使用equals()： 1234// 本段截取官方源码，是错误的if (text == oldText || (text == null &amp;&amp; oldText.length() == 0)) &#123; return; &#125; 正确写法： 123if (text == null || text.equals(oldText) || oldText.length() == 0) &#123; return;&#125; 回到本例，比如上面的EditText在实现双向绑定后，既不需要添加SimpleWatcher，也不需要用方法调用，实现代码如下： 1234567&lt;EditText android:id=\"@+id/et_account\" android:layout_width=\"0dp\" android:layout_height=\"0dp\" android:text=\"@=&#123;model.n.get()&#125;\" ...... /&gt; 仅仅将@{model.n.get()}换为@={model.n.get()},需要注意，属性必须是可观察的，即使用上面提到的ObservableField，也可以自定义实现BaseObservable接口。 4. 注解4.1 @Bindable用于数据更新自动刷新视图。 4.2 BindingAdapter创建一个XML属性和函数，然后在属性中进行设置数据操作会进入该函数。图片加载框架可以使用此方法。 1234@BindingAdapter(value = &#123; \"imageUrl\", \"error\" &#125;, requireAll = false)public static void loadImage(ImageView view, String url, Drawable error) &#123; Glide.with(view.getContext()).load(url).into(view);&#125; 方法必须是public static； 第一个参数必须是控件或其父类 方法名随意 最后一个boolean类型是可选参数，可以要求是否所有参数都要填写，默认为true 如果requireAll为false，没有填的属性将默认为null，所以需要做非空判断 使用： 123456&lt;ImageView android:layout_width=\"match_parent\" android:layout_height=\"200dp\" app:error=\"@&#123;@drawable/error&#125;\" allen:imageUrl=\"@&#123;imageUrl&#125;\" app:onClickListener=\"@&#123;activity.avatarClickListener&#125;\"/&gt; 命名空间可以是随意的，但如果在BindingAdapter的数组内定义了命名空间，就必须遵守。 例如： 123456// 这里省略了一个注解参数. @BindingAdapter(&#123; \"android:imageUrl\", \"error\" &#125;)public static void loadImage(ImageView view, String url, Drawable error) &#123; if(url == null) return; Glide.with(view.getContext()).load(url).into(view);&#125; 如果数据初始化在异步，会回调方法，但数据为null（成员默认值），所以要先进行非空判断。 Kotlin有两种实现方式： 单例 + @JvmStatic注解 123456object ProgressAdapter &#123; @JvmStatic @BindingAdapter(\"android:bindName\") fun setBindName(view: View, name:String)&#123; &#125;&#125; 顶级函数 12345678@BindingAdapter(\"android:bindName\")fun setBindName(view: View, name:String)&#123;&#125;// 由于顶级函数太多影响代码补全建议使用顶级扩展函数, 之后也可以在代码中方便使用@BindingAdapter(\"android:bindName\")fun View.setBindName( name:String)&#123;&#125; 4.3 @BindingMethods如果想创建一个XML属性并且和View中函数关联（即自动使用属性值作为参数调用该函数），就可以使用@BindingMethods注解这个类（也可以是一个接口）。 该注解属于一个容器，内部参数是一个@BindingMethods数组，只能用于修饰类或接口。 官方Demo： 1234567@BindingMethods(&#123; @BindingMethod(type = android.widget.ProgressBar.class, attribute = \"android:indeterminateTint\", method = \"setIndeterminateTintList\"), @BindingMethod(type = android.widget.ProgressBar.class, attribute = \"android:progressTint\", method = \"setProgressTintList\"), @BindingMethod(type = android.widget.ProgressBar.class, attribute = \"android:secondaryProgressTint\", method = \"setSecondaryProgressTintList\"),&#125;)public class ProgressBarBindingAdapter &#123;&#125; @BindingMethods注解参数（必选）： type：字节码，即控件类型 attribute：XML属性 method：函数名，即控件中的函数名称 注意： 如果属性名和@BindingAdapter定义的XML属性相同，会冲突报错 如果控件类中已经存在一个和定义的属性相关联的函数（例如setName函数和android:name属性就相关联），则会优先执行该函数。 4.4 @BindingConversion属性值自动进行类型转换。 只能修饰public static方法 任意位置任意方法名都不受限制 Data Binding自动匹配被该注解修饰的方法和参数类型 返回值类型必须和属性setter方法匹配，且参数只有一个 要求属性值必须是@{}Data Binding表达式 官方示例： 12345678910public class Converters &#123; @BindingConversion public static ColorDrawable convertColorToDrawable(int color) &#123; return new ColorDrawable(color); &#125; @BindingConversion public static ColorStateList convertColorToColorStateList(int color) &#123; return ColorStateList.valueOf(color); &#125;&#125; kotlin示例： 123456@BindingConversionfun int2string(integer:Int):String&#123; Log.d(\"日志\", \"(CusView.kt:92) int2string ___ integer = [$integer]\") return integer.toString()&#125; XML 1234567891011121314151617181920212223242526&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\"&gt; &lt;data&gt; &lt;variable name=\"m\" type=\"com.example.architecture.Model\" /&gt; &lt;/data&gt; &lt;FrameLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".MainActivity\"&gt; &lt;com.example.architecture.CusView android:bindName=\"@=&#123;m.age&#125;\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt; &lt;/FrameLayout&gt;&lt;/layout&gt; 上面这段代码会报错，因为涉及双向数据绑定，@BindingConversion只会在数据设置视图时生效，但是如果是视图设置数据则会走其他函数（如get()），如果该函数返回的类型和Model中的类型不匹配会报异常，除非将函数改为类型匹配，或者去掉=，不使用双向数据绑定。 android:text不能使用int转为String，因为它本身能正常接收int（作为resouceId），会报： 1android.content.res.Resources$NotFoundException: String resource ID #0xa 4.5 @InverseMethodAndroid Studio 3.0提供了inverse系列新的注解，都是针对数据双向绑定的。 在数据和视图的数据不统一时可以使用该注解@InverseMethod解决数据转换问题。 例如，数据模型存储的是用户id，但视图不显示id，而是显示用户名（数据和视图类型不一样），就需要进行二者的转换。 需要两个函数：设置数据到视图的函数set()和设置视图变更到数据的函数get() set()和get()都至少有一个参数 自身参数必须和另一个函数的返回值对应 简单示例：在用户id和用户名称之间转换，存储的是id，但显示的是用户名。 12345678910111213141516package com.ly.allendemojetpack.DataBindingOtherimport androidx.databinding.InverseMethodclass Model &#123; var name = \"设计师\" @InverseMethod(\"ui2data\") fun data2ui(): String &#123; return \"设计师1\" &#125; fun ui2data(): String &#123; return \"设计师2\" &#125;&#125; 使用： 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\"&gt; &lt;data&gt; &lt;variable name=\"model\" type=\"com.ly.allendemojetpack.DataBindingOther.Model\"/&gt; &lt;/data&gt; &lt;FrameLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".MainActivity\"&gt; &lt;com.ly.allendemojetpack.DataBindingOther.CusView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@&#123;model.data2ui(model.name)&#125;\"/&gt; &lt;/FrameLayout&gt;&lt;/layout&gt; 4.6 @InverseBindingAdapter参数： String attribute：属性值，必填 String event：默认值，非必填，属性值 + AttrChanged后缀 和@BindingAdapter配合，实现双向绑定。 完全的双向绑定需要三个函数： set()：数据到视图 get()：视图到数据 notify()：通知Data Binding视图已经刷新，可以更新数据（Model）了 set()函数： 123456@BindingAdapter(\"android:bindName\")fun TextView.setBindName(name:String?)&#123; if (name.isNullOrEmpty() &amp;&amp; name != text) &#123; text = name &#125;&#125; get()函数： 12345@InverseBindingAdapter(attribute = \"android:bindName\", event = \"cus_event\")fun TextView.getBindName():String&#123; // 这里你可以对视图上的数据进行处理最终设置给Model层 return text.toString()&#125; 不允许有更多参数 返回值类型必须是绑定的数据类型 notify()视图变化后要通知Data Binding开始设置Model层，也要用到@BindingAdapter。 1234567@BindingAdapter(\"cus_event\")fun TextView.notifyBindName( inverseBindingListener: InverseBindingListener)&#123; // 这个函数是监听TextWatch官方源码 doAfterTextChanged &#123; inverseBindingListener.onChange() &#125;&#125; InverseBindingListener是一个接口，里面只有一个函数，它是notify()函数必要的参数： 123456public interface InverseBindingListener &#123; /** * Notifies the data binding system that the attribute value has changed. */ void onChange();&#125; 4.7 @InverseBindingMethods和@BindingMethods类似，但是@InverseBindingMethods是视图变更数据（get()函数）,而@BindingMethods是数据到视图（set()函数）。 1234567891011121314151617181920212223242526272829@Target(ElementType.ANNOTATION_TYPE)public @interface InverseBindingMethod &#123; /** * 控件的类字节码 * The View type that is associated with the attribute. */ Class type(); /** * 自定义的属性 * The attribute that supports two-way binding. */ String attribute(); /** * notify函数的名称，即用于通知数据更新的函数 * The event used to notify the data binding system that the attribute value has changed. * Defaults to attribute() + \"AttrChanged\" */ String event() default \"\"; /** * 控件自身的函数名称，如果省略，即自动生成为&#123;attribute&#125;AttrChanged * The getter method to retrieve the attribute value from the View. The default is * the bean method name based on the attribute name. */ String method() default \"\";&#125; 如果说@BindingMethods是关联setter方法和自定义属性，那么@InverseBindingMethods就是关联getter方法和自定义属性。setter是更新视图时使用的，getter是更新数据时使用的。比@BindingMethods只是多了一个用于通知数据更新的notify()。示例： 123456789@InverseBindingMethods( InverseBindingMethod( type = CusView::class, attribute = \"android:bindName\", method = \"getName\", event = \"cus_event\" ))object Adapter &#123;&#125; 查看生成类中用于视图更新数据的代码： 12345678910111213141516171819private android.databinding.InverseBindingListener ivandroidTextAttr = new android.databinding.InverseBindingListener() &#123; @Override public void onChange() &#123; // Inverse of data.name // is data.setName((java.lang.String) callbackArg_0) java.lang.String callbackArg_0 = com.liangjingkanji.databinding.MyInverseBindingAdapter.getTextString(iv); // 拿到变化的属性 // localize variables for thread safety // data != null boolean dataJavaLangObjectNull = false; // data.name java.lang.String dataName = null; // data com.liangjingkanji.databinding.Bean data = mData; // 拿到数据 dataJavaLangObjectNull = (data) != (null); if (dataJavaLangObjectNull) &#123; data.setName(((java.lang.String) (callbackArg_0))); // 存储到数据 &#125; &#125;&#125;; 如果没有重写Inverse的数据变更方法，将无法让视图通知数据更新。 12345678910111213141516171819202122232425262728// 该方法会在绑定布局的时候回调 @Override protected void executeBindings() &#123; long dirtyFlags = 0; synchronized(this) &#123; dirtyFlags = mDirtyFlags; mDirtyFlags = 0; &#125; java.lang.String dataName = null; com.liangjingkanji.databinding.Bean data = mData; if ((dirtyFlags &amp; 0x1aL) != 0) &#123; if (data != null) &#123; // read data.name dataName = data.getName(); &#125; &#125; // batch finished if ((dirtyFlags &amp; 0x1aL) != 0) &#123; // api target 1 com.liangjingkanji.databinding.MyInverseBindingAdapter.setText(this.iv, dataName); &#125; if ((dirtyFlags &amp; 0x10L) != 0) &#123; // api target 1 // 重点是这段代码, 将上面创建的监听器传入setTextWatcher方法 com.liangjingkanji.databinding.MyInverseBindingAdapter.setTextWatcher(this.iv, (com.liangjingkanji.databinding.MyInverseBindingAdapter.BeforeTextChanged)null, (com.liangjingkanji.databinding.MyInverseBindingAdapter.OnTextChanged)null, (com.liangjingkanji.databinding.MyInverseBindingAdapter.AfterTextChanged)null, ivandroidTextAttr); &#125; &#125; 4.8 总结@BindingBuildInfo和Untaggable两个注解是Data Binding自动生成Java类时使用的。 @Bindable：设置数据刷新视图，自动生成BR的id @BindingAdapter：设置自定义属性，可以覆盖系统原有属性 @BindingMethod/BindingMethods：关联自定义属性到控件原有的setter方法 @BindingConversion：如果属性不能匹配类型，参数将自动根据类型参数匹配该注解修饰的方法来转换。 @InverseMethod：负责实现视图和数据之间的转换 @InverseBindingAdapter：视图通知数据刷新 @InverseBindingMethod/InverseBindingMethods：视图通知数据刷新（如果存在已有getter()方法可用的情况下） BindingMethods系统优先级高于BindingAdapter系列 所有注解的功能都是基于XML属性值为Data Binding表达式才生效（即@{}） 5. 表达式前面也列举了，这里着重讲几个。 5.1 避免空指针variable的值即使设置null，或者没有设置，也不会报空指针异常。因为谷歌已经用Data Binding的@BindingAdapter注解重写了很多属性，并且在里面进行了判空处理。 1234567&lt;variable name=\"userName\" type=\"String\"/&gt;.....android:text=\"@&#123;userName&#125;\" 1dataBinding.setUserName(null); 不会报空指针，并且还支持特有的非空多元表达式： 1android:text=\"@&#123;user.displayName ?? user.lastName&#125;\" 等价于 1android:text=\"@&#123;user.displayName !=null user.displayName :: user.lastName&#125;\" 但是要注意数组越界。 5.2 集合集合不属于java.lang.*下的，需要导入全路径 1234567&lt;variable name=\"list\" type=\"java.util.List&amp;lt;String&amp;gt;\"/&gt;&lt;variable name=\"map\" type=\"java.util.Map&lt;String, String&gt;\"/&gt; 上面的写法是错误的：Error:与元素类型 “variable” 相关联的 “type” 属性值不能包含 ‘&lt;’ 字符。因为&lt;符号需要转义。 常用的转义符： 12345678 空格 &amp;nbsp 或 &amp;#160；&lt; 小于号 &amp;lt; 或 &amp;#60;&gt; 大于号 &amp;gt; 或 &amp;#62;&amp; 与号 &amp;amp; 或 &amp;#38;&quot; 引号 &amp;quot; 或 &amp;#34;‘ 撇号 &amp;apos; 或 &amp;#39;× 乘号 &amp;times; 或 &amp;#215;÷ 除号 &amp;divide; 或 &amp;#247; 正确写法： 1234567&lt;variable name=\"list\" type=\"java.util.List&amp;lt;String&amp;gt;\"/&gt;&lt;variable name=\"map\" type=\"java.util.Map&amp;lt;String, String&amp;gt;\"/&gt; 集合数组都可以用[]来得到元素： 1android:text=\"@&#123;map[\"firstName\"]&#125;\" 5.3 字符串如果要在@{}中使用字符串，有三种方式： 12345678// 方式1：android:text=\"@&#123;\"XXX\"&#125;\"// 方式2：android:text=\"@&#123;'XXX'&#125;\"// 方式3：android:text=\"@&#123;@string/name&#125;\" 同样也支持@color和@drawable。 5.4 格式化字符串首先在stirngs文件中定义&lt;string&gt;： 1&lt;string name=\"string_format\"&gt;名字：%s 性别：%s&lt;/string&gt; 然后就可以使用Data Binding表达式了： 1android:text=\"@&#123;@string/string_format('XXX', '男')&#125;\" 输出内容： 1名字：XXX 性别：男 5.5 默认值如果variable还没有赋值，就会先使用默认值。 1android:text=\"@&#123;user.integral, default=`30`&#125;\" 5.6 上下文Data Binding提供了一个名为context的variable，可以直接使用。等价于View的getContext()。 1android:color=\"@&#123;context.getApplication().toString()&#125;\" 5.7 引用其他控件12345678910111213141516&lt;TextView android:id=\"@+id/datingName\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_centerVertical=\"true\" android:layout_marginLeft=\"8dp\" android:layout_toRightOf=\"@id/iv_dating\" android:text=\"活动\"/&gt;&lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_centerVertical=\"true\" android:layout_marginLeft=\"8dp\" android:layout_toRightOf=\"@id/iv_order\" android:text=\"@&#123;datingName.text&#125;\"/&gt; 引用包含_的控件id，可以直接忽略该符号，如tv_name直接写tvName。 5.8 使用Class如果想使用Class作为参数，那么该Class不能直接通过静态导入来使用，需要作为字段常量来使用。 6. Data Binding组件6.1 ViewDataBinding自动生成的Data Binding类都继承自该类，里面的主要方法有： 1234567891011121314151617181920212223// 添加绑定监听器, 可以在Variable被设置的时候回调void addOnRebindCallback(OnRebindCallback listener)// 删除绑定监听器void removeOnRebindCallback(OnRebindCallback listener)// 返回被绑定的视图对象View getRoot()// 使所有的表达式无效并且立刻重新设置表达式. 会重新触发OnRebindCallback回调(可以看做重置)abstract void invalidateAll()// 可以根据字段id来设置变量abstract boolean setVariable(int variableId, Object value)// 解绑布局, ui不会根据数据来变化, 但是监听器还是会触发的void unbind()// 当ui需要根据当前数据变化时就会返回true(数据变化后有一瞬间)abstract boolean hasPendingBindings()// 强制ui立刻刷新数据void executePendingBindings() 当改变数据以后（在设置了Observable观察者的情况下）会马上刷新UI，但是会在下一帧才会刷新UI，存在一定的延迟。在这段时间内，hasPendingBindings()会返回true。 如果想要同步刷新UI，可以调用executePendingBindings()。OnRebindCallback()：该监听器可以监听布局绑定的生命周期。 123456789101112131415161718192021222324public abstract class OnRebindCallback&lt;T extends ViewDataBinding&gt; &#123; /** * 绑定前 * @param binding * @return 如果返回true，就会绑定布局，；返回fasle，则取消绑定 */ public boolean onPreBind(T binding) &#123; return true; &#125; /** * 如果取消绑定则回调该方法，取决于onPreBind()的返回值 * @param binding */ public void onCanceled(T binding) &#123; &#125; /** * 绑定完成 * @param binding */ public void onBound(T binding) &#123; &#125;&#125; Data Binding也有一个数据变更监听器，可以监听variable的设置事件： 1234567891011121314151617mDataBinding.addOnPropertyChangedCallback(new Observable.OnPropertyChangedCallback() &#123; /** * 会在DataBinding设置数据的时候回调 * @param sender DataBinding生成的类 * @param propertyId Variable的id */ @Override public void onPropertyChanged(Observable sender, int propertyId) &#123; ActivityMainBinding databinding = (ActivityMainBinding) sender; switch (propertyId) &#123; case BR.data: Log.d(\"日志\", \"(MainActivity.java:54) ___ Result = \" + databinding.getData().getName()); break; case BR.dataSecond: break; &#125; &#125;&#125;); 6.2 DataBindingUtilData Binding不仅可以绑定Activity，还可以绑定视图内容（View）。 123456789101112131415// 视图static &lt;T extends ViewDataBinding&gt; T bind(View root)static &lt;T extends ViewDataBinding&gt; T bind(View root, DataBindingComponent bindingComponent) // 布局static &lt;T extends ViewDataBinding&gt; T inflate(LayoutInflater inflater, int layoutId, ViewGroup parent, boolean attachToParent, DataBindingComponent bindingComponent)// 组件static &lt;T extends ViewDataBinding&gt; T inflate(LayoutInflater inflater, int layoutId, ViewGroup parent, boolean attachToParent)// activitystatic &lt;T extends ViewDataBinding&gt; T setContentView(Activity activity, int layoutId)static &lt;T extends ViewDataBinding&gt; T setContentView(Activity activity, int layoutId, DataBindingComponent bindingComponent) 还有两个不常用的方法，用于检索糊涂是否被绑定，如果没有绑定，返回null。 1234static &lt;T extends ViewDataBinding&gt; T getBinding(View view)// 和getBinding不同的是如果视图没有绑定会去检查父容器是否被绑定static &lt;T extends ViewDataBinding&gt; T findBinding(View view) 其他方法： 12// 根据传的BR的id来返回字符串类型. 可能用于日志输出static String convertBrIdToString(int id) 6.3 DataBindingComponent每个Data Binding都可以拥有一个组件或者说设置一个默认的全局组件。创建DataBindingComponent的步骤： 创建一个类，类中写入@BindingAdapter注解（需设置静态），这时Android Studio会扫描自动生成对应的DataBindingComponent接口； 创建一个类实现DataBindingComponent，这时会提示有方法需要覆写，如果省略第一步，则不会有。 第一步： 123456789101112131415161718192021222324252627package com.ly.allendemojetpack.databindingotherimport android.widget.TextViewimport androidx.databinding.BindingAdapterimport androidx.databinding.InverseBindingAdapterimport androidx.databinding.InverseBindingListenerclass PinkComponent &#123; @BindingAdapter(\"android:bindName\") fun TextView.setBindName(name: String) &#123; if (name.isNotEmpty() &amp;&amp; name != text) &#123; text = \"数据体\" &#125; &#125; @BindingAdapter(\"android:bindNameAttrChanged\") fun TextView.notifyBindName(inverseBindingListener: InverseBindingListener) &#123; doAfterTextChanged &#123; inverseBindingListener.onChange() &#125; &#125; @InverseBindingAdapter(attribute = \"android:bindName\") fun TextView.getBindName(): String &#123; return text.toString() &#125;&#125; 第二步： 12345678package com.ly.allendemojetpack.databindingotherclass CusComponent : androidx.databinding.DataBindingComponent &#123; override fun getPinkComponent(): PinkComponent &#123; // 此处不能返回null return PinkComponent() &#125;&#125; 设置默认组件都是由DataBindingUtil设置，但是方法有所不同： 123static void setDefaultComponent(DataBindingComponent bindingComponent)static DataBindingComponent getDefaultComponent() 以上这种设置必须在绑定视图之前设置，并且默认全局的，只需要设置一次。 1static &lt;T extends ViewDataBinding&gt; T setContentView(Activity activity, int layoutId, DataBindingComponent bindingComponent) 如果没有执行setDefaultComponent()，则选择通过函数单独传入，则每次都要传入，否则报错。或者可以将@BindingAdapter注解的方法变为static修饰。DataBindingComponent只能使用@BindingAdapter注解。 7. 注意 可以使用include，但是不能作为root布局，merge不能使用； 如果没有自动生成DataBinding类，可以先写一个variable（或者make module一下）； 即使没有绑定数据（可能会等到网络请求成功之后再去绑定数据），但是只要视图创建完成，就会自动绑定数据，这是数据是一个空对象。空对象的字段也有默认值（String的默认值是null，TextView就会显示null）；并且，如果用了三元表达式，空对象的三元表达式都为fasle，所以建议不考虑空对象的情况； 如果给一个要求值是bolean类型的值自定义属性（@BindingAdapter）赋值一个函数，空指针的情况会返回false。","categories":[{"name":"Android","slug":"Android","permalink":"https://tylerLiu.top/categories/Android/"},{"name":"Jetpack","slug":"Android/Jetpack","permalink":"https://tylerLiu.top/categories/Android/Jetpack/"}],"tags":[{"name":"Jetpack","slug":"Jetpack","permalink":"https://tylerLiu.top/tags/Jetpack/"}]},{"title":"Android Jetpack：Navigation","slug":"Android-Jetpack-Navigation","date":"2019-07-29T08:10:39.000Z","updated":"2019-08-22T03:13:27.082Z","comments":true,"path":"2019/07/29/Android-Jetpack-Navigation/","link":"","permalink":"https://tylerLiu.top/2019/07/29/Android-Jetpack-Navigation/","excerpt":"","text":"前言Android Jetpack是谷歌在2018年的I/O大会上发布的，官网,主要包含一下模块，系列文章主要介绍架构部分的内容： 这里先学习Navigation。 官方Demo：android-architecture-components。 1. 简介1.1 定义Navigation是一个可简化Android导航和库的插件。更确切来说，Navigation是用来管理Fragment切换的，并且可以通过可视化的方式，看见App的交互流程。 1.2 优点 处理Fragment的切换 默认情况下正确处理Fragment的前进和后退 为过渡和动画提供标准化的资源 实现和处理深层连接 可以绑定Toolbar、BottomNavigationView和ActionBar等 SafeArgs（Gradle插件）数据传递时提供类型安全性 ViewModel的支持 2. 具体学习Navigation三个关键组成部分： Navigation Graph：导航图，一个XML资源，包含集中在一个位置的所有和导航相关的信息。包括应用程序中所有单独的内容区域（也成目的地），以及用户可以通过应用程序访问的可能路径。 NavHost：一个存储前面目的地的容器，Navigation组件包含了一个默认的实现了NavHostFragment的NavHost，用来显示Fragment的目的地。 NavController：导航控制者，在NavHost中，管理应用程序导航的对象。当用户在app中进行切换页面等操作时，NavController在NavHost中协调目标内容的切换。 2.1 步骤1：添加依赖在module的build.gradle中添加依赖： 1234567dependencies &#123; ...... implementation 'androidx.fragment:fragment-ktx:1.2.0-alpha01' implementation 'androidx.navigation:navigation-fragment-ktx:2.1.0-beta02' implementation 'androidx.navigation:navigation-ui-ktx:2.1.0-beta02'&#125; 要加上kotlin依赖，在项目的build.gradle： 1234567891011buildscript &#123; repositories &#123; google() jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:3.4.0' classpath 'org.jetbrains.kotlin:kotlin-gradle-plugin:1.3.31' &#125;&#125; 如果要使用SafeArgs插件，可以在项目的build.gradle中添加： 12345buildscript &#123; dependencies &#123; classpath 'androidx.navigation:navigation-safe-args-gradle-plugin:2.0.0' &#125;&#125; 以及module下的build.gradle中添加： 12apply plugin: 'kotlin-android-extensions'apply plugin: 'androidx.navigation.safeargs' 2.2 步骤2：创建Navigation导航 创建基础目录：资源文件res目录下创建navigation目录； 创建一个Destination，如果说navigation是导航工具，Destination就是目的地，在此之前已经写好了需要用到的Fragment——SplashFragment、LoginFragment和RegisterFragment，添加Desination，如下示图： 除了上面的可视化界面，也能通过代码进行编辑，login_navigation.xml： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;navigation xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/login_navigation\" app:startDestination=\"@id/splash\" tools:ignore=\"UnusedNavigation\"&gt; &lt;fragment android:id=\"@+id/login\" android:name=\"com.ly.allendemojetpack.ui.fragment.login.LoginFragment\" android:label=\"LoginFragment\" tools:layout=\"@layout/fragment_login\"/&gt; &lt;fragment android:id=\"@+id/splash\" android:name=\"com.ly.allendemojetpack.ui.fragment.login.SplashFragment\" android:label=\"LoginFragment\" tools:layout=\"@layout/fragment_splash\"&gt; &lt;action android:id=\"@+id/action_welcome_to_login\" app:destination=\"@id/login\"/&gt; &lt;action android:id=\"@+id/action_welcome_to_register\" app:enterAnim=\"@anim/common_fade_in\" app:exitAnim=\"@anim/common_slide_out_left\" app:popEnterAnim=\"@anim/common_slide_in_left\" app:popExitAnim=\"@anim/common_slide_out_right\" app:destination=\"@id/register\"/&gt; &lt;/fragment&gt; &lt;fragment android:id=\"@+id/register\" android:name=\"com.ly.allendemojetpack.ui.fragment.login.RegisterFragment\" android:label=\"LoginFragment\" tools:layout=\"@layout/fragment_register\"&gt; &lt;argument android:name=\"EMAIL\" android:defaultValue=\"2019\" app:argType=\"string\"/&gt; &lt;/fragment&gt;&lt;/navigation&gt; 这里看看navigation标签的属性，app:startDestination，即默认的起始位置。 2.3 步骤3：创建NavHostFragment这里创建一个新的LoginActivity作为NavHostFragment，在activity_login.xml中： 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".ui.activity.LoginActivity\"&gt; &lt;fragment android:id=\"@+id/my_nav_host_fragment\" android:name=\"androidx.navigation.fragment.NavHostFragment\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:navGraph=\"@navigation/login_navigation\" app:defaultNavHost=\"true\"/&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; android:name：值必须是androidx.navigation.fragment.NavHostFragment，声明这是一个NavHostFragemnt。 app:navGraph：存放导航的资源文件，确定Navgation Graph。 app:defaultNavHost：关联系统的返回按钮 。 2.4 步骤4：界面跳转、参数传递和动画在SplashFragment中，点击登录按钮和注册按钮可以分别跳转到LoginFragment和RegisterFragment。 有两种实现方式： 2.4.1 方式1：利用ID导航目标：SplashFragment携带key为name的数据跳转到LoginFragment，LoginFragment接收后显示。 登录按钮的点击事件如下： 123456789101112131415btnLogin.setOnClickListener &#123; // 设置动画参数 val navOption = navOptions &#123; anim &#123; enter = R.anim.common_slide_in_right exit = R.anim.common_slide_out_left popEnter = R.anim.common_slide_in_left popExit = R.anim.common_slide_out_right &#125; &#125; // 参数设置 val bundle = Bundle() bundle.putString(\"name\", \"TeaOf\") findNavController().navigate(R.id.login, bundle, navOption)&#125; 在LoginFragment中就可以通过Fragment的Bundle直接获取传来的参数。代码如下：LoginFragment.kt 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.ly.allendemojetpack.ui.fragment.loginimport android.content.Intentimport android.os.Bundleimport android.view.LayoutInflaterimport android.view.Viewimport android.view.ViewGroupimport android.widget.Buttonimport android.widget.EditTextimport android.widget.TextViewimport androidx.fragment.app.Fragmentimport com.ly.allendemojetpack.MainActivityimport com.ly.allendemojetpack.Rclass LoginFragment : Fragment() &#123; override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? &#123; return inflater.inflate(R.layout.fragment_login, container, false) &#125; lateinit var cancel: TextView lateinit var login: Button lateinit var account: EditText override fun onViewCreated(view: View, savedInstanceState: Bundle?) &#123; super.onViewCreated(view, savedInstanceState) cancel = view.findViewById(R.id.txt_cancel) login = view.findViewById(R.id.btn_login) account = view.findViewById(R.id.et_account) login.setOnClickListener &#123; val intent = Intent(context, MainActivity::class.java) context!!.startActivity(intent) &#125; cancel.setOnClickListener &#123; activity?.onBackPressed() &#125; val name = arguments?.getString(\"name\") account.setText(name) &#125;&#125; 效果图： 2.4.2 利用Safe Args目标：SplashFragment通过Safe Args将数据传到RegisterFragment，RegisterFragment接收后显示。 在前面的login_navigation.xml中可以看到里面还有action标签和argument标签。 action标签里面的属性 app:destination：跳转完成到达的fragment的id app:popUpTo：将fragment从栈中弹出，直到某个id的fragment argument标签里面的属性 android:name：标签名字 app:argType：标签的类型 android:defaultValue：默认值 点击Make Project按钮，Android Studio会自动生成两个类： SplashFragment的注册按钮点击事件： 123456btnRegister.setOnClickListener &#123; val action = SplashFragmentDirections .actionWelcomeToRegister() .setEMAIL(\"TeaOf1995@Gamil.com\") findNavController().navigate(action)&#125; RegisterFragment中的接收： 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.ly.allendemojetpack.ui.fragment.loginimport android.os.Bundleimport android.view.LayoutInflaterimport android.view.Viewimport android.view.ViewGroupimport android.widget.Buttonimport android.widget.EditTextimport android.widget.TextViewimport android.widget.Toastimport androidx.fragment.app.Fragmentimport androidx.navigation.fragment.navArgsimport com.ly.allendemojetpack.Rclass RegisterFragment : Fragment() &#123; override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? &#123; return inflater.inflate(R.layout.fragment_register, container, false) &#125; lateinit var cancel: TextView lateinit var register: Button lateinit var emailEt: EditText override fun onViewCreated(view: View, savedInstanceState: Bundle?) &#123; super.onViewCreated(view, savedInstanceState) cancel = view.findViewById(R.id.txt_cancel) register = view.findViewById(R.id.btn_register) emailEt = view.findViewById(R.id.et_email) register.setOnClickListener &#123; Toast.makeText(context, \"Register\", Toast.LENGTH_SHORT).show() &#125; cancel.setOnClickListener &#123; activity?.onBackPressed() &#125; val safeArgs: RegisterFragmentArgs by navArgs() val email = safeArgs.email emailEt.setText(email) &#125;&#125; 注意这里的navArgs()必须在JVM 1.8 以上，低于此版本会报错，Cannot inline bytecode built with JVM target 1.8 into bytecode that is being built with JVM target 1.6，在Android Studio中，Settings -&gt; Other Settings -&gt; Kotlin Compiler -&gt; Target JVM version，选择1.8及以上，同时在module的build.gradle添加以下： 1234567891011121314android &#123; ...... // 这里也要添加，否则报错 Error: Invoke-customs are only supported starting with Android O (--min-api compileOptions &#123; sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 &#125;&#125;tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).all &#123; kotlinOptions &#123; jvmTarget = \"1.8\" &#125;&#125; 效果图： 3. 其他Navigation还可以绑定其他，如menu、drawables和bottom navigation，这里以bototm navigation为例，先在navigation目录下创建main_navigation.xml，用之前的MainActivity，修改activity_main.xml如下： 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".MainActivity\"&gt; &lt;fragment android:id=\"@+id/my_nav_host_fragment\" android:name=\"androidx.navigation.fragment.NavHostFragment\" app:navGraph=\"@navigation/main_navigation\" app:defaultNavHost=\"true\" android:layout_width=\"match_parent\" android:layout_height=\"0dp\" android:layout_weight=\"1\"/&gt; &lt;com.google.android.material.bottomnavigation.BottomNavigationView android:id=\"@+id/navigation_view\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:background=\"@android:color/white\" app:itemIconTint=\"@color/colorAccent\" app:itemTextColor=\"@color/colorPrimary\" app:menu=\"@menu/menu_main\"/&gt;&lt;/LinearLayout&gt; MainActivity中的处理也很简单： 12345678910111213141516171819202122232425262728293031323334package com.ly.allendemojetpackimport android.os.Bundleimport androidx.appcompat.app.AppCompatActivityimport androidx.navigation.NavControllerimport androidx.navigation.fragment.NavHostFragmentimport androidx.navigation.ui.setupWithNavControllerimport com.google.android.material.bottomnavigation.BottomNavigationViewclass MainActivity : AppCompatActivity() &#123; lateinit var bottomNavigationView: BottomNavigationView override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) val host: NavHostFragment = supportFragmentManager.findFragmentById(R.id.my_nav_host_fragment) as NavHostFragment val navController = host.navController initWidget() initBottomNavigationView(bottomNavigationView, navController) &#125; private fun initBottomNavigationView(bottomNavigationView: BottomNavigationView, navController: NavController) &#123; bottomNavigationView.setupWithNavController(navController) &#125; private fun initWidget() &#123; bottomNavigationView = findViewById(R.id.navigation_view) &#125;&#125; 效果图： 4. 总结 定义：可简化Android导航的库和插件 功能： 处理Fragment的切换 实现和处理深层连接 绑定Toolbar、BottomNavigationView和DrawableLayout 支持ViewModel Safe Args 准备：Android Studio 3.2及以上 三要素 Navigation Graph 地图 关键标签： navigation fragment action：可以设置动画 argument NavHostFragment：容器 NavController：控制器 跳转 通过fragment id实现跳转 action实现跳转 传参 fragment自带的Bundle Safe Args：类型安全 绑定View：Toolbar、BottomNavigationView和DrawableLayout 深层连接（本文未涉及） Demo地址：Allen_Demo_WebService","categories":[{"name":"Android","slug":"Android","permalink":"https://tylerLiu.top/categories/Android/"},{"name":"Jetpack","slug":"Android/Jetpack","permalink":"https://tylerLiu.top/categories/Android/Jetpack/"}],"tags":[{"name":"Jetpack","slug":"Jetpack","permalink":"https://tylerLiu.top/tags/Jetpack/"}]},{"title":"Android热修复 Tinker接入与源码浅析（有问题）","slug":"Android热修复-Tinker接入与源码浅析","date":"2019-07-29T02:26:54.000Z","updated":"2019-07-31T08:17:45.392Z","comments":true,"path":"2019/07/29/Android热修复-Tinker接入与源码浅析/","link":"","permalink":"https://tylerLiu.top/2019/07/29/Android热修复-Tinker接入与源码浅析/","excerpt":"","text":"1. 概述现在主流热修复：阿里的AndFix、腾讯的QZone的方案、美团的Robust和腾讯的Tinker。 其中AndFix接入是最简单的，不过兼容性还是问题；QZone对性能有一定影响，在在Art模式下出现内存错乱的问题；美团的Robust是基于Instant Run原理的，兼容性好；Tinker就是用在微信上面的热修复，性能和兼容性不用多说。 这里主要学习腾讯的Tinker和美团的Robust。 本文主要学习Tinker的接入以及对Tinker大致原理的分析。 2. Tinker的接入接入前提（开启混淆模式）： 对于API，一般来说，接入热修复，会在Application的onCreate()中进行一些初始化操，然后在某个地方去调用类似loadPatch这样的API去加载patch文件。 对于patch最简单的生成方式就是通过对比两个APK然后生成；注意，两个APK做对比，需要的前提是，第二次打包混淆使用的mapping.txt文件应该和线上的APK是一致的。 最后看看该项目有没有需要配置混淆的。 Tinker官方文档 2.1 步骤1：添加gradle插件依赖gradle远程仓库依赖jcenter： 123456789buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; // TinkerPatch 插件 classpath \"com.tinkerpatch.sdk:tinkerpatch-gradle-plugin:1.2.13.3\" &#125;&#125; 注意，在这里SDK使用了fat打包模式，不能再引用任何Tinker的相关 依赖，否则会造成版本冲突。 2.2 步骤2：集成TinkerPatch SDK添加TinkerPatch SDK库的依赖，可以参考Sample中的app/build.gradle： 12345678dependencies &#123; ...... //若使用annotation需要单独引用,对于tinker的其他库都无需再引用 // 可选，用于生成application类 compileOnly(\"com.tinkerpatch.tinker:tinker-android-anno:1.9.13.3\") &#123; changing = true &#125; annotationProcessor(\"com.tinkerpatch.tinker:tinker-android-anno:1.9.13.3\") &#123; changing = true &#125; implementation(\"com.tinkerpatch.sdk:tinkerpatch-android-sdk:1.2.13.3\") &#123; changing = true &#125;&#125; 若使用annotation自动生成Application，需要单独引入Tinker的tiner-android-anno库。除此之外，不需要单独引入tinker的其他库。 为了方便，已经将TinkerPatch相关的配置放到了tinkerpatch.gradle中，所以需要引用：（注释：这块内容还需要整理，有报错！！） 1apply from: 'tinkerpatch.gradle' 2.3 步骤3：配置tinkerpatchSupport参数：（可以不配置，使用默认的）打开前面的tinkerpatcch.gradle文件可以看到如下参数： 123456789101112131415161718192021222324252627tinkerpatchSupport &#123; /** 可以在debug的时候关闭 tinkerPatch **/ tinkerEnable = true /** 是否使用一键接入功能 **/ reflectApplication = true /** 是否开启加固模式，只有在使用加固时才能开启此开关 **/ protectedApp = false /** 补丁是否支持新增 Activity (新增Activity的exported属性必须为false)**/ supportComponent = false autoBackupApkPath = \"$&#123;bakPath&#125;\" /** 在tinkerpatch.com得到的appKey **/ appKey = \"yourAppKey\" /** 注意: 若发布新的全量包, appVersion一定要更新 **/ appVersion = \"1.0.0\" def pathPrefix = \"$&#123;bakPath&#125;/$&#123;baseInfo&#125;/$&#123;variantName&#125;/\" def name = \"$&#123;project.name&#125;-$&#123;variantName&#125;\" baseApkFile = \"$&#123;pathPrefix&#125;/$&#123;name&#125;.apk\" baseProguardMappingFile = \"$&#123;pathPrefix&#125;/$&#123;name&#125;-mapping.txt\" baseResourceRFile = \"$&#123;pathPrefix&#125;/$&#123;name&#125;-R.txt\"&#125; 具体含义如下： 参数 默认值 描述 tinkerEnable true 是否开启tinkerpatchSupport插件功能 appKey “” 在TinkerPatch平台申请的appKey appVersion “” 在TinkerPatch平台输入的版本号。注意：使用appVerison作为TinkerId，需要保证每个发布出去的基础安装包的appVersion都不一样。 reflectApplication false 是否反射Application autoBackupAppPath “” 将每次编译产生的apk/mapping.txt/R.txt归档存储的位置 baseApkFile “” 基准包的文件路径，对应tinker插件中的oldApk参数；编译补丁包时，必须指定基准版本的apk，默认值为空，表示不进行补丁包的编译 baseProguardMappingFile “” 基准包的Proguard mapping.txt文件路径，对应tinker插件appliMapping参数；在编译新的apk时，希望通过基准apk的proguard混淆方式，从而减小补丁包的大小。编译补丁包时，推荐输入基准apk生成的mapping.txt文件 baseResourceRFile “” 基准包的资源R.txt文件路径，对应tinker插件applyResourceMapping参数；在编译新的apk时，希望通过基准apk的R.txt文件来保存Resource Id的分配，这样不仅可以减少补丁包的大小，同时也能避免由于Resource Id改变导致remote view异常 protectedApp false 是否开启加固支持，注意：只有在使用加固支持时才能开启此开关 supportComponent false 是否开启支持在补丁包中动态增加Activity，注意：新增Activity的exported属性必须设置为false backupFileNameFormat ‘${appName}-${variantName}’ 格式化命名备份文件，这里要使用单引号 一般来说，不需要修改引用Android的编译配置，也不用修改tinker插件原来的配置。对于需要特殊配置，参考接入指南 2.4 初始化TinkerPatch SDK reflectApplication = true：这时，无需为Tinker而改造Application。12345678910111213141516171819202122public class SampleApplication extends Application &#123; ... @Override public void onCreate() &#123; super.onCreate(); // 我们可以从这里获得Tinker加载过程的信息 tinkerApplicationLike = TinkerPatchApplicationLike.getTinkerPatchApplicationLike(); // 初始化TinkerPatch SDK, 更多配置可参照API章节中的,初始化SDK TinkerPatch.init(tinkerApplicationLike) .reflectPatchLibrary() .setPatchRollbackOnScreenOff(true) .setPatchRestartOnSrceenOff(true) .setFetchPatchIntervalByHours(3); // 每隔3个小时(通过setFetchPatchIntervalByHours设置)去访问后台时候有更新,通过handler实现轮训的效果 TinkerPatch.with().fetchPatchUpdateAndPollWithInterval(); &#125; ... 将Tinker加载补丁过程的结果放在TinkerPatchApplicationLike中。 reflectApplication = false（一般使用）：API主要就是初始化和loadPatch()。 通常情况下，会考虑在Application的onCreate()中初始化，但Tinker推荐下面的写法： 123456789101112131415161718192021222324252627282930313233343536373839package com.ly.allendemotinker;import android.app.Application;import android.content.Context;import android.content.Intent;import com.tencent.tinker.anno.DefaultLifeCycle;import com.tencent.tinker.entry.DefaultApplicationLike;import com.tencent.tinker.lib.tinker.TinkerInstaller;import com.tencent.tinker.loader.shareutil.ShareConstants;/** * 初始化TinkerPatch SDK * * @author Liuyang * @date 2019/7/29 */@DefaultLifeCycle(application = \".SampleApplication\", flags = ShareConstants.TINKER_ENABLE_ALL, loadVerifyFlag = false)public class SampleApplicationLike extends DefaultApplicationLike &#123; public SampleApplicationLike(Application application, int tinkerFlags, boolean tinkerLoadVerifyFlag, long applicationStartElapsedTime, long applicationStartMillisTime, Intent tinkerResultIntent) &#123; super(application, tinkerFlags, tinkerLoadVerifyFlag, applicationStartElapsedTime, applicationStartMillisTime , tinkerResultIntent); &#125; @Override public void onBaseContextAttached(Context base) &#123; super.onBaseContextAttached(base); &#125; @Override public void onCreate() &#123; super.onCreate(); TinkerManager.installedTinker(this); &#125;&#125; Tinker建议编写一个ApplicationLike的子类，可以当成Application去使用，顶部的注解@DefaultLifeCycle，其中application属性，会在编译期生成一个SimpleTinkerInApplication类。 所以，实际上Application会在编译期生成，所以AndroidManifest.xml中是这样的： 123&lt;application android:name=\".SampleApplication\" .../&gt; 编译报红，build一下就可以。 实际上，注解的背后有一个Annotation Processor的处理，具体原理可以查看Android 如何编写基于编译时注解的项目。 2.5 创建一个ApplicationLike代理类：实现对Tinker的管理，TinkerManager： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.ly.allendemotinker;import android.content.Context;import com.tencent.tinker.lib.tinker.Tinker;import com.tencent.tinker.lib.tinker.TinkerInstaller;/** * Tinker管理类 * * @author Liuyang * @date 2019/7/29 */public class TinkerManager &#123; private static boolean mIsInstalled = false; private static ApplicationLike mApplicationLike; /** * 完成Tinker初始化 */ public static void installedTinker(ApplicationLike applicationLike) &#123; mApplicationLike = applicationLike; if (mIsInstalled) &#123; return; &#125; TinkerInstaller.install(mApplicationLike); mIsInstalled = true; &#125; /** * 完成patch文件的加载 * * @param path 补丁文件路径 */ public static void loadPatch(String path) &#123; // 是否已经安装过 if (Tinker.isTinkerInstalled()) &#123; TinkerInstaller.onReceiveUpgradePatch(getApplicationContext(), path); &#125; &#125; /** * 利用Tinker代理Application 获取应用全局的上下文 * * @return 全局的上下文 */ private static Context getApplicationContext() &#123; if (mApplicationLike != null) return mApplicationLike.getApplication().getApplicationContext(); return null; &#125;&#125; 2.6 AndroidManifest.xml配置123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" package=\"com.ly.allendemotinker\"&gt; &lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /&gt; &lt;uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" /&gt; &lt;application android:name=\".Application\" android:allowBackup=\"true\" android:icon=\"@mipmap/ic_launcher\" android:label=\"@string/app_name\" android:roundIcon=\"@mipmap/ic_launcher_round\" android:supportsRtl=\"true\" android:theme=\"@style/AppTheme\" tools:ignore=\"GoogleAppIndexingWarning\"&gt; &lt;activity android:name=\".MainActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;!-- 这个标签开判断我们生成的patch的.apk文件中的tinker_id_XXX 与我们的版本号tinker_id_XXX比较。相同合法，不同则不会进行更新 --&gt; &lt;meta-data android:name=\"TINKER_ID\" android:value=\"tinker_id_6235657\" /&gt; &lt;/application&gt;&lt;/manifest&gt; 在这里加上必要的权限，然后设置andorid:name = &quot;.Application&quot;，最后配置TINKER_ID属性，里面的数字部分一般是versionCode。 2.7 生成差异apk文件首先生成old.apk。布局文件：activity_main.xml： 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".MainActivity\"&gt; &lt;Button android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:onClick=\"loadPatch\" android:text=\"热修复\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 代码文件：MainActivity.java： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.ly.allendemotinker;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import java.io.File;/** * @author Liuyang * @date 2019/7/29 */public class MainActivity extends AppCompatActivity &#123; /** * 文件后缀 */ private static final String FILE_END = \".apk\"; /** * 文件路径 */ private String mFileDir; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // /storage/emulated/0/Android/data/com.ly.allendemotinker/cache/demo_patch/ mFileDir = getExternalCacheDir().getAbsolutePath() + \"/demo_patch/\"; // 创建路径对应的文件夹 File file = new File(mFileDir); if (!file.exists()) &#123; file.mkdir(); &#125; &#125; public void loadPatch(View view) &#123; TinkerManager.loadPatch(getPatchName()); &#125; public String getPatchName() &#123; return mFileDir.concat(\"tinker\").concat(FILE_END); &#125;&#125; 打包成old.apk，然后修改布局代码如下： 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".MainActivity\"&gt; &lt;Button android:id=\"@+id/button\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:onClick=\"loadPatch\" android:text=\"热修复\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" /&gt; &lt;Button android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"测试\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toBottomOf=\"@+id/button\" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 其他不用修改，打包成new.apk。 2.8 命令行生成补丁文件Tinker官方提供了命令行工具： 将前面生成的两个apk文件和签名文件复制到该目录下（.keystore是eclipse的签名文件，.jks是Andorid Studio的签名文件，可以直接修改后缀，不影响使用），然后输入下面的命令： 参考： https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650821993&amp;idx=1&amp;sn=550a90e30a398bbb652ecd65209b62e2&amp;chksm=80b781f7b7c008e17d9f5a59542f46329d28cbcd2ec075d4c2d44784f789135166a4e1949303&amp;scene=38#wechat_redirect https://www.jianshu.com/p/d649fc014919","categories":[{"name":"Android","slug":"Android","permalink":"https://tylerLiu.top/categories/Android/"},{"name":"热修复","slug":"Android/热修复","permalink":"https://tylerLiu.top/categories/Android/热修复/"}],"tags":[{"name":"热修复","slug":"热修复","permalink":"https://tylerLiu.top/tags/热修复/"}]},{"title":"Android代码混淆","slug":"Android代码混淆","date":"2019-07-27T06:32:49.000Z","updated":"2019-07-31T08:08:16.462Z","comments":true,"path":"2019/07/27/Android代码混淆/","link":"","permalink":"https://tylerLiu.top/2019/07/27/Android代码混淆/","excerpt":"","text":"在Android日常开发中，混淆是必不可少的。 1. 混淆简介代码混淆：Obfuscated code，是将程序中的代码以某种规则转换为难以阅读和理解的代码的一种行为。 1.1 混淆的好处好处就是目的：令APK难以被逆向工程，即很大程度上增加反编译的成本。此外，Android中的“混淆”还能在打包时移除没用的资源，显著减小APK的体积。最后，还能以变通方式避免Anddroid中常见的64k方法数引用的限制。 先看看APK混淆前后的结构对比： 从上面两张图可以看出：经过混淆后，APK中的包名、类名、成员名等都被替换为随机、无意义的名称，增加了代码阅读和理解的难度，提高反编译的成本。混淆前后APK的大小也从2.7M下降到1.4M。 2. Android中的混淆在Android中，平时说的“混淆”其实包含两层意思，一是Java代码的混淆，二是资源的压缩。 2.1 开启混淆12345678910......android &#123; buildTypes &#123; release &#123; minifyEnabled true shrinkResources true proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125;&#125; 以上就是开启混淆的基本操作，通过minifyEnabled设置为true来开启混淆。同时，可以设置shrinkResources为true来开启资源的压缩。一般在打release包时才会开启混淆，因为混淆会增加额外的编译时间，所以不建议在debug下启用。此外，需要注意：只有在开启混淆的前提下开启资源压缩才有效果。以上代码中的proguard-android.txt表示Android系统提供的默认混淆规则文件，而proguard-rules.pro是我们自定义的混淆规则。下面讲解如何自定义混淆规则。 2.2 代码混淆Java平台提供了Proguard工具来帮助我们快速地对代码进行混淆。根据Java官方介绍，Proguard对应的具体中文定义如下： 它是一个包含代码文件压缩、优化、混淆和校验等功能的工具； 它能检测并删除无用的类、变量、方法和属性； 它能优化字节码并删除未使用的指令； 它能将类、变量和方法的名字重命名为无意义的名称从而达到混淆效果； 它会校验处理后的代码，只有针对Java 6及以上的版本和Java ME。 2.3 资源压缩在Android中，编译提供了另一个功能：资源压缩。资源压缩能帮助移除项目和仓库中未使用到的资源，有效降低APK的大小，。由于资源压缩与代码混淆是协同工作，所以，如果要开启资源压缩，一定要先开启代码混淆，否则会报错： 12ERROR: Removing unused resources requires unused code shrinking to be turned on. See http://d.android.com/r/tools/shrink-resources.html for more information.Affected Modules: app 2.4 自定义要保留的资源开启资源压缩后，系统默认会移除所有未使用的资源，如果要保留特定的资源，可以在项目中创建一个被&lt;resources&gt;标记的XML文件（如，res/raw/keep.xml），并在tools:keep属性中指定每个要保留的资源，在tools:discard属性中指定每个要舍弃的资源。这两个属性都接受逗号分隔的资源名称列表。同样，可以使用*作为通配符。如： 1234&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources xmlns:tools=\"http://schemas.android.com/tools\" tools:keep=\"@layout/activity_video*,@layout/dialog_update_v2\" tools:discard=\"@layout/unused_layout,@drawable/unused_selector\" /&gt; 2.5 启用严格检查模式通常， 资源压缩器可以准确判定系统是否使用了资源。但，如果代码（包含库）调用了Resources.getIdentifier()，这就表示代码将根据动态生成的字符串查询名称。这时，资源压缩器会采取防御性行为，将所有具有匹配名称格式的资源标记为可能已使用，无法移除。如，以下代码会使所有带img_前缀的资源标记为已使用： 12String name = String.format(\"img_%1d\", angle + 1);res = getResources().getIdentifier(name, \"drawable\", getPackageName()); 这时，可以启用严格检查模式，只会保留确定已经使用的资源。 2.6 移除备用资源Gradle资源压缩器只会移除未被应用引用的资源，意味着它不会移除用于不同设备配置的备用资源。必要时，可以使用Android Gradle插件的resCOnfigs属性来移除应用中不需要的备用资源文件（常见的有用于国际化支持的strings.xml，适配用的layout.xml等）。 1234567android &#123; defaultConfig &#123; ... //保留中文和英文国际化支持 resConfigs \"en\", \"zh\" &#125;&#125; 3. 自定义混淆规则先了解常用的混淆命令： 3.1 keep命令指一系列以-keep开头的命令，主要是用来保留Java中不需要进行混淆的元素。以下是常见的-keep命令： -keep：作用：保留指定的类和成员，防止被混淆处理。如： 12345# 保留包：com.moos.media.entity 下面的类以及类成员-keep public class com.moos.media.entity.**# 保留类：NumberProgressBar-keep public class com.moos.media.widget.NumberProgressBar &#123;*;&#125; -keepclassmembers：作用：保留指定的类的成员（变量/方法），它们将不会被混淆。如： 12345# 保留类的成员：MediaUtils类中的特定成员方法-keepclassmembers class com.moos.media.MediaUtils &#123; public static *** getLocalVideos(android.content.Context); public static *** getLocalPictures(android.content.Context);&#125; -keepclasseswithmembers：作用：保留指定的类及其成员（变量/方法），前提是它们在压缩阶段没有被删除。与-keep使用方式类似： 12345# 保留类：BaseMediaEntity 的子类-keepclasseswithmembers public class * extends com.moos.media.entity.BaseMediaEntity&#123;*;&#125;# 保留类：OnProgressBarListener接口的实现类-keep public class * implements com.moos.media.widget.OnProgressBarListener &#123;*;&#125; @keep：除了以上的方式，还可以使用@keep注解来保留代码，防止它们被混淆处理。比如，通过@keep来修饰一个类来保留它不被混淆： 123456@Keepdata class CloudMusicBean(var createDate: String, var id: Long, var name: String, var url: String, val imgUrl: String) 也可以修饰方法或字段进行保留。 3.2 其他命令 dontwarn-dontwarn命令一般在引入新的library时会用到，常用于处理library中无法解决的警告。如： 123-keep class twitter4j.** &#123; *; &#125;-dontwarn twitter4j.** 其他命令用法可以参考Android系统提供的默认混淆规则： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#混淆时不生成大小写混合的类名-dontusemixedcaseclassnames#不跳过非公共的库的类-dontskipnonpubliclibraryclasses#混淆过程中记录日志-verbose#关闭预校验-dontpreverify#关闭优化-dontoptimize#保留注解-keepattributes *Annotation*#保留所有拥有本地方法的类名及本地方法名-keepclasseswithmembernames class * &#123; native &lt;methods&gt;;&#125;#保留自定义View的get和set方法-keepclassmembers public class * extends android.view.View &#123; void set*(***); *** get*();&#125;#保留Activity中View及其子类入参的方法，如: onClick(android.view.View)-keepclassmembers class * extends android.app.Activity &#123; public void *(android.view.View);&#125;#保留枚举-keepclassmembers enum * &#123; **[] $VALUES; public *;&#125;#保留序列化的类-keepclassmembers class * implements android.os.Parcelable &#123; public static final android.os.Parcelable$Creator CREATOR;&#125;#保留R文件的静态成员-keepclassmembers class **.R$* &#123; public static &lt;fields&gt;;&#125;-dontwarn android.support.**-keep class android.support.annotation.Keep-keep @android.support.annotation.Keep class * &#123;*;&#125;-keepclasseswithmembers class * &#123; @android.support.annotation.Keep &lt;methods&gt;;&#125;-keepclasseswithmembers class * &#123; @android.support.annotation.Keep &lt;fields&gt;;&#125;-keepclasseswithmembers class * &#123; @android.support.annotation.Keep &lt;init&gt;(...);&#125; 更多混淆命令可以参考文章：ProGuard 最全混淆规则说明 4. 不能混淆的部分哪些内容应该混淆？其实，在使用代码混淆时，ProGuard对项目大部分代码进行了混淆操作，为防止编译出错，应该通过-keep命令保留一些元素不被混淆。所以需要知道哪些元素不应该被混淆： 4.1 枚举枚举不能参与到混淆中，原因是：枚举内部存在values方法，混淆后该方法会被重新命名，并抛出NoSuchMethodException。Android系统默认的混淆规则中已经添加了对枚举类的处理，无需额外进行处理。 4.2 被反射的元素被反射使用的类、方法、变量、包名等不能被混淆，原因是：代码混淆过程中，被反射的元素会被重命名，而反射依旧按照先前的名称去查找元素，会发生NoSuchMethodException和NoSuchFieldException。 4.3 实体类实体类通常会伴随着序列化和反序列化操作。混合是将原本有特定含义的“元素”转成无意义的名称，所以，经过混淆之后，序列化之后的value对应的key已经变成没有意义的字段。同时，反序列化的过程创建对象从根本上还是借助反射，混淆后key会被改变，所以实体类通常也不能混淆。 4.4 四大组件Android中的四大组件也不能被混淆，原因是： 四大组件使用前都需要在AndroidManifest.xml文件中进行注册声明，然而混淆处理后，四大组件的类名就会被更改，实际使用的类与AndroidMainifest.xml中注册的类不匹配，会报错。 其他应用程序访问组件时，可能会用到类的包名和类名，经过混淆，可能会找不到对应的组件而产生异常。 4.5 JNI调用的Java方法当JNI调用的Java方法被混淆后，方法名会变成无意义的名称，这就与C++中原本的Java方法名不匹配，因而无法找到所调用的方法。 4.6 其他不应被混淆的 自定义控件不能被混淆 JavaScript调用Java的方法不应被混淆 Java的native方法不应被混淆 项目中引用的第三方库不建议混淆 5. 混淆后的堆栈跟踪代码经过ProGuard混淆处理后，想要读取StackTrace（堆栈追踪）信息就会变得困难。由于方法名和类名都经过混淆处理，即使程序崩溃，也很难定位问题。但是，ProGuard提供了补救的措施，先来看看ProGuard每次构建后生成哪些内容。 5.1 混淆输出结果混淆构建完成之后，会在&lt;module-name&gt;/build/outputs/mapping/release/目录下生成以下文件： dump.txt：说明APK内所有类文件的内部结构。 mapping.txt：提供混淆前后的内容对照表，内容主要包括类、方法和类的成员变量。 seeds.txt：罗列出未进行混淆处理的类和成员。 usage.txt：罗列出从APK移除的代码。 5.2 恢复堆栈跟踪前面的遗留问题：混淆处理后，StackTrace定位困难。如何恢复StackTrace的定位能力？系统提供了retrace工具，结合上面定义的mapping.txt文件，就可以将混淆后的崩溃堆栈追踪器信息还原成正常情况下的StackTrace信息。主要有两种方式来恢复SrackTrace，为了方便理解，以下面的崩溃信息为例，协助两种方式分别进行还原： 123456java.lang.RuntimeException: Unable to start activity Caused by: kotlin.KotlinNullPointerException at com.moos.media.ui.ImageSelectActivity.k(ImageSelectActivity.kt:71) at com.moos.media.ui.ImageSelectActivity.onCreate(ImageSelectActivity.kt:58) at android.app.Activity.performCreate(Activity.java:6237) at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1107) 通过retrace脚本工具 首先进入Android SDK路径的tools/proguard/bin中： 可以看到里面有三个文件，而proguardgui.bat就是需要的retrace脚本。双加该脚本文件，运行，即可看到： 选择Retrace栏，添加项目中混淆生成的mapping.txt文件所在位置，然后将混淆后的崩溃信息复制到Obfuscated stack trace一栏，点击Retrace，即可还原出崩溃日志信息。 通过retrace命令行首先将崩溃信息复制到.txt文件中，然后执行下面命令：1retrace.bat -verbose mapping.txt proguard_stacktrace.txt 最终还原结果和之前效果相同： 在对stackTrace进行恢复时，发现unknown Source问题： 在混淆规则上添加如下配置来提升StackSource查找效率， 12# 保留源文件名和具体代码行号-keepattributes SourceFile,LineNumberTable 此外，每次使用ProGuard创建发布构建时都会覆盖之前版本的mapping.txt文件，因此，每次发布一个新版本时，建议保存一个副本。通过为每个发布构建保留一个mapping.txt文件副本，就可以在用户提交的已混淆的StackTrace来对旧版本应用的问题进行调试和修复。 6. 其他操作前面介绍到，APK在经过代码混淆处理后，包名、类名、成员名被转化为无意义、难以理解的名称，增加反编译的成本。Android ProGuard提供了默认的“混淆字典”，即将元素名称转为英文小写字母的形式。那么，可以定义自己的混淆字典吗？先看一张效果图： 只要生成一套自己的.txt格式的混淆字典，然后在混淆规则Proguard-rules.pro中应用下即可：","categories":[{"name":"Android","slug":"Android","permalink":"https://tylerLiu.top/categories/Android/"},{"name":"其他","slug":"Android/其他","permalink":"https://tylerLiu.top/categories/Android/其他/"}],"tags":[{"name":"代码混淆","slug":"代码混淆","permalink":"https://tylerLiu.top/tags/代码混淆/"}]},{"title":"Android-RecyclerView自动滚动","slug":"Android-RecyclerView自动滚动","date":"2019-07-27T05:03:29.000Z","updated":"2020-05-16T05:54:30.726Z","comments":true,"path":"2019/07/27/Android-RecyclerView自动滚动/","link":"","permalink":"https://tylerLiu.top/2019/07/27/Android-RecyclerView自动滚动/","excerpt":"","text":"实现功能：使用RecyclerView实现垂直滚动效果。 1. 自定义RecyclerView实现滚动效果12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package com.ly.allendemoautopollrecyclerview;import android.annotation.SuppressLint;import android.content.Context;import android.support.annotation.NonNull;import android.support.annotation.Nullable;import android.support.v7.widget.RecyclerView;import android.util.AttributeSet;import android.view.MotionEvent;import java.lang.ref.WeakReference;/** * 自定义垂直滚动RecyclerView * * @author Liuyang * @date 2019/7/27 */public class AutoPollRecyclerView extends RecyclerView &#123; private static final long TIME_AUTO_POLL = 16; private AutoPollTask mAutoPollTask; /** * 标示是否正在自动轮询 */ private boolean mRunning; /** * 标示是否可以自动轮询，可在不需要的是否置false */ private boolean mCanRun; public AutoPollRecyclerView(@NonNull Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); mAutoPollTask = new AutoPollTask(this); &#125; static class AutoPollTask implements Runnable &#123; private final WeakReference&lt;AutoPollRecyclerView&gt; mReference; /** * 使用弱引用持有外部引用，放置内存泄露 */ AutoPollTask(AutoPollRecyclerView reference) &#123; mReference = new WeakReference&lt;&gt;(reference); &#125; @Override public void run() &#123; AutoPollRecyclerView recyclerView = mReference.get(); if (recyclerView != null &amp;&amp; recyclerView.mRunning &amp;&amp; recyclerView.mCanRun) &#123; recyclerView.scrollBy(2, 2); recyclerView.postDelayed(recyclerView.mAutoPollTask, TIME_AUTO_POLL); &#125; &#125; &#125; /** * 开启：如果正在运行，则先停止，再开始 */ public void start() &#123; if (mRunning) &#123; stop(); &#125; mCanRun = true; mRunning = true; postDelayed(mAutoPollTask, TIME_AUTO_POLL); &#125; /** * 停止 */ public void stop() &#123; mRunning = false; removeCallbacks(mAutoPollTask); &#125; @SuppressLint(\"ClickableViewAccessibility\") @Override public boolean onTouchEvent(MotionEvent e) &#123; switch (e.getAction()) &#123; case MotionEvent.ACTION_DOWN: if (mRunning) &#123; stop(); &#125; break; case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: case MotionEvent.ACTION_OUTSIDE: if (mCanRun) &#123; start(); &#125; break; default: break; &#125; return super.onTouchEvent(e); &#125;&#125; 2. 实现Adapter1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.ly.allendemoautopollrecyclerview;import android.annotation.SuppressLint;import android.content.Context;import android.support.annotation.NonNull;import android.support.v7.widget.RecyclerView;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.TextView;import java.util.List;public class AutoPollAdapter extends RecyclerView.Adapter&lt;AutoPollAdapter.BaseViewHolder&gt; &#123; private final Context mContext; private final List&lt;AutoScrollLuckyListReq.DatasBean&gt; mData; public AutoPollAdapter(Context context, List&lt;AutoScrollLuckyListReq.DatasBean&gt; data) &#123; mContext = context; mData = data; &#125; @NonNull @Override public BaseViewHolder onCreateViewHolder(@NonNull ViewGroup viewGroup, int i) &#123; View view = LayoutInflater.from(mContext).inflate(R.layout.auto_list_item, viewGroup, false); return new BaseViewHolder(view); &#125; @SuppressLint(\"SetTextI18n\") @Override public void onBindViewHolder(@NonNull BaseViewHolder baseViewHolder, int position) &#123; AutoScrollLuckyListReq.DatasBean datasBean = mData.get(position % mData.size()); baseViewHolder.content.setText(datasBean.getPhone() + \" 获得 \" + datasBean.getGiftName()); &#125; @Override public int getItemCount() &#123; return Integer.MAX_VALUE; &#125; class BaseViewHolder extends RecyclerView.ViewHolder &#123; TextView content; BaseViewHolder(View itemView) &#123; super(itemView); content = itemView.findViewById(R.id.content); &#125; &#125;&#125; 3. 适配器布局文件12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:background=\"#fffcf5\" android:orientation=\"vertical\"&gt; &lt;TextView android:id=\"@+id/content\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"8dp\" android:layout_marginBottom=\"8dp\" android:text=\"135xxxx8888 获得 8积分\" android:textColor=\"#797762\" android:textSize=\"14sp\" /&gt; &lt;View android:layout_width=\"match_parent\" android:layout_height=\"1dp\" android:background=\"#797762\" /&gt;&lt;/LinearLayout&gt; 4. 调用布局文件：activity_main.xml： 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".MainActivity\"&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"150dp\" android:layout_centerInParent=\"true\" android:layout_marginLeft=\"15dp\" android:layout_marginTop=\"15dp\" android:layout_marginRight=\"15dp\" android:background=\"@drawable/luckyer_bg\"&gt; &lt;RelativeLayout android:layout_width=\"40dp\" android:layout_height=\"wrap_content\" android:layout_marginStart=\"23dp\" android:layout_marginTop=\"1dp\" android:layout_marginBottom=\"1dp\" android:background=\"#fff6ea\"&gt; &lt;ImageView android:layout_width=\"wrap_content\" android:layout_height=\"match_parent\" android:layout_centerInParent=\"true\" android:padding=\"10dp\" android:src=\"@drawable/zhongjiangzhemingdan\" /&gt; &lt;/RelativeLayout&gt; &lt;com.ly.allendemoautopollrecyclerview.AutoPollRecyclerView android:id=\"@+id/recyclerview\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_margin=\"20dp\" /&gt; &lt;/LinearLayout&gt;&lt;/RelativeLayout&gt; Java文件：MainActivity.java： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129package com.ly.allendemoautopollrecyclerview;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.support.v7.widget.LinearLayoutManager;import com.alibaba.fastjson.JSON;/** * @author Liuyang * @date 2019/7/27 */public class MainActivity extends AppCompatActivity &#123; private AutoPollRecyclerView mRecyclerView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); initData(); &#125; private void initView() &#123; mRecyclerView = findViewById(R.id.recyclerview); mRecyclerView.setLayoutManager(new LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false)); &#125; private void initData() &#123; String response = \"&#123;\\n\" + \" \\\"datas\\\": [\\n\" + \" &#123;\\n\" + \" \\\"giftName\\\": \\\"20个积分\\\",\\n\" + \" \\\"phone\\\": \\\"****\\\"\\n\" + \" &#125;,\\n\" + \" &#123;\\n\" + \" \\\"giftName\\\": \\\"20个积分\\\",\\n\" + \" \\\"phone\\\": \\\"****\\\"\\n\" + \" &#125;,\\n\" + \" &#123;\\n\" + \" \\\"giftName\\\": \\\"满10减1元\\\",\\n\" + \" \\\"phone\\\": \\\"****\\\"\\n\" + \" &#125;,\\n\" + \" &#123;\\n\" + \" \\\"giftName\\\": \\\"20个积分\\\",\\n\" + \" \\\"phone\\\": \\\"****\\\"\\n\" + \" &#125;,\\n\" + \" &#123;\\n\" + \" \\\"giftName\\\": \\\"20个积分\\\",\\n\" + \" \\\"phone\\\": \\\"****\\\"\\n\" + \" &#125;,\\n\" + \" &#123;\\n\" + \" \\\"giftName\\\": \\\"满10减1元\\\",\\n\" + \" \\\"phone\\\": \\\"****\\\"\\n\" + \" &#125;,\\n\" + \" &#123;\\n\" + \" \\\"giftName\\\": \\\"20个积分\\\",\\n\" + \" \\\"phone\\\": \\\"****\\\"\\n\" + \" &#125;,\\n\" + \" &#123;\\n\" + \" \\\"giftName\\\": \\\"满10减1元\\\",\\n\" + \" \\\"phone\\\": \\\"****\\\"\\n\" + \" &#125;,\\n\" + \" &#123;\\n\" + \" \\\"giftName\\\": \\\"满10减1元\\\",\\n\" + \" \\\"phone\\\": \\\"****\\\"\\n\" + \" &#125;,\\n\" + \" &#123;\\n\" + \" \\\"giftName\\\": \\\"三花便签（20枚）\\\",\\n\" + \" \\\"phone\\\": \\\"****\\\"\\n\" + \" &#125;,\\n\" + \" &#123;\\n\" + \" \\\"giftName\\\": \\\"三花便签（20枚）\\\",\\n\" + \" \\\"phone\\\": \\\"****\\\"\\n\" + \" &#125;,\\n\" + \" &#123;\\n\" + \" \\\"giftName\\\": \\\"满10减1元\\\",\\n\" + \" \\\"phone\\\": \\\"****\\\"\\n\" + \" &#125;,\\n\" + \" &#123;\\n\" + \" \\\"giftName\\\": \\\"20个积分\\\",\\n\" + \" \\\"phone\\\": \\\"****\\\"\\n\" + \" &#125;,\\n\" + \" &#123;\\n\" + \" \\\"giftName\\\": \\\"满10减1元\\\",\\n\" + \" \\\"phone\\\": \\\"****\\\"\\n\" + \" &#125;,\\n\" + \" &#123;\\n\" + \" \\\"giftName\\\": \\\"20个积分\\\",\\n\" + \" \\\"phone\\\": \\\"****\\\"\\n\" + \" &#125;,\\n\" + \" &#123;\\n\" + \" \\\"giftName\\\": \\\"三花便签（20枚）\\\",\\n\" + \" \\\"phone\\\": \\\"****\\\"\\n\" + \" &#125;,\\n\" + \" &#123;\\n\" + \" \\\"giftName\\\": \\\"三花便签（20枚）\\\",\\n\" + \" \\\"phone\\\": \\\"****\\\"\\n\" + \" &#125;,\\n\" + \" &#123;\\n\" + \" \\\"giftName\\\": \\\"满10减1元\\\",\\n\" + \" \\\"phone\\\": \\\"****\\\"\\n\" + \" &#125;,\\n\" + \" &#123;\\n\" + \" \\\"giftName\\\": \\\"20个积分\\\",\\n\" + \" \\\"phone\\\": \\\"****\\\"\\n\" + \" &#125;,\\n\" + \" &#123;\\n\" + \" \\\"giftName\\\": \\\"20个积分\\\",\\n\" + \" \\\"phone\\\": \\\"****\\\"\\n\" + \" &#125;\\n\" + \" ],\\n\" + \" \\\"msg\\\": \\\"success\\\",\\n\" + \" \\\"ret\\\": 0\\n\" + \"&#125;\"; AutoScrollLuckyListReq autoScrollLuckyListReq = JSON.parseObject(response, AutoScrollLuckyListReq.class); // 0为请求成功 if (autoScrollLuckyListReq.getRet() == 0) &#123; AutoPollAdapter autoPollAdapter = new AutoPollAdapter(getApplicationContext(), autoScrollLuckyListReq.getDatas()); mRecyclerView.setAdapter(autoPollAdapter); // 启动滚动 mRecyclerView.start(); &#125; &#125;&#125; 5. 效果和Demo地址 Demo地址：Allen_Demo_AutoPollRecyclerView","categories":[{"name":"Android","slug":"Android","permalink":"https://tylerLiu.top/categories/Android/"},{"name":"View","slug":"Android/View","permalink":"https://tylerLiu.top/categories/Android/View/"}],"tags":[{"name":"RecyclerView","slug":"RecyclerView","permalink":"https://tylerLiu.top/tags/RecyclerView/"}]},{"title":"蘸水牛肉","slug":"蘸水牛肉","date":"2019-07-27T03:25:47.000Z","updated":"2019-07-31T07:35:20.295Z","comments":true,"path":"2019/07/27/蘸水牛肉/","link":"","permalink":"https://tylerLiu.top/2019/07/27/蘸水牛肉/","excerpt":"","text":"【食材】：牛腱子两斤，老姜一大块，花椒四五十粒， 食盐适量，大蒜泥适量、调味盐、味精适量，红油辣子一大勺，花椒面适量，藤椒油适量，芝麻油适量，香葱花适量。 流程： 牛腱子用洗水浸泡两三个小时，尽量泡出肉的的血水，因为肉中血水多，肉的腥味就比较重，不好吃； 浸泡好的牛肉入冷水锅，中火煮开后，再煮两分钟； 经过稍稍煮过的牛肉会紧缩一团，我们从锅中取出肉，再用温水冲洗干净牛肉表面的血污，再控干水分，以上几个步骤的目的都是尽量去除肉中的血污，让肉的味道更鲜美，而没有腥味； 砂锅中放入前面处理好的牛肉，再加入纯净水或矿泉水，再加入一块用刀拍破的老姜和花椒粒，以及适量的食盐，开 大火烧开后，转小火盖上锅盖煮，大约一个小时左右； 煮一个小时左右，我们用一根筷子插肉，如果可以轻松插入牛肉肉中就差不多了； 我们再把牛肉从锅中取出，彻底晾凉后再切成薄片备用； 取一个碗，碗中加入大蒜泥，红油辣子（最好是近期制作的在，时间长了不香），适量的花面和藤椒油卡 ，还要加上适量的调味盐（虽然前面煮肉时加过盐，但比较淡，这里还是需要加少量的调味盐），最后我们还要加入，适量的味精、芝麻油、香葱花，再搅拌匀就可以蘸牛肉了。","categories":[{"name":"美食","slug":"美食","permalink":"https://tylerLiu.top/categories/美食/"}],"tags":[{"name":"美食","slug":"美食","permalink":"https://tylerLiu.top/tags/美食/"}]},{"title":"豆角焖面","slug":"豆角焖面","date":"2019-07-27T03:19:40.000Z","updated":"2019-07-27T03:22:40.402Z","comments":true,"path":"2019/07/27/豆角焖面/","link":"","permalink":"https://tylerLiu.top/2019/07/27/豆角焖面/","excerpt":"","text":"主料：圆滚豆角一小把切成丁，五花肉适量切成末，细刀切面适量 配料：泡发好的香菇4、5朵切丁，胡萝卜一小段切丁，葱末、姜米、蒜米，香菜碎，八角一朵，干红辣椒4、5只 酱汁：另准备4、5瓣大蒜切米放入碗中，加适量青葱碎，里面放入两匙酱油，一匙陈醋，1\\3匙白糖 调成酱汁备用 流程： 热锅凉油，油温7、8层热时放入八角爆香，下肉末煸炒，肉末变色断生后放入干红辣椒翻炒几下，依次加入姜末、葱末、蒜末，翻炒出香味后加入适量酱油和少许盐，加稍多些水，烧开后慢火炖煮10分钟； 冲调酱汁：10分钟后将锅里面的汤一勺一勺舀出，冲倒在酱汁碗中； 锅内留少许汤汁，以不没过豆角为限，将刀切面疏散的铺在豆角上面，尽量不要贴在锅壁上，防粘和糊； 将冲调好的酱汁分三次均匀淋在面条上，每次间隔3分钟； 9分钟后关火，在面条上淋少许香油，撒上香菜碎，用筷子轻轻将面条拨散拌匀，装盘上桌。 搭配上橄榄油沙拉和花生米，营养很均衡。","categories":[{"name":"美食","slug":"美食","permalink":"https://tylerLiu.top/categories/美食/"}],"tags":[{"name":"美食","slug":"美食","permalink":"https://tylerLiu.top/tags/美食/"}]},{"title":"二、Android XML数据解析","slug":"二、Android-XML数据解析","date":"2019-07-26T08:27:11.000Z","updated":"2019-07-29T02:32:02.644Z","comments":true,"path":"2019/07/26/二、Android-XML数据解析/","link":"","permalink":"https://tylerLiu.top/2019/07/26/二、Android-XML数据解析/","excerpt":"","text":"1. XML数据要点介绍XML，可扩展标记语言。可以用来存储数据，可以看做是一个小型的数据库，SharedPreference就是使用XML文件存储数据的，SQLite底层也是一个XML文件，而在网络应用方面，通常作为信息的载体，通常把数据包装成XML来传递。 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; -----文档开始&lt;persons&gt; -----开始元素(persons) &lt;person id = \"11\"&gt; -----文本节点（空白文本） 开始元素(person)属性 &lt;name&gt;Coder-pig&lt;/name&gt; -----文本节点（空白文本） 开始元素(name)属性 结束元素 &lt;age&gt;18&lt;/age&gt; -----文本节点（空白文本） 开始元素(age)属性 结束元素 &lt;/person&gt; -----文本节点（空白文本） 结束元素 &lt;person id = \"13\"&gt; &lt;name&gt;Jay&lt;/name&gt; &lt;age&gt;20&lt;/age&gt; &lt;/person&gt;&lt;/persons&gt; -----结束元素(persons) -----文档结束 上面就简单的定义了一个存储person对象的xml文件的编码，注意，外面的空白区域也是文本节点。 2. 三种解析XML方法的比较2.1 SAX解析XML对文档进行顺序扫描，当扫描到文档(doucument)开始与结束、元素(element)开始与结束等地方时，通知事件处理函数，由事件处理函数做相对应动作，然后继续进行同样的扫描，直至文档结束。解释速度快，占用内存小，，每需要解析一类XML，就需要编写新的适合该类的XML处理类，比较麻烦。采用的是流式解析，解析是同步的，读到哪就处理到哪。 2.2 Dom解析XML先把XML文档读取到内存中，然后再用DOM API来访问树形结构，并获取数据。这个写起来很简单，但是很消耗内存，假如读取的数据量大，手机内存不够的话，可能导致手机死机。不建议在Android设备中使用，解析简单的XML可以。常用的五个接口与类：Docculem、Element、Node、NodeList、DOMParser，Don是整个文件解析到内存中，供用户需要的节点信息，支持随机访问。 2.3 pull解析XMLXML pull提供了开始元素和结束元素。当某个元素开始时，可以调用parser、nextText从XML文档中提取所有字符数据。当解析到文档结束时，自动生成EndDocument。常用接口和类：XmlPullParser、XmlSerializer、XmlPullParserFactory。和SAX差不多，代码实现比较简单，非常适合移动设备，Android系统内置pull解析器，而且Android系统内部默认使用pull来解析XML文件。 3. SAX解析XMLSAX是一个解析速度快且占用内存少的XML解析器，非常适合用于Android等移动设备；SAX解析XML文件采用的是事件驱动，也就是说不需要解析整个文档，而是在解析过程中，判断读取的字符是否符合XML语法的某部分（文档开头，文档结束，或者标签开头和标签结束），符合的话就会触发事件（回调方法），而这些方法都定义在ContentHandler接口中，而ContentHandler是一个接口， 使用起来不方便，所以Android准备了一个帮助类DefaultHandler，只需要继承这个类，重写里面对应的方法即可。 可以重写的方法： startDocument()：当读取到文文档开始标志时触发，通常在这里完成一些初始化操作。 endDocument()：文档结束部分，在这里完成一些善后工作。 startElement(names, paceURI, localName, qName, atts)：参数依次问命名空间，不带命名空间的前缀标签名，带命名空间的前缀标签名，通过atts可以得到所有的属性名和相应的值；SAX中一个重要的特点就是它的流式处理，当遇到一个标签时，它并不会记录下以前遇到的标签，就是说，在startElement()中，所有知道的信息就是标签的名字和属性，至于标签的嵌套结构，上层标签的名字，是否有子元素等其他与结构相关的信息，都不知道，需要程序来完成，这使得SAX在编程处理上没有DOM方便。 endElement(uri, localName, name)：在遇到结束标签的时候，调用该方法。 characters(ch, start, length)：这个方法用来处理在XML文件中读到的内容，第一个参数用于存放文件的内容，后面两个参数是读到的字符串在这个数组中的起始位置和长度，使用new String(ch, start, length)就可以获取内容。 核心代码：SAX解析类——SaxHelper.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package com.ly.allendemowebservice;import android.util.Log;import org.xml.sax.Attributes;import org.xml.sax.SAXException;import org.xml.sax.helpers.DefaultHandler;import java.util.ArrayList;/** * SAX解析XML * * @author Liuyang * @date 2019/7/26 */public class SaxHelper extends DefaultHandler &#123; private static final String TAG = \"SaxHelper\"; private Person mPerson; private ArrayList&lt;Person&gt; mPersons; /** * 当前解析的元素标签 */ private String mTagName = null; /** * 当读取到文档开始标志时触发，通常在里面完成一些初始化操作 */ @Override public void startDocument() throws SAXException &#123; this.mPersons = new ArrayList&lt;&gt;(); Log.i(TAG, \"读取到文档头,开始解析xml\"); &#125; private static final String ELEMENT = \"person\"; /** * 读到一个开始标签时触发，第二个参数为标签名，最后一个参数为属性数组 */ @Override public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException &#123; if (ELEMENT.equals(localName)) &#123; mPerson = new Person(); mPerson.setId(Integer.parseInt(attributes.getValue(\"id\"))); Log.i(TAG, \"开始处理person元素~\"); &#125; mTagName = localName; &#125; private static final String TAG_NAME1 = \"name\"; private static final String TAG_NAME2 = \"age\"; /** * 读取标签里面的内容，第一个参数为字符串内容，后面依次为起始位置和长度 */ @Override public void characters(char[] ch, int start, int length) throws SAXException &#123; // 判断当前标签是否有效 if (mTagName != null) &#123; String data = new String(ch, start, length); // 读取标签内容 if (TAG_NAME1.equals(mTagName)) &#123; mPerson.setName(data); Log.i(TAG, \"处理name元素内容\"); &#125; else if (TAG_NAME2.equals(mTagName)) &#123; mPerson.setAge(Integer.parseInt(data)); Log.i(TAG, \"处理age元素内容\"); &#125; &#125; &#125; /** * 读取到元素结束时触发，这里将对象添加到集合中 */ @Override public void endElement(String uri, String localName, String qName) throws SAXException &#123; if (ELEMENT.equals(localName)) &#123; mPersons.add(mPerson); mPerson = null; Log.i(TAG, \"处理person元素结束~\"); &#125; mTagName = null; &#125; /** * 读取到文档结束时触发， */ @Override public void endDocument() throws SAXException &#123; super.endDocument(); Log.i(TAG, \"处理person元素结束~\"); &#125; /** * 获取persons集合 */ public ArrayList&lt;Person&gt; getPersons() &#123; return mPersons; &#125;&#125; 1234567891011121314private ArrayList&lt;Person&gt; readXmlForSax() throws IOException, ParserConfigurationException, SAXException &#123; // 获取文件资源建立输入流对象，可能是从网络获取 InputStream inputStream = getAssets().open(\"person1.xml\"); // 创建XML解析器 SaxHelper helper = new SaxHelper(); // 得到SAX解析工厂 SAXParserFactory factory = SAXParserFactory.newInstance(); // 创建SAX解析器 SAXParser parser = factory.newSAXParser(); // 将XML解析器分配给解析器，对文档进行解析，将事件发送给处理器 parser.parse(inputStream, helper); inputStream.close(); return helper.getPersons();&#125; 在项目assets目录下有一个文件person1.xml。 1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;persons&gt; &lt;person id = \"11\"&gt; &lt;name&gt;SAX解析&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;/person&gt; &lt;person id = \"13\"&gt; &lt;name&gt;XML1&lt;/name&gt; &lt;age&gt;43&lt;/age&gt; &lt;/person&gt;&lt;/persons&gt; Demo地址：Allen_Demo_WebService 4. DOM解析XML数据DOM解析XML文件时会将文件所有的内容以文档树的形式存放在内存中，可以使用DOM API遍历XML树，检索到需要的数据。使用DOM操作XML的代码比较直观，并且在编码方面比基于SAX的实现更加简单。但是DOM需要将XML文件的所有内容存放到内存中，所以内存消耗大，特别是对于Android设备而言，内存资源有限，因此建议使用前面的SAX解析。如果解析的内容比较小，也可以使用DOM来解析。 DOM API： DocumentBuilderFactory（解析器工厂类）：创建方法DoucmentBuilderFactory factory = DoucmentBuilderFactory.newInstance(); DocumentBuilder（解析器类）：创建方法：通过解析器工厂类来获得DocumentBuidler builder = factory.newDocumentBuilder(); Document（文档树模型）：将需要解析的XML文件读入DOM解析器：Document doc = builder.parse(context.getAssets().open(&quot;person2.xml&quot;)); Document对象代表了一个XML文档的模型，所有的其他Node都以一定的顺序包含在Document对象内，排列成树状，以后对XML文档的所有操作都与解析器无关。 NodeList（列表类）：代表一个包含一个或多个Node的列表，有以下两个方法： item(index)：返回集合的第index个Node项； getLength()：列表的节点数 Node（节点类）：DOM中最基本的对象，代表文档树中的抽象节点，很少会直接使用；通常调用其子对象的Element、Attr、Text等。 Element（元素类）：Node最主要的子对象，在元素中可以包含属性，因此有获取属性的方法： getAttrbute()：获取属性值 getTagName()：获取元素名称 Attr（属性类）：代表某个元素的属性，虽然Attr继承自Node接口，但因为Attr是包含在Element中的，但并不能将其看做是Element的子对象，因为Attr并不是DOM树的一部分。 核心代码：DOM解析类——DomHelper.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.ly.allendemowebservice;import android.content.Context;import android.util.Log;import org.w3c.dom.Document;import org.w3c.dom.Element;import org.w3c.dom.Node;import org.w3c.dom.NodeList;import org.xml.sax.SAXException;import java.io.IOException;import java.util.ArrayList;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.parsers.ParserConfigurationException;/** * DOM解析XML * * @author Liuyang * @date 2019/7/26 */public class DomHelper &#123; private static final String TAG = \"DomHelper\"; private static final String TAG_NAME = \"name\"; private static final String TAG_AGE = \"age\"; public static ArrayList&lt;Person&gt; queryXML(Context context) &#123; ArrayList&lt;Person&gt; persons = new ArrayList&lt;&gt;(); try &#123; // 1. 获取DOM解析器工厂 DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); // 2. 获取DOM解析器 DocumentBuilder builder = factory.newDocumentBuilder(); // 3. 将要解析的XML文件读入DOM解析器 Document document = builder.parse(context.getAssets().open(\"person2.xml\")); Log.i(TAG, \"处理该文档的DomImplementation对象 = \" + document.getImplementation()); // 4. 得到文档中名称为person的元素的节点元素 NodeList nodeList = document.getElementsByTagName(\"person\"); // 5. 遍历集合，显示集合中的元素以及子元素的名字 for (int i = 0; i &lt; nodeList.getLength(); i++) &#123; // 先从person元素开始解析 Element personElement = (Element) nodeList.item(i); Person person = new Person(); person.setId(Integer.valueOf(personElement.getAttribute(\"id\"))); // 获取person下的name和age的Note集合 NodeList childNodeList = personElement.getChildNodes(); for (int j = 0; j &lt; childNodeList.getLength(); j++) &#123; Node childNode = childNodeList.item(j); // 判断子Node类型是否为元素的Node if (childNode.getNodeType() == Node.ELEMENT_NODE) &#123; Element childElement = (Element) childNode; if (TAG_NAME.equals(childElement.getNodeName())) &#123; person.setName(childElement.getFirstChild().getNodeValue()); &#125; else if (TAG_AGE.equals(childElement.getNodeName())) &#123; person.setAge(Integer.valueOf(childElement.getFirstChild().getNodeValue())); &#125; &#125; &#125; persons.add(person); &#125; &#125; catch (ParserConfigurationException e) &#123; e.printStackTrace(); &#125; catch (SAXException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return persons; &#125;&#125; 5. PULL解析XML数据除了SAX和DOM解析XML之外，Android系统内置了Pull解析器用来解析XML，比如SharedPreference就是使用内置的pull解析配置文件的。它的使用和SAX类似，都是采用事件驱动来完成XML的解析，而pull代码比较简单，只需处理开始和结束的事件，通常使用switch语句，根据事件不同的类型，匹配不同的处理方式，有五种事件：START_DOCUMENT、START_TAG、TEXT、END_TAG、END_DUCOMENT。 XML pull 提供了开始元素和结束元素。当某个元素开始的时候，可以调用paser.nextText从XML文档中提取所有字符数据。当解析到一个文档结束时，自动生成EndDocument事件。在PULL解析过程中返回的是数字，且需要自己获取产生事件然后做出相应的操作，而不像SAX那样由处理器触发一种事件的方法，执行我们的代码：读取到XML的声明返回START_DOCUMENT；结束返回END_DOCUMENT；开始标签返回START_TAG；结束标签返回END_TAG；文本返回TEXT。使用PULL解析XML的流程： 获取一个XmlPullPaser类的引用： 1234// 方式1：通过xml解析工厂获得实体类XmlPullPaserFactory factory = XmlPullPaserFactory.newInstance(); XmlPullPaser paser = factory.newPullPaser();// 方式2：直接获得实体类XmlPullPaser paser = Xml.newPullPaser(); 为paser解析器对象提供xml流与编码格式： 1paser.setInput(xml, \"UTF-8\"); 获得事件的类型： 1int eventType = paser.getEventType(); 用switch对不同的事件类型进行不同的处理： START_DUCUMENT：开始读文档时触发，在这里完成初始化操作； START_TAG:开始读标签，通过paser的getName()方法获得标签名信息比较，使用getAttributeValue(index)获取属性值； 对于文字节点TEXT可以使用paser.nextText()获得节点内容； END_TAG：标签结束； paser.next()：循环解析下一个元素。 核心代码：PULL解析XML——PullHelper.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.ly.allendemowebservice;import org.xmlpull.v1.XmlPullParser;import org.xmlpull.v1.XmlPullParserException;import org.xmlpull.v1.XmlPullParserFactory;import java.io.IOException;import java.io.InputStream;import java.util.ArrayList;/** * PULL解析XML * * @author Liuyang * @date 2019/7/27 */public class PullHelper &#123; public static ArrayList&lt;Person&gt; getPersons(InputStream xml) throws XmlPullParserException, IOException &#123; ArrayList&lt;Person&gt; persons = null; Person person = null; // 创建一个XML解析工厂 XmlPullParserFactory factory = XmlPullParserFactory.newInstance(); // 获得XML解析类的引用 XmlPullParser parser = factory.newPullParser(); parser.setInput(xml, \"UTF_8\"); // 获得事件类型 int eventType = parser.getEventType(); while (eventType != XmlPullParser.END_DOCUMENT) &#123; switch (eventType) &#123; case XmlPullParser.START_DOCUMENT: persons = new ArrayList&lt;&gt;(); break; case XmlPullParser.START_TAG: if (\"person\".equals(parser.getName())) &#123; person = new Person(); // 取出属性值 int id = Integer.parseInt(parser.getAttributeValue(0)); person.setId(id); &#125; else if (\"name\".equals(parser.getName())) &#123; // 获取该节点的内容 String name = parser.nextText(); assert person != null; person.setName(name); &#125; else if (\"age\".equals(parser.getName())) &#123; int age = Integer.parseInt(parser.nextText()); assert person != null; person.setAge(age); &#125; break; case XmlPullParser.END_TAG: if (\"person\".equals(parser.getName())) &#123; assert persons != null; persons.add(person); person = null; &#125; break; default: break; &#125; eventType = parser.next(); &#125; return persons; &#125;&#125; 使用： 1234567891011try &#123; InputStream inputStream = getAssets().open(\"person3.xml\"); ArrayList&lt;Person&gt; persons = PullHelper.getPersons(inputStream); for (int i = 0; i &lt; persons.size(); i++) &#123; Log.i(TAG, i + \" == \" + persons.get(i).toString()); &#125;&#125; catch (IOException e) &#123; e.printStackTrace();&#125; catch (XmlPullParserException e) &#123; e.printStackTrace();&#125; 使用PULL生成XML数据的流程： 创建XMlSerializer（XML序列化类）的实例： 1XmlSerializer serializer = Xml.newSerializer(); 为XmlSerializer设置输出流与编码格式： 1serializersetOutput(out, \"UTF-8\"); 为XMlSerializer设置XML的编码格式： 1serializer.startDocument(\"UTF-8\", true); 设置根元素： 1serializer.startTag(null, \"person\"); 使用foreach循环遍历persons集合中所有的元素，同时依次写入标签与属性： 1234567891011for(Person p: persons)&#123; serializer.startTag(null, \"person\"); serializer.attribute(null, \"id\", p.getId() + \"\"); serializer.startTag(null, \"name\"); serializer.text(p.getName()); serializer.endTag(null, \"name\"); serializer.startTag(null, \"age\"); serializer.text(p.getAge() + \"\"); serializer.endTag(null, \"age\"); serializer.endTag(null, \"person\");&#125; 设置跟踪完结元素： 1serializer.endTag(null, \"persons\"); 结束文档编写： 1serializer.endDocument(); 调用flush()，将内存中的数据写入文件中并关闭输出流 12out.flush();out.close(); 核心代码： 12345678910111213141516171819202122public static void save(List&lt;Person&gt; persons, OutputStream out) throws Exception &#123; XmlSerializer serializer = Xml.newSerializer(); serializer.setOutput(out, \"UTF-8\"); serializer.startDocument(\"UTF-8\", true); serializer.startTag(null, \"persons\"); for (Person p : persons) &#123; serializer.startTag(null, \"person\"); serializer.attribute(null, \"id\", p.getId() + \"\"); serializer.startTag(null, \"name\"); serializer.text(p.getName()); serializer.endTag(null, \"name\"); serializer.startTag(null, \"age\"); serializer.text(p.getAge() + \"\"); serializer.endTag(null, \"age\"); serializer.endTag(null, \"person\"); &#125; serializer.endTag(null, \"persons\"); serializer.endDocument(); out.flush(); out.close();&#125; Demo地址：Allen_Demo_WebService","categories":[{"name":"Android","slug":"Android","permalink":"https://tylerLiu.top/categories/Android/"},{"name":"网络","slug":"Android/网络","permalink":"https://tylerLiu.top/categories/Android/网络/"}],"tags":[{"name":"WebService","slug":"WebService","permalink":"https://tylerLiu.top/tags/WebService/"}]},{"title":"一、Android调用WebService","slug":"一、Android调用WebService","date":"2019-07-26T08:12:57.000Z","updated":"2019-07-31T08:07:13.078Z","comments":true,"path":"2019/07/26/一、Android调用WebService/","link":"","permalink":"https://tylerLiu.top/2019/07/26/一、Android调用WebService/","excerpt":"","text":"Android调用WebService类似于一些给我们提供了原始数据API服务的数据平台，比如聚合数据。而WebService则用到了XML和SOAP，通过HTTP协议即可完成与远程机器的交互。 1. WebService简介1.1 WebService的引入手机硬件资源是有限的，对于一些复杂的数据处理和计算，通常都是部署在远程服务器上，然后安卓手机作为对应的客户端。为了让Android APP与远程服务器进行交互，肯定需要一些技术，这里使用WebService就可以了。 什么是WebService？ 简单来说，就是某些站点开放出来的服务，当然也可以自己开发一个service，也就是一些方法，通过URI，指定某一个方法名，发出请求，站点的这个服务（方法），接收请求后，根据传入的参数进行一些处理，然后将处理的结果以XML的形式返回。客户端收到这些XML并进行解析，然后显示或者进行其他操作。 例如，很多大的站点提供天气预报的WebSwevice、查询某网站的数据的WebService，只要发送请求，它就返回天气预报、某网站的数据，然后在客户端就能显示出来。 1.2 主要采用的四个技术1.2.1 XML可扩展的标记语言。同时采用XML Schema。正式因为WebWervice采用了XML，才使得它可以跨越各种编程语言。 1.2.2 SOAP简单对象访问协议。提供了标准的RPC（Remote Procedure Call，远程调用过程）方法来调用WebService。SOAP规范中定义了SOAP消息格式，以及怎样通过HTTP协议来使用SOAP。SOAP是基于XML语言和XSD标准的，其中XML是SOAP的数据编码方式。 1.2.3 WSDLWSDL是一种基于XML的用于描述WenService及其操作、参数和返回值的语言。因为是基于XML，一些IDE可以根据WenService来生成WSDL文档，又能通过导入WSDL文档 ，生成调用相应WebWervice的代码。 1.2.4 UDDI用于在网上自动查找WebService，一旦WebService注册到UDDI，客户就可以很方便的查找和定位所需要的WebService。 1.3 WebService模型 服务提供者：把自己的服务注册到“服务注册中心”。 服务请求者：到“服务注册中心”查找相应的服务，然后定位到“服务提供者”。 服务提供者：开始为“服务请求者”提供相应的服务。 2. 去哪里获取WebService网上有很多WebService的站点，这里选取了WebXmlu为例。 WebXml：http://www.webxml.com.cn/zh_cn/index.aspx 3. 第三方jar包准备首先如果想在Android平台上调用WebService，需要依赖第三方库ksoap2，而在Android平台上使用的是ksoap2-android-releases，一个高效、轻量级的SOAP开发包。 ksoap2-Android项目网站：https://simpligility.github.io/ksoap2-android/index.html ksoap2-android-assembly发布版本列表(包含所有可用版本jar包)：https://oss.sonatype.org/content/repositories/ksoap2-android-releases/com/google/code/ksoap2-android/ksoap2-android-assembly/ 4. 获取相关参数首先找到需要获取的服务，然后记录相关的参数：NameSpace（命名空间）、SoapAction以及URL。 比如这里查找天气的查询参数，点击去可以看到一个参数文档： 假设这里需要的是天气查询部分的功能： 这里可以拿到SoapAction和NameSpace。 这是一个测试页，可以不用填id信息，点击查询，可以看到这样一个页面： 这就是返回的XML文件，下面就需要去解析这个文件，这里的.gif表示天气的图标。 上面的查询号码归属地也是同理操作。 5. 注册 6. Demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234package com.ly.allendemowebservice;import android.annotation.SuppressLint;import android.os.Handler;import android.os.Message;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.TextView;import android.widget.Toast;import org.ksoap2.SoapEnvelope;import org.ksoap2.serialization.SoapObject;import org.ksoap2.serialization.SoapPrimitive;import org.ksoap2.serialization.SoapSerializationEnvelope;import org.ksoap2.transport.HttpTransportSE;import org.xmlpull.v1.XmlPullParserException;import java.io.IOException;import java.lang.reflect.Method;/** * WebService demo * * @author Liuyang * @date 2019/7/24 */public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private static final String TAG = \"MainActivity\"; private EditText mEtParam; private TextView mTvResult; private String mResult; private static final String USER_ID = \"1e3c36a0f18b4da4affa98cdd26ab0b4\"; /** * 定义获取手机信息的SoapAction与命名空间,作为常量 */ private static final String NAME_SPACE = \"http://WebXml.com.cn/\"; /** * 天气查询相关参数 */ private static final String WEATHER_URL = \"http://ws.webxml.com.cn/WebServices/WeatherWS.asmx\"; private static final String WEATHER_METHOD = \"getWeather\"; private static final String WEATHER_SOAP_ACTION = \"http://WebXml.com.cn/getWeather\"; /** * 号码归属地查询相关参数 */ private static final String ADDRESS_URL = \"http://ws.webxml.com.cn/WebServices/MobileCodeWS.asmx\"; private static final String ADDRESS_METHOD = \"getMobileCodeInfo\"; private static final String ADDRESS_SOAP_ACTION = \"http://WebXml.com.cn/getMobileCodeInfo\"; /** * 定义一个Handler用来更新页面 */ @SuppressLint(\"HandlerLeak\") private Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case 0x001: mTvResult.setText(mResult); Toast.makeText(MainActivity.this, \"获取天气信息成功\", Toast.LENGTH_SHORT).show(); break; case 0x002: mTvResult.setText(mResult); Toast.makeText(MainActivity.this, \"号码归属地查询成功\", Toast.LENGTH_SHORT).show(); break; default: break; &#125; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); bindViews(); &#125; private void bindViews() &#123; mEtParam = findViewById(R.id.et_param); Button btnAttribution = findViewById(R.id.btn_attribution); Button btnWeather = findViewById(R.id.btn_weather); mTvResult = findViewById(R.id.tv_result); btnAttribution.setOnClickListener(this); btnWeather.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.btn_attribution: new Thread() &#123; @Override public void run() &#123; getLand(); &#125; &#125;.start(); break; case R.id.btn_weather: new Thread() &#123; @Override public void run() &#123; getWeather();// getWeather1(); &#125; &#125;.start(); break; default: break; &#125; &#125; /** * 获取某个号码的归属地信息 */ private void getLand() &#123; mResult = \"\"; // 根据命名空间和方法得到SoapObject对象 SoapObject soapObject = new SoapObject(NAME_SPACE, ADDRESS_METHOD); soapObject.addProperty(\"mobileCode\", mEtParam.getText().toString()); soapObject.addProperty(\"userID\", USER_ID); // 通过SOAP1.1协议得到envelop对象 SoapSerializationEnvelope envelope = new SoapSerializationEnvelope(SoapEnvelope.VER11); // 将soapObject对象设置为envelop对象，传出消息 envelope.bodyOut = soapObject; // 设置是否调用的是dotNet开发的WebService // 指定webservice的类型的（java，PHP，dotNet） envelope.dotNet = true; // 等价于envelop.bodyOut = soapObject; envelope.setOutputSoapObject(soapObject); HttpTransportSE httpTransportSe = new HttpTransportSE(ADDRESS_URL); Log.i(TAG, \"号码服务设置完毕,准备开启服务\"); // 开始调用远程方法 try &#123; // 得到远程方法返回的SOAP对象 httpTransportSe.call(ADDRESS_SOAP_ACTION, envelope); Log.i(TAG, \"调用号码归属地查询WebService服务成功\"); &#125; catch (IOException e) &#123; e.printStackTrace(); Log.i(TAG, \"调用号码归属地查询WebService服务失败 = IOException\"); &#125; catch (XmlPullParserException e) &#123; e.printStackTrace(); Log.i(TAG, \"调用号码归属地查询WebService服务失败 = XmlPullParserException\"); &#125; // 获取返回的数据，并开始解析 SoapObject object = (SoapObject) envelope.bodyIn; mResult = object.getProperty(0).toString(); int count = object.getPropertyCount(); Log.i(TAG, \"count = \" + count); for (int i = 0; i &lt; count; i++) &#123; Log.i(TAG, i + \" === \" + object.getProperty(i).toString()); &#125; mHandler.sendEmptyMessage(0x002); Log.i(TAG, \"发送号码归属地数据完毕\"); &#125; /** * 获取某个城市的天气信息，使用封装的工具类 */ private void getWeather1() &#123;// SoapNetUtils.getInstance().doSoapRequest(); &#125; /** * 获取某个城市的天气信息 */ private void getWeather() &#123; mResult = \"\"; // 根据命名空间和方法得到SoapObject对象 SoapObject soapObject = new SoapObject(NAME_SPACE, WEATHER_METHOD); soapObject.addProperty(\"theCityCode\", mEtParam.getText().toString()); soapObject.addProperty(\"theUserID\", USER_ID); // 通过SOAP1.1协议得到envelop对象 SoapSerializationEnvelope envelope = new SoapSerializationEnvelope(SoapEnvelope.VER11); // 将soapObject对象设置为envelop对象，传出消息 envelope.bodyOut = soapObject; // 设置是否调用的是dotNet开发的WebService // 指定webservice的类型的（java，PHP，dotNet） envelope.dotNet = true; // 等价于envelop.bodyOut = soapObject; envelope.setOutputSoapObject(soapObject); HttpTransportSE httpTransportSe = new HttpTransportSE(WEATHER_URL); Log.i(TAG, \"天气服务设置完毕,准备开启服务\"); // 开始调用远程方法 try &#123; // 得到远程方法返回的SOAP对象 httpTransportSe.call(WEATHER_SOAP_ACTION, envelope); Log.i(TAG, \"调用天气查询WebService服务成功\"); &#125; catch (IOException e) &#123; e.printStackTrace(); Log.i(TAG, \"调用天气查询WebService服务失败 = IOException\"); &#125; catch (XmlPullParserException e) &#123; e.printStackTrace(); Log.i(TAG, \"调用天气查询WebService服务失败 = XmlPullParserException\"); &#125; // 获取返回的数据，并开始解析，以下都通过getClass()直到数据的类型，才去进行强制类型转换的 SoapObject object = (SoapObject) envelope.bodyIn; SoapPrimitive primitive; int count = object.getPropertyCount(); for (int i = 0; i &lt; count; i++) &#123; SoapObject object1 = (SoapObject) object.getProperty(i); for (int j = 0; j &lt; object1.getPropertyCount(); j++) &#123; primitive = (SoapPrimitive) object1.getProperty(j); Log.i(TAG, \"第\" + j + \"个数据为：\" + primitive.getName() + \" = \" + primitive.getValue()); &#125; &#125; primitive = (SoapPrimitive) ((SoapObject) object.getProperty(0)).getProperty(37); mResult = (String) primitive.getValue(); mHandler.sendEmptyMessage(0x001); Log.i(TAG, \"发送天气数据完毕\"); &#125;&#125; Demo地址：Allen_Demo_WebService","categories":[{"name":"Android","slug":"Android","permalink":"https://tylerLiu.top/categories/Android/"},{"name":"网络","slug":"Android/网络","permalink":"https://tylerLiu.top/categories/Android/网络/"}],"tags":[{"name":"WebService","slug":"WebService","permalink":"https://tylerLiu.top/tags/WebService/"}]}],"categories":[{"name":"Android","slug":"Android","permalink":"https://tylerLiu.top/categories/Android/"},{"name":"进阶","slug":"Android/进阶","permalink":"https://tylerLiu.top/categories/Android/进阶/"},{"name":"设计模式","slug":"设计模式","permalink":"https://tylerLiu.top/categories/设计模式/"},{"name":"大话设计模式","slug":"设计模式/大话设计模式","permalink":"https://tylerLiu.top/categories/设计模式/大话设计模式/"},{"name":"Kotlin","slug":"Android/Kotlin","permalink":"https://tylerLiu.top/categories/Android/Kotlin/"},{"name":"网络","slug":"Android/网络","permalink":"https://tylerLiu.top/categories/Android/网络/"},{"name":"蓝牙","slug":"Android/蓝牙","permalink":"https://tylerLiu.top/categories/Android/蓝牙/"},{"name":"计算机基础","slug":"计算机基础","permalink":"https://tylerLiu.top/categories/计算机基础/"},{"name":"计算机组成原理","slug":"计算机基础/计算机组成原理","permalink":"https://tylerLiu.top/categories/计算机基础/计算机组成原理/"},{"name":"Java","slug":"Java","permalink":"https://tylerLiu.top/categories/Java/"},{"name":"源码","slug":"Java/源码","permalink":"https://tylerLiu.top/categories/Java/源码/"},{"name":"View","slug":"Android/View","permalink":"https://tylerLiu.top/categories/Android/View/"},{"name":"Android进阶","slug":"Android进阶","permalink":"https://tylerLiu.top/categories/Android进阶/"},{"name":"框架层","slug":"Android进阶/框架层","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/"},{"name":"Binder原理","slug":"Android进阶/框架层/Binder原理","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/Binder原理/"},{"name":"解析WindowManagerService","slug":"Android进阶/框架层/解析WindowManagerService","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/解析WindowManagerService/"},{"name":"解析WindowManager","slug":"Android进阶/框架层/解析WindowManager","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/解析WindowManager/"},{"name":"Flutter","slug":"Flutter","permalink":"https://tylerLiu.top/categories/Flutter/"},{"name":"学习","slug":"Flutter/学习","permalink":"https://tylerLiu.top/categories/Flutter/学习/"},{"name":"深入理解ActivityManagerService","slug":"Android进阶/框架层/深入理解ActivityManagerService","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/深入理解ActivityManagerService/"},{"name":"深入理解JNI","slug":"Android进阶/框架层/深入理解JNI","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/深入理解JNI/"},{"name":"深入理解Context","slug":"Android进阶/框架层/深入理解Context","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/深入理解Context/"},{"name":"深入理解四大组件","slug":"Android进阶/框架层/深入理解四大组件","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/深入理解四大组件/"},{"name":"异常","slug":"Android/异常","permalink":"https://tylerLiu.top/categories/Android/异常/"},{"name":"应用进程启动流程","slug":"Android进阶/框架层/应用进程启动流程","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/应用进程启动流程/"},{"name":"AOSP","slug":"Android进阶/框架层/AOSP","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/AOSP/"},{"name":"系统启动","slug":"Android进阶/框架层/系统启动","permalink":"https://tylerLiu.top/categories/Android进阶/框架层/系统启动/"},{"name":"RxJava","slug":"Android/RxJava","permalink":"https://tylerLiu.top/categories/Android/RxJava/"},{"name":"美食","slug":"美食","permalink":"https://tylerLiu.top/categories/美食/"},{"name":"Jetpack","slug":"Android/Jetpack","permalink":"https://tylerLiu.top/categories/Android/Jetpack/"},{"name":"美文","slug":"美文","permalink":"https://tylerLiu.top/categories/美文/"},{"name":"热修复","slug":"Android/热修复","permalink":"https://tylerLiu.top/categories/Android/热修复/"},{"name":"其他","slug":"Android/其他","permalink":"https://tylerLiu.top/categories/Android/其他/"}],"tags":[{"name":"Android核心技术","slug":"Android核心技术","permalink":"https://tylerLiu.top/tags/Android核心技术/"},{"name":"JVM与DVM必知必会","slug":"JVM与DVM必知必会","permalink":"https://tylerLiu.top/tags/JVM与DVM必知必会/"},{"name":"设计模式","slug":"设计模式","permalink":"https://tylerLiu.top/tags/设计模式/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://tylerLiu.top/tags/Kotlin/"},{"name":"网络","slug":"网络","permalink":"https://tylerLiu.top/tags/网络/"},{"name":"蓝牙","slug":"蓝牙","permalink":"https://tylerLiu.top/tags/蓝牙/"},{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://tylerLiu.top/tags/计算机组成原理/"},{"name":"源码","slug":"源码","permalink":"https://tylerLiu.top/tags/源码/"},{"name":"RecyclerView","slug":"RecyclerView","permalink":"https://tylerLiu.top/tags/RecyclerView/"},{"name":"Binder","slug":"Binder","permalink":"https://tylerLiu.top/tags/Binder/"},{"name":"WindowManagerService","slug":"WindowManagerService","permalink":"https://tylerLiu.top/tags/WindowManagerService/"},{"name":"WindowManager","slug":"WindowManager","permalink":"https://tylerLiu.top/tags/WindowManager/"},{"name":"Flutter","slug":"Flutter","permalink":"https://tylerLiu.top/tags/Flutter/"},{"name":"ActivityManagerService","slug":"ActivityManagerService","permalink":"https://tylerLiu.top/tags/ActivityManagerService/"},{"name":"JNI","slug":"JNI","permalink":"https://tylerLiu.top/tags/JNI/"},{"name":"Context","slug":"Context","permalink":"https://tylerLiu.top/tags/Context/"},{"name":"四大组件","slug":"四大组件","permalink":"https://tylerLiu.top/tags/四大组件/"},{"name":"异常","slug":"异常","permalink":"https://tylerLiu.top/tags/异常/"},{"name":"Android系统启动","slug":"Android系统启动","permalink":"https://tylerLiu.top/tags/Android系统启动/"},{"name":"AOSP","slug":"AOSP","permalink":"https://tylerLiu.top/tags/AOSP/"},{"name":"RxJava","slug":"RxJava","permalink":"https://tylerLiu.top/tags/RxJava/"},{"name":"美食","slug":"美食","permalink":"https://tylerLiu.top/tags/美食/"},{"name":"Jetpack","slug":"Jetpack","permalink":"https://tylerLiu.top/tags/Jetpack/"},{"name":"美文","slug":"美文","permalink":"https://tylerLiu.top/tags/美文/"},{"name":"热修复","slug":"热修复","permalink":"https://tylerLiu.top/tags/热修复/"},{"name":"代码混淆","slug":"代码混淆","permalink":"https://tylerLiu.top/tags/代码混淆/"},{"name":"WebService","slug":"WebService","permalink":"https://tylerLiu.top/tags/WebService/"}]}