{"meta":{"title":"Tyler的博客","subtitle":null,"description":null,"author":"Tyler Liu","url":"http://tylerLiu.top","root":"/"},"pages":[{"title":"标签","date":"2019-07-31T03:22:41.000Z","updated":"2019-07-31T05:38:27.183Z","comments":false,"path":"tags/index.html","permalink":"http://tylerLiu.top/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-07-31T03:21:47.000Z","updated":"2019-07-31T05:39:03.830Z","comments":false,"path":"categories/index.html","permalink":"http://tylerLiu.top/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Android Jetpack-Navigation","slug":"Android-Jetpack-Navigation","date":"2019-07-29T08:10:39.000Z","updated":"2019-07-31T07:03:42.279Z","comments":true,"path":"2019/07/29/Android-Jetpack-Navigation/","link":"","permalink":"http://tylerLiu.top/2019/07/29/Android-Jetpack-Navigation/","excerpt":"","text":"前言Android Jetpack是谷歌在2018年的I/O大会上发布的，官网,主要包含一下模块，系列文章主要介绍架构部分的内容： 这里先学习Navigation。 官方Demo：android-architecture-components。 1. 简介1.1 定义Navigation是一个可简化Android导航和库的插件。更确切来说，Navigation是用来管理Fragment切换的，并且可以通过可视化的方式，看见App的交互流程。 1.2 优点 处理Fragment的切换 默认情况下正确处理Fragment的前进和后退 为过渡和动画提供标准化的资源 实现和处理深层连接 可以绑定Toolbar、BottomNavigationView和ActionBar等 SafeArgs（Gradle插件）数据传递时提供类型安全性 ViewModel的支持 2. 具体学习Navigation三个关键组成部分： Navigation Graph：导航图，一个XML资源，包含集中在一个位置的所有和导航相关的信息。包括应用程序中所有单独的内容区域（也成目的地），以及用户可以通过应用程序访问的可能路径。 NavHost：一个存储前面目的地的容器，Navigation组件包含了一个默认的实现了NavHostFragment的NavHost，用来显示Fragment的目的地。 NavController：导航控制者，在NavHost中，管理应用程序导航的对象。当用户在app中进行切换页面等操作时，NavController在NavHost中协调目标内容的切换。 2.1 步骤1：添加依赖在module的build.gradle中添加依赖： 1234567dependencies &#123; ...... implementation 'androidx.fragment:fragment-ktx:1.2.0-alpha01' implementation 'androidx.navigation:navigation-fragment-ktx:2.1.0-beta02' implementation 'androidx.navigation:navigation-ui-ktx:2.1.0-beta02'&#125; 要加上kotlin依赖，在项目的build.gradle： 1234567891011buildscript &#123; repositories &#123; google() jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:3.4.0' classpath 'org.jetbrains.kotlin:kotlin-gradle-plugin:1.3.31' &#125;&#125; 如果要使用SafeArgs插件，可以在项目的build.gradle中添加： 12345buildscript &#123; dependencies &#123; classpath 'androidx.navigation:navigation-safe-args-gradle-plugin:2.0.0' &#125;&#125; 以及module下的build.gradle中添加： 12apply plugin: 'kotlin-android-extensions'apply plugin: 'androidx.navigation.safeargs' 2.2 步骤2：创建Navigation导航 创建基础目录：资源文件res目录下创建navigation目录； 创建一个Destination，如果说navigation是导航工具，Destination就是目的地，在此之前已经写好了需要用到的Fragment——SplashFragment、LoginFragment和RegisterFragment，添加Desination，如下示图： 除了上面的可视化界面，也能通过代码进行编辑，login_navigation.xml： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;navigation xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/login_navigation\" app:startDestination=\"@id/splash\" tools:ignore=\"UnusedNavigation\"&gt; &lt;fragment android:id=\"@+id/login\" android:name=\"com.ly.allendemojetpack.ui.fragment.login.LoginFragment\" android:label=\"LoginFragment\" tools:layout=\"@layout/fragment_login\"/&gt; &lt;fragment android:id=\"@+id/splash\" android:name=\"com.ly.allendemojetpack.ui.fragment.login.SplashFragment\" android:label=\"LoginFragment\" tools:layout=\"@layout/fragment_splash\"&gt; &lt;action android:id=\"@+id/action_welcome_to_login\" app:destination=\"@id/login\"/&gt; &lt;action android:id=\"@+id/action_welcome_to_register\" app:enterAnim=\"@anim/common_fade_in\" app:exitAnim=\"@anim/common_slide_out_left\" app:popEnterAnim=\"@anim/common_slide_in_left\" app:popExitAnim=\"@anim/common_slide_out_right\" app:destination=\"@id/register\"/&gt; &lt;/fragment&gt; &lt;fragment android:id=\"@+id/register\" android:name=\"com.ly.allendemojetpack.ui.fragment.login.RegisterFragment\" android:label=\"LoginFragment\" tools:layout=\"@layout/fragment_register\"&gt; &lt;argument android:name=\"EMAIL\" android:defaultValue=\"2019\" app:argType=\"string\"/&gt; &lt;/fragment&gt;&lt;/navigation&gt; 这里看看navigation标签的属性，app:startDestination，即默认的起始位置。 2.3 步骤3：创建NavHostFragment这里创建一个新的LoginActivity作为NavHostFragment，在activity_login.xml中： 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".ui.activity.LoginActivity\"&gt; &lt;fragment android:id=\"@+id/my_nav_host_fragment\" android:name=\"androidx.navigation.fragment.NavHostFragment\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:navGraph=\"@navigation/login_navigation\" app:defaultNavHost=\"true\"/&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; android:name：值必须是androidx.navigation.fragment.NavHostFragment，声明这是一个NavHostFragemnt。 app:navGraph：存放导航的资源文件，确定Navgation Graph。 app:defaultNavHost：关联系统的返回按钮 。 2.4 步骤4：界面跳转、参数传递和动画在SplashFragment中，点击登录按钮和注册按钮可以分别跳转到LoginFragment和RegisterFragment。 有两种实现方式： 2.4.1 方式1：利用ID导航目标：SplashFragment携带key为name的数据跳转到LoginFragment，LoginFragment接收后显示。 登录按钮的点击事件如下： 123456789101112131415btnLogin.setOnClickListener &#123; // 设置动画参数 val navOption = navOptions &#123; anim &#123; enter = R.anim.common_slide_in_right exit = R.anim.common_slide_out_left popEnter = R.anim.common_slide_in_left popExit = R.anim.common_slide_out_right &#125; &#125; // 参数设置 val bundle = Bundle() bundle.putString(\"name\", \"TeaOf\") findNavController().navigate(R.id.login, bundle, navOption)&#125; 在LoginFragment中就可以通过Fragment的Bundle直接获取传来的参数。代码如下：LoginFragment.kt 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.ly.allendemojetpack.ui.fragment.loginimport android.content.Intentimport android.os.Bundleimport android.view.LayoutInflaterimport android.view.Viewimport android.view.ViewGroupimport android.widget.Buttonimport android.widget.EditTextimport android.widget.TextViewimport androidx.fragment.app.Fragmentimport com.ly.allendemojetpack.MainActivityimport com.ly.allendemojetpack.Rclass LoginFragment : Fragment() &#123; override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? &#123; return inflater.inflate(R.layout.fragment_login, container, false) &#125; lateinit var cancel: TextView lateinit var login: Button lateinit var account: EditText override fun onViewCreated(view: View, savedInstanceState: Bundle?) &#123; super.onViewCreated(view, savedInstanceState) cancel = view.findViewById(R.id.txt_cancel) login = view.findViewById(R.id.btn_login) account = view.findViewById(R.id.et_account) login.setOnClickListener &#123; val intent = Intent(context, MainActivity::class.java) context!!.startActivity(intent) &#125; cancel.setOnClickListener &#123; activity?.onBackPressed() &#125; val name = arguments?.getString(\"name\") account.setText(name) &#125;&#125; 效果图： 2.4.2 利用Safe Args目标：SplashFragment通过Safe Args将数据传到RegisterFragment，RegisterFragment接收后显示。 在前面的login_navigation.xml中可以看到里面还有action标签和argument标签。 action标签里面的属性 app:destination：跳转完成到达的fragment的id app:popUpTo：将fragment从栈中弹出，直到某个id的fragment argument标签里面的属性 android:name：标签名字 app:argType：标签的类型 android:defaultValue：默认值 点击Make Project按钮，Android Studio会自动生成两个类： SplashFragment的注册按钮点击事件： 123456btnRegister.setOnClickListener &#123; val action = SplashFragmentDirections .actionWelcomeToRegister() .setEMAIL(\"TeaOf1995@Gamil.com\") findNavController().navigate(action)&#125; RegisterFragment中的接收： 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.ly.allendemojetpack.ui.fragment.loginimport android.os.Bundleimport android.view.LayoutInflaterimport android.view.Viewimport android.view.ViewGroupimport android.widget.Buttonimport android.widget.EditTextimport android.widget.TextViewimport android.widget.Toastimport androidx.fragment.app.Fragmentimport androidx.navigation.fragment.navArgsimport com.ly.allendemojetpack.Rclass RegisterFragment : Fragment() &#123; override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? &#123; return inflater.inflate(R.layout.fragment_register, container, false) &#125; lateinit var cancel: TextView lateinit var register: Button lateinit var emailEt: EditText override fun onViewCreated(view: View, savedInstanceState: Bundle?) &#123; super.onViewCreated(view, savedInstanceState) cancel = view.findViewById(R.id.txt_cancel) register = view.findViewById(R.id.btn_register) emailEt = view.findViewById(R.id.et_email) register.setOnClickListener &#123; Toast.makeText(context, \"Register\", Toast.LENGTH_SHORT).show() &#125; cancel.setOnClickListener &#123; activity?.onBackPressed() &#125; val safeArgs: RegisterFragmentArgs by navArgs() val email = safeArgs.email emailEt.setText(email) &#125;&#125; 注意这里的navArgs()必须在JVM 1.8 以上，低于此版本会报错，Cannot inline bytecode built with JVM target 1.8 into bytecode that is being built with JVM target 1.6，在Android Studio中，Settings -&gt; Other Settings -&gt; Kotlin Compiler -&gt; Target JVM version，选择1.8及以上，同时在module的build.gradle添加以下： 1234567891011121314android &#123; ...... // 这里也要添加，否则报错 Error: Invoke-customs are only supported starting with Android O (--min-api compileOptions &#123; sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 &#125;&#125;tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).all &#123; kotlinOptions &#123; jvmTarget = \"1.8\" &#125;&#125; 效果图： 3. 其他Navigation还可以绑定其他，如menu、drawables和bottom navigation，这里以bototm navigation为例，先在navigation目录下创建main_navigation.xml，用之前的MainActivity，修改activity_main.xml如下： 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".MainActivity\"&gt; &lt;fragment android:id=\"@+id/my_nav_host_fragment\" android:name=\"androidx.navigation.fragment.NavHostFragment\" app:navGraph=\"@navigation/main_navigation\" app:defaultNavHost=\"true\" android:layout_width=\"match_parent\" android:layout_height=\"0dp\" android:layout_weight=\"1\"/&gt; &lt;com.google.android.material.bottomnavigation.BottomNavigationView android:id=\"@+id/navigation_view\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:background=\"@android:color/white\" app:itemIconTint=\"@color/colorAccent\" app:itemTextColor=\"@color/colorPrimary\" app:menu=\"@menu/menu_main\"/&gt;&lt;/LinearLayout&gt; MainActivity中的处理也很简单： 12345678910111213141516171819202122232425262728293031323334package com.ly.allendemojetpackimport android.os.Bundleimport androidx.appcompat.app.AppCompatActivityimport androidx.navigation.NavControllerimport androidx.navigation.fragment.NavHostFragmentimport androidx.navigation.ui.setupWithNavControllerimport com.google.android.material.bottomnavigation.BottomNavigationViewclass MainActivity : AppCompatActivity() &#123; lateinit var bottomNavigationView: BottomNavigationView override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) val host: NavHostFragment = supportFragmentManager.findFragmentById(R.id.my_nav_host_fragment) as NavHostFragment val navController = host.navController initWidget() initBottomNavigationView(bottomNavigationView, navController) &#125; private fun initBottomNavigationView(bottomNavigationView: BottomNavigationView, navController: NavController) &#123; bottomNavigationView.setupWithNavController(navController) &#125; private fun initWidget() &#123; bottomNavigationView = findViewById(R.id.navigation_view) &#125;&#125; 效果图： 4. 总结 定义：可简化Android导航的库和插件 功能： 处理Fragment的切换 实现和处理深层连接 绑定Toolbar、BottomNavigationView和DrawableLayout 支持ViewModel Safe Args 准备：Android Studio 3.2及以上 三要素 Navigation Graph 地图 关键标签： navigation fragment action：可以设置动画 argument NavHostFragment：容器 NavController：控制器 跳转 通过fragment id实现跳转 action实现跳转 传参 fragment自带的Bundle Safe Args：类型安全 绑定View：Toolbar、BottomNavigationView和DrawableLayout 深层连接（本文未涉及） Demo地址：Allen_Demo_WebService","categories":[{"name":"Android","slug":"Android","permalink":"http://tylerLiu.top/categories/Android/"},{"name":"Jetpack","slug":"Android/Jetpack","permalink":"http://tylerLiu.top/categories/Android/Jetpack/"}],"tags":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://tylerLiu.top/tags/Jetpack/"}]},{"title":"Android热修复 Tinker接入与源码浅析（有问题）","slug":"Android热修复-Tinker接入与源码浅析","date":"2019-07-29T02:26:54.000Z","updated":"2019-07-31T06:56:37.631Z","comments":true,"path":"2019/07/29/Android热修复-Tinker接入与源码浅析/","link":"","permalink":"http://tylerLiu.top/2019/07/29/Android热修复-Tinker接入与源码浅析/","excerpt":"","text":"1. 概述现在主流热修复：阿里的AndFix、腾讯的QZone的方案、美团的Robust和腾讯的Tinker。 其中AndFix接入是最简单的，不过兼容性还是问题；QZone对性能有一定影响，在在Art模式下出现内存错乱的问题；美团的Robust是基于Instant Run原理的，兼容性好；Tinker就是用在微信上面的热修复，性能和兼容性不用多说。 这里主要学习腾讯的Tinker和美团的Robust。 本文主要学习Tinker的接入以及对Tinker大致原理的分析。 2. Tinker的接入接入前提（开启混淆模式）： 对于API，一般来说，接入热修复，会在Application的onCreate()中进行一些初始化操，然后在某个地方去调用类似loadPatch这样的API去加载patch文件。 对于patch最简单的生成方式就是通过对比两个APK然后生成；注意，两个APK做对比，需要的前提是，第二次打包混淆使用的mapping.txt文件应该和线上的APK是一致的。 最后看看该项目有没有需要配置混淆的。 Tinker官方文档 2.1 步骤1：添加gradle插件依赖gradle远程仓库依赖jcenter： 123456789buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; // TinkerPatch 插件 classpath \"com.tinkerpatch.sdk:tinkerpatch-gradle-plugin:1.2.13.3\" &#125;&#125; 注意，在这里SDK使用了fat打包模式，不能再引用任何Tinker的相关 依赖，否则会造成版本冲突。 2.2 步骤2：集成TinkerPatch SDK添加TinkerPatch SDK库的依赖，可以参考Sample中的app/build.gradle： 12345678dependencies &#123; ...... //若使用annotation需要单独引用,对于tinker的其他库都无需再引用 // 可选，用于生成application类 compileOnly(\"com.tinkerpatch.tinker:tinker-android-anno:1.9.13.3\") &#123; changing = true &#125; annotationProcessor(\"com.tinkerpatch.tinker:tinker-android-anno:1.9.13.3\") &#123; changing = true &#125; implementation(\"com.tinkerpatch.sdk:tinkerpatch-android-sdk:1.2.13.3\") &#123; changing = true &#125;&#125; 若使用annotation自动生成Application，需要单独引入Tinker的tiner-android-anno库。除此之外，不需要单独引入tinker的其他库。 为了方便，已经将TinkerPatch相关的配置放到了tinkerpatch.gradle中，所以需要引用：（注释：这块内容还需要整理，有报错！！） 1apply from: 'tinkerpatch.gradle' 2.3 步骤3：配置tinkerpatchSupport参数：（可以不配置，使用默认的）打开前面的tinkerpatcch.gradle文件可以看到如下参数： 123456789101112131415161718192021222324252627tinkerpatchSupport &#123; /** 可以在debug的时候关闭 tinkerPatch **/ tinkerEnable = true /** 是否使用一键接入功能 **/ reflectApplication = true /** 是否开启加固模式，只有在使用加固时才能开启此开关 **/ protectedApp = false /** 补丁是否支持新增 Activity (新增Activity的exported属性必须为false)**/ supportComponent = false autoBackupApkPath = \"$&#123;bakPath&#125;\" /** 在tinkerpatch.com得到的appKey **/ appKey = \"yourAppKey\" /** 注意: 若发布新的全量包, appVersion一定要更新 **/ appVersion = \"1.0.0\" def pathPrefix = \"$&#123;bakPath&#125;/$&#123;baseInfo&#125;/$&#123;variantName&#125;/\" def name = \"$&#123;project.name&#125;-$&#123;variantName&#125;\" baseApkFile = \"$&#123;pathPrefix&#125;/$&#123;name&#125;.apk\" baseProguardMappingFile = \"$&#123;pathPrefix&#125;/$&#123;name&#125;-mapping.txt\" baseResourceRFile = \"$&#123;pathPrefix&#125;/$&#123;name&#125;-R.txt\"&#125; 具体含义如下： 参数 默认值 描述 tinkerEnable true 是否开启tinkerpatchSupport插件功能 appKey “” 在TinkerPatch平台申请的appKey appVersion “” 在TinkerPatch平台输入的版本号。注意：使用appVerison作为TinkerId，需要保证每个发布出去的基础安装包的appVersion都不一样。 reflectApplication false 是否反射Application autoBackupAppPath “” 将每次编译产生的apk/mapping.txt/R.txt归档存储的位置 baseApkFile “” 基准包的文件路径，对应tinker插件中的oldApk参数；编译补丁包时，必须指定基准版本的apk，默认值为空，表示不进行补丁包的编译 baseProguardMappingFile “” 基准包的Proguard mapping.txt文件路径，对应tinker插件appliMapping参数；在编译新的apk时，希望通过基准apk的proguard混淆方式，从而减小补丁包的大小。编译补丁包时，推荐输入基准apk生成的mapping.txt文件 baseResourceRFile “” 基准包的资源R.txt文件路径，对应tinker插件applyResourceMapping参数；在编译新的apk时，希望通过基准apk的R.txt文件来保存Resource Id的分配，这样不仅可以减少补丁包的大小，同时也能避免由于Resource Id改变导致remote view异常 protectedApp false 是否开启加固支持，注意：只有在使用加固支持时才能开启此开关 supportComponent false 是否开启支持在补丁包中动态增加Activity，注意：新增Activity的exported属性必须设置为false backupFileNameFormat ‘${appName}-${variantName}’ 格式化命名备份文件，这里要使用单引号 一般来说，不需要修改引用Android的编译配置，也不用修改tinker插件原来的配置。对于需要特殊配置，参考接入指南 2.4 初始化TinkerPatch SDK reflectApplication = true：这时，无需为Tinker而改造Application。12345678910111213141516171819202122public class SampleApplication extends Application &#123; ... @Override public void onCreate() &#123; super.onCreate(); // 我们可以从这里获得Tinker加载过程的信息 tinkerApplicationLike = TinkerPatchApplicationLike.getTinkerPatchApplicationLike(); // 初始化TinkerPatch SDK, 更多配置可参照API章节中的,初始化SDK TinkerPatch.init(tinkerApplicationLike) .reflectPatchLibrary() .setPatchRollbackOnScreenOff(true) .setPatchRestartOnSrceenOff(true) .setFetchPatchIntervalByHours(3); // 每隔3个小时(通过setFetchPatchIntervalByHours设置)去访问后台时候有更新,通过handler实现轮训的效果 TinkerPatch.with().fetchPatchUpdateAndPollWithInterval(); &#125; ... 将Tinker加载补丁过程的结果放在TinkerPatchApplicationLike中。 reflectApplication = false（一般使用）：API主要就是初始化和loadPatch()。 通常情况下，会考虑在Application的onCreate()中初始化，但Tinker推荐下面的写法： 123456789101112131415161718192021222324252627282930313233343536373839package com.ly.allendemotinker;import android.app.Application;import android.content.Context;import android.content.Intent;import com.tencent.tinker.anno.DefaultLifeCycle;import com.tencent.tinker.entry.DefaultApplicationLike;import com.tencent.tinker.lib.tinker.TinkerInstaller;import com.tencent.tinker.loader.shareutil.ShareConstants;/** * 初始化TinkerPatch SDK * * @author Liuyang * @date 2019/7/29 */@DefaultLifeCycle(application = \".SampleApplication\", flags = ShareConstants.TINKER_ENABLE_ALL, loadVerifyFlag = false)public class SampleApplicationLike extends DefaultApplicationLike &#123; public SampleApplicationLike(Application application, int tinkerFlags, boolean tinkerLoadVerifyFlag, long applicationStartElapsedTime, long applicationStartMillisTime, Intent tinkerResultIntent) &#123; super(application, tinkerFlags, tinkerLoadVerifyFlag, applicationStartElapsedTime, applicationStartMillisTime , tinkerResultIntent); &#125; @Override public void onBaseContextAttached(Context base) &#123; super.onBaseContextAttached(base); &#125; @Override public void onCreate() &#123; super.onCreate(); TinkerManager.installedTinker(this); &#125;&#125; Tinker建议编写一个ApplicationLike的子类，可以当成Application去使用，顶部的注解@DefaultLifeCycle，其中application属性，会在编译期生成一个SimpleTinkerInApplication类。 所以，实际上Application会在编译期生成，所以AndroidManifest.xml中是这样的： 123&lt;application android:name=\".SampleApplication\" .../&gt; 编译报红，build一下就可以。 实际上，注解的背后有一个Annotation Processor的处理，具体原理可以查看Android 如何编写基于编译时注解的项目。 2.5 创建一个ApplicationLike代理类：实现对Tinker的管理，TinkerManager： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.ly.allendemotinker;import android.content.Context;import com.tencent.tinker.lib.tinker.Tinker;import com.tencent.tinker.lib.tinker.TinkerInstaller;/** * Tinker管理类 * * @author Liuyang * @date 2019/7/29 */public class TinkerManager &#123; private static boolean mIsInstalled = false; private static ApplicationLike mApplicationLike; /** * 完成Tinker初始化 */ public static void installedTinker(ApplicationLike applicationLike) &#123; mApplicationLike = applicationLike; if (mIsInstalled) &#123; return; &#125; TinkerInstaller.install(mApplicationLike); mIsInstalled = true; &#125; /** * 完成patch文件的加载 * * @param path 补丁文件路径 */ public static void loadPatch(String path) &#123; // 是否已经安装过 if (Tinker.isTinkerInstalled()) &#123; TinkerInstaller.onReceiveUpgradePatch(getApplicationContext(), path); &#125; &#125; /** * 利用Tinker代理Application 获取应用全局的上下文 * * @return 全局的上下文 */ private static Context getApplicationContext() &#123; if (mApplicationLike != null) return mApplicationLike.getApplication().getApplicationContext(); return null; &#125;&#125; 2.6 AndroidManifest.xml配置123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" package=\"com.ly.allendemotinker\"&gt; &lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /&gt; &lt;uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" /&gt; &lt;application android:name=\".Application\" android:allowBackup=\"true\" android:icon=\"@mipmap/ic_launcher\" android:label=\"@string/app_name\" android:roundIcon=\"@mipmap/ic_launcher_round\" android:supportsRtl=\"true\" android:theme=\"@style/AppTheme\" tools:ignore=\"GoogleAppIndexingWarning\"&gt; &lt;activity android:name=\".MainActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;!-- 这个标签开判断我们生成的patch的.apk文件中的tinker_id_XXX 与我们的版本号tinker_id_XXX比较。相同合法，不同则不会进行更新 --&gt; &lt;meta-data android:name=\"TINKER_ID\" android:value=\"tinker_id_6235657\" /&gt; &lt;/application&gt;&lt;/manifest&gt; 在这里加上必要的权限，然后设置andorid:name = &quot;.Application&quot;，最后配置TINKER_ID属性，里面的数字部分一般是versionCode。 2.7 生成差异apk文件首先生成old.apk。布局文件：activity_main.xml： 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".MainActivity\"&gt; &lt;Button android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:onClick=\"loadPatch\" android:text=\"热修复\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 代码文件：MainActivity.java： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.ly.allendemotinker;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import java.io.File;/** * @author Liuyang * @date 2019/7/29 */public class MainActivity extends AppCompatActivity &#123; /** * 文件后缀 */ private static final String FILE_END = \".apk\"; /** * 文件路径 */ private String mFileDir; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // /storage/emulated/0/Android/data/com.ly.allendemotinker/cache/demo_patch/ mFileDir = getExternalCacheDir().getAbsolutePath() + \"/demo_patch/\"; // 创建路径对应的文件夹 File file = new File(mFileDir); if (!file.exists()) &#123; file.mkdir(); &#125; &#125; public void loadPatch(View view) &#123; TinkerManager.loadPatch(getPatchName()); &#125; public String getPatchName() &#123; return mFileDir.concat(\"tinker\").concat(FILE_END); &#125;&#125; 打包成old.apk，然后修改布局代码如下： 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".MainActivity\"&gt; &lt;Button android:id=\"@+id/button\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:onClick=\"loadPatch\" android:text=\"热修复\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" /&gt; &lt;Button android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"测试\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toBottomOf=\"@+id/button\" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 其他不用修改，打包成new.apk。 2.8 命令行生成补丁文件Tinker官方提供了命令行工具： 将前面生成的两个apk文件和签名文件复制到该目录下（.keystore是eclipse的签名文件，.jks是Andorid Studio的签名文件，可以直接修改后缀，不影响使用），然后输入下面的命令： 参考： https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650821993&amp;idx=1&amp;sn=550a90e30a398bbb652ecd65209b62e2&amp;chksm=80b781f7b7c008e17d9f5a59542f46329d28cbcd2ec075d4c2d44784f789135166a4e1949303&amp;scene=38#wechat_redirect https://www.jianshu.com/p/d649fc014919","categories":[{"name":"Android","slug":"Android","permalink":"http://tylerLiu.top/categories/Android/"},{"name":"热修复","slug":"Android/热修复","permalink":"http://tylerLiu.top/categories/Android/热修复/"}],"tags":[{"name":"热修复","slug":"热修复","permalink":"http://tylerLiu.top/tags/热修复/"}]},{"title":"Android代码混淆","slug":"Android代码混淆","date":"2019-07-27T06:32:49.000Z","updated":"2019-07-29T02:32:27.680Z","comments":true,"path":"2019/07/27/Android代码混淆/","link":"","permalink":"http://tylerLiu.top/2019/07/27/Android代码混淆/","excerpt":"","text":"在Android日常开发中，混淆是必不可少的。 1. 混淆简介 代码混淆：Obfuscated code，是将程序中的代码以某种规则转换为难以阅读和理解的代码的一种行为。 1.1 混淆的好处好处就是目的：令APK难以被逆向工程，即很大程度上增加反编译的成本。此外，Android中的“混淆”还能在打包时移除没用的资源，显著减小APK的体积。最后，还能以变通方式避免Anddroid中常见的64k方法数引用的限制。 先看看APK混淆前后的结构对比： 从上面两张图可以看出：经过混淆后，APK中的包名、类名、成员名等都被替换为随机、无意义的名称，增加了代码阅读和理解的难度，提高反编译的成本。混淆前后APK的大小也从2.7M下降到1.4M。 2. Android中的混淆在Android中，平时说的“混淆”其实包含两层意思，一是Java代码的混淆，二是资源的压缩。 2.1 开启混淆12345678910......android &#123; buildTypes &#123; release &#123; minifyEnabled true shrinkResources true proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125;&#125; 以上就是开启混淆的基本操作，通过minifyEnabled设置为true来开启混淆。同时，可以设置shrinkResources为true来开启资源的压缩。一般在打release包时才会开启混淆，因为混淆会增加额外的编译时间，所以不建议在debug下启用。此外，需要注意：只有在开启混淆的前提下开启资源压缩才有效果。以上代码中的proguard-android.txt表示Android系统提供的默认混淆规则文件，而proguard-rules.pro是我们自定义的混淆规则。下面讲解如何自定义混淆规则。 2.2 代码混淆Java平台提供了Proguard工具来帮助我们快速地对代码进行混淆。根据Java官方介绍，Proguard对应的具体中文定义如下： 它是一个包含代码文件压缩、优化、混淆和校验等功能的工具； 它能检测并删除无用的类、变量、方法和属性； 它能优化字节码并删除未使用的指令； 它能将类、变量和方法的名字重命名为无意义的名称从而达到混淆效果； 它会校验处理后的代码，只有针对Java 6及以上的版本和Java ME。 2.3 资源压缩在Android中，编译提供了另一个功能：资源压缩。资源压缩能帮助移除项目和仓库中未使用到的资源，有效降低APK的大小，。由于资源压缩与代码混淆是协同工作，所以，如果要开启资源压缩，一定要先开启代码混淆，否则会报错： 12ERROR: Removing unused resources requires unused code shrinking to be turned on. See http://d.android.com/r/tools/shrink-resources.html for more information.Affected Modules: app 2.4 自定义要保留的资源开启资源压缩后，系统默认会移除所有未使用的资源，如果要保留特定的资源，可以在项目中创建一个被&lt;resources&gt;标记的XML文件（如，res/raw/keep.xml），并在tools:keep属性中指定每个要保留的资源，在tools:discard属性中指定每个要舍弃的资源。这两个属性都接受逗号分隔的资源名称列表。同样，可以使用*作为通配符。如： 1234&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources xmlns:tools=\"http://schemas.android.com/tools\" tools:keep=\"@layout/activity_video*,@layout/dialog_update_v2\" tools:discard=\"@layout/unused_layout,@drawable/unused_selector\" /&gt; 2.5 启用严格检查模式通常， 资源压缩器可以准确判定系统是否使用了资源。但，如果代码（包含库）调用了Resources.getIdentifier()，这就表示代码将根据动态生成的字符串查询名称。这时，资源压缩器会采取防御性行为，将所有具有匹配名称格式的资源标记为可能已使用，无法移除。如，以下代码会使所有带img_前缀的资源标记为已使用： 12String name = String.format(\"img_%1d\", angle + 1);res = getResources().getIdentifier(name, \"drawable\", getPackageName()); 这时，可以启用严格检查模式，只会保留确定已经使用的资源。 2.6 移除备用资源Gradle资源压缩器只会移除未被应用引用的资源，意味着它不会移除用于不同设备配置的备用资源。必要时，可以使用Android Gradle插件的resCOnfigs属性来移除应用中不需要的备用资源文件（常见的有用于国际化支持的strings.xml，适配用的layout.xml等）。 1234567android &#123; defaultConfig &#123; ... //保留中文和英文国际化支持 resConfigs \"en\", \"zh\" &#125;&#125; 3. 自定义混淆规则先了解常用的混淆命令： 3.1 keep命令指一系列以-keep开头的命令，主要是用来保留Java中不需要进行混淆的元素。以下是常见的-keep命令： -keep：作用：保留指定的类和成员，防止被混淆处理。如： 12345# 保留包：com.moos.media.entity 下面的类以及类成员-keep public class com.moos.media.entity.**# 保留类：NumberProgressBar-keep public class com.moos.media.widget.NumberProgressBar &#123;*;&#125; -keepclassmembers：作用：保留指定的类的成员（变量/方法），它们将不会被混淆。如： 12345# 保留类的成员：MediaUtils类中的特定成员方法-keepclassmembers class com.moos.media.MediaUtils &#123; public static *** getLocalVideos(android.content.Context); public static *** getLocalPictures(android.content.Context);&#125; -keepclasseswithmembers：作用：保留指定的类及其成员（变量/方法），前提是它们在压缩阶段没有被删除。与-keep使用方式类似： 12345# 保留类：BaseMediaEntity 的子类-keepclasseswithmembers public class * extends com.moos.media.entity.BaseMediaEntity&#123;*;&#125;# 保留类：OnProgressBarListener接口的实现类-keep public class * implements com.moos.media.widget.OnProgressBarListener &#123;*;&#125; @keep：除了以上的方式，还可以使用@keep注解来保留代码，防止它们被混淆处理。比如，通过@keep来修饰一个类来保留它不被混淆： 123456@Keepdata class CloudMusicBean(var createDate: String, var id: Long, var name: String, var url: String, val imgUrl: String) 也可以修饰方法或字段进行保留。 3.2 其他命令 dontwarn-dontwarn命令一般在引入新的library时会用到，常用于处理library中无法解决的警告。如： 123-keep class twitter4j.** &#123; *; &#125;-dontwarn twitter4j.** 其他命令用法可以参考Android系统提供的默认混淆规则： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#混淆时不生成大小写混合的类名-dontusemixedcaseclassnames#不跳过非公共的库的类-dontskipnonpubliclibraryclasses#混淆过程中记录日志-verbose#关闭预校验-dontpreverify#关闭优化-dontoptimize#保留注解-keepattributes *Annotation*#保留所有拥有本地方法的类名及本地方法名-keepclasseswithmembernames class * &#123; native &lt;methods&gt;;&#125;#保留自定义View的get和set方法-keepclassmembers public class * extends android.view.View &#123; void set*(***); *** get*();&#125;#保留Activity中View及其子类入参的方法，如: onClick(android.view.View)-keepclassmembers class * extends android.app.Activity &#123; public void *(android.view.View);&#125;#保留枚举-keepclassmembers enum * &#123; **[] $VALUES; public *;&#125;#保留序列化的类-keepclassmembers class * implements android.os.Parcelable &#123; public static final android.os.Parcelable$Creator CREATOR;&#125;#保留R文件的静态成员-keepclassmembers class **.R$* &#123; public static &lt;fields&gt;;&#125;-dontwarn android.support.**-keep class android.support.annotation.Keep-keep @android.support.annotation.Keep class * &#123;*;&#125;-keepclasseswithmembers class * &#123; @android.support.annotation.Keep &lt;methods&gt;;&#125;-keepclasseswithmembers class * &#123; @android.support.annotation.Keep &lt;fields&gt;;&#125;-keepclasseswithmembers class * &#123; @android.support.annotation.Keep &lt;init&gt;(...);&#125; 更多混淆命令可以参考文章：ProGuard 最全混淆规则说明 4. 不能混淆的部分哪些内容应该混淆？其实，在使用代码混淆时，ProGuard对项目大部分代码进行了混淆操作，为防止编译出错，应该通过-keep命令保留一些元素不被混淆。所以需要知道哪些元素不应该被混淆： 4.1 枚举枚举不能参与到混淆中，原因是：枚举内部存在values方法，混淆后该方法会被重新命名，并抛出NoSuchMethodException。Android系统默认的混淆规则中已经添加了对枚举类的处理，无需额外进行处理。 4.2 被反射的元素被反射使用的类、方法、变量、包名等不能被混淆，原因是：代码混淆过程中，被反射的元素会被重命名，而反射依旧按照先前的名称去查找元素，会发生NoSuchMethodException和NoSuchFieldException。 4.3 实体类实体类通常会伴随着序列化和反序列化操作。混合是将原本有特定含义的“元素”转成无意义的名称，所以，经过混淆之后，序列化之后的value对应的key已经变成没有意义的字段。同时，反序列化的过程创建对象从根本上还是借助反射，混淆后key会被改变，所以实体类通常也不能混淆。 4.4 四大组件Android中的四大组件也不能被混淆，原因是： 四大组件使用前都需要在AndroidManifest.xml文件中进行注册声明，然而混淆处理后，四大组件的类名就会被更改，实际使用的类与AndroidMainifest.xml中注册的类不匹配，会报错。 其他应用程序访问组件时，可能会用到类的包名和类名，经过混淆，可能会找不到对应的组件而产生异常。 4.5 JNI调用的Java方法当JNI调用的Java方法被混淆后，方法名会变成无意义的名称，这就与C++中原本的Java方法名不匹配，因而无法找到所调用的方法。 4.6 其他不应被混淆的 自定义控件不能被混淆 JavaScript调用Java的方法不应被混淆 Java的native方法不应被混淆 项目中引用的第三方库不建议混淆 5. 混淆后的堆栈跟踪代码经过ProGuard混淆处理后，想要读取StackTrace（堆栈追踪）信息就会变得困难。由于方法名和类名都经过混淆处理，即使程序崩溃，也很难定位问题。但是，ProGuard提供了补救的措施，先来看看ProGuard每次构建后生成哪些内容。 5.1 混淆输出结果混淆构建完成之后，会在&lt;module-name&gt;/build/outputs/mapping/release/目录下生成以下文件： dump.txt：说明APK内所有类文件的内部结构。 mapping.txt：提供混淆前后的内容对照表，内容主要包括类、方法和类的成员变量。 seeds.txt：罗列出未进行混淆处理的类和成员。 usage.txt：罗列出从APK移除的代码。 5.2 恢复堆栈跟踪前面的遗留问题：混淆处理后，StackTrace定位困难。如何恢复StackTrace的定位能力？系统提供了retrace工具，结合上面定义的mapping.txt文件，就可以将混淆后的崩溃堆栈追踪器信息还原成正常情况下的StackTrace信息。主要有两种方式来恢复SrackTrace，为了方便理解，以下面的崩溃信息为例，协助两种方式分别进行还原： 123456java.lang.RuntimeException: Unable to start activity Caused by: kotlin.KotlinNullPointerException at com.moos.media.ui.ImageSelectActivity.k(ImageSelectActivity.kt:71) at com.moos.media.ui.ImageSelectActivity.onCreate(ImageSelectActivity.kt:58) at android.app.Activity.performCreate(Activity.java:6237) at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1107) 通过retrace脚本工具首先进入Android SDK路径的tools/proguard/bin中： 可以看到里面有三个文件，而proguardgui.bat就是需要的retrace脚本。双加该脚本文件，运行，即可看到： 选择Retrace栏，添加项目中混淆生成的mapping.txt文件所在位置，然后将混淆后的崩溃信息复制到Obfuscated stack trace一栏，点击Retrace，即可还原出崩溃日志信息。 通过retrace命令行首先将崩溃信息复制到.txt文件中，然后执行下面命令：1retrace.bat -verbose mapping.txt proguard_stacktrace.txt 最终还原结果和之前效果相同： 在对stackTrace进行恢复时，发现unknown Source问题： 在混淆规则上添加如下配置来提升StackSource查找效率， 12# 保留源文件名和具体代码行号-keepattributes SourceFile,LineNumberTable 此外，每次使用ProGuard创建发布构建时都会覆盖之前版本的mapping.txt文件，因此，每次发布一个新版本时，建议保存一个副本。通过为每个发布构建保留一个mapping.txt文件副本，就可以在用户提交的已混淆的StackTrace来对旧版本应用的问题进行调试和修复。 6. 其他操作前面介绍到，APK在经过代码混淆处理后，包名、类名、成员名被转化为无意义、难以理解的名称，增加反编译的成本。Android ProGuard提供了默认的“混淆字典”，即将元素名称转为英文小写字母的形式。那么，可以定义自己的混淆字典吗？先看一张效果图： 只要生成一套自己的.txt格式的混淆字典，然后在混淆规则Proguard-rules.pro中应用下即可：","categories":[{"name":"Android","slug":"Android","permalink":"http://tylerLiu.top/categories/Android/"},{"name":"其他","slug":"Android/其他","permalink":"http://tylerLiu.top/categories/Android/其他/"}],"tags":[{"name":"代码混淆","slug":"代码混淆","permalink":"http://tylerLiu.top/tags/代码混淆/"}]},{"title":"Android实现RecyclerView自动滚动","slug":"Android实现RecyclerView自动滚动","date":"2019-07-27T05:03:29.000Z","updated":"2019-07-29T02:33:06.007Z","comments":true,"path":"2019/07/27/Android实现RecyclerView自动滚动/","link":"","permalink":"http://tylerLiu.top/2019/07/27/Android实现RecyclerView自动滚动/","excerpt":"","text":"实现功能：使用RecyclerView实现垂直滚动效果。 1. 自定义RecyclerView实现滚动效果12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package com.ly.allendemoautopollrecyclerview;import android.annotation.SuppressLint;import android.content.Context;import android.support.annotation.NonNull;import android.support.annotation.Nullable;import android.support.v7.widget.RecyclerView;import android.util.AttributeSet;import android.view.MotionEvent;import java.lang.ref.WeakReference;/** * 自定义垂直滚动RecyclerView * * @author Liuyang * @date 2019/7/27 */public class AutoPollRecyclerView extends RecyclerView &#123; private static final long TIME_AUTO_POLL = 16; private AutoPollTask mAutoPollTask; /** * 标示是否正在自动轮询 */ private boolean mRunning; /** * 标示是否可以自动轮询，可在不需要的是否置false */ private boolean mCanRun; public AutoPollRecyclerView(@NonNull Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); mAutoPollTask = new AutoPollTask(this); &#125; static class AutoPollTask implements Runnable &#123; private final WeakReference&lt;AutoPollRecyclerView&gt; mReference; /** * 使用弱引用持有外部引用，放置内存泄露 */ AutoPollTask(AutoPollRecyclerView reference) &#123; mReference = new WeakReference&lt;&gt;(reference); &#125; @Override public void run() &#123; AutoPollRecyclerView recyclerView = mReference.get(); if (recyclerView != null &amp;&amp; recyclerView.mRunning &amp;&amp; recyclerView.mCanRun) &#123; recyclerView.scrollBy(2, 2); recyclerView.postDelayed(recyclerView.mAutoPollTask, TIME_AUTO_POLL); &#125; &#125; &#125; /** * 开启：如果正在运行，则先停止，再开始 */ public void start() &#123; if (mRunning) &#123; stop(); &#125; mCanRun = true; mRunning = true; postDelayed(mAutoPollTask, TIME_AUTO_POLL); &#125; /** * 停止 */ public void stop() &#123; mRunning = false; removeCallbacks(mAutoPollTask); &#125; @SuppressLint(\"ClickableViewAccessibility\") @Override public boolean onTouchEvent(MotionEvent e) &#123; switch (e.getAction()) &#123; case MotionEvent.ACTION_DOWN: if (mRunning) &#123; stop(); &#125; break; case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: case MotionEvent.ACTION_OUTSIDE: if (mCanRun) &#123; start(); &#125; break; default: break; &#125; return super.onTouchEvent(e); &#125;&#125; 2. 实现Adapter1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.ly.allendemoautopollrecyclerview;import android.annotation.SuppressLint;import android.content.Context;import android.support.annotation.NonNull;import android.support.v7.widget.RecyclerView;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.TextView;import java.util.List;public class AutoPollAdapter extends RecyclerView.Adapter&lt;AutoPollAdapter.BaseViewHolder&gt; &#123; private final Context mContext; private final List&lt;AutoScrollLuckyListReq.DatasBean&gt; mData; public AutoPollAdapter(Context context, List&lt;AutoScrollLuckyListReq.DatasBean&gt; data) &#123; mContext = context; mData = data; &#125; @NonNull @Override public BaseViewHolder onCreateViewHolder(@NonNull ViewGroup viewGroup, int i) &#123; View view = LayoutInflater.from(mContext).inflate(R.layout.auto_list_item, viewGroup, false); return new BaseViewHolder(view); &#125; @SuppressLint(\"SetTextI18n\") @Override public void onBindViewHolder(@NonNull BaseViewHolder baseViewHolder, int position) &#123; AutoScrollLuckyListReq.DatasBean datasBean = mData.get(position % mData.size()); baseViewHolder.content.setText(datasBean.getPhone() + \" 获得 \" + datasBean.getGiftName()); &#125; @Override public int getItemCount() &#123; return Integer.MAX_VALUE; &#125; class BaseViewHolder extends RecyclerView.ViewHolder &#123; TextView content; BaseViewHolder(View itemView) &#123; super(itemView); content = itemView.findViewById(R.id.content); &#125; &#125;&#125; 3. 适配器布局文件12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:background=\"#fffcf5\" android:orientation=\"vertical\"&gt; &lt;TextView android:id=\"@+id/content\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"8dp\" android:layout_marginBottom=\"8dp\" android:text=\"135xxxx8888 获得 8积分\" android:textColor=\"#797762\" android:textSize=\"14sp\" /&gt; &lt;View android:layout_width=\"match_parent\" android:layout_height=\"1dp\" android:background=\"#797762\" /&gt;&lt;/LinearLayout&gt; 4. 调用布局文件：activity_main.xml： 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".MainActivity\"&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"150dp\" android:layout_centerInParent=\"true\" android:layout_marginLeft=\"15dp\" android:layout_marginTop=\"15dp\" android:layout_marginRight=\"15dp\" android:background=\"@drawable/luckyer_bg\"&gt; &lt;RelativeLayout android:layout_width=\"40dp\" android:layout_height=\"wrap_content\" android:layout_marginStart=\"23dp\" android:layout_marginTop=\"1dp\" android:layout_marginBottom=\"1dp\" android:background=\"#fff6ea\"&gt; &lt;ImageView android:layout_width=\"wrap_content\" android:layout_height=\"match_parent\" android:layout_centerInParent=\"true\" android:padding=\"10dp\" android:src=\"@drawable/zhongjiangzhemingdan\" /&gt; &lt;/RelativeLayout&gt; &lt;com.ly.allendemoautopollrecyclerview.AutoPollRecyclerView android:id=\"@+id/recyclerview\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_margin=\"20dp\" /&gt; &lt;/LinearLayout&gt;&lt;/RelativeLayout&gt; Java文件：MainActivity.java： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129package com.ly.allendemoautopollrecyclerview;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.support.v7.widget.LinearLayoutManager;import com.alibaba.fastjson.JSON;/** * @author Liuyang * @date 2019/7/27 */public class MainActivity extends AppCompatActivity &#123; private AutoPollRecyclerView mRecyclerView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); initData(); &#125; private void initView() &#123; mRecyclerView = findViewById(R.id.recyclerview); mRecyclerView.setLayoutManager(new LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false)); &#125; private void initData() &#123; String response = \"&#123;\\n\" + \" \\\"datas\\\": [\\n\" + \" &#123;\\n\" + \" \\\"giftName\\\": \\\"20个积分\\\",\\n\" + \" \\\"phone\\\": \\\"****\\\"\\n\" + \" &#125;,\\n\" + \" &#123;\\n\" + \" \\\"giftName\\\": \\\"20个积分\\\",\\n\" + \" \\\"phone\\\": \\\"****\\\"\\n\" + \" &#125;,\\n\" + \" &#123;\\n\" + \" \\\"giftName\\\": \\\"满10减1元\\\",\\n\" + \" \\\"phone\\\": \\\"****\\\"\\n\" + \" &#125;,\\n\" + \" &#123;\\n\" + \" \\\"giftName\\\": \\\"20个积分\\\",\\n\" + \" \\\"phone\\\": \\\"****\\\"\\n\" + \" &#125;,\\n\" + \" &#123;\\n\" + \" \\\"giftName\\\": \\\"20个积分\\\",\\n\" + \" \\\"phone\\\": \\\"****\\\"\\n\" + \" &#125;,\\n\" + \" &#123;\\n\" + \" \\\"giftName\\\": \\\"满10减1元\\\",\\n\" + \" \\\"phone\\\": \\\"****\\\"\\n\" + \" &#125;,\\n\" + \" &#123;\\n\" + \" \\\"giftName\\\": \\\"20个积分\\\",\\n\" + \" \\\"phone\\\": \\\"****\\\"\\n\" + \" &#125;,\\n\" + \" &#123;\\n\" + \" \\\"giftName\\\": \\\"满10减1元\\\",\\n\" + \" \\\"phone\\\": \\\"****\\\"\\n\" + \" &#125;,\\n\" + \" &#123;\\n\" + \" \\\"giftName\\\": \\\"满10减1元\\\",\\n\" + \" \\\"phone\\\": \\\"****\\\"\\n\" + \" &#125;,\\n\" + \" &#123;\\n\" + \" \\\"giftName\\\": \\\"三花便签（20枚）\\\",\\n\" + \" \\\"phone\\\": \\\"****\\\"\\n\" + \" &#125;,\\n\" + \" &#123;\\n\" + \" \\\"giftName\\\": \\\"三花便签（20枚）\\\",\\n\" + \" \\\"phone\\\": \\\"****\\\"\\n\" + \" &#125;,\\n\" + \" &#123;\\n\" + \" \\\"giftName\\\": \\\"满10减1元\\\",\\n\" + \" \\\"phone\\\": \\\"****\\\"\\n\" + \" &#125;,\\n\" + \" &#123;\\n\" + \" \\\"giftName\\\": \\\"20个积分\\\",\\n\" + \" \\\"phone\\\": \\\"****\\\"\\n\" + \" &#125;,\\n\" + \" &#123;\\n\" + \" \\\"giftName\\\": \\\"满10减1元\\\",\\n\" + \" \\\"phone\\\": \\\"****\\\"\\n\" + \" &#125;,\\n\" + \" &#123;\\n\" + \" \\\"giftName\\\": \\\"20个积分\\\",\\n\" + \" \\\"phone\\\": \\\"****\\\"\\n\" + \" &#125;,\\n\" + \" &#123;\\n\" + \" \\\"giftName\\\": \\\"三花便签（20枚）\\\",\\n\" + \" \\\"phone\\\": \\\"****\\\"\\n\" + \" &#125;,\\n\" + \" &#123;\\n\" + \" \\\"giftName\\\": \\\"三花便签（20枚）\\\",\\n\" + \" \\\"phone\\\": \\\"****\\\"\\n\" + \" &#125;,\\n\" + \" &#123;\\n\" + \" \\\"giftName\\\": \\\"满10减1元\\\",\\n\" + \" \\\"phone\\\": \\\"****\\\"\\n\" + \" &#125;,\\n\" + \" &#123;\\n\" + \" \\\"giftName\\\": \\\"20个积分\\\",\\n\" + \" \\\"phone\\\": \\\"****\\\"\\n\" + \" &#125;,\\n\" + \" &#123;\\n\" + \" \\\"giftName\\\": \\\"20个积分\\\",\\n\" + \" \\\"phone\\\": \\\"****\\\"\\n\" + \" &#125;\\n\" + \" ],\\n\" + \" \\\"msg\\\": \\\"success\\\",\\n\" + \" \\\"ret\\\": 0\\n\" + \"&#125;\"; AutoScrollLuckyListReq autoScrollLuckyListReq = JSON.parseObject(response, AutoScrollLuckyListReq.class); // 0为请求成功 if (autoScrollLuckyListReq.getRet() == 0) &#123; AutoPollAdapter autoPollAdapter = new AutoPollAdapter(getApplicationContext(), autoScrollLuckyListReq.getDatas()); mRecyclerView.setAdapter(autoPollAdapter); // 启动滚动 mRecyclerView.start(); &#125; &#125;&#125; 5. 效果和Demo地址 Demo地址：Allen_Demo_AutoPollRecyclerView","categories":[{"name":"Android","slug":"Android","permalink":"http://tylerLiu.top/categories/Android/"},{"name":"View","slug":"Android/View","permalink":"http://tylerLiu.top/categories/Android/View/"}],"tags":[{"name":"View","slug":"View","permalink":"http://tylerLiu.top/tags/View/"}]},{"title":"蘸水牛肉","slug":"蘸水牛肉","date":"2019-07-27T03:25:47.000Z","updated":"2019-07-31T07:28:39.299Z","comments":true,"path":"2019/07/27/蘸水牛肉/","link":"","permalink":"http://tylerLiu.top/2019/07/27/蘸水牛肉/","excerpt":"","text":"【食材】：牛腱子两斤，老姜一大块，花椒四五十粒， 食盐适量，大蒜泥适量、调味盐、味精适量，红油辣子一大勺，花椒面适量，藤椒油适量，芝麻油适量，香葱花适量。 流程： 牛腱子用洗水浸泡两三个小时，尽量泡出肉的的血水，因为肉中血水多，肉的腥味就比较重，不好吃； 浸泡好的牛肉入冷水锅，中火煮开后，再煮两分钟； 经过稍稍煮过的牛肉会紧缩一团，我们从锅中取出肉，再用温水冲洗干净牛肉表面的血污，再控干水分，以上几个步骤的目的都是尽量去除肉中的血污，让肉的味道更鲜美，而没有腥味； 砂锅中放入前面处理好的牛肉，再加入纯净水或矿泉水，再加入一块用刀拍破的老姜和花椒粒，以及适量的食盐，开 大火烧开后，转小火盖上锅盖煮，大约一个小时左右； 煮一个小时左右，我们用一根筷子插肉，如果可以轻松插入牛肉肉中就差不多了； 我们再把牛肉从锅中取出，彻底晾凉后再切成薄片备用； 取一个碗，碗中加入大蒜泥，红油辣子（最好是近期制作的在，时间长了不香），适量的花面和藤椒油卡 ，还要加上适量的调味盐（虽然前面煮肉时加过盐，但比较淡，这里还是需要加少量的调味盐），最后我们还要加入，适量的味精、芝麻油、香葱花，再搅拌匀就可以蘸牛肉了。","categories":[{"name":"美食","slug":"美食","permalink":"http://tylerLiu.top/categories/美食/"}],"tags":[{"name":"美食","slug":"美食","permalink":"http://tylerLiu.top/tags/美食/"}]},{"title":"豆角焖面","slug":"豆角焖面","date":"2019-07-27T03:19:40.000Z","updated":"2019-07-27T03:22:40.402Z","comments":true,"path":"2019/07/27/豆角焖面/","link":"","permalink":"http://tylerLiu.top/2019/07/27/豆角焖面/","excerpt":"","text":"主料：圆滚豆角一小把切成丁，五花肉适量切成末，细刀切面适量 配料：泡发好的香菇4、5朵切丁，胡萝卜一小段切丁，葱末、姜米、蒜米，香菜碎，八角一朵，干红辣椒4、5只 酱汁：另准备4、5瓣大蒜切米放入碗中，加适量青葱碎，里面放入两匙酱油，一匙陈醋，1\\3匙白糖 调成酱汁备用 流程： 热锅凉油，油温7、8层热时放入八角爆香，下肉末煸炒，肉末变色断生后放入干红辣椒翻炒几下，依次加入姜末、葱末、蒜末，翻炒出香味后加入适量酱油和少许盐，加稍多些水，烧开后慢火炖煮10分钟； 冲调酱汁：10分钟后将锅里面的汤一勺一勺舀出，冲倒在酱汁碗中； 锅内留少许汤汁，以不没过豆角为限，将刀切面疏散的铺在豆角上面，尽量不要贴在锅壁上，防粘和糊； 将冲调好的酱汁分三次均匀淋在面条上，每次间隔3分钟； 9分钟后关火，在面条上淋少许香油，撒上香菜碎，用筷子轻轻将面条拨散拌匀，装盘上桌。 搭配上橄榄油沙拉和花生米，营养很均衡。","categories":[{"name":"美食","slug":"美食","permalink":"http://tylerLiu.top/categories/美食/"}],"tags":[{"name":"美食","slug":"美食","permalink":"http://tylerLiu.top/tags/美食/"}]},{"title":"二、Android XML数据解析","slug":"二、Android-XML数据解析","date":"2019-07-26T08:27:11.000Z","updated":"2019-07-29T02:32:02.644Z","comments":true,"path":"2019/07/26/二、Android-XML数据解析/","link":"","permalink":"http://tylerLiu.top/2019/07/26/二、Android-XML数据解析/","excerpt":"","text":"1. XML数据要点介绍XML，可扩展标记语言。可以用来存储数据，可以看做是一个小型的数据库，SharedPreference就是使用XML文件存储数据的，SQLite底层也是一个XML文件，而在网络应用方面，通常作为信息的载体，通常把数据包装成XML来传递。 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; -----文档开始&lt;persons&gt; -----开始元素(persons) &lt;person id = \"11\"&gt; -----文本节点（空白文本） 开始元素(person)属性 &lt;name&gt;Coder-pig&lt;/name&gt; -----文本节点（空白文本） 开始元素(name)属性 结束元素 &lt;age&gt;18&lt;/age&gt; -----文本节点（空白文本） 开始元素(age)属性 结束元素 &lt;/person&gt; -----文本节点（空白文本） 结束元素 &lt;person id = \"13\"&gt; &lt;name&gt;Jay&lt;/name&gt; &lt;age&gt;20&lt;/age&gt; &lt;/person&gt;&lt;/persons&gt; -----结束元素(persons) -----文档结束 上面就简单的定义了一个存储person对象的xml文件的编码，注意，外面的空白区域也是文本节点。 2. 三种解析XML方法的比较2.1 SAX解析XML对文档进行顺序扫描，当扫描到文档(doucument)开始与结束、元素(element)开始与结束等地方时，通知事件处理函数，由事件处理函数做相对应动作，然后继续进行同样的扫描，直至文档结束。解释速度快，占用内存小，，每需要解析一类XML，就需要编写新的适合该类的XML处理类，比较麻烦。采用的是流式解析，解析是同步的，读到哪就处理到哪。 2.2 Dom解析XML先把XML文档读取到内存中，然后再用DOM API来访问树形结构，并获取数据。这个写起来很简单，但是很消耗内存，假如读取的数据量大，手机内存不够的话，可能导致手机死机。不建议在Android设备中使用，解析简单的XML可以。常用的五个接口与类：Docculem、Element、Node、NodeList、DOMParser，Don是整个文件解析到内存中，供用户需要的节点信息，支持随机访问。 2.3 pull解析XMLXML pull提供了开始元素和结束元素。当某个元素开始时，可以调用parser、nextText从XML文档中提取所有字符数据。当解析到文档结束时，自动生成EndDocument。常用接口和类：XmlPullParser、XmlSerializer、XmlPullParserFactory。和SAX差不多，代码实现比较简单，非常适合移动设备，Android系统内置pull解析器，而且Android系统内部默认使用pull来解析XML文件。 3. SAX解析XMLSAX是一个解析速度快且占用内存少的XML解析器，非常适合用于Android等移动设备；SAX解析XML文件采用的是事件驱动，也就是说不需要解析整个文档，而是在解析过程中，判断读取的字符是否符合XML语法的某部分（文档开头，文档结束，或者标签开头和标签结束），符合的话就会触发事件（回调方法），而这些方法都定义在ContentHandler接口中，而ContentHandler是一个接口， 使用起来不方便，所以Android准备了一个帮助类DefaultHandler，只需要继承这个类，重写里面对应的方法即可。 可以重写的方法： startDocument()：当读取到文文档开始标志时触发，通常在这里完成一些初始化操作。 endDocument()：文档结束部分，在这里完成一些善后工作。 startElement(names, paceURI, localName, qName, atts)：参数依次问命名空间，不带命名空间的前缀标签名，带命名空间的前缀标签名，通过atts可以得到所有的属性名和相应的值；SAX中一个重要的特点就是它的流式处理，当遇到一个标签时，它并不会记录下以前遇到的标签，就是说，在startElement()中，所有知道的信息就是标签的名字和属性，至于标签的嵌套结构，上层标签的名字，是否有子元素等其他与结构相关的信息，都不知道，需要程序来完成，这使得SAX在编程处理上没有DOM方便。 endElement(uri, localName, name)：在遇到结束标签的时候，调用该方法。 characters(ch, start, length)：这个方法用来处理在XML文件中读到的内容，第一个参数用于存放文件的内容，后面两个参数是读到的字符串在这个数组中的起始位置和长度，使用new String(ch, start, length)就可以获取内容。 核心代码：SAX解析类——SaxHelper.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package com.ly.allendemowebservice;import android.util.Log;import org.xml.sax.Attributes;import org.xml.sax.SAXException;import org.xml.sax.helpers.DefaultHandler;import java.util.ArrayList;/** * SAX解析XML * * @author Liuyang * @date 2019/7/26 */public class SaxHelper extends DefaultHandler &#123; private static final String TAG = \"SaxHelper\"; private Person mPerson; private ArrayList&lt;Person&gt; mPersons; /** * 当前解析的元素标签 */ private String mTagName = null; /** * 当读取到文档开始标志时触发，通常在里面完成一些初始化操作 */ @Override public void startDocument() throws SAXException &#123; this.mPersons = new ArrayList&lt;&gt;(); Log.i(TAG, \"读取到文档头,开始解析xml\"); &#125; private static final String ELEMENT = \"person\"; /** * 读到一个开始标签时触发，第二个参数为标签名，最后一个参数为属性数组 */ @Override public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException &#123; if (ELEMENT.equals(localName)) &#123; mPerson = new Person(); mPerson.setId(Integer.parseInt(attributes.getValue(\"id\"))); Log.i(TAG, \"开始处理person元素~\"); &#125; mTagName = localName; &#125; private static final String TAG_NAME1 = \"name\"; private static final String TAG_NAME2 = \"age\"; /** * 读取标签里面的内容，第一个参数为字符串内容，后面依次为起始位置和长度 */ @Override public void characters(char[] ch, int start, int length) throws SAXException &#123; // 判断当前标签是否有效 if (mTagName != null) &#123; String data = new String(ch, start, length); // 读取标签内容 if (TAG_NAME1.equals(mTagName)) &#123; mPerson.setName(data); Log.i(TAG, \"处理name元素内容\"); &#125; else if (TAG_NAME2.equals(mTagName)) &#123; mPerson.setAge(Integer.parseInt(data)); Log.i(TAG, \"处理age元素内容\"); &#125; &#125; &#125; /** * 读取到元素结束时触发，这里将对象添加到集合中 */ @Override public void endElement(String uri, String localName, String qName) throws SAXException &#123; if (ELEMENT.equals(localName)) &#123; mPersons.add(mPerson); mPerson = null; Log.i(TAG, \"处理person元素结束~\"); &#125; mTagName = null; &#125; /** * 读取到文档结束时触发， */ @Override public void endDocument() throws SAXException &#123; super.endDocument(); Log.i(TAG, \"处理person元素结束~\"); &#125; /** * 获取persons集合 */ public ArrayList&lt;Person&gt; getPersons() &#123; return mPersons; &#125;&#125; 1234567891011121314private ArrayList&lt;Person&gt; readXmlForSax() throws IOException, ParserConfigurationException, SAXException &#123; // 获取文件资源建立输入流对象，可能是从网络获取 InputStream inputStream = getAssets().open(\"person1.xml\"); // 创建XML解析器 SaxHelper helper = new SaxHelper(); // 得到SAX解析工厂 SAXParserFactory factory = SAXParserFactory.newInstance(); // 创建SAX解析器 SAXParser parser = factory.newSAXParser(); // 将XML解析器分配给解析器，对文档进行解析，将事件发送给处理器 parser.parse(inputStream, helper); inputStream.close(); return helper.getPersons();&#125; 在项目assets目录下有一个文件person1.xml。 1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;persons&gt; &lt;person id = \"11\"&gt; &lt;name&gt;SAX解析&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;/person&gt; &lt;person id = \"13\"&gt; &lt;name&gt;XML1&lt;/name&gt; &lt;age&gt;43&lt;/age&gt; &lt;/person&gt;&lt;/persons&gt; Demo地址：Allen_Demo_WebService 4. DOM解析XML数据DOM解析XML文件时会将文件所有的内容以文档树的形式存放在内存中，可以使用DOM API遍历XML树，检索到需要的数据。使用DOM操作XML的代码比较直观，并且在编码方面比基于SAX的实现更加简单。但是DOM需要将XML文件的所有内容存放到内存中，所以内存消耗大，特别是对于Android设备而言，内存资源有限，因此建议使用前面的SAX解析。如果解析的内容比较小，也可以使用DOM来解析。 DOM API： DocumentBuilderFactory（解析器工厂类）：创建方法DoucmentBuilderFactory factory = DoucmentBuilderFactory.newInstance(); DocumentBuilder（解析器类）：创建方法：通过解析器工厂类来获得DocumentBuidler builder = factory.newDocumentBuilder(); Document（文档树模型）：将需要解析的XML文件读入DOM解析器：Document doc = builder.parse(context.getAssets().open(&quot;person2.xml&quot;)); Document对象代表了一个XML文档的模型，所有的其他Node都以一定的顺序包含在Document对象内，排列成树状，以后对XML文档的所有操作都与解析器无关。 NodeList（列表类）：代表一个包含一个或多个Node的列表，有以下两个方法： item(index)：返回集合的第index个Node项； getLength()：列表的节点数 Node（节点类）：DOM中最基本的对象，代表文档树中的抽象节点，很少会直接使用；通常调用其子对象的Element、Attr、Text等。 Element（元素类）：Node最主要的子对象，在元素中可以包含属性，因此有获取属性的方法： getAttrbute()：获取属性值 getTagName()：获取元素名称 Attr（属性类）：代表某个元素的属性，虽然Attr继承自Node接口，但因为Attr是包含在Element中的，但并不能将其看做是Element的子对象，因为Attr并不是DOM树的一部分。 核心代码：DOM解析类——DomHelper.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.ly.allendemowebservice;import android.content.Context;import android.util.Log;import org.w3c.dom.Document;import org.w3c.dom.Element;import org.w3c.dom.Node;import org.w3c.dom.NodeList;import org.xml.sax.SAXException;import java.io.IOException;import java.util.ArrayList;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.parsers.ParserConfigurationException;/** * DOM解析XML * * @author Liuyang * @date 2019/7/26 */public class DomHelper &#123; private static final String TAG = \"DomHelper\"; private static final String TAG_NAME = \"name\"; private static final String TAG_AGE = \"age\"; public static ArrayList&lt;Person&gt; queryXML(Context context) &#123; ArrayList&lt;Person&gt; persons = new ArrayList&lt;&gt;(); try &#123; // 1. 获取DOM解析器工厂 DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); // 2. 获取DOM解析器 DocumentBuilder builder = factory.newDocumentBuilder(); // 3. 将要解析的XML文件读入DOM解析器 Document document = builder.parse(context.getAssets().open(\"person2.xml\")); Log.i(TAG, \"处理该文档的DomImplementation对象 = \" + document.getImplementation()); // 4. 得到文档中名称为person的元素的节点元素 NodeList nodeList = document.getElementsByTagName(\"person\"); // 5. 遍历集合，显示集合中的元素以及子元素的名字 for (int i = 0; i &lt; nodeList.getLength(); i++) &#123; // 先从person元素开始解析 Element personElement = (Element) nodeList.item(i); Person person = new Person(); person.setId(Integer.valueOf(personElement.getAttribute(\"id\"))); // 获取person下的name和age的Note集合 NodeList childNodeList = personElement.getChildNodes(); for (int j = 0; j &lt; childNodeList.getLength(); j++) &#123; Node childNode = childNodeList.item(j); // 判断子Node类型是否为元素的Node if (childNode.getNodeType() == Node.ELEMENT_NODE) &#123; Element childElement = (Element) childNode; if (TAG_NAME.equals(childElement.getNodeName())) &#123; person.setName(childElement.getFirstChild().getNodeValue()); &#125; else if (TAG_AGE.equals(childElement.getNodeName())) &#123; person.setAge(Integer.valueOf(childElement.getFirstChild().getNodeValue())); &#125; &#125; &#125; persons.add(person); &#125; &#125; catch (ParserConfigurationException e) &#123; e.printStackTrace(); &#125; catch (SAXException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return persons; &#125;&#125; 5. PULL解析XML数据除了SAX和DOM解析XML之外，Android系统内置了Pull解析器用来解析XML，比如SharedPreference就是使用内置的pull解析配置文件的。它的使用和SAX类似，都是采用事件驱动来完成XML的解析，而pull代码比较简单，只需处理开始和结束的事件，通常使用switch语句，根据事件不同的类型，匹配不同的处理方式，有五种事件：START_DOCUMENT、START_TAG、TEXT、END_TAG、END_DUCOMENT。 XML pull 提供了开始元素和结束元素。当某个元素开始的时候，可以调用paser.nextText从XML文档中提取所有字符数据。当解析到一个文档结束时，自动生成EndDocument事件。在PULL解析过程中返回的是数字，且需要自己获取产生事件然后做出相应的操作，而不像SAX那样由处理器触发一种事件的方法，执行我们的代码：读取到XML的声明返回START_DOCUMENT；结束返回END_DOCUMENT；开始标签返回START_TAG；结束标签返回END_TAG；文本返回TEXT。使用PULL解析XML的流程： 获取一个XmlPullPaser类的引用： 1234// 方式1：通过xml解析工厂获得实体类XmlPullPaserFactory factory = XmlPullPaserFactory.newInstance(); XmlPullPaser paser = factory.newPullPaser();// 方式2：直接获得实体类XmlPullPaser paser = Xml.newPullPaser(); 为paser解析器对象提供xml流与编码格式： 1paser.setInput(xml, \"UTF-8\"); 获得事件的类型： 1int eventType = paser.getEventType(); 用switch对不同的事件类型进行不同的处理： START_DUCUMENT：开始读文档时触发，在这里完成初始化操作； START_TAG:开始读标签，通过paser的getName()方法获得标签名信息比较，使用getAttributeValue(index)获取属性值； 对于文字节点TEXT可以使用paser.nextText()获得节点内容； END_TAG：标签结束； paser.next()：循环解析下一个元素。 核心代码：PULL解析XML——PullHelper.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.ly.allendemowebservice;import org.xmlpull.v1.XmlPullParser;import org.xmlpull.v1.XmlPullParserException;import org.xmlpull.v1.XmlPullParserFactory;import java.io.IOException;import java.io.InputStream;import java.util.ArrayList;/** * PULL解析XML * * @author Liuyang * @date 2019/7/27 */public class PullHelper &#123; public static ArrayList&lt;Person&gt; getPersons(InputStream xml) throws XmlPullParserException, IOException &#123; ArrayList&lt;Person&gt; persons = null; Person person = null; // 创建一个XML解析工厂 XmlPullParserFactory factory = XmlPullParserFactory.newInstance(); // 获得XML解析类的引用 XmlPullParser parser = factory.newPullParser(); parser.setInput(xml, \"UTF_8\"); // 获得事件类型 int eventType = parser.getEventType(); while (eventType != XmlPullParser.END_DOCUMENT) &#123; switch (eventType) &#123; case XmlPullParser.START_DOCUMENT: persons = new ArrayList&lt;&gt;(); break; case XmlPullParser.START_TAG: if (\"person\".equals(parser.getName())) &#123; person = new Person(); // 取出属性值 int id = Integer.parseInt(parser.getAttributeValue(0)); person.setId(id); &#125; else if (\"name\".equals(parser.getName())) &#123; // 获取该节点的内容 String name = parser.nextText(); assert person != null; person.setName(name); &#125; else if (\"age\".equals(parser.getName())) &#123; int age = Integer.parseInt(parser.nextText()); assert person != null; person.setAge(age); &#125; break; case XmlPullParser.END_TAG: if (\"person\".equals(parser.getName())) &#123; assert persons != null; persons.add(person); person = null; &#125; break; default: break; &#125; eventType = parser.next(); &#125; return persons; &#125;&#125; 使用： 1234567891011try &#123; InputStream inputStream = getAssets().open(\"person3.xml\"); ArrayList&lt;Person&gt; persons = PullHelper.getPersons(inputStream); for (int i = 0; i &lt; persons.size(); i++) &#123; Log.i(TAG, i + \" == \" + persons.get(i).toString()); &#125;&#125; catch (IOException e) &#123; e.printStackTrace();&#125; catch (XmlPullParserException e) &#123; e.printStackTrace();&#125; 使用PULL生成XML数据的流程： 创建XMlSerializer（XML序列化类）的实例： 1XmlSerializer serializer = Xml.newSerializer(); 为XmlSerializer设置输出流与编码格式： 1serializersetOutput(out, \"UTF-8\"); 为XMlSerializer设置XML的编码格式： 1serializer.startDocument(\"UTF-8\", true); 设置根元素： 1serializer.startTag(null, \"person\"); 使用foreach循环遍历persons集合中所有的元素，同时依次写入标签与属性： 1234567891011for(Person p: persons)&#123; serializer.startTag(null, \"person\"); serializer.attribute(null, \"id\", p.getId() + \"\"); serializer.startTag(null, \"name\"); serializer.text(p.getName()); serializer.endTag(null, \"name\"); serializer.startTag(null, \"age\"); serializer.text(p.getAge() + \"\"); serializer.endTag(null, \"age\"); serializer.endTag(null, \"person\");&#125; 设置跟踪完结元素： 1serializer.endTag(null, \"persons\"); 结束文档编写： 1serializer.endDocument(); 调用flush()，将内存中的数据写入文件中并关闭输出流 12out.flush();out.close(); 核心代码： 12345678910111213141516171819202122public static void save(List&lt;Person&gt; persons, OutputStream out) throws Exception &#123; XmlSerializer serializer = Xml.newSerializer(); serializer.setOutput(out, \"UTF-8\"); serializer.startDocument(\"UTF-8\", true); serializer.startTag(null, \"persons\"); for (Person p : persons) &#123; serializer.startTag(null, \"person\"); serializer.attribute(null, \"id\", p.getId() + \"\"); serializer.startTag(null, \"name\"); serializer.text(p.getName()); serializer.endTag(null, \"name\"); serializer.startTag(null, \"age\"); serializer.text(p.getAge() + \"\"); serializer.endTag(null, \"age\"); serializer.endTag(null, \"person\"); &#125; serializer.endTag(null, \"persons\"); serializer.endDocument(); out.flush(); out.close();&#125; Demo地址：Allen_Demo_WebService","categories":[{"name":"Android","slug":"Android","permalink":"http://tylerLiu.top/categories/Android/"},{"name":"网络","slug":"Android/网络","permalink":"http://tylerLiu.top/categories/Android/网络/"}],"tags":[{"name":"WebService","slug":"WebService","permalink":"http://tylerLiu.top/tags/WebService/"}]},{"title":"一、Android调用WebService","slug":"一、Android调用WebService","date":"2019-07-26T08:12:57.000Z","updated":"2019-07-31T04:59:12.660Z","comments":true,"path":"2019/07/26/一、Android调用WebService/","link":"","permalink":"http://tylerLiu.top/2019/07/26/一、Android调用WebService/","excerpt":"","text":"Android调用WebService类似于一些给我们提供了原始数据API服务的数据平台，比如聚合数据。而WebService则用到了XML和SOAP，通过HTTP协议即可完成与远程机器的交互。 1. WebService简介1.1 WebService的引入手机硬件资源是有限的，对于一些复杂的数据处理和计算，通常都是部署在远程服务器上，然后安卓手机作为对应的客户端。为了让Android APP与远程服务器进行交互，肯定需要一些技术，这里使用WebService就可以了。 什么是WebService？ 简单来说，就是某些站点开放出来的服务，当然也可以自己开发一个service，也就是一些方法，通过URI，指定某一个方法名，发出请求，站点的这个服务（方法），接收请求后，根据传入的参数进行一些处理，然后将处理的结果以XML的形式返回。客户端收到这些XML并进行解析，然后显示或者进行其他操作。 例如，很多大的站点提供天气预报的WebSwevice、查询某网站的数据的WebService，只要发送请求，它就返回天气预报、某网站的数据，然后在客户端就能显示出来。 1.2 主要采用的四个技术1.2.1 XML可扩展的标记语言。同时采用XML Schema。正式因为WebWervice采用了XML，才使得它可以跨越各种编程语言。 1.2.2 SOAP简单对象访问协议。提供了标准的RPC（Remote Procedure Call，远程调用过程）方法来调用WebService。SOAP规范中定义了SOAP消息格式，以及怎样通过HTTP协议来使用SOAP。SOAP是基于XML语言和XSD标准的，其中XML是SOAP的数据编码方式。 1.2.3 WSDLWSDL是一种基于XML的用于描述WenService及其操作、参数和返回值的语言。因为是基于XML，一些IDE可以根据WenService来生成WSDL文档，又能通过导入WSDL文档 ，生成调用相应WebWervice的代码。 1.2.4 UDDI用于在网上自动查找WebService，一旦WebService注册到UDDI，客户就可以很方便的查找和定位所需要的WebService。 1.3 WebService模型 服务提供者：把自己的服务注册到“服务注册中心”。 服务请求者：到“服务注册中心”查找相应的服务，然后定位到“服务提供者”。 服务提供者：开始为“服务请求者”提供相应的服务。 2. 去哪里获取WebService网上有很多WebService的站点，这里选取了WebXmlu为例。 WebXml：http://www.webxml.com.cn/zh_cn/index.aspx 3. 第三方jar包准备首先如果想在Android平台上调用WebService，需要依赖第三方库ksoap2，而在Android平台上使用的是ksoap2-android-releases，一个高效、轻量级的SOAP开发包。 ksoap2-Android项目网站：https://simpligility.github.io/ksoap2-android/index.html ksoap2-android-assembly发布版本列表(包含所有可用版本jar包)：https://oss.sonatype.org/content/repositories/ksoap2-android-releases/com/google/code/ksoap2-android/ksoap2-android-assembly/ 4. 获取相关参数首先找到需要获取的服务，然后记录相关的参数：NameSpace（命名空间）、SoapAction以及URL。 比如这里查找天气的查询参数，点击去可以看到一个参数文档： 假设这里需要的是天气查询部分的功能： 这里可以拿到SoapAction和NameSpace。 这是一个测试页，可以不用填id信息，点击查询，可以看到这样一个页面： 这就是返回的XML文件，下面就需要去解析这个文件，这里的.gif表示天气的图标。 上面的查询号码归属地也是同理操作。 5. 注册 6. Demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234package com.ly.allendemowebservice;import android.annotation.SuppressLint;import android.os.Handler;import android.os.Message;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.TextView;import android.widget.Toast;import org.ksoap2.SoapEnvelope;import org.ksoap2.serialization.SoapObject;import org.ksoap2.serialization.SoapPrimitive;import org.ksoap2.serialization.SoapSerializationEnvelope;import org.ksoap2.transport.HttpTransportSE;import org.xmlpull.v1.XmlPullParserException;import java.io.IOException;import java.lang.reflect.Method;/** * WebService demo * * @author Liuyang * @date 2019/7/24 */public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private static final String TAG = \"MainActivity\"; private EditText mEtParam; private TextView mTvResult; private String mResult; private static final String USER_ID = \"1e3c36a0f18b4da4affa98cdd26ab0b4\"; /** * 定义获取手机信息的SoapAction与命名空间,作为常量 */ private static final String NAME_SPACE = \"http://WebXml.com.cn/\"; /** * 天气查询相关参数 */ private static final String WEATHER_URL = \"http://ws.webxml.com.cn/WebServices/WeatherWS.asmx\"; private static final String WEATHER_METHOD = \"getWeather\"; private static final String WEATHER_SOAP_ACTION = \"http://WebXml.com.cn/getWeather\"; /** * 号码归属地查询相关参数 */ private static final String ADDRESS_URL = \"http://ws.webxml.com.cn/WebServices/MobileCodeWS.asmx\"; private static final String ADDRESS_METHOD = \"getMobileCodeInfo\"; private static final String ADDRESS_SOAP_ACTION = \"http://WebXml.com.cn/getMobileCodeInfo\"; /** * 定义一个Handler用来更新页面 */ @SuppressLint(\"HandlerLeak\") private Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case 0x001: mTvResult.setText(mResult); Toast.makeText(MainActivity.this, \"获取天气信息成功\", Toast.LENGTH_SHORT).show(); break; case 0x002: mTvResult.setText(mResult); Toast.makeText(MainActivity.this, \"号码归属地查询成功\", Toast.LENGTH_SHORT).show(); break; default: break; &#125; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); bindViews(); &#125; private void bindViews() &#123; mEtParam = findViewById(R.id.et_param); Button btnAttribution = findViewById(R.id.btn_attribution); Button btnWeather = findViewById(R.id.btn_weather); mTvResult = findViewById(R.id.tv_result); btnAttribution.setOnClickListener(this); btnWeather.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.btn_attribution: new Thread() &#123; @Override public void run() &#123; getLand(); &#125; &#125;.start(); break; case R.id.btn_weather: new Thread() &#123; @Override public void run() &#123; getWeather();// getWeather1(); &#125; &#125;.start(); break; default: break; &#125; &#125; /** * 获取某个号码的归属地信息 */ private void getLand() &#123; mResult = \"\"; // 根据命名空间和方法得到SoapObject对象 SoapObject soapObject = new SoapObject(NAME_SPACE, ADDRESS_METHOD); soapObject.addProperty(\"mobileCode\", mEtParam.getText().toString()); soapObject.addProperty(\"userID\", USER_ID); // 通过SOAP1.1协议得到envelop对象 SoapSerializationEnvelope envelope = new SoapSerializationEnvelope(SoapEnvelope.VER11); // 将soapObject对象设置为envelop对象，传出消息 envelope.bodyOut = soapObject; // 设置是否调用的是dotNet开发的WebService // 指定webservice的类型的（java，PHP，dotNet） envelope.dotNet = true; // 等价于envelop.bodyOut = soapObject; envelope.setOutputSoapObject(soapObject); HttpTransportSE httpTransportSe = new HttpTransportSE(ADDRESS_URL); Log.i(TAG, \"号码服务设置完毕,准备开启服务\"); // 开始调用远程方法 try &#123; // 得到远程方法返回的SOAP对象 httpTransportSe.call(ADDRESS_SOAP_ACTION, envelope); Log.i(TAG, \"调用号码归属地查询WebService服务成功\"); &#125; catch (IOException e) &#123; e.printStackTrace(); Log.i(TAG, \"调用号码归属地查询WebService服务失败 = IOException\"); &#125; catch (XmlPullParserException e) &#123; e.printStackTrace(); Log.i(TAG, \"调用号码归属地查询WebService服务失败 = XmlPullParserException\"); &#125; // 获取返回的数据，并开始解析 SoapObject object = (SoapObject) envelope.bodyIn; mResult = object.getProperty(0).toString(); int count = object.getPropertyCount(); Log.i(TAG, \"count = \" + count); for (int i = 0; i &lt; count; i++) &#123; Log.i(TAG, i + \" === \" + object.getProperty(i).toString()); &#125; mHandler.sendEmptyMessage(0x002); Log.i(TAG, \"发送号码归属地数据完毕\"); &#125; /** * 获取某个城市的天气信息，使用封装的工具类 */ private void getWeather1() &#123;// SoapNetUtils.getInstance().doSoapRequest(); &#125; /** * 获取某个城市的天气信息 */ private void getWeather() &#123; mResult = \"\"; // 根据命名空间和方法得到SoapObject对象 SoapObject soapObject = new SoapObject(NAME_SPACE, WEATHER_METHOD); soapObject.addProperty(\"theCityCode\", mEtParam.getText().toString()); soapObject.addProperty(\"theUserID\", USER_ID); // 通过SOAP1.1协议得到envelop对象 SoapSerializationEnvelope envelope = new SoapSerializationEnvelope(SoapEnvelope.VER11); // 将soapObject对象设置为envelop对象，传出消息 envelope.bodyOut = soapObject; // 设置是否调用的是dotNet开发的WebService // 指定webservice的类型的（java，PHP，dotNet） envelope.dotNet = true; // 等价于envelop.bodyOut = soapObject; envelope.setOutputSoapObject(soapObject); HttpTransportSE httpTransportSe = new HttpTransportSE(WEATHER_URL); Log.i(TAG, \"天气服务设置完毕,准备开启服务\"); // 开始调用远程方法 try &#123; // 得到远程方法返回的SOAP对象 httpTransportSe.call(WEATHER_SOAP_ACTION, envelope); Log.i(TAG, \"调用天气查询WebService服务成功\"); &#125; catch (IOException e) &#123; e.printStackTrace(); Log.i(TAG, \"调用天气查询WebService服务失败 = IOException\"); &#125; catch (XmlPullParserException e) &#123; e.printStackTrace(); Log.i(TAG, \"调用天气查询WebService服务失败 = XmlPullParserException\"); &#125; // 获取返回的数据，并开始解析，以下都通过getClass()直到数据的类型，才去进行强制类型转换的 SoapObject object = (SoapObject) envelope.bodyIn; SoapPrimitive primitive; int count = object.getPropertyCount(); for (int i = 0; i &lt; count; i++) &#123; SoapObject object1 = (SoapObject) object.getProperty(i); for (int j = 0; j &lt; object1.getPropertyCount(); j++) &#123; primitive = (SoapPrimitive) object1.getProperty(j); Log.i(TAG, \"第\" + j + \"个数据为：\" + primitive.getName() + \" = \" + primitive.getValue()); &#125; &#125; primitive = (SoapPrimitive) ((SoapObject) object.getProperty(0)).getProperty(37); mResult = (String) primitive.getValue(); mHandler.sendEmptyMessage(0x001); Log.i(TAG, \"发送天气数据完毕\"); &#125;&#125; Demo地址：Allen_Demo_WebService","categories":[{"name":"Android","slug":"Android","permalink":"http://tylerLiu.top/categories/Android/"},{"name":"网络","slug":"Android/网络","permalink":"http://tylerLiu.top/categories/Android/网络/"}],"tags":[{"name":"WebService","slug":"WebService","permalink":"http://tylerLiu.top/tags/WebService/"}]}]}