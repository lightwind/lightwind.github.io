<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android RxJava应用：功能防抖]]></title>
    <url>%2F2019%2F08%2F23%2FAndroid-RxJava%E5%BA%94%E7%94%A8%EF%BC%9A%E5%8A%9F%E8%83%BD%E9%98%B2%E6%8A%96%2F</url>
    <content type="text"><![CDATA[1. 需求场景背景：用户只需要使用功能一次 问题：如果多次触发功能，就会导致出现冗余功能操作，如： 用户只需要使用网络请求功能一次（点击按钮） 但由于网络不好，点击一次后，用户发现没有响应 于是就多次点击按钮，就会导致发送多次网络请求 解决方法：功能防抖，通过根据指定时间过滤事件的过滤操作符实现，防止功能抖动 2. 功能说明功能防抖：即用户同规定时间内多次触发功能，仅会响应第一次的触发操作。 原理：使用根据指定时间过滤事件的过滤操作符实现，throttleFirst()操作符。 3. Demo12345678910111213141516171819202122232425262728293031323334public class AntiShakeActivity extends AppCompatActivity &#123; private static final String TAG = "RxJava"; @SuppressLint("CheckResult") @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_anti_shake); Button button = findViewById(R.id.button); // 1. 此处采用了RxBinding：RxView.clicks(button)控件点击进行监听， // 需要引入依赖：implementation 'com.jakewharton.rxbinding2:rxbinding:2.0.0' // 2. 传入Button控件，点击时，都会发送数据事件， // 但由于使用了throttleFirst()操作符，所以只会发送该段时间内的第1次点击事件 RxView.clicks(button) // 2s内第1次点击按钮的事件才发送 .throttleFirst(2, TimeUnit.SECONDS) .subscribe(new Consumer&lt;Object&gt;() &#123; @Override public void accept(Object o) throws Exception &#123; Log.d(TAG, "发送了网络请求"); &#125; &#125;, new Consumer&lt;Throwable&gt;() &#123; @Override public void accept(Throwable throwable) throws Exception &#123; // 获取异常错误信息 Log.d(TAG, "对Error事件作出响应" + throwable.getMessage()); &#125; &#125;); &#125;&#125; Demo地址：Allen_Demo_Rx]]></content>
      <categories>
        <category>Android</category>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android RxJava应用：网络请求出错重连]]></title>
    <url>%2F2019%2F08%2F23%2FAndroid-RxJava%E5%BA%94%E7%94%A8%EF%BC%9A%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%87%BA%E9%94%99%E9%87%8D%E8%BF%9E%2F</url>
    <content type="text"><![CDATA[1. 需求场景背景：发送网络请求问题：发送网络请求过程中，出现错误时，导致该次网络请求不成功解决方案：当发生错误使得网络请求不成功时，自动重新发送网络请求，即差错自动重试机制 2. 功能说明功能描述：当发送错误时，使得网络请求不成功时，自动重新发送网络请求实现原理：采用RxJava中的retryWhen()操作符具体说明：根据错误类型判断实现需要重连，所有网络错误异常都属于IOException，其余异常都不在重试范围内。若要重试，设置退避策略，即，为请求重试设置一个合理的退避算法，而不是一出现错误马上就重试。合理的退避算法： 遇到错误时，等待一段时间后再重试 若遇到的异常次数越多，等待时间应该越长 即，设置等待时间，会随着错误异常次数增多而可变 限制可重试次数，避免无限重试 即，设置重试次数 3. Demo采用GET方法对金山词霸API进行网络请求： 通过判断网络连接模拟网络异常错误（即回复网络即可发送请求） 限制重试次数为10次 采用Gson进行数据解析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102public class RxJavafixRxjavaActivity3 extends AppCompatActivity &#123; private static final String TAG = "RxJava"; /** * 可重试次数 */ private int mMaxConnectCount = 10; /** * 当前已重试次数 */ private int mCurrentRetryCount = 0; /** * 重试等待时间 */ private int mWaitRetryTime = 0; @SuppressLint("CheckResult") @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_rx_javafix_rxjava3); Retrofit retrofit = new Retrofit.Builder() .baseUrl("http://fy.iciba.com/") .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .build(); GetRequest_Interface request = retrofit.create(GetRequest_Interface.class); Observable&lt;Translation&gt; observable = request.getCall(); // 主要异常才会回调retryWhen()进行重试 observable.retryWhen(new Function&lt;Observable&lt;Throwable&gt;, ObservableSource&lt;?&gt;&gt;() &#123; @Override public ObservableSource&lt;?&gt; apply(Observable&lt;Throwable&gt; throwableObservable) throws Exception &#123; // Observable&lt;Throwable&gt;中的泛型为上游操作符抛出的异常，可以通过该条件判断异常的类型 return throwableObservable.flatMap(new Function&lt;Throwable, ObservableSource&lt;?&gt;&gt;() &#123; @Override public ObservableSource&lt;?&gt; apply(Throwable throwable) throws Exception &#123; // 输出异常信息 Log.d(TAG, "发生异常 = " + throwable.toString()); // 需求1：根据异常类型选择是否重试 if (throwable instanceof IOException) &#123; Log.d(TAG, "属于IOException，需重试"); // 需求2：设置重试次数 if (mCurrentRetryCount &lt; mMaxConnectCount) &#123; // 记录重试次数 mCurrentRetryCount++; Log.d(TAG, "重试次数 = " + mCurrentRetryCount); // 需求2：实现重试 // 通过返回的Observable发送的事件，即Next事件，使得retryWhen()重新订阅，实现重试功能 // 需求3：延迟重试 // 使用delay()操作符 // 需求4：遇到的异常次数越多，时间越长 // 设置delay()操作符的等待时间，每重试一次，增加延迟重试时间1s // 设置等待时间 mWaitRetryTime = 1000 + mCurrentRetryCount * 1000; Log.d(TAG, "等待时间 =" + mWaitRetryTime); return Observable.just(1).delay(mWaitRetryTime, TimeUnit.MILLISECONDS); &#125; else &#123; // 若重试次数已 ＞ 设置重试次数，则不重试 // 通过发送error来停止重试（可在观察者的onError()中获取信息） return Observable.error(new Throwable("重试次数已超过设置次数 = " + mCurrentRetryCount + "，即，不再重试")); &#125; &#125; // 若发生的异常不属于I/O异常，则不重试 // 通过返回的Observable发送的Error事件，实现（可在观察者的onError()中获取信息） else &#123; return Observable.error(new Throwable("发生了非网络异常（非I/O异常）")); &#125; &#125; &#125;); &#125; &#125;).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;Translation&gt;() &#123; @Override public void accept(Translation translation) throws Exception &#123; // 接收服务器返回的数据 Log.d(TAG, "发送成功"); translation.show(); &#125; &#125;, new Consumer&lt;Throwable&gt;() &#123; @Override public void accept(Throwable throwable) throws Exception &#123; // 获取停止重试的信息 Log.d(TAG, throwable.getMessage()); &#125; &#125;); &#125;&#125; 123456789101112131415161718D/RxJava: 发生异常 = java.net.UnknownHostException: Unable to resolve host &quot;fy.iciba.com&quot;: No address associated with hostnameD/RxJava: 属于IOException，需重试D/RxJava: 重试次数 = 1D/RxJava: 等待时间 =2000D/RxJava: 发生异常 = java.net.UnknownHostException: Unable to resolve host &quot;fy.iciba.com&quot;: No address associated with hostnameD/RxJava: 属于IOException，需重试D/RxJava: 重试次数 = 2D/RxJava: 等待时间 =3000D/RxJava: 发生异常 = java.net.UnknownHostException: Unable to resolve host &quot;fy.iciba.com&quot;: No address associated with hostnameD/RxJava: 属于IOException，需重试D/RxJava: 重试次数 = 3D/RxJava: 等待时间 =4000D/RxJava: 发生异常 = java.net.UnknownHostException: Unable to resolve host &quot;fy.iciba.com&quot;: No address associated with hostnameD/RxJava: 属于IOException，需重试D/RxJava: 重试次数 = 4D/RxJava: 等待时间 =5000D/RxJava: 发送成功D/RxJava: 嗨世界 Demo地址：Allen_Demo_Rx]]></content>
      <categories>
        <category>Android</category>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android RxJava应用：网络请求轮询（有条件）]]></title>
    <url>%2F2019%2F08%2F23%2FAndroid-RxJava%E5%BA%94%E7%94%A8%EF%BC%9A%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E8%BD%AE%E8%AF%A2%EF%BC%88%E6%9C%89%E6%9D%A1%E4%BB%B6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1. 需求场景背景：实现轮询，也称pull。客户端隔固定时间主动向服务器发送请求获取信息，可根据服务器返回信息停止轮询，即，有条件轮询。解决方案：使用RxJava的repeatWhen()操作符 2. 功能说明采用GET，对金山词霸API按规定时间重复发送网络请求，模拟轮询。 停止轮询的条件：当轮询到第四次时 采用Gson解析数据 3. 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class RxJavafixRxjavaActivity2 extends AppCompatActivity &#123; private static final String TAG = "RxJava"; /** * 模拟轮询服务器次数 */ private int i = 0; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_rx_javafix_rxjava2); Retrofit retrofit = new Retrofit.Builder() .baseUrl("http://fy.iciba.com/") .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .build(); GetRequest_Interface request = retrofit.create(GetRequest_Interface.class); Observable&lt;Translation&gt; observable = request.getCall(); observable.repeatWhen(new Function&lt;Observable&lt;Object&gt;, ObservableSource&lt;?&gt;&gt;() &#123; // 在Function函数中，必须对输入的 Observable&lt;Object&gt;进行处理，此处使用flatMap()操作符接收上游的数据 @Override public ObservableSource&lt;?&gt; apply(Observable&lt;Object&gt; objectObservable) throws Exception &#123; // 将原始Observable停止发送事件的标识（Complete()/Error()）转换成一个Object类型数据传递给一个新的Observable， // 以此决定是否重新订阅并发送原来的Observable，即轮询 // 此处由两种情况： // 1. 若返回一个Complete()/Error()事件，则不重新订阅并发送原来的Observable，即轮询结束 // 2. 若返回其余事件，则重新订阅并发送原来的Observable，即继续轮询 return objectObservable.flatMap(new Function&lt;Object, ObservableSource&lt;?&gt;&gt;() &#123; @Override public ObservableSource&lt;?&gt; apply(Object o) throws Exception &#123; // 加入判断条件，当轮询次数为5次时，停止轮询 if (i &gt; 3) &#123; // 此处选择发送onError()事件以结束轮询，因为可触发下游观察者的onError()方法回调 return Observable.error(new Throwable("轮询结束")); &#125; // 若轮询次数 ＜ 4，发送一个Next事件继续轮询 return Observable.just(1).delay(2, TimeUnit.SECONDS); &#125; &#125;); &#125; &#125;).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;Translation&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Translation translation) &#123; // e.接收服务器返回的数据 translation.show(); i++; &#125; @Override public void onError(Throwable e) &#123; // 获取轮询结束信息 Log.d(TAG, e.toString()); &#125; @Override public void onComplete() &#123; &#125; &#125;); &#125;&#125; 12345614:46:35.250 3950-3950/com.ly.allendemorx D/RxJava: 嗨世界14:46:37.240 3950-3950/com.ly.allendemorx D/RxJava: 嗨世界14:46:39.554 3950-3950/com.ly.allendemorx D/RxJava: 嗨世界14:46:42.787 3950-3950/com.ly.allendemorx D/RxJava: 嗨世界14:46:44.929 3950-3950/com.ly.allendemorx D/RxJava: 嗨世界14:46:44.971 3950-3950/com.ly.allendemorx D/RxJava: java.lang.Throwable: 轮询结束 Demo地址：Allen_Demo_Rx]]></content>
      <categories>
        <category>Android</category>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android RxJava应用：联合判断多个事件]]></title>
    <url>%2F2019%2F08%2F22%2FAndroid-RxJava%E5%BA%94%E7%94%A8%EF%BC%9A%E8%81%94%E5%90%88%E5%88%A4%E6%96%AD%E5%A4%9A%E4%B8%AA%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[1. 需求场景同时对多个事件进行联合判断。如，填写表单时，需要表里的所有信息（姓名、年龄、职业等）都被填写后，才能点击提交按钮。 2. 功能说明此处采用 填写表单 作为联合判断功能展示，即，表单里所有信息（姓名、年龄、职业等）都被填写后，才允许点击 “提交” 按钮。 3. 实现采用combineLatest()操作符。 12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;EditText android:id="@+id/name" android:layout_width="wrap_content" android:layout_height="wrap_content" android:hint="请填写姓名" /&gt; &lt;EditText android:id="@+id/age" android:layout_width="wrap_content" android:layout_height="wrap_content" android:hint="请填写年龄" /&gt; &lt;EditText android:id="@+id/job" android:layout_width="wrap_content" android:layout_height="wrap_content" android:hint="请填写职业" /&gt; &lt;Button android:id="@+id/list" android:layout_width="wrap_content" android:layout_height="wrap_content" android:enabled="false" android:text="提交" /&gt;&lt;/LinearLayout&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class CombineJudgeActivity extends AppCompatActivity &#123; private EditText mName, mAge, mJob; private Button mButton; @SuppressLint("CheckResult") @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_combine_judge); mName = findViewById(R.id.name); mAge = findViewById(R.id.age); mJob = findViewById(R.id.job); mButton = findViewById(R.id.list); // 为每个EditText设置被观察者，用于发送监听事件 // 说明： // 1. 这里使用RxBinding的RxTextView.textChanges(name)是对对控件数据变更进行监听 // （功能类似TextWatcher），需要引入依赖：implementation 'com.jakewharton.rxbinding2:rxbinding:2.0.0' // 2. 传入EditText控件，点击任一个EditText撰写时，都会发送数据事件 = Function3（）的返回值（下面会详细说明） // 3. 采用skip(1)原因：跳过 一开始EditText无任何输入时的空值 Observable&lt;CharSequence&gt; nameObservable = RxTextView.textChanges(mName).skip(1); Observable&lt;CharSequence&gt; ageObservable = RxTextView.textChanges(mAge).skip(1); Observable&lt;CharSequence&gt; jobObservable = RxTextView.textChanges(mJob).skip(1); // 通过combineLatest()合并事件并联合判断 Observable.combineLatest(nameObservable, ageObservable, jobObservable, new Function3&lt;CharSequence, CharSequence, CharSequence, Boolean&gt;() &#123; @Override public Boolean apply(CharSequence charSequence, CharSequence charSequence2, CharSequence charSequence3) throws Exception &#123; // 规定表单输入信息不能为空 boolean isNameEmpty = !TextUtils.isEmpty(mName.getText()); boolean isAgeEmpty = !TextUtils.isEmpty(mAge.getText()); boolean isJobEmpty = !TextUtils.isEmpty(mJob.getText()); return isNameEmpty &amp;&amp; isAgeEmpty &amp;&amp; isJobEmpty; &#125; &#125;).subscribe(new Consumer&lt;Boolean&gt;() &#123; @Override public void accept(Boolean aBoolean) throws Exception &#123; // 返回结果 &amp; 设置按钮可点击样式 mButton.setEnabled(aBoolean); &#125; &#125;); &#125;&#125; Demo地址：Allen_Demo_Rx]]></content>
      <categories>
        <category>Android</category>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android RxJava应用：从磁盘/内存缓存中获取数据]]></title>
    <url>%2F2019%2F08%2F22%2FAndroid-RxJava%E5%BA%94%E7%94%A8%EF%BC%9A%E4%BB%8E%E7%A3%81%E7%9B%98-%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98%E4%B8%AD%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[1. 需求场景背景：从服务器获取数据问题：每次获取数据都通过网络请求向服务器获取会浪费很多资源，包括流量和时间解决方案：从缓存中读取数据，即，当需要获取数据时，先从本地的磁盘/内存缓存中获取所需数据，如果缓存中没有数据，再通过网络请求向服务器获取数据实现原理：组合操作符concat()和过滤操作符firstElement() 2. 功能说明 3. 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class CacheDemoActivity extends AppCompatActivity &#123; private static final String TAG = "RxJava"; /** * 模拟内存缓存和磁盘缓存 */ String memoryCache = null; String diskCache = "从磁盘缓存中获取的数据"; @SuppressLint("CheckResult") @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_cache_demo); // 设置第一个Observable，检查内存缓存是否由该数据的缓存 Observable&lt;String&gt; memory = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123; // 判断内存缓存有无数据 if (memoryCache != null) &#123; // 若有该数据，则发送 emitter.onNext(memoryCache); &#125; else &#123; // 若没有，直接发送结束事件 emitter.onComplete(); &#125; &#125; &#125;); // 设置第二个Observable，检查磁盘缓存是否由该数据的缓存 Observable&lt;String&gt; disk = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123; // 判断磁盘缓存有无数据 if (diskCache != null) &#123; // 若有该数据，则发送 emitter.onNext(diskCache); &#125; else &#123; // 若没有，直接发送结束事件 emitter.onComplete(); &#125; &#125; &#125;); // 设置第三个Observable：通过网络获取数据 Observable&lt;String&gt; network = Observable.just("从网络获取数据"); // 使用concat()和firstElement()实现缓存功能 // 1. 通过concat()合并三个被观察者的事件，并将它们按顺序串成队列 Observable.concat(memory, disk, network) // 通过firstElement()，从队列中取出并发送第一个有效事件，即依次判断检查三个Observable // 即本例的逻辑为： // a. firstElement()取出第一个事件memory，即先判断内存缓存中有无数据缓存； // 由于memoryCache = null，即内存缓存中无数据，所以发送结束事件（视为无效事件） // b. firstElement()继续取出第二个事件disk，即判断磁盘缓存中有无数据缓存： // 由于diskCache ≠ null，即磁盘缓存中有数据，所以发送Next事件（有效事件） // c. 即firstElement()已发出第一个有效事件（disk事件），所以停止判断。 .firstElement() // 3. 订阅 .subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; Log.d(TAG, "最终获取的数据来源 = " + s); &#125; &#125;); &#125;&#125; 1D/RxJava: 最终获取的数据来源 = 从磁盘缓存中获取的数据]]></content>
      <categories>
        <category>Android</category>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android RxJava应用：合并数据源并展示]]></title>
    <url>%2F2019%2F08%2F22%2FAndroid-RxJava%E5%BA%94%E7%94%A8%EF%BC%9A%E5%90%88%E5%B9%B6%E6%95%B0%E6%8D%AE%E6%BA%90%E5%B9%B6%E5%B1%95%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[1. 需求场景背景：获取数据并统一展示到客户端冲突：数据来源不同，网络和本地，即，数据源多样解决方案：采用RxJava操作符，这里使用merge()和zip()演示。 2. 功能说明获取数据并统一展示到客户端 3. 实现 merge()：实现从（网络和本地）获取数据并统一展示 zip()：结合Retrofit和RxJava，实现合并两个网络请求，向两个服务器获取数据并统一展示。 3.1 merge()1234567891011121314151617181920212223242526272829303132333435363738394041424344public class MergeDemoActivity extends AppCompatActivity &#123; private static final String TAG = "RxJava"; /** * 用于存放最终展示的数据 */ String result = "数据源来自 = "; Observable&lt;String&gt; network = Observable.just("网络"); Observable&lt;String&gt; file = Observable.just("本地文件"); @SuppressLint("CheckResult") @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_merge_demo); Observable.merge(network, file) .subscribe(new Observer&lt;String&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(String value) &#123; Log.d(TAG, "数据源有： " + value); result += value + "+"; &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, "对Error事件作出响应"); &#125; // 接收合并事件后，统一展示 @Override public void onComplete() &#123; Log.d(TAG, "获取数据完成"); Log.d(TAG, result); &#125; &#125;); &#125;&#125; 1234D/RxJava: 数据源有： 网络D/RxJava: 数据源有： 本地文件D/RxJava: 获取数据完成D/RxJava: 数据源来自 = 网络+本地文件+ 3.2 zip() 从不同数据源（两个服务器）获取数据，并合并 统一显示结果 两个接收服务器数据的类： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Translation1 &#123; private int status; private ContentBean content; private static class ContentBean &#123; private String from; private String to; private String vendor; private String out; private String ciba_use; private String ciba_out; private int err_no; &#125; /** * 定义输出返回数据的方法 */ public String show() &#123; return ("第1次翻译=" + content.out); &#125;&#125;public class Translation2 &#123; private int status; private ContentBean content; private static class ContentBean &#123; private String from; private String to; private String vendor; private String out; private String ciba_use; private String ciba_out; private int err_no; &#125; /** * 定义输出返回数据的方法 */ public String show() &#123; return ("第2翻译=" + content.out); &#125;&#125; 在Activity中的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class ZipDemoActivity extends AppCompatActivity &#123; private static final String TAG = "Rxjava"; /** * 定义Observable接口类型的网络请求对象 */ Observable&lt;Translation1&gt; mObservable1; Observable&lt;Translation2&gt; mObservable2; @SuppressLint("CheckResult") @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_zip_demo); // 步骤1：创建Retrofit对象 Retrofit retrofit = new Retrofit.Builder() .baseUrl("http://fy.iciba.com/") .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .build(); // 步骤2：创建网络请求接口的实例 GetRequest_Interface request = retrofit.create(GetRequest_Interface.class); // 步骤3：对两个网络请求进行封装 mObservable1 = request.getCall_1().subscribeOn(Schedulers.io()); mObservable2 = request.getCall_2().subscribeOn(Schedulers.io()); // 步骤4：通过使用zip()对两个网络请求进行合并再发送 Observable.zip(mObservable1, mObservable2, new BiFunction&lt;Translation1, Translation2, String&gt;() &#123; @Override public String apply(Translation1 translation1, Translation2 translation2) throws Exception &#123; return translation1.show() + " &amp; " + translation2.show(); &#125; &#125;).observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; // 结合显示2个网络请求的数据结果 Log.d(TAG, "最终接收到的数据是：" + s); &#125; &#125;, new Consumer&lt;Throwable&gt;() &#123; @Override public void accept(Throwable throwable) throws Exception &#123; Log.d(TAG, "登录失败"); &#125; &#125;); &#125;&#125; 1D/Rxjava: 最终接收到的数据是：第1次翻译=HI寄存器 &amp; 第2翻译=嗨登录]]></content>
      <categories>
        <category>Android</category>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android RxJava应用：网络请求嵌套回调]]></title>
    <url>%2F2019%2F08%2F22%2FAndroid-RxJava%E5%BA%94%E7%94%A8%EF%BC%9A%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%B5%8C%E5%A5%97%E5%9B%9E%E8%B0%83%2F</url>
    <content type="text"><![CDATA[1. 需求场景1.1 背景需要进行嵌套网络请求，即，在第一个网络请求成功后，再继续进行一次网络请求。 如先进行注册的网路请求，等注册成功后，再进行登录的网路请求。 1.2 冲突嵌套实现网路请求较为复杂。 123456789101112131415161718192021222324252627282930313233343536373839// 发送注册网络请求的函数方法private void register() &#123; api.register(new RegisterRequest()) // 在IO线程进行网络请求 .subscribeOn(Schedulers.io()) // 回到主线程去处理请求结果 .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;RegisterResponse&gt;() &#123; @Override public void accept(RegisterResponse registerResponse) throws Exception &#123; Toast.makeText(MainActivity.this, "注册成功", Toast.LENGTH_SHORT).show(); // 注册成功, 调用登录的方法 login(); &#125; &#125;, new Consumer&lt;Throwable&gt;() &#123; @Override public void accept(Throwable throwable) throws Exception &#123; Toast.makeText(MainActivity.this, "注册失败", Toast.LENGTH_SHORT).show(); &#125; &#125;);&#125;// 发送登录网络请求的函数方法private void login() &#123; api.login(new LoginRequest()) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;LoginResponse&gt;() &#123; @Override public void accept(LoginResponse loginResponse) throws Exception &#123; Toast.makeText(MainActivity.this, "登录成功", Toast.LENGTH_SHORT).show(); &#125; &#125;, new Consumer&lt;Throwable&gt;() &#123; @Override public void accept(Throwable throwable) throws Exception &#123; Toast.makeText(MainActivity.this, "登录失败", Toast.LENGTH_SHORT).show(); &#125; &#125;);&#125; 1.3 解决方案结合RxJava中的变换操作符flatMap()实现嵌套网路请求。Android RxJava：变换操作符 2. 功能说明实现功能：发送嵌套网络请求（将英文翻译成中文，翻译两次）Demo：先翻译注册，再翻译登录。 3. 具体实现步骤和前面的相同，这里列出不同的部分。 为了演示两个网络请求，这里设置两个接收服务器的数据类： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Translation1 &#123; private int status; private ContentBean content; private static class ContentBean &#123; private String from; private String to; private String vendor; private String out; private String ciba_use; private String ciba_out; private int err_no; &#125; /** * 定义输出返回数据的方法 */ public void show() &#123; Log.d("RxJava", "翻译内容 = " + content.out); &#125;&#125;public class Translation2 &#123; private int status; private ContentBean content; private static class ContentBean &#123; private String from; private String to; private String vendor; private String out; private String ciba_use; private String ciba_out; private int err_no; &#125; /** * 定义输出返回数据的方法 */ public void show() &#123; Log.d("RxJava", "翻译内容 = " + content.out); &#125;&#125; 创建用于描述网络请求的接口 12345678910111213public interface GetRequest_Interface &#123; /** * 网络请求1 */ @GET("ajax.php?a=fy&amp;f=auto&amp;t=auto&amp;w=hi%20register") Observable&lt;Translation1&gt; getCall_1(); /** * 网络请求2 */ @GET("ajax.php?a=fy&amp;f=auto&amp;t=auto&amp;w=hi%20login") Observable&lt;Translation2&gt; getCall_2();&#125; 在Activity中的实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package com.ly.allendemorx;import android.annotation.SuppressLint;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;import com.jakewharton.retrofit2.adapter.rxjava2.RxJava2CallAdapterFactory;import io.reactivex.Observable;import io.reactivex.ObservableSource;import io.reactivex.android.schedulers.AndroidSchedulers;import io.reactivex.functions.Consumer;import io.reactivex.functions.Function;import io.reactivex.schedulers.Schedulers;import retrofit2.Retrofit;import retrofit2.converter.gson.GsonConverterFactory;/** * RxJava实现嵌套网络请求 * * @author Liuyang * @date 2019/8/22 */public class Main8Activity extends AppCompatActivity &#123; private static final String TAG = "Rxjava"; /** * 定义Observable接口类型的网络请求对象 */ Observable&lt;Translation1&gt; mObservable1; Observable&lt;Translation2&gt; mObservable2; @SuppressLint("CheckResult") @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main8); // 步骤1：创建Retrofit对象 Retrofit retrofit = new Retrofit.Builder() .baseUrl("http://fy.iciba.com/") .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .build(); // 步骤2：创建网络请求接口实例 GetRequest_Interface request = retrofit.create(GetRequest_Interface.class); // 步骤3：对两个网络请求进行封装 mObservable1 = request.getCall_1(); mObservable2 = request.getCall_2(); mObservable1 // 在IO线程进行第一次网络请求 .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .doOnNext(new Consumer&lt;Translation1&gt;() &#123; @Override public void accept(Translation1 translation1) throws Exception &#123; Log.d(TAG, "第1次网络请求成功"); translation1.show(); &#125; &#125;) // 切换到IO线程进行第二次网络请求 // 因为flatMap()是对初始被观察者作变换，所以对于旧的被观察者，它是新的观察者， // 所以使用observeOn()进行线程切换，但是对于初始观察者，它就是新的被观察者。 .observeOn(Schedulers.io()) .flatMap(new Function&lt;Translation1, ObservableSource&lt;Translation2&gt;&gt;() &#123; @Override public ObservableSource&lt;Translation2&gt; apply(Translation1 translation1) throws Exception &#123; // 将网络请求1转换成网络请求2，即发送网络请求2 return mObservable2; &#125; &#125;) // 初始观察者切换到主线程，处理网络请求2的结果 .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;Translation2&gt;() &#123; @Override public void accept(Translation2 translation2) throws Exception &#123; Log.d(TAG, "第2次网络请求成功"); translation2.show(); &#125; &#125;, new Consumer&lt;Throwable&gt;() &#123; @Override public void accept(Throwable throwable) throws Exception &#123; Log.d(TAG, "登录失败"); &#125; &#125;); &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android RxJava应用：网络请求轮询（无条件）]]></title>
    <url>%2F2019%2F08%2F22%2FAndroid-RxJava%E5%BA%94%E7%94%A8%EF%BC%9A%E7%BD%91%E7%BB%9C%E8%BD%AE%E8%AF%A2%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[1. 需求场景 背景：实现轮询请求，即，客户端固定时间主动向服务器发送请求，获取信息，也称pull。 冲突：通过Handler和Timer定时器 的实现方式较为复杂，可扩展性差。 解决方案：采用RxJava的延时创建操作符 interval()：无限次轮询 intervalRange()：有限次轮询 2. 功能说明采用GET方法对金山词霸API按规定时间重复发送网络请求，模拟轮询需求。采用Gson进行数据解析。 3. 具体实现3.1 步骤说明 添加依赖 创建接收服务器返回的数据的类 创建用于描述网络请求的接口 创建Retrofit实例 创建网络请求接口实例，配置网络请求参数 发送网络请求 对返回的数据进行处理 前面的步骤在Android RxJava：线程控制中已经讲解，这里主要分析轮询部分的实现。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * RxJava实现轮询 * * @author Liuyang * @date 2019/8/22 */public class RxJavafixRxjavaActivity extends AppCompatActivity &#123; private static final String TAG = "Rxjava"; @SuppressLint("CheckResult") @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_rx_javafix_rxjava); // 步骤1：采用interval()延迟发送 // 注：此处主要展示无限轮询，要实现有限轮询，使用intervalRange()即可 Observable.interval(2, 1, TimeUnit.SECONDS) // 步骤2：每次发送数字前发送一次网络请求（doOnNext()在执行Next事件前调用） // 即每隔1秒产生一个数字前，就发送一次网络请求，实现轮询 .doOnNext(new Consumer&lt;Long&gt;() &#123; @Override public void accept(Long aLong) throws Exception &#123; Log.d(TAG, "第 " + aLong + " 次轮询"); // 步骤3：通过Retrofit实现网络请求 Retrofit retrofit = new Retrofit.Builder() .baseUrl("http://fy.iciba.com/") .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .build(); GetRequest_Interface request = retrofit.create(GetRequest_Interface.class); Observable&lt;Translation&gt; observable = request.getCall(); observable.subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;Translation&gt;() &#123; @Override public void accept(Translation translation) throws Exception &#123; if (translation != null) &#123; Log.d(TAG, "结果 from：" + translation.getContent().getFrom()); Log.d(TAG, "结果 to：" + translation.getContent().getTo()); Log.d(TAG, "结果 vendor：" + translation.getContent().getVendor()); Log.d(TAG, "结果 out：" + translation.getContent().getOut()); Log.d(TAG, "结果 ciba_use：" + translation.getContent().getCiba_use()); Log.d(TAG, "结果 ciba_out：" + translation.getContent().getCiba_out()); Log.d(TAG, "结果 err_no：" + translation.getContent().getErr_no()); &#125; &#125; &#125;); &#125; &#125;).subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(Long aLong) throws Exception &#123; Log.d(TAG, "接收到的事件：" + aLong); &#125; &#125;, new Consumer&lt;Throwable&gt;() &#123; @Override public void accept(Throwable throwable) throws Exception &#123; Log.d(TAG, "对Error事件作出响应"); &#125; &#125;); &#125;&#125; 1234567891011121314151617181920212223242526272829D/Rxjava: 第 0 次轮询D/Rxjava: 接收到的事件：0D/Rxjava: 第 1 次轮询D/Rxjava: 接收到的事件：1D/Rxjava: 第 2 次轮询D/Rxjava: 接收到的事件：2D/Rxjava: 结果 from：en-EUD/Rxjava: 结果 to：zh-CND/Rxjava: 结果 vendor：tencentD/Rxjava: 结果 out：嗨世界D/Rxjava: 结果 ciba_use：来自机器翻译。D/Rxjava: 结果 ciba_out：D/Rxjava: 结果 err_no：0D/Rxjava: 第 3 次轮询D/Rxjava: 接收到的事件：3D/Rxjava: 结果 from：en-EUD/Rxjava: 结果 to：zh-CND/Rxjava: 结果 vendor：tencentD/Rxjava: 结果 out：嗨世界D/Rxjava: 结果 ciba_use：来自机器翻译。D/Rxjava: 结果 ciba_out：D/Rxjava: 结果 err_no：0D/Rxjava: 结果 from：en-EUD/Rxjava: 结果 to：zh-CND/Rxjava: 结果 vendor：tencentD/Rxjava: 结果 out：嗨世界D/Rxjava: 结果 ciba_use：来自机器翻译。D/Rxjava: 结果 ciba_out：D/Rxjava: 结果 err_no：0]]></content>
      <categories>
        <category>Android</category>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android RxJava：背压策略]]></title>
    <url>%2F2019%2F08%2F20%2FAndroid-RxJava%EF%BC%9A%E8%83%8C%E5%8E%8B%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[1. 引言1.1 背景观察者和被观察者之间存在两种订阅关系：同步、异步。 同步订阅： 观察者和被观察者工作在同一个线程 被观察者每发送一个事件，必须等到观察者接收且处理后，才能继续发送下一个事件。 异步订阅 观察者和被观察者工作不在同一线程 被观察者不需要等待观察者接收和处理后才能继续发送下一个事件，而是不断发送，直到发送事件完毕 此时的事件并不会直接发送到观察者处，而是先发送到缓存区，等观察者从缓存区取出事件来处理 对于异步订阅关系，存在被观察者发送事件的速度与观察者接收事件的速度不匹配的情况： 发送和接收事件速度就是单位时间内发送和接收事件的数量 大部分情况是，被观察者发送事件速度 &gt; 观察者接收事件速度 1.2 问题被观察者发送事件速度太快，观察者来不及接收所有事件，导致观察者无法及时响应/处理所有发送过来的事件，最终导致缓存区溢出、事件丢失或OOM问题。 点击按钮事件：连续快速点击按钮，则只会造成点击两次的效果。 原因：因为点击速度太快，按钮来不及响应。 例子：被观察者发送事件速度为10ms/个，观察者接收事件速度为5s/个，即发送和接收速度严重不匹配。 123456789101112131415161718192021222324252627Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; for (int i = 0; ; i++) &#123; Log.d(TAG, "发送了事件" + i); Thread.sleep(10); // 发送事件速度：10ms / 个 emitter.onNext(i); &#125; &#125;&#125;) // 设置被观察者在IO线程中进行 .subscribeOn(Schedulers.io()) // 设置观察者在主线程中进行 .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; try &#123; // 接收事件速度：5s / 个 Thread.sleep(5000); Log.d(TAG, "接收到了事件" + integer); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); 1.3 解决方案背压策略。 2. 背压策略简介2.1 定义一种控制事件流速的策略。 2.2 作用在异步订阅关系中，控制事件发送和接收的速度。 2.3 解决的问题解决因为被观察者发送事件速度和观察者接收事件速度不匹配，导致的观察者无法及时响应/处理所有被观察者发送事件的问题。 2.4 应用场景被观察者发送事件速度与观察者接收事件速度不匹配的场景。具体场景取决于该事件的类型，如：网络请求，具体场景：有很多网络请求需要执行，但执行者的执行速度没有那么快，此时就需要使用背压策略来控制。 3. 背压策略的原理RxJava实现背压策略Backpressure的原理： 避免出现事件发送和接收流速不匹配的情况： a. 控制观察者接收事件的速度：响应式拉拉取，响应式拉取，即观察者根据自身实际情况按需接收事件 b. 控制被观察者发送事件的速度：反馈控制，即被观察者根据观察者接收事件能力l来控制发送事件的速度 当出现事件发送和接收流速不匹配时的解决方案：采用背压策略模式，使用缓存区，对超出缓存区大小的事件进行丢弃、保留和报错的措施 示意图如下： 与RxJava 1.0 中的Observable相比： 在RxJava 2.0中的Flowable是什么呢？它其实是RxJava 2.0中被观察者的一种新的实现，同时也是背压策略实现的承载着。 4. 背压策略的具体实现：Flowable在RxJava 2.0中，采用Flowable来实现背压策略。 准确来说，是非阻塞式背压策略 4.1 Flowable介绍定义：在RxJava 2.0中，Observable的一种新实现。作用：实现非阻塞式背压策略。 4.2 Flowable特点 对应的Observer变为Subscriber：被观察者Flowable——观察者Subscriber 所有的操作符强制支持背压：Flowable中的操作符大多与旧有的Observable类似 缓存区存放策略：按发送的顺序保存在缓存区：即先发送先进入缓存区，先进入缓存区的事件先取出 默认的缓存区（队列）大小为128 下面是1.0与2.0观察者模型的对比图：实际上RxJava 2.0也保留了Observable——Observer的观察者模型。 4.3 与RxJava 1.0中被观察者的旧实现Observable的关系 为什么要采用Flowable实现背压，而不采用旧的Observable呢？原因：Observable无法很好解决背压问题。 背景：在RxJava 1.0中，Observable内部采用队列存储事件，在Android中，默认缓存大小为16 冲突：若发送事件速度 &gt; 接收事件速度时，队列中的数目可能会超过16个，从而导致Observable有很多事件不能被正确背压，最终抛出MissingBackpressureException。在RxJava 1.0也有解决背压的方案：手动减少被观察者发送的事件，降低被观察者发送事件的速度（采用延迟方式），但效果并不好，还是会出现丢失的可能性。 解决方案：采用RxJava 2.0被观察者的新实现Flowable来实现背压。 4.4 Flowable的基础使用使用方式类似于Observable。 1234567891011121314151617181920212223242526272829303132333435363738394041// 创建被观察者FlowableFlowable&lt;Integer&gt; upstream = Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; // 传入背压参数 @Override public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception &#123; emitter.onNext(1); emitter.onNext(2); emitter.onNext(3); emitter.onComplete(); &#125;&#125;, BackpressureStrategy.ERROR);// 创建观察者SubscriberSubscriber&lt;Integer&gt; downstream = new Subscriber&lt;Integer&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; // 对比Observable传入的Disposable参数，Subscriber这里传入的参数为Subscription // 相同点：Subscription具备Disposable参数的作用，可以通过调用Subscription.cancel()切断连接 // 不同点：Subscription增加了void request(long n) Log.d(TAG, "onSubscribe"); s.request(Long.MAX_VALUE); &#125; @Override public void onNext(Integer integer) &#123; Log.d(TAG, "onNext: " + integer); &#125; @Override public void onError(Throwable t) &#123; Log.w(TAG, "onError: ", t); &#125; @Override public void onComplete() &#123; Log.d(TAG, "onComplete"); &#125;&#125;;// 建立订阅关系upstream.subscribe(downstream); 12345D/MainActivity6: onSubscribeD/MainActivity6: onNext: 1D/MainActivity6: onNext: 2D/MainActivity6: onNext: 3D/MainActivity6: onComplete 更优雅的链式调用： 12345678910111213141516171819202122232425262728293031323334Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception &#123; Log.d(TAG, "发送事件 1"); emitter.onNext(1); Log.d(TAG, "发送事件 2"); emitter.onNext(2); Log.d(TAG, "发送事件 3"); emitter.onNext(3); Log.d(TAG, "发送完成"); emitter.onComplete(); &#125;&#125;, BackpressureStrategy.ERROR).subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; Log.d(TAG, "onSubscribe"); s.request(3); &#125; @Override public void onNext(Integer integer) &#123; Log.d(TAG, "接收到了事件" + integer); &#125; @Override public void onError(Throwable t) &#123; Log.w(TAG, "onError: ", t); &#125; @Override public void onComplete() &#123; Log.d(TAG, "onComplete"); &#125;&#125;); 5. 背压策略的使用前面说到，使用背压的场景一般是在异步订阅关系下的，所以下面主要讲解异步订阅关系场景，即被观察者和观察者工作在不同线程，但是，由于在同步订阅场景中也有可能出现流速不匹配的问题，所以会以同讲解一下。 5.1 控制观察者接收事件的速度5.1.1 异步订阅情况面向对象：观察者原理：响应式拉取，观察者根据自身实际情况按需接收事件。虽然观察者是响应式拉取接收事件，但被观察者还是一次性发送完毕。实现方式：Subscriber.Subscription.request()。 1234567891011121314151617181920212223242526272829303132333435363738394041Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception &#123; // 一共发送4个事件 Log.d(TAG, "发送事件 1"); emitter.onNext(1); Log.d(TAG, "发送事件 2"); emitter.onNext(2); Log.d(TAG, "发送事件 3"); emitter.onNext(3); Log.d(TAG, "发送事件 4"); emitter.onNext(4); Log.d(TAG, "发送完成"); emitter.onComplete(); &#125;&#125;, BackpressureStrategy.ERROR) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; // 观察者能够接收多少个事件 // 官方默认推荐使用Long.MAX_VALUE，即s.request(Long.MAX_VALUE); s.request(3); &#125; @Override public void onNext(Integer integer) &#123; Log.d(TAG, "接收到了事件" + integer); &#125; @Override public void onError(Throwable t) &#123; Log.w(TAG, "onError: ", t); &#125; @Override public void onComplete() &#123; Log.d(TAG, "onComplete"); &#125; &#125;); 12345678D/MainActivity6: 发送事件 1D/MainActivity6: 发送事件 2D/MainActivity6: 发送事件 3D/MainActivity6: 发送事件 4D/MainActivity6: 发送完成D/MainActivity6: 接收到了事件1D/MainActivity6: 接收到了事件2D/MainActivity6: 接收到了事件3 特别注意： 结论：对于异步订阅情况，若观察者没有设置Subscription.request(long n)，说明观察者不接受事件。此时被观察者仍能继续发送事件（存放在缓存区），等观察者需要时再取出。 解释：不设置Subscription.request(long n)，观察者虽然不能接收事件，但是由于异步订阅关系中存在缓存区（大小为128），所以被观察者仍然能继续发送事件并暂时存放到缓存区。当缓存区满（128个事件）时，就会溢出报错。只有当观察者有需求时，才调用request()从缓存区按需取出事件。 额外：缓存区大小默认为128个事件，由Flowable的bufferSize决定。 代码演示1：观察者不接收事件的情况下，被观察者继续发送事件并存到缓存区，再按需取出。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class Main7Activity extends AppCompatActivity &#123; private static final String TAG = "MainActivity7"; /** * 该按钮用于调用Subscription.request() */ private Button btn; /** * 用于保存Subscription对象 */ private Subscription mSubscription; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main7); btn = findViewById(R.id.button); btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; mSubscription.request(2); &#125; &#125;); Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception &#123; Log.d(TAG, "发送事件 1"); emitter.onNext(1); Log.d(TAG, "发送事件 2"); emitter.onNext(2); Log.d(TAG, "发送事件 3"); emitter.onNext(3); Log.d(TAG, "发送事件 4"); emitter.onNext(4); Log.d(TAG, "发送完成"); emitter.onComplete(); &#125; &#125;, BackpressureStrategy.ERROR) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; Log.d(TAG, "onSubscribe"); // 保存Subscription对象，等待点击按钮时（调用request(2)）观察者再接收事件 mSubscription = s; &#125; @Override public void onNext(Integer integer) &#123; Log.d(TAG, "接收到了事件" + integer); &#125; @Override public void onError(Throwable t) &#123; Log.w(TAG, "onError: ", t); &#125; @Override public void onComplete() &#123; Log.d(TAG, "onComplete"); &#125; &#125;); &#125;&#125; 12345678D/MainActivity7: onSubscribeD/MainActivity7: 发送事件 1D/MainActivity7: 发送事件 2D/MainActivity7: 发送事件 3D/MainActivity7: 发送事件 4D/MainActivity7: 发送完成D/MainActivity7: 接收到了事件1D/MainActivity7: 接收到了事件2 代码演示2：观察者不接收事件的情况下，被观察者连续发送事件，直到超出缓存区大小（128）。 1234567891011121314151617181920212223242526272829303132333435Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception &#123; // 一共发送129个事件，即超出了缓存区的大小 for (int i = 0; i &lt; 129; i++) &#123; Log.d(TAG, "发送了事件" + i); emitter.onNext(i); &#125; emitter.onComplete(); &#125;&#125;, BackpressureStrategy.ERROR) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; Log.d(TAG, "onSubscribe"); // 默认不设置可接收事件大小 &#125; @Override public void onNext(Integer integer) &#123; Log.d(TAG, "接收到了事件" + integer); &#125; @Override public void onError(Throwable t) &#123; Log.w(TAG, "onError: ", t); &#125; @Override public void onComplete() &#123; Log.d(TAG, "onComplete"); &#125; &#125;); 123456789101112131415162019-08-21 15:43:16.479 4703-4703/com.ly.allendemorx W/MainActivity7: onError: io.reactivex.exceptions.MissingBackpressureException: create: could not emit value due to lack of requests at io.reactivex.internal.operators.flowable.FlowableCreate$ErrorAsyncEmitter.onOverflow(FlowableCreate.java:438) at io.reactivex.internal.operators.flowable.FlowableCreate$NoOverflowBaseAsyncEmitter.onNext(FlowableCreate.java:406) at com.ly.allendemorx.Main7Activity$3.subscribe(Main7Activity.java:55) at io.reactivex.internal.operators.flowable.FlowableCreate.subscribeActual(FlowableCreate.java:71) at io.reactivex.Flowable.subscribe(Flowable.java:14827) at io.reactivex.Flowable.subscribe(Flowable.java:14774) at io.reactivex.internal.operators.flowable.FlowableSubscribeOn$SubscribeOnSubscriber.run(FlowableSubscribeOn.java:82) at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:66) at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:57) at java.util.concurrent.FutureTask.run(FutureTask.java:237) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:272) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1133) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:607) at java.lang.Thread.run(Thread.java:761) 5.1.2 同步订阅情况与异步订阅的区别： 同步订阅中，被观察者和观察者工作于同一线程 同步订阅中，没有缓存区 被观察者再发送一个事件后，必须等待观察者接收后，才能继续发送下一个事件。 1234567891011121314151617181920212223242526272829303132333435Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception &#123; // 发送3个事件 Log.d(TAG, "发送了事件1"); emitter.onNext(1); Log.d(TAG, "发送了事件2"); emitter.onNext(2); Log.d(TAG, "发送了事件3"); emitter.onNext(3); emitter.onComplete(); &#125;&#125;, BackpressureStrategy.ERROR) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; Log.d(TAG, "onSubscribe"); s.request(3); &#125; @Override public void onNext(Integer integer) &#123; Log.d(TAG, "接收到了事件" + integer); &#125; @Override public void onError(Throwable t) &#123; Log.w(TAG, "onError: ", t); &#125; @Override public void onComplete() &#123; Log.d(TAG, "onComplete"); &#125; &#125;); 12345678D/MainActivity7: onSubscribeD/MainActivity7: 发送了事件1D/MainActivity7: 接收到了事件1D/MainActivity7: 发送了事件2D/MainActivity7: 接收到了事件2D/MainActivity7: 发送了事件3D/MainActivity7: 接收到了事件3D/MainActivity7: onComplete 所以，同步订阅不会出现被观察者发送事件速度 ＞ 观察者接收事件速度的情况，而是会出现被观察者发送事件数量 ＞ 观察者接收事件数量的问题。 如：观察者子还能接收三个事件，被观察者发送了四个事件。 12345678910111213141516171819202122232425262728293031323334353637Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception &#123; // 被观察者发送事件数量 = 4个 Log.d(TAG, "发送了事件1"); emitter.onNext(1); Log.d(TAG, "发送了事件2"); emitter.onNext(2); Log.d(TAG, "发送了事件3"); emitter.onNext(3); Log.d(TAG, "发送了事件4"); emitter.onNext(4); emitter.onComplete(); &#125;&#125;, BackpressureStrategy.ERROR) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; Log.d(TAG, "onSubscribe"); s.request(3); &#125; @Override public void onNext(Integer integer) &#123; Log.d(TAG, "接收到了事件" + integer); &#125; @Override public void onError(Throwable t) &#123; Log.w(TAG, "onError: ", t); &#125; @Override public void onComplete() &#123; Log.d(TAG, "onComplete"); &#125; &#125;); 12345678910111213141516171819202122232425262728292019-08-21 15:52:30.381 5179-5179/com.ly.allendemorx D/MainActivity7: onSubscribe2019-08-21 15:52:30.388 5179-5179/com.ly.allendemorx D/MainActivity7: 发送了事件12019-08-21 15:52:30.388 5179-5179/com.ly.allendemorx D/MainActivity7: 接收到了事件12019-08-21 15:52:30.388 5179-5179/com.ly.allendemorx D/MainActivity7: 发送了事件22019-08-21 15:52:30.388 5179-5179/com.ly.allendemorx D/MainActivity7: 接收到了事件22019-08-21 15:52:30.388 5179-5179/com.ly.allendemorx D/MainActivity7: 发送了事件32019-08-21 15:52:30.388 5179-5179/com.ly.allendemorx D/MainActivity7: 接收到了事件32019-08-21 15:52:30.388 5179-5179/com.ly.allendemorx D/MainActivity7: 发送了事件42019-08-21 15:52:30.391 5179-5179/com.ly.allendemorx W/MainActivity7: onError: io.reactivex.exceptions.MissingBackpressureException: create: could not emit value due to lack of requests at io.reactivex.internal.operators.flowable.FlowableCreate$ErrorAsyncEmitter.onOverflow(FlowableCreate.java:438) at io.reactivex.internal.operators.flowable.FlowableCreate$NoOverflowBaseAsyncEmitter.onNext(FlowableCreate.java:406) at com.ly.allendemorx.Main7Activity$3.subscribe(Main7Activity.java:60) at io.reactivex.internal.operators.flowable.FlowableCreate.subscribeActual(FlowableCreate.java:71) at io.reactivex.Flowable.subscribe(Flowable.java:14827) at io.reactivex.Flowable.subscribe(Flowable.java:14777) at com.ly.allendemorx.Main7Activity.onCreate(Main7Activity.java:64) at android.app.Activity.performCreate(Activity.java:6692) at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1118) at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2621) at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2729) at android.app.ActivityThread.-wrap12(ActivityThread.java) at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1480) at android.os.Handler.dispatchMessage(Handler.java:102) at android.os.Looper.loop(Looper.java:154) at android.app.ActivityThread.main(ActivityThread.java:6169) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:891) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:781) 5.2 控制被观察者发送事件的速度面向对象：被观察者原理：反馈控制，被观察者根据观察者接收事件的能力控制发送事件的速度，观察者预先告知被观察者其事件接收的能力。实现方式：FlowableEmitter.requested() 1234567891011public interface FlowableEmitter&lt;T&gt; extends Emitter&lt;T&gt; &#123;// FlowableEmitter = 1个接口，继承自Emitter// Emitter接口方法包括：onNext(),onComplete() &amp; onError long requested(); // 作用：返回当前线程中request（a）中的a值 // 该request（a）则是措施1中讲解的方法，作用 = 设置 ....// 仅贴出关键代码&#125; 每个线程中的requested()的返回值为该线程中request(a)的a值。 5.2.1 同步订阅情况在同步订阅中，被观察者通过FlowableEmitter.requested()获得观察者自身接收事件能力，从而根据该信息控制事件发送速度，从而达到观察者反向控制被观察者的效果。 例子：被观察者根据观察者自身接收能力（10事件），从而进发送10个事件。 12345678910111213141516171819202122232425262728293031323334353637Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception &#123; // 获取当前观察者接收事件的能力 long l = emitter.requested(); Log.d(TAG, "观察者可接收事件" + l); // 根据获得的值，控制发送事件的数量 for (int i = 0; i &lt; l; i++) &#123; Log.d(TAG, "发送了事件" + i); emitter.onNext(i); &#125; &#125;&#125;, BackpressureStrategy.ERROR) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; Log.d(TAG, "onSubscribe"); // 设置观察者接收事件的能力 s.request(10); &#125; @Override public void onNext(Integer integer) &#123; Log.d(TAG, "接收到了事件" + integer); &#125; @Override public void onError(Throwable t) &#123; Log.w(TAG, "onError: ", t); &#125; @Override public void onComplete() &#123; Log.d(TAG, "onComplete"); &#125; &#125;); 12345678910111213141516171819202122D/MainActivity7: onSubscribeD/MainActivity7: 观察者可接收事件10D/MainActivity7: 发送了事件0D/MainActivity7: 接收到了事件0D/MainActivity7: 发送了事件1D/MainActivity7: 接收到了事件1D/MainActivity7: 发送了事件2D/MainActivity7: 接收到了事件2D/MainActivity7: 发送了事件3D/MainActivity7: 接收到了事件3D/MainActivity7: 发送了事件4D/MainActivity7: 接收到了事件4D/MainActivity7: 发送了事件5D/MainActivity7: 接收到了事件5D/MainActivity7: 发送了事件6D/MainActivity7: 接收到了事件6D/MainActivity7: 发送了事件7D/MainActivity7: 接收到了事件7D/MainActivity7: 发送了事件8D/MainActivity7: 接收到了事件8D/MainActivity7: 发送了事件9D/MainActivity7: 接收到了事件9 特别注意：在同步订阅时，使用FlowableEmitter.requested()时，要注意以下使用特性。 可叠加性：观察者可连续要求接收事件，被观察者会进行叠加，一起发送。 实时更新性：每次发送事件后，FlowableEmitter.requested()的返回值会实时更新观察者能接收的事件。 异常： 当FlowableEmitter.requested()返回0时，代表观察者已经不能接收事件，此时被观察者若继续发送事件，会抛出MissingBackpressureException 若观察者中没有设置可接收事件数量，即，没有调用Subscription.request()，那么被观察者默认观察者可接收事件为0，因为同步订阅中没有缓存区。 可叠加性观察者可连续要求接收事件，被观察者会进行叠加，一起发送。 1234Subscription.request（a1）；Subscription.request（a2）；FlowableEmitter.requested()的返回值 = a1 + a2 代码演示： 1234567891011121314151617181920212223242526272829303132Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception &#123; // 调用emitter.requested()获取当前观察者需要接收的事件数量 Log.d(TAG, "观察者可接收事件" + emitter.requested()); &#125;&#125;, BackpressureStrategy.ERROR) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; Log.d(TAG, "onSubscribe"); // 第1次设置观察者每次能接受10个事件 s.request(10); // 第2次设置观察者每次能接受20个事件 s.request(20); &#125; @Override public void onNext(Integer integer) &#123; Log.d(TAG, "接收到了事件" + integer); &#125; @Override public void onError(Throwable t) &#123; Log.w(TAG, "onError: ", t); &#125; @Override public void onComplete() &#123; Log.d(TAG, "onComplete"); &#125; &#125;); 12D/MainActivity7: onSubscribeD/MainActivity7: 观察者可接收事件30 实时更新性每次发送事件后，FlowableEmitter.requested()的返回值会实时更新观察者能接收的事件。 即一开始观察者可接收事件的数量为10，发送一个后，会实时更新为9。 仅计算Next事件，Complete和Error事件不算。 代码演示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception &#123; // 1. 调用emitter.requested()获取当前观察者需要接收的事件数量 Log.d(TAG, "观察者可接收事件数量 = " + emitter.requested()); // 2. 每次发送事件后，emitter.requested()会实时更新观察者能接受的事件 // 即一开始观察者要接收10个事件，发送了1个后，会实时更新为9个 Log.d(TAG, "发送了事件 1"); emitter.onNext(1); Log.d(TAG, "发送了事件1后, 还需要发送事件数量 = " + emitter.requested()); Log.d(TAG, "发送了事件 2"); emitter.onNext(2); Log.d(TAG, "发送事件2后, 还需要发送事件数量 = " + emitter.requested()); Log.d(TAG, "发送了事件 3"); emitter.onNext(3); Log.d(TAG, "发送事件3后, 还需要发送事件数量 = " + emitter.requested()); emitter.onComplete(); &#125;&#125;, BackpressureStrategy.ERROR) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; Log.d(TAG, "onSubscribe"); s.request(10); &#125; @Override public void onNext(Integer integer) &#123; Log.d(TAG, "接收到了事件" + integer); &#125; @Override public void onError(Throwable t) &#123; Log.w(TAG, "onError: ", t); &#125; @Override public void onComplete() &#123; Log.d(TAG, "onComplete"); &#125; &#125;); 123456789101112D/MainActivity7: onSubscribeD/MainActivity7: 观察者可接收事件数量 = 10D/MainActivity7: 发送了事件 1D/MainActivity7: 接收到了事件1D/MainActivity7: 发送了事件1后, 还需要发送事件数量 = 9D/MainActivity7: 发送了事件 2D/MainActivity7: 接收到了事件2D/MainActivity7: 发送事件2后, 还需要发送事件数量 = 8D/MainActivity7: 发送了事件 3D/MainActivity7: 接收到了事件3D/MainActivity7: 发送事件3后, 还需要发送事件数量 = 7D/MainActivity7: onComplete 异常当FlowableEmitter.requested()减到0时，则代表观察者已经不可接收事件，此时被观察者若继续发送事件，则会抛出MissingBackpressureException。代码演示： 1234567891011121314151617181920212223242526272829303132333435363738394041Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception &#123; // 1. 调用emitter.requested()获取当前观察者需要接收的事件数量 Log.d(TAG, "观察者可接收事件数量 = " + emitter.requested()); // 2. 每次发送事件后，emitter.requested()会实时更新观察者能接受的事件 // 即一开始观察者要接收10个事件，发送了1个后，会实时更新为9个 Log.d(TAG, "发送了事件 1"); emitter.onNext(1); Log.d(TAG, "发送了事件1后, 还需要发送事件数量 = " + emitter.requested()); Log.d(TAG, "发送了事件 2"); emitter.onNext(2); Log.d(TAG, "发送事件2后, 还需要发送事件数量 = " + emitter.requested()); emitter.onComplete(); &#125;&#125;, BackpressureStrategy.ERROR) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; Log.d(TAG, "onSubscribe"); s.request(1); &#125; @Override public void onNext(Integer integer) &#123; Log.d(TAG, "接收到了事件" + integer); &#125; @Override public void onError(Throwable t) &#123; Log.w(TAG, "onError: ", t); &#125; @Override public void onComplete() &#123; Log.d(TAG, "onComplete"); &#125; &#125;); 123456789101112131415161718192021222324252627282019-08-21 17:23:57.540 6023-6023/com.ly.allendemorx D/MainActivity7: onSubscribe2019-08-21 17:23:57.547 6023-6023/com.ly.allendemorx D/MainActivity7: 观察者可接收事件数量 = 12019-08-21 17:23:57.547 6023-6023/com.ly.allendemorx D/MainActivity7: 发送了事件 12019-08-21 17:23:57.547 6023-6023/com.ly.allendemorx D/MainActivity7: 接收到了事件12019-08-21 17:23:57.547 6023-6023/com.ly.allendemorx D/MainActivity7: 发送了事件1后, 还需要发送事件数量 = 02019-08-21 17:23:57.547 6023-6023/com.ly.allendemorx D/MainActivity7: 发送了事件 22019-08-21 17:23:57.551 6023-6023/com.ly.allendemorx W/MainActivity7: onError: io.reactivex.exceptions.MissingBackpressureException: create: could not emit value due to lack of requests at io.reactivex.internal.operators.flowable.FlowableCreate$ErrorAsyncEmitter.onOverflow(FlowableCreate.java:438) at io.reactivex.internal.operators.flowable.FlowableCreate$NoOverflowBaseAsyncEmitter.onNext(FlowableCreate.java:406) at com.ly.allendemorx.Main7Activity$3.subscribe(Main7Activity.java:62) at io.reactivex.internal.operators.flowable.FlowableCreate.subscribeActual(FlowableCreate.java:71) at io.reactivex.Flowable.subscribe(Flowable.java:14827) at io.reactivex.Flowable.subscribe(Flowable.java:14777) at com.ly.allendemorx.Main7Activity.onCreate(Main7Activity.java:68) at android.app.Activity.performCreate(Activity.java:6692) at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1118) at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2621) at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2729) at android.app.ActivityThread.-wrap12(ActivityThread.java) at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1480) at android.os.Handler.dispatchMessage(Handler.java:102) at android.os.Looper.loop(Looper.java:154) at android.app.ActivityThread.main(ActivityThread.java:6169) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:891) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:781)2019-08-21 17:23:57.551 6023-6023/com.ly.allendemorx D/MainActivity7: 发送事件2后, 还需要发送事件数量 = 0 5.2.2 异步订阅情况由于二者不在同一线程，所以被观察者无法通过FlowableEmitter.requested()获取观察者接收事件的能力。 1234567891011121314151617181920212223242526272829303132Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception &#123; Log.d(TAG, "观察者可接收事件数量 = " + emitter.requested()); &#125;&#125;, BackpressureStrategy.ERROR) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; Log.d(TAG, "onSubscribe"); // 该设置仅影响观察者线程中的requested，却不会影响的被观察者中的FlowableEmitter.requested()的返回值 // 因为FlowableEmitter.requested()的返回值 取决于RxJava内部调用request(n)，而该内部调用会在一开始就调用request(128) s.request(150); &#125; @Override public void onNext(Integer integer) &#123; Log.d(TAG, "接收到了事件" + integer); &#125; @Override public void onError(Throwable t) &#123; Log.w(TAG, "onError: ", t); &#125; @Override public void onComplete() &#123; Log.d(TAG, "onComplete"); &#125; &#125;); 12D/MainActivity7: onSubscribeD/MainActivity7: 观察者可接收事件数量 = 128 在异步订阅中，反向控制的原理是：通过RxJava内部固定调用被观察者线程中的request(n)，从而方向控制被观察者的发送事件速度。 那么该在什么时候调用被观察者线程中的request(n)，n的值该是多少呢？ 关于RxJava内部调用request(n)（n = 128、96、0）的逻辑如下： 至于为什么调用request(128)、request(96)、request(0)，可以查看Flowable的源码 代码演示：被观察者一共需要发送500个事件，但真正开始发送事件的前提为FlowableEmtter.requested()的返回值不为0；观察者每次接收48个事件（点击按钮接收事件）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class Main7Activity extends AppCompatActivity &#123; private static final String TAG = "MainActivity7"; /** * 该按钮用于调用Subscription.request() */ private Button btn; /** * 用于保存Subscription对象 */ private Subscription mSubscription; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main7); btn = findViewById(R.id.button); // 点击按钮接收事件，每次接收48个事件 btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; mSubscription.request(48); &#125; &#125;); Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception &#123; Log.d(TAG, "观察者可接收事件数量 = " + emitter.requested()); //设置标记位控制 boolean flag; // 被观察者一共需要发送500个事件 for (int i = 0; i &lt; 500; i++) &#123; flag = false; // 若requested() == 0，则不发送 while (emitter.requested() == 0) &#123; if (!flag) &#123; Log.d(TAG, "不再发送"); flag = true; &#125; &#125; // requested() ≠ 0 才发送 Log.d(TAG, "发送了事件" + i + "，观察者可接收事件数量 = " + emitter.requested()); emitter.onNext(i); &#125; &#125; &#125;, BackpressureStrategy.ERROR) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; Log.d(TAG, "onSubscribe"); // 初始状态 = 不接收事件；通过点击按钮接收事件 mSubscription = s; &#125; @Override public void onNext(Integer integer) &#123; Log.d(TAG, "接收到了事件" + integer); &#125; @Override public void onError(Throwable t) &#123; Log.w(TAG, "onError: ", t); &#125; @Override public void onComplete() &#123; Log.d(TAG, "onComplete"); &#125; &#125;); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181D/MainActivity7: onSubscribeD/MainActivity7: 观察者可接收事件数量 = 128D/MainActivity7: 发送了事件0，观察者可接收事件数量 = 128D/MainActivity7: 发送了事件1，观察者可接收事件数量 = 127D/MainActivity7: 发送了事件2，观察者可接收事件数量 = 126D/MainActivity7: 发送了事件3，观察者可接收事件数量 = 125D/MainActivity7: 发送了事件4，观察者可接收事件数量 = 124D/MainActivity7: 发送了事件5，观察者可接收事件数量 = 123D/MainActivity7: 发送了事件6，观察者可接收事件数量 = 122D/MainActivity7: 发送了事件7，观察者可接收事件数量 = 121D/MainActivity7: 发送了事件8，观察者可接收事件数量 = 120D/MainActivity7: 发送了事件9，观察者可接收事件数量 = 119D/MainActivity7: 发送了事件10，观察者可接收事件数量 = 118D/MainActivity7: 发送了事件11，观察者可接收事件数量 = 117D/MainActivity7: 发送了事件12，观察者可接收事件数量 = 116D/MainActivity7: 发送了事件13，观察者可接收事件数量 = 115D/MainActivity7: 发送了事件14，观察者可接收事件数量 = 114D/MainActivity7: 发送了事件15，观察者可接收事件数量 = 113D/MainActivity7: 发送了事件16，观察者可接收事件数量 = 112D/MainActivity7: 发送了事件17，观察者可接收事件数量 = 111D/MainActivity7: 发送了事件18，观察者可接收事件数量 = 110D/MainActivity7: 发送了事件19，观察者可接收事件数量 = 109D/MainActivity7: 发送了事件20，观察者可接收事件数量 = 108D/MainActivity7: 发送了事件21，观察者可接收事件数量 = 107D/MainActivity7: 发送了事件22，观察者可接收事件数量 = 106D/MainActivity7: 发送了事件23，观察者可接收事件数量 = 105D/MainActivity7: 发送了事件24，观察者可接收事件数量 = 104D/MainActivity7: 发送了事件25，观察者可接收事件数量 = 103D/MainActivity7: 发送了事件26，观察者可接收事件数量 = 102D/MainActivity7: 发送了事件27，观察者可接收事件数量 = 101D/MainActivity7: 发送了事件28，观察者可接收事件数量 = 100D/MainActivity7: 发送了事件29，观察者可接收事件数量 = 99D/MainActivity7: 发送了事件30，观察者可接收事件数量 = 98D/MainActivity7: 发送了事件31，观察者可接收事件数量 = 97D/MainActivity7: 发送了事件32，观察者可接收事件数量 = 96D/MainActivity7: 发送了事件33，观察者可接收事件数量 = 95D/MainActivity7: 发送了事件34，观察者可接收事件数量 = 94D/MainActivity7: 发送了事件35，观察者可接收事件数量 = 93D/MainActivity7: 发送了事件36，观察者可接收事件数量 = 92D/MainActivity7: 发送了事件37，观察者可接收事件数量 = 91D/MainActivity7: 发送了事件38，观察者可接收事件数量 = 90D/MainActivity7: 发送了事件39，观察者可接收事件数量 = 89D/MainActivity7: 发送了事件40，观察者可接收事件数量 = 88D/MainActivity7: 发送了事件41，观察者可接收事件数量 = 87D/MainActivity7: 发送了事件42，观察者可接收事件数量 = 86D/MainActivity7: 发送了事件43，观察者可接收事件数量 = 85D/MainActivity7: 发送了事件44，观察者可接收事件数量 = 84D/MainActivity7: 发送了事件45，观察者可接收事件数量 = 83D/MainActivity7: 发送了事件46，观察者可接收事件数量 = 82D/MainActivity7: 发送了事件47，观察者可接收事件数量 = 81D/MainActivity7: 发送了事件48，观察者可接收事件数量 = 80D/MainActivity7: 发送了事件49，观察者可接收事件数量 = 79D/MainActivity7: 发送了事件50，观察者可接收事件数量 = 78D/MainActivity7: 发送了事件51，观察者可接收事件数量 = 77D/MainActivity7: 发送了事件52，观察者可接收事件数量 = 76D/MainActivity7: 发送了事件53，观察者可接收事件数量 = 75D/MainActivity7: 发送了事件54，观察者可接收事件数量 = 74D/MainActivity7: 发送了事件55，观察者可接收事件数量 = 73D/MainActivity7: 发送了事件56，观察者可接收事件数量 = 72D/MainActivity7: 发送了事件57，观察者可接收事件数量 = 71D/MainActivity7: 发送了事件58，观察者可接收事件数量 = 70D/MainActivity7: 发送了事件59，观察者可接收事件数量 = 69D/MainActivity7: 发送了事件60，观察者可接收事件数量 = 68D/MainActivity7: 发送了事件61，观察者可接收事件数量 = 67D/MainActivity7: 发送了事件62，观察者可接收事件数量 = 66D/MainActivity7: 发送了事件63，观察者可接收事件数量 = 65D/MainActivity7: 发送了事件64，观察者可接收事件数量 = 64D/MainActivity7: 发送了事件65，观察者可接收事件数量 = 63D/MainActivity7: 发送了事件66，观察者可接收事件数量 = 62D/MainActivity7: 发送了事件67，观察者可接收事件数量 = 61D/MainActivity7: 发送了事件68，观察者可接收事件数量 = 60D/MainActivity7: 发送了事件69，观察者可接收事件数量 = 59D/MainActivity7: 发送了事件70，观察者可接收事件数量 = 58D/MainActivity7: 发送了事件71，观察者可接收事件数量 = 57D/MainActivity7: 发送了事件72，观察者可接收事件数量 = 56D/MainActivity7: 发送了事件73，观察者可接收事件数量 = 55D/MainActivity7: 发送了事件74，观察者可接收事件数量 = 54D/MainActivity7: 发送了事件75，观察者可接收事件数量 = 53D/MainActivity7: 发送了事件76，观察者可接收事件数量 = 52D/MainActivity7: 发送了事件77，观察者可接收事件数量 = 51D/MainActivity7: 发送了事件78，观察者可接收事件数量 = 50D/MainActivity7: 发送了事件79，观察者可接收事件数量 = 49D/MainActivity7: 发送了事件80，观察者可接收事件数量 = 48D/MainActivity7: 发送了事件81，观察者可接收事件数量 = 47D/MainActivity7: 发送了事件82，观察者可接收事件数量 = 46D/MainActivity7: 发送了事件83，观察者可接收事件数量 = 45D/MainActivity7: 发送了事件84，观察者可接收事件数量 = 44D/MainActivity7: 发送了事件85，观察者可接收事件数量 = 43D/MainActivity7: 发送了事件86，观察者可接收事件数量 = 42D/MainActivity7: 发送了事件87，观察者可接收事件数量 = 41D/MainActivity7: 发送了事件88，观察者可接收事件数量 = 40D/MainActivity7: 发送了事件89，观察者可接收事件数量 = 39D/MainActivity7: 发送了事件90，观察者可接收事件数量 = 38D/MainActivity7: 发送了事件91，观察者可接收事件数量 = 37D/MainActivity7: 发送了事件92，观察者可接收事件数量 = 36D/MainActivity7: 发送了事件93，观察者可接收事件数量 = 35D/MainActivity7: 发送了事件94，观察者可接收事件数量 = 34D/MainActivity7: 发送了事件95，观察者可接收事件数量 = 33D/MainActivity7: 发送了事件96，观察者可接收事件数量 = 32D/MainActivity7: 发送了事件97，观察者可接收事件数量 = 31D/MainActivity7: 发送了事件98，观察者可接收事件数量 = 30D/MainActivity7: 发送了事件99，观察者可接收事件数量 = 29D/MainActivity7: 发送了事件100，观察者可接收事件数量 = 28D/MainActivity7: 发送了事件101，观察者可接收事件数量 = 27D/MainActivity7: 发送了事件102，观察者可接收事件数量 = 26D/MainActivity7: 发送了事件103，观察者可接收事件数量 = 25D/MainActivity7: 发送了事件104，观察者可接收事件数量 = 24D/MainActivity7: 发送了事件105，观察者可接收事件数量 = 23D/MainActivity7: 发送了事件106，观察者可接收事件数量 = 22D/MainActivity7: 发送了事件107，观察者可接收事件数量 = 21D/MainActivity7: 发送了事件108，观察者可接收事件数量 = 20D/MainActivity7: 发送了事件109，观察者可接收事件数量 = 19D/MainActivity7: 发送了事件110，观察者可接收事件数量 = 18D/MainActivity7: 发送了事件111，观察者可接收事件数量 = 17D/MainActivity7: 发送了事件112，观察者可接收事件数量 = 16D/MainActivity7: 发送了事件113，观察者可接收事件数量 = 15D/MainActivity7: 发送了事件114，观察者可接收事件数量 = 14D/MainActivity7: 发送了事件115，观察者可接收事件数量 = 13D/MainActivity7: 发送了事件116，观察者可接收事件数量 = 12D/MainActivity7: 发送了事件117，观察者可接收事件数量 = 11D/MainActivity7: 发送了事件118，观察者可接收事件数量 = 10D/MainActivity7: 发送了事件119，观察者可接收事件数量 = 9D/MainActivity7: 发送了事件120，观察者可接收事件数量 = 8D/MainActivity7: 发送了事件121，观察者可接收事件数量 = 7D/MainActivity7: 发送了事件122，观察者可接收事件数量 = 6D/MainActivity7: 发送了事件123，观察者可接收事件数量 = 5D/MainActivity7: 发送了事件124，观察者可接收事件数量 = 4D/MainActivity7: 发送了事件125，观察者可接收事件数量 = 3D/MainActivity7: 发送了事件126，观察者可接收事件数量 = 2D/MainActivity7: 发送了事件127，观察者可接收事件数量 = 1D/MainActivity7: 不再发送D/MainActivity7: 接收到了事件0D/MainActivity7: 接收到了事件1D/MainActivity7: 接收到了事件2D/MainActivity7: 接收到了事件3D/MainActivity7: 接收到了事件4D/MainActivity7: 接收到了事件5D/MainActivity7: 接收到了事件6D/MainActivity7: 接收到了事件7D/MainActivity7: 接收到了事件8D/MainActivity7: 接收到了事件9D/MainActivity7: 接收到了事件10D/MainActivity7: 接收到了事件11D/MainActivity7: 接收到了事件12D/MainActivity7: 接收到了事件13D/MainActivity7: 接收到了事件14D/MainActivity7: 接收到了事件15D/MainActivity7: 接收到了事件16D/MainActivity7: 接收到了事件17D/MainActivity7: 接收到了事件18D/MainActivity7: 接收到了事件19D/MainActivity7: 接收到了事件20D/MainActivity7: 接收到了事件21D/MainActivity7: 接收到了事件22D/MainActivity7: 接收到了事件23D/MainActivity7: 接收到了事件24D/MainActivity7: 接收到了事件25D/MainActivity7: 接收到了事件26D/MainActivity7: 接收到了事件27D/MainActivity7: 接收到了事件28D/MainActivity7: 接收到了事件29D/MainActivity7: 接收到了事件30D/MainActivity7: 接收到了事件31D/MainActivity7: 接收到了事件32D/MainActivity7: 接收到了事件33D/MainActivity7: 接收到了事件34D/MainActivity7: 接收到了事件35D/MainActivity7: 接收到了事件36D/MainActivity7: 接收到了事件37D/MainActivity7: 接收到了事件38D/MainActivity7: 接收到了事件39D/MainActivity7: 接收到了事件40D/MainActivity7: 接收到了事件41D/MainActivity7: 接收到了事件42D/MainActivity7: 接收到了事件43D/MainActivity7: 接收到了事件44D/MainActivity7: 接收到了事件45D/MainActivity7: 接收到了事件46D/MainActivity7: 接收到了事件47 5.3 采用背压策略模式：BackpressureStrategy5.3.1 背压模式介绍在Flowable中要求传入背压模式参数。 面向对象：针对缓存区。作用：当缓存区存满、被观察者仍然继续发送下一个事件时，如何处理的策略方式。 5.3.2 背压模式类型： 需要解决的问题：流速不匹配，发送事件速度 ＞ 接收事件速度，具体表现为当缓存区存满时，被观察者仍然继续发送下一个事件。 类型： BackpressureStrategy.ERROR：直接抛出异常MissingBackpressureException BackpressureStrategy.MISSING：友好提示，缓存区满了 BackpressureStrategy.BUFFER：将缓存区大小设置成无限大，即，被观察者可以无限发送事件到缓存区 BackpressureStrategy.DROP：超过缓存区大小（128）的事件丢弃 BackpressureStrategy.LATEST：只保存最新（最后）事件，超过缓存区大小（128）的事件丢弃 5.3.3 特别注意使用背压策略模式时，有一点要注意： 背景Flowable可以通过自己创建，或者通过其他方式自动创建，如interval操作符。 interval操作符简介 作用：每间隔一段时间产生一个数字（Long类型），从0开始、一次递增1，直至无穷大 默认运行在一个新的线程上 与timer()操作符区别：timer()操作符可结束发送 冲突对于手动创建Flowable的情况，可以通过传入背压模式参数选择背压策略，但是对于自动创建Flowable，就无法手动传入背压模式参数，这时，出现流速不匹配的情况，该如何处理？ 1234567891011121314151617181920212223242526272829303132333435363738// 通过interval自动创建被观察者Flowable// 每隔1ms将当前数字（从0开始）加1，并发送出去// interval操作符会默认开启一个新的工作线程Flowable.interval(1, TimeUnit.MILLISECONDS) // 观察者同样工作在一个新的线程 .observeOn(Schedulers.newThread()) .subscribe(new Subscriber&lt;Long&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; Log.d(TAG, "onSubscribe"); mSubscription = s; // 默认可以接收Long.MAX_VALUE个事件 s.request(Long.MAX_VALUE); &#125; @Override public void onNext(Long aLong) &#123; Log.d(TAG, "onNext: " + aLong); try &#123; // 每延迟一秒再接收事件 Thread.sleep(1000); // 因为发送事件为延时1ms，接收事件为延时1s，出现了发送速度与接收速度不匹配的问题 // 缓存区很快就存满了128个事件，从而抛出MissingBackpressureException &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onError(Throwable t) &#123; Log.w(TAG, "onError: ", t); &#125; @Override public void onComplete() &#123; Log.d(TAG, "onComplete"); &#125; &#125;); 解决方案RxJava 2.0内部提供了封装背压策略模式的方法： onBackpressureBuffer() onBackpressureDrop() onBackpressureLatest() 默认采用了BackpressureStrategy.ERROR模式。 代码演示： 1234567891011121314151617181920212223242526272829303132333435Flowable.interval(1, TimeUnit.MILLISECONDS) // 添加背压策略模式 .onBackpressureBuffer() // 观察者同样工作在一个新的线程 .observeOn(Schedulers.newThread()) .subscribe(new Subscriber&lt;Long&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; Log.d(TAG, "onSubscribe"); mSubscription = s; // 默认可以接收Long.MAX_VALUE个事件 s.request(Long.MAX_VALUE); &#125; @Override public void onNext(Long aLong) &#123; Log.d(TAG, "onNext: " + aLong); try &#123; // 每延迟一秒再接收事件 Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onError(Throwable t) &#123; Log.w(TAG, "onError: ", t); &#125; @Override public void onComplete() &#123; Log.d(TAG, "onComplete"); &#125; &#125;); Demo地址：Allen_Demo_Rx]]></content>
      <categories>
        <category>Android</category>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android RxJava：条件/布尔操作符]]></title>
    <url>%2F2019%2F08%2F20%2FAndroid-RxJava%EF%BC%9A%E6%9D%A1%E4%BB%B6-%E5%B8%83%E5%B0%94%E6%93%8D%E4%BD%9C%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[1. 作用通过设置函数，判断Obsevable发送的事件是否符合条件。 2. 类型 3. 详解3.1 all()作用：判断发送的每项数据是否都满足设置的函数条件。若满足，返回true；否则，返回false。 12345678910111213Observable.just(1, 2, 3, 4, 5, 6) .all(new Predicate&lt;Integer&gt;() &#123; @Override public boolean test(Integer integer) throws Exception &#123; // 判断发送的所有数据是否都≤10 return integer &lt;= 10; &#125; &#125;).subscribe(new Consumer&lt;Boolean&gt;() &#123; @Override public void accept(Boolean aBoolean) throws Exception &#123; Log.d(TAG, "result is " + aBoolean); &#125;&#125;); 1D/MainActivity5: result is true 3.2 takeWhile()作用：判断发送的每项数据是否满足设置函数的条件。若发送的数据满足条件，则发送该项数据，否则不发送。 123456789101112Observable.interval(1, TimeUnit.SECONDS) .takeWhile(new Predicate&lt;Long&gt;() &#123; @Override public boolean test(Long aLong) throws Exception &#123; return aLong &lt;= 5; &#125; &#125;).subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(Long aLong) throws Exception &#123; Log.d(TAG, "发送了事件 " + aLong); &#125;&#125;); 123456D/MainActivity5: 发送了事件 0D/MainActivity5: 发送了事件 1D/MainActivity5: 发送了事件 2D/MainActivity5: 发送了事件 3D/MainActivity5: 发送了事件 4D/MainActivity5: 发送了事件 5 3.3 skipWhile()作用：判断发送的每项数据是否满足设置的函数条件。直到该判断条件为false时，才开始发送Observable的数据。 12345678910111213Observable.interval(1, TimeUnit.SECONDS) .skipWhile(new Predicate&lt;Long&gt;() &#123; @Override public boolean test(Long aLong) throws Exception &#123; // 直到发射的数据≥5时，才开始发送 return aLong &lt; 5; &#125; &#125;).subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(Long aLong) throws Excaeption &#123; Log.d(TAG, "发送了事件 " + aLong); &#125;&#125;); 1234567D/MainActivity5: 发送了事件 5D/MainActivity5: 发送了事件 6D/MainActivity5: 发送了事件 7D/MainActivity5: 发送了事件 8D/MainActivity5: 发送了事件 9D/MainActivity5: 发送了事件 10D/MainActivity5: 发送了事件 11 3.4 takeUtil()作用：执行到某个条件时，停止发送事件。 12345678910111213Observable.interval(1, TimeUnit.SECONDS) .takeUntil(new Predicate&lt;Long&gt;() &#123; @Override public boolean test(Long aLong) throws Exception &#123; // 直到发射的数据＞3时，停止发送事件 return aLong &gt; 3; &#125; &#125;).subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(Long aLong) throws Exception &#123; Log.d(TAG, "发送了事件 " + aLong); &#125;&#125;); 12345D/MainActivity5: 发送了事件 0D/MainActivity5: 发送了事件 1D/MainActivity5: 发送了事件 2D/MainActivity5: 发送了事件 3D/MainActivity5: 发送了事件 4 该判断条件也可以是Observable，即等到takeUtil()传入的Observable开始发送函数，（原始）第一个Observable的数据停止发送数据。 12345678910111213141516171819202122232425// 原始第一个Observable，每个1s发送一个数据Observable.interval(1, TimeUnit.SECONDS) // 第二个Observable，延迟5s后开始发送第一个数据 .takeUntil(Observable.timer(5, TimeUnit.SECONDS)) .subscribe(new Observer&lt;Long&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, "开始采用subscribe连接"); &#125; @Override public void onNext(Long aLong) &#123; Log.d(TAG, "接收到了事件" + aLong); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, "对Error事件作出响应"); &#125; @Override public void onComplete() &#123; Log.d(TAG, "对Complete事件作出响应"); &#125; &#125;); 当第5s时，第二个Observable开始发送数据，于是（原始）第一个Observable停止发送数据。 123456D/MainActivity5: 开始采用subscribe连接D/MainActivity5: 接收到了事件0D/MainActivity5: 接收到了事件1D/MainActivity5: 接收到了事件2D/MainActivity5: 接收到了事件3D/MainActivity5: 对Complete事件作出响应 3.5 skipUtil()作用：等到skipUtil()传入的Observable开始发送数据，（原始）第一个Observable才开始发送数据。 12345678910// （原始）第1个ObservableObservable.interval(1, TimeUnit.SECONDS) // 第2个Observable，延迟5s后开始发送型数据 .skipUntil(Observable.timer(5, TimeUnit.SECONDS)) .subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(Long aLong) throws Exception &#123; Log.d(TAG, "接收到了事件" + aLong); &#125; &#125;); 1234567D/MainActivity5: 接收到了事件4D/MainActivity5: 接收到了事件5D/MainActivity5: 接收到了事件6D/MainActivity5: 接收到了事件7D/MainActivity5: 接收到了事件8D/MainActivity5: 接收到了事件9D/MainActivity5: 接收到了事件10 3.6 sequenceEqual()作用：判断两个Observable需要发送的数据是否相同。若相同，返回true，反之，返回false。 123456789Observable.sequenceEqual( Observable.just(1, 3, 5), Observable.just(1, 3, 5)).subscribe(new Consumer&lt;Boolean&gt;() &#123; @Override public void accept(Boolean aBoolean) throws Exception &#123; Log.d(TAG, "2个Observable是否相同：" + aBoolean); &#125;&#125;); 1D/MainActivity5: 2个Observable是否相同：true 3.7 contains()作用：判断发送的数据中是否包含指定数据。若包含，返回true，反之，返回false。在其内部实现了exists()。 12345678Observable.just(1, 2, 3, 4, 5) .contains(3) .subscribe(new Consumer&lt;Boolean&gt;() &#123; @Override public void accept(Boolean aBoolean) throws Exception &#123; Log.d(TAG, "result is " + aBoolean); &#125; &#125;); 1D/MainActivity5: result is true 3.8 isEmpty()作用：判断发送的数据是否为空。若为空，返回true，反之，返回false。 12345678Observable.just(1, 2, 3, 4, 5) .isEmpty() .subscribe(new Consumer&lt;Boolean&gt;() &#123; @Override public void accept(Boolean aBoolean) throws Exception &#123; Log.d(TAG, "result is " + aBoolean); &#125; &#125;); 1D/MainActivity5: result is false 3.9 amb()作用：当需要发送多个Observable时，只发送先发送数据的Observable的数据，而其余Observable则被丢弃。 123456789101112131415// 设置两个需要发送的Observable，并放到集合中List&lt;ObservableSource&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();// 第一个Observable，延迟一秒发送数据list.add(Observable.just(1, 2, 3).delay(1, TimeUnit.SECONDS));// 第二个Observable，正常发送数据list.add(Observable.just(4, 5, 6));// 使用amba()，这样仅发送先发送数据的Observable，即第二个Observable，第一个因为延迟，被丢弃Observable.amb(list) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, "接收到了事件 " + integer); &#125; &#125;); 123D/MainActivity5: 接收到了事件 4D/MainActivity5: 接收到了事件 5D/MainActivity5: 接收到了事件 6 3.10 defaultEmpty()作用：在不发送任何有效事件（Next事件）、仅发送Complete事件的前提下，发送一个默认值。 123456789101112131415Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; // 不发送任何事件，仅发送Complete事件 emitter.onComplete(); &#125;&#125;) // 仅发送Complete事件时，默认发送10 .defaultIfEmpty(10) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, "接收到了事件" + integer); &#125; &#125;); 1D/MainActivity5: 接收到了事件10 Demo地址：Allen_Demo_Rx]]></content>
      <categories>
        <category>Android</category>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android RxJava：过滤操作符]]></title>
    <url>%2F2019%2F08%2F19%2FAndroid-RxJava%EF%BC%9A%E8%BF%87%E6%BB%A4%E6%93%8D%E4%BD%9C%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[1. 作用过滤/筛选Observable发送的事件和Observer接收的事件。 2. 类型RxJava中，过滤操作符的类型包括： 根据指定条件过滤事件：Filter()、ofType()、skip()、skipLast()、distinct()、distinctUntilChanged() 根据指定事件数量过滤事件：take()、takeLast() 根据指定事件过滤：throttleFirst()、throttleLast()、sample()、throttleWithTimeout()、debounce() 根据指定事件位置过滤事件：firstElement()、lastElement()、elementAt()、emelentAtOrErorr() 3. 讲解3.1 根据指定条件过滤作用：通过设置指定的过滤条件，当且仅当该事件满足条件时，就将该事件过滤（即不发送）。 操作符：Filter()作用：过滤特定条件的事件。 原理： 123456789101112131415161718192021222324252627282930313233343536373839404142Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; // 1. 发送5个事件 emitter.onNext(1); emitter.onNext(2); emitter.onNext(3); emitter.onNext(4); emitter.onNext(5); &#125;&#125;) // 采用filter()变换操作符 .filter(new Predicate&lt;Integer&gt;() &#123; // 根据test()的返回值，对被观察者发送的事件进行过滤并筛选 // a. 返回true，则继续发送 // b. 返回false，则不发送（过滤） @Override public boolean test(Integer integer) throws Exception &#123; // 过滤≤3的事件 return integer &gt; 3; &#125; &#125;).subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, "开始采用subscribe连接"); &#125; @Override public void onNext(Integer value) &#123; Log.d(TAG, "过滤后得到的事件是：" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, "对Error事件作出响应"); &#125; @Override public void onComplete() &#123; Log.d(TAG, "对Complete事件作出响应"); &#125;&#125;); 123D/MainActivity4: 开始采用subscribe连接D/MainActivity4: 过滤后得到的事件是：4D/MainActivity4: 过滤后得到的事件是：5 操作符：ofType()作用：过滤特定数据类型的事件。 123456789Observable.just(1, "Allen", 3, "liu", 5) // 筛选出整型 .ofType(Integer.class) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, "获取到的整型事件元素是： " + integer); &#125; &#125;); 123D/MainActivity4: 获取到的整型事件元素是： 1D/MainActivity4: 获取到的整型事件元素是： 3D/MainActivity4: 获取到的整型事件元素是： 5 操作符：skip()和skipLast()作用：跳过某个事件 1234567891011121314151617181920212223242526// 使用1：根据顺序跳过数据项Observable.just(1, 2, 3, 4, 5) // 跳过正序的前一项 .skip(1) // 跳过正序的后两项 .skipLast(2) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, "获取到的整型事件元素是： " + integer); &#125; &#125;);// 使用2：根据时间跳过数据项// 发送数据0-5，每间隔1s发送一次，每次递增1，第一次发送延迟0sObservable.intervalRange(0, 5, 0, 1, TimeUnit.SECONDS) // 跳过第1s发送的数据 .skip(1, TimeUnit.SECONDS) // 跳过最后1s发送的数据 .skipLast(1, TimeUnit.SECONDS) .subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(Long aLong) throws Exception &#123; Log.d(TAG, "获取到的整型事件元素是： " + aLong); &#125; &#125;); 12345D/MainActivity4: 获取到的整型事件元素是： 2D/MainActivity4: 获取到的整型事件元素是： 3D/MainActivity4: 获取到的整型事件元素是： 1D/MainActivity4: 获取到的整型事件元素是： 2D/MainActivity4: 获取到的整型事件元素是： 3 操作符：distinct()和distinctUntilChanged()作用：过滤事件序列中重复的事件/连续重复的事件。 1234567891011121314151617181920// 使用1：过滤事件序列中重复的事件Observable.just(1, 2, 3, 1, 2) .distinct() .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, "不重复的整型事件元素是： " + integer); &#125; &#125;);// 使用2：过滤事件序列中 连续重复的事件// 下面序列中，连续重复的事件 = 3、4Observable.just(1, 2, 3, 1, 2, 3, 3, 4, 4) .distinctUntilChanged() .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, "不连续重复的整型事件元素是： " + integer); &#125; &#125;); 12345678910D/MainActivity4: 不重复的整型事件元素是： 1D/MainActivity4: 不重复的整型事件元素是： 2D/MainActivity4: 不重复的整型事件元素是： 3D/MainActivity4: 不连续重复的整型事件元素是： 1D/MainActivity4: 不连续重复的整型事件元素是： 2D/MainActivity4: 不连续重复的整型事件元素是： 3D/MainActivity4: 不连续重复的整型事件元素是： 1D/MainActivity4: 不连续重复的整型事件元素是： 2D/MainActivity4: 不连续重复的整型事件元素是： 3D/MainActivity4: 不连续重复的整型事件元素是： 4 3.2 根据指定事件数量过滤事件作用：通过设置指定的事件数量，仅发送特定数量的事件。 操作符：take()作用：指定观察者最多能接收到的事件数量原理： 123456789101112131415161718Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; // 发送5个事件 emitter.onNext(1); emitter.onNext(2); emitter.onNext(3); emitter.onNext(4); emitter.onNext(5); &#125;&#125;) // 采用take()操作符，指定观察者只能接收2个事件 .take(2).subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, "过滤后得到的事件是：" + integer); &#125;&#125;); 实际上，被观察者还是发送了5个事件，只是因为操作符的存在，拦截了3个事件，最终， 观察者只接收到了2个事件。 12D/MainActivity4: 过滤后得到的事件是：1D/MainActivity4: 过滤后得到的事件是：2 操作符：takeLast()作用：指定观察者只能接收到被观察者发送的最后几个事件。 123456789Observable.just(1, 2, 3, 4, 5) //指定观察者只能接受被观察者发送的3个事件 .takeLast(3) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, "过滤后得到的事件是：" + integer); &#125; &#125;); 123D/MainActivity4: 过滤后得到的事件是：3D/MainActivity4: 过滤后得到的事件是：4D/MainActivity4: 过滤后得到的事件是：5 3.3 根据指定事件过滤事件作用：通过设置指定的时间，仅发送在该时间内的事件。 操作符：throttleFirst()和throttlelast()作用：在某段时间内，只发送该段时间内第一次事件/最后一次事件。如，一段时间内连续点击按钮，但只执行第一次的点击事件。原理： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// 在某段时间内，只发送该段时间内第1次事件Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; // 隔段事件发送时间 e.onNext(1); Thread.sleep(500); e.onNext(2); Thread.sleep(400); e.onNext(3); Thread.sleep(300); e.onNext(4); Thread.sleep(300); e.onNext(5); Thread.sleep(300); e.onNext(6); Thread.sleep(400); e.onNext(7); Thread.sleep(300); e.onNext(8); Thread.sleep(300); e.onNext(9); Thread.sleep(300); e.onComplete(); &#125;&#125;) //每1秒中采用数据 .throttleFirst(1, TimeUnit.SECONDS) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, "接收到了事件" + integer); &#125; &#125;);// 在某段时间内，只发送该段时间内最后1次事件Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; // 隔段事件发送时间 e.onNext(1); Thread.sleep(500); e.onNext(2); Thread.sleep(400); e.onNext(3); Thread.sleep(300); e.onNext(4); Thread.sleep(300); e.onNext(5); Thread.sleep(300); e.onNext(6); Thread.sleep(400); e.onNext(7); Thread.sleep(300); e.onNext(8); Thread.sleep(300); e.onNext(9); Thread.sleep(300); e.onComplete(); &#125;&#125;) // 每1秒中采用数据 .throttleLast(1, TimeUnit.SECONDS) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, "接收到了事件" + integer); &#125; &#125;); 123456D/MainActivity4: 接收到了事件throttleFirst = 1D/MainActivity4: 接收到了事件throttleFirst = 4D/MainActivity4: 接收到了事件throttleFirst = 7D/MainActivity4: 接收到了事件throttleLast = 3D/MainActivity4: 接收到了事件throttleLast = 6D/MainActivity4: 接收到了事件throttleLast = 9 操作符：sample()作用：在某段时间内，只发送该段时间内最新一次事件，与throttleLast()操作符类似。使用方法就是把上文的throttleLast()改成sample()操作符即可。 操作符：throttleWithTimeOut()/debounce()作用：发送数据事件时，若2次发送事件的间隔 &lt; 指定时间，就会丢弃前一次的数据，直到指定时间内都没有新数据发射时才会发送后一次的数据。 12345678910111213141516171819202122232425262728293031323334Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; // 隔段事件发送时间 emitter.onNext(1); Thread.sleep(500); // 1和2之间的间隔小于指定时间1s，所以前1次数据（1）会被抛弃，2会被保留 emitter.onNext(2); Thread.sleep(1500); // 因为2和3之间的间隔大于指定时间1s，所以之前被保留的2事件将发出 emitter.onNext(3); Thread.sleep(1500); // 因为3和4之间的间隔大于指定时间1s，所以3事件将发出 emitter.onNext(4); Thread.sleep(500); // 因为4和5之间的间隔小于指定时间1s，所以前1次数据（4）会被抛弃，5会被保留 emitter.onNext(5); Thread.sleep(500); // 因为5和6之间的间隔小于指定时间1s，所以前1次数据（5）会被抛弃，6会被保留 emitter.onNext(6); Thread.sleep(1500); // 因为6和Complete实践之间的间隔大于指定时间1s，所以之前被保留的6事件将发出 emitter.onComplete(); &#125;&#125;) // 每1秒采用数据 .throttleWithTimeout(1, TimeUnit.SECONDS) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, "接收到了事件" + integer); &#125; &#125;); 123D/MainActivity4: 接收到了事件2D/MainActivity4: 接收到了事件3D/MainActivity4: 接收到了事件6 3.4 根据指定事件位置过滤事件作用：通过设置指定的位置，过滤在该位置的事件。 操作符：firstElement()/lastElement()作用：仅选取第一个元素/最后一个元素。 12345678910111213141516171819// 获取第1个元素Observable.just(1, 2, 3, 4, 5) .firstElement() .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, "获取到的第一个事件是： " + integer); &#125; &#125;);// 获取最后1个元素Observable.just(1, 2, 3, 4, 5) .lastElement() .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, "获取到的最后1个事件是： " + integer); &#125; &#125;); 12D/MainActivity4: 获取到的第一个事件： 1D/MainActivity4: 获取到的最后一个事件： 5 操作符：elementAt()作用：指定接收某个元素（通过索引值确定）。 允许越界，即获取的位置索引 &gt; 发送事件序列长度 1234567891011121314151617181920// 使用1：获取位置索引为2的元素// 位置索引从0开始Observable.just(1, 2, 3, 4, 5) .elementAt(2) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, "使用1获取到的事件元素是： " + integer); &#125; &#125;);// 使用2：获取的位置索引 ＞ 发送事件序列长度时，设置默认参数Observable.just(1, 2, 3, 4, 5) .elementAt(6, 10) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, "使用2获取到的事件元素是： " + integer); &#125; &#125;); 12D/MainActivity4: 使用1获取到的事件元素是： 3D/MainActivity4: 使用2获取到的事件元素是： 10 操作符：elementAtOrError()作用：在elementAt()的基础上，当出现越界情况（即获取的位置索引 &gt; 发送事件序列长度）时，抛出异常。 12345678Observable.just(1, 2, 3, 4, 5) .elementAtOrError(6) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept( Integer integer) throws Exception &#123; Log.d(TAG,"获取到的事件元素是： "+ integer); &#125; &#125;); 4. 实际开发需求在实际开发中，常见的过滤操作符实际需求场景有：功能防抖和联想搜索请求优化 4.1 功能防抖 背景：用户只需要使用功能1次 冲突：由于外部原因，多次触发了功能，导致出现冗余功能操作。 用户只需要使用网络请求功能一次（点击按钮）， 但由于外部网络不好，点击一次后用户发现无响应， 于是多次点击按钮，最终导致发出了多个网络请求。 解决方案：功能防抖，通过根据指定时间过滤事件的过滤操作符实现，防止功能的抖动。 具体使用可以看看后面的实例详解。 4.2 联想搜索优化 背景：实现联想搜索功能，即每当用户输入一个字符，即显示与当前输入框内字符相关的搜索结果。最基本的实现流程： 通过EditText.addTextChangedListener()监听输入框变化 当输入框发生变化后，回调afterTextChanged()将当前输入框的文字像服务器发起请求 服务器返回与该搜索文字关联的结果 冲突：在用户搜索需求明确的情况下（体现为连续输入），可能会发起一些不必要的网络请求。例子： 用户搜索需求明确 = abc，即连续输入了abc 按上面的实现，客户端会向服务器发起a、ab、abc三个网络请求 即，多发起了a、ab两个不必要的网络请求 解决方案：通过根据指定时间过滤事件的过滤操作符（debounce）实现，防止不必要的网络请求。原理： 当输入框发生变化时，不会立刻将当前输入框内的文字发送给服务器，而是等待一段时间； 若在这段时间内，输入框不再有文字输入（无发生变化），那么才发送输入框内的文字给服务器； 若在这段时间内，输入框有文字输入（有变化），则继续等待该段时间，循环上述过程。 具体使用可以看看后面的实例详解。 Demo地址：Allen_Demo_Rx]]></content>
      <categories>
        <category>Android</category>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android RxJava：线程控制]]></title>
    <url>%2F2019%2F08%2F17%2FAndroid-RxJava%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[1. 作用指定Observable/Observer的工作线程类型。 2. 原因2.1 背景在RxJava模型中，Observable/Observer的工作线程就是创建时所在的线程。如果创建Observable/Observer在主线程，则生产事件/接收和响应事件都发生在主线程。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class MainActivity extends AppCompatActivity &#123; private static final String TAG = "Rxjava"; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 步骤1：创建被观察者 Observable &amp; 发送事件 // 在主线程创建被观察者 Observable 对象 // 所以生产事件的线程是：主线程 Observable&lt;Integer&gt; observable = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; Log.d(TAG, " 被观察者 Observable的工作线程是: " + Thread.currentThread().getName()); // 打印验证 emitter.onNext(1); emitter.onComplete(); &#125; &#125;); // 步骤2：创建观察者 Observer 并 定义响应事件行为 // 在主线程创建观察者 Observer 对象 // 所以接收 &amp; 响应事件的线程是：主线程 Observer&lt;Integer&gt; observer = new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, "开始采用subscribe连接"); Log.d(TAG, " 观察者 Observer的工作线程是: " + Thread.currentThread().getName()); &#125; @Override public void onNext(Integer value) &#123; Log.d(TAG, "对Next事件"+ value +"作出响应" ); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, "对Error事件作出响应"); &#125; @Override public void onComplete() &#123; Log.d(TAG, "对Complete事件作出响应"); &#125; &#125;; // 步骤3：通过订阅（subscribe）连接观察者和被观察者 observable.subscribe(observer); &#125;&#125; 2.2 冲突一般情况下，需要在子线程中去实现耗时操作，然后回到主线程实现UI操作。对应RxJava，可以理解为： Observable要在子线程中生产事件（如实现耗时操作等） Observer在主线程接收和响应事件（如实现UI操作） 2.3 解决方法为了解决上面的冲突，实现异步操作，就需要对RxJava进行线程控制（切换/调度） 3. 实现方式采用RxJava内置的线程调度器Scheduler，即通过功能型操作符subscribeOn()和observeOn()来实现。 3.1 subscribeOn和observeOn简介作用：线程控制，即指定被观察者Obserable和观察者Observer的工作线程类型 线程类型： 类型 含义 应用场景 Schedulers.immediate() 当前线程，不指定线程 默认 AndroidSchedulers.mainThread() Android主线程 操作UI Schedulers.newThread() 常规新线程 耗时等操作 Schedulers.io() IO操作线程 网络请求、读写文件等UI密集型操作 Schedulers.computation() CPU计算操作线程 大量计算操作 注：RxJava内部使用线程池来维护这些线程，所以线程的调度效率非常高。 3.2 具体使用具体是在（上面步骤3）通过订阅subscribe连接观察者和被观察者中实现： 123456789101112// 使用说明// Observable.subscribeOn（Schedulers.Thread）：指定被观察者 发送事件的线程（传入RxJava内置的线程类型）// Observable.observeOn（Schedulers.Thread）：指定观察者 接收 &amp; 响应事件的线程（传入RxJava内置的线程类型）// 实例使用// 步骤3：通过订阅（subscribe）连接观察者和被观察者// 1. 指定被观察者 生产事件的线程observable.subscribeOn(Schedulers.newThread()) // 2. 指定观察者接收和响应事件的线程 .observeOn(AndroidSchedulers.mainThread()) // 3. 最后再通过订阅（subscribe）连接观察者和被观察者 .subscribe(observer); 特别注意： 若Observable.subscribeOn()多次指定被观察者生产事件的线程，则只有第一次指定有效，其余的指定线程无效。 1234567observable // 第一次指定被观察者线程为新线程，有效 .subscribeOn(Schedulers.newThread()) // 第二次指定被观察者线程为主线程，无效 .subscribeOn(AndroidSchedulers.mainThread()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(observer); 若Observable.observeOn()多次指定Observer接收和响应事件的线程，则每次指定均有效，即没指定一次，就进行一次线程切换。 1234567891011121314observable.subscribeOn(Schedulers.newThread()) // 第一次指定观察者线程为主线程 .observeOn(AndroidSchedulers.mainThread()) // 生产事件 .doOnNext(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, "第一次观察者Observer的工作线程是： " + Thread.currentThread().getName()); &#125;&#125;) // 第二次指定观察者线程为新的工作线程 .observeOn(Schedulers.newThread()) // 生产事件 .subscribe(observer); 注： 整体方法调用顺序：观察者.onSubscribe() &gt; 被观察者.subscribe() &gt; 观察者.doOnNext() 观察者.onSubscribe()固定在主线程进行 4. Demo下面，采用Retrofit + RxJava实现网络请求功能，说明RxJava的线程控制的具体应用。 4.1 功能说明实现功能：将中文翻译成英文，并显示到界面实现方案：采用GET方法对金山词霸API发送网络请求 4.2 步骤说明 添加依赖 创建接收服务器返回数据的类 创建用于描述网络请求的接口（区别于传统形式） 创建Retrofit实例 创建网络请求接口实例并配置网络请求参数（区别于传统形式） 发送网络请求（区别于传统形式） 对返回数据进行处理 4.3 具体实现4.3.1 添加依赖1234567891011121314// Android 支持 RxJava// 此处一定要注意使用RxJava2的版本implementation 'io.reactivex.rxjava2:rxjava:2.2.7'implementation 'io.reactivex.rxjava2:rxandroid:2.1.0'// Android 支持 Retrofitimplementation 'com.squareup.retrofit2:retrofit:2.5.0'// 衔接 Retrofit &amp; RxJava// 此处一定要注意使用RxJava2的版本implementation 'com.jakewharton.retrofit:retrofit2-rxjava2-adapter:1.0.0'// 支持Gson解析implementation 'com.squareup.retrofit2:converter-gson:2.5.0' 权限： 1&lt;uses-permission android:name="android.permission.INTERNET" /&gt; 4.3.2 创建接收服务器返回数据的类金山词霸API数据格式说明： 1234567891011// URL模板http://fy.iciba.com/ajax.php// URL实例http://fy.iciba.com/ajax.php?a=fy&amp;f=auto&amp;t=auto&amp;w=hello%20world// 参数说明：// a：固定值 fy// f：原文内容类型，日语取 ja，中文取 zh，英语取 en，韩语取 ko，德语取 de，西班牙语取 es，法语取 fr，自动则取 auto// t：译文内容类型，日语取 ja，中文取 zh，英语取 en，韩语取 ko，德语取 de，西班牙语取 es，法语取 fr，自动则取 auto// w：查询内容 示例： 123456789101112&#123; "status": 1, "content": &#123; "from": "en-EU", "to": "zh-CN", "vendor": "ciba_cnn", "out": "\u4f60\u597d\u4e16\u754c", "ciba_use": "\u6765\u81ea\u673a\u5668\u7ffb\u8bd1\u3002", "ciba_out": "", "err_no": 0 &#125;&#125; 创建的类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package com.ly.allendemorx;public class Translation &#123; /** * status : 1 * content : &#123;"from":"en-EU","to":"zh-CN","vendor":"ciba_cnn","out":"你好世界","ciba_use":"来自机器翻译。","ciba_out":"", * "err_no":0&#125; */ private int status; private ContentBean content; public int getStatus() &#123; return status; &#125; public void setStatus(int status) &#123; this.status = status; &#125; public ContentBean getContent() &#123; return content; &#125; public void setContent(ContentBean content) &#123; this.content = content; &#125; public static class ContentBean &#123; /** * from : en-EU * to : zh-CN * vendor : ciba_cnn * out : 你好世界 * ciba_use : 来自机器翻译。 * ciba_out : * err_no : 0 */ private String from; private String to; private String vendor; private String out; private String ciba_use; private String ciba_out; private int err_no; public String getFrom() &#123; return from; &#125; public void setFrom(String from) &#123; this.from = from; &#125; public String getTo() &#123; return to; &#125; public void setTo(String to) &#123; this.to = to; &#125; public String getVendor() &#123; return vendor; &#125; public void setVendor(String vendor) &#123; this.vendor = vendor; &#125; public String getOut() &#123; return out; &#125; public void setOut(String out) &#123; this.out = out; &#125; public String getCiba_use() &#123; return ciba_use; &#125; public void setCiba_use(String ciba_use) &#123; this.ciba_use = ciba_use; &#125; public String getCiba_out() &#123; return ciba_out; &#125; public void setCiba_out(String ciba_out) &#123; this.ciba_out = ciba_out; &#125; public int getErr_no() &#123; return err_no; &#125; public void setErr_no(int err_no) &#123; this.err_no = err_no; &#125; &#125;&#125; 4.3.3 创建用于描述网络请求的接口采用注解 + Observable接口描述网络请求参数。 12345678910111213package com.ly.allendemorx;import io.reactivex.Observable;import retrofit2.http.GET;public interface GetRequest_Interface &#123; /** * 注解中传入网络请求部分的URL地址 * Retrofit将网络请求的URL分成两个部分：一是放在Retrofit对象里，另一是放在网络请求接口里 */ @GET("ajax.php?a=fy&amp;f=auto&amp;t=auto&amp;w=hi%20world") Observable&lt;Translation&gt; getCall();&#125; 4.3.4 后面的步骤均可在Activity中实现，详见代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.ly.allendemorx;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.util.Log;import com.jakewharton.retrofit2.adapter.rxjava2.RxJava2CallAdapterFactory;import io.reactivex.Observable;import io.reactivex.Observer;import io.reactivex.android.schedulers.AndroidSchedulers;import io.reactivex.disposables.Disposable;import io.reactivex.schedulers.Schedulers;import retrofit2.Retrofit;import retrofit2.converter.gson.GsonConverterFactory;/** * @author Liuyang * @date 2019/8/19 */public class Main3Activity extends AppCompatActivity &#123; private static final String TAG = "Allen"; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main3); // 步骤4：创建Retrofit对象 Retrofit retrofit = new Retrofit.Builder() // 设置网络请求URL .baseUrl("http://fy.iciba.com/") // 设置使用GSON解析 .addConverterFactory(GsonConverterFactory.create()) // 设置支持RxJava .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .build(); // 步骤5：创建网络请求接口实例 final GetRequest_Interface request = retrofit.create(GetRequest_Interface.class); // 步骤6：采用Observable&lt;...&gt;形式对网络请求进行封装 Observable&lt;Translation&gt; observable = request.getCall(); // 步骤7：发送网络请求 observable // 在IO线程进行网络请求 .subscribeOn(Schedulers.io()) // 回到主线程 处理请求结果 .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;Translation&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, "开始采用subscribe连接"); &#125; @Override public void onNext(Translation translation) &#123; // 步骤8：对返回的数据进行处理 if (translation != null) &#123; Log.d(TAG, "结果 from：" + translation.getContent().getFrom()); Log.d(TAG, "结果 to：" + translation.getContent().getTo()); Log.d(TAG, "结果 vendor：" + translation.getContent().getVendor()); Log.d(TAG, "结果 out：" + translation.getContent().getOut()); Log.d(TAG, "结果 ciba_use：" + translation.getContent().getCiba_use()); Log.d(TAG, "结果 ciba_out：" + translation.getContent().getCiba_out()); Log.d(TAG, "结果 err_no：" + translation.getContent().getErr_no()); &#125; &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, "请求失败"); &#125; @Override public void onComplete() &#123; Log.d(TAG, "请求成功"); &#125; &#125;); &#125;&#125; 123456789D/Allen: 开始采用subscribe连接D/Allen: 结果 from：en-EUD/Allen: 结果 to：zh-CND/Allen: 结果 vendor：tencentD/Allen: 结果 out：嗨世界D/Allen: 结果 ciba_use：来自机器翻译。D/Allen: 结果 ciba_out：D/Allen: 结果 err_no：0D/Allen: 请求成功 地址：Allen_Demo_Rx 5. 程序崩溃问题背景：在发送网络请求时，退出当前Activity。冲突：此时如果回到主线程更新UI，APP会崩溃解决方案：当Activity退出时，调用Disposiable.dispose()切断观察者和被观察者之间的订阅，使得观察者无法接收到事件和响应事件。 当出现多个Disposiable时，可以采用RxJava内置容器CompositeDisposable进行统一管理。 12345// 添加Disposable到CompositeDisposable容器CompositeDisposable.add()// 清空CompositeDisposable容器CompositeDisposable.clear()]]></content>
      <categories>
        <category>Android</category>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android RxJava：功能性操作符]]></title>
    <url>%2F2019%2F08%2F16%2FAndroid-RxJava%EF%BC%9A%E5%8A%9F%E8%83%BD%E6%80%A7%E6%93%8D%E4%BD%9C%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[1. 作用辅助被观察者Observable在发送事件时实现一些功能性需求，如错误处理、线程调度等。 2. 类型常用的功能性操作符： 连接被观察者和观察者：subscribe()，订阅 线程调度：subscribeOn()、observeOn() 延迟操作：delay() 在事件的生命周期中操作：do() 错误处理：即遇到错误时的机制，onErrorReturn()、onErrorResumeNext()、onExceptionResumeNext()、retry()、retryUntil()、retryWhen() 重复发起操作：repeat()、repeatWhen() 3. 详细说明3.1 连接被观察者和观察者作用：使被观察者和观察者形成订阅关系。 操作符：subscribe()具体例子看前面的就可以了。 3.2 线程调度作用：快速、方便指定和控制被观察者及观察者的工作线程。该部分在下一篇详细看看。 3.3 延迟操作：作用：使得被观察者延迟一段时间再发送事件。里面有多个重载方法： 12345678910111213141516// 指定延迟时间// @param delay 时间// @param unit 时间单位delay(long delay, TimeUnit unit)// 指定延迟时间和错误延迟// 如果出现Error事件，则先正常执行，执行结束之后，再抛出异常// @param delayError 错误延迟参数delay(long delay, TimeUnit unit, boolean delayError)// 指定延迟时间和调度器// @param scheduler 线程调度器delay(long delay, TimeUnit unit, Scheduler scheduler)// 指定延迟时间、调度器和错误延迟参数delay(long delay, TimeUnit unit, Scheduler scheduler, boolean delayError) 3.4 在事件的生命周期中操作作用：在事件发送和接收的整个生命周期过程中进行操作。如发送事件前的初始化、发送事件后的回调请求等。 操作符：do()作用：在某个事件的生命周期中调用。do()操作符包含以下： 当Observable每发送一次数据事件，就会调用一次。doOnEach()，含onNext()、onError()和onComplete() Next事件 执行Next事件前调用：doOnNext() 执行Next事件后调用：doAfterNext() 发送事件完毕后调用 发送错误事件时：doOnError() 正常发送事件完毕后：doOnCompleted() 无论正常发送/异常终止：doOnTeriminate() 最后执行：doFinaly() 订阅相关 观察者订阅时调用：doOnSubscribe() 观察者取消订阅时调用：doOnUnsubscribe() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; emitter.onNext(1); emitter.onNext(2); emitter.onNext(3); emitter.onError(new Throwable("发生错误")); &#125;&#125;) // 当Observable每发送一次数据事件，就调用一次 .doOnEach(new Consumer&lt;Notification&lt;Integer&gt;&gt;() &#123; @Override public void accept(Notification&lt;Integer&gt; integerNotification) throws Exception &#123; Log.d(TAG, "doOnEach: " + integerNotification.getValue()); &#125; &#125;) // 执行Next事件前执行 .doOnNext(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, "doOnNext: " + integer); &#125; &#125;) // 执行Next事件后执行 .doAfterNext(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, "doAfterNext: " + integer); &#125; &#125;) // Observable正常发送事件结束后调用 .doOnComplete(new Action() &#123; @Override public void run() throws Exception &#123; Log.d(TAG, "doOnComplete: "); &#125; &#125;) // Observable发送错误事件时调用 .doOnError(new Consumer&lt;Throwable&gt;() &#123; @Override public void accept(Throwable throwable) throws Exception &#123; Log.d(TAG, "doOnError: " + throwable.getMessage()); &#125; &#125;) // 观察者订阅时调用 .doOnSubscribe(new Consumer&lt;Disposable&gt;() &#123; @Override public void accept(Disposable disposable) throws Exception &#123; Log.d(TAG, "doOnSubscribe: "); &#125; &#125;) // Observable发送事件结束后调用，无论正常发送完毕还是异常终止 .doAfterTerminate(new Action() &#123; @Override public void run() throws Exception &#123; Log.d(TAG, "doAfterTerminate: "); &#125; &#125;) // 最后执行 .doFinally(new Action() &#123; @Override public void run() throws Exception &#123; Log.d(TAG, "doFinally: "); &#125; &#125;).subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Integer integer) &#123; Log.d(TAG, "接收到了事件" + integer); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, "对Error事件作出响应"); &#125; @Override public void onComplete() &#123; Log.d(TAG, "对Complete事件作出响应"); &#125;&#125;); 3.5 错误处理作用：发送事件过程中，遇到错误时的处理机制。 常用的操作符： 发送数据 发送一个特殊的事件并正常终止：onErrorReturn() 发送一个新的Observable：onErrorResumeNext()、onExceptionResumeNext() 重试 重试：retry() 让Observable重新订阅：retryUntil() 将错误传递给另一个Observable，来决定是否要重新订阅该Observable：retryWhen() 操作符：onErrorReturn()作用：遇到错误时，发送一个特殊事件并正常终止，可以捕获在它之前发生的异常。 123456789101112131415161718192021222324252627282930313233343536Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; emitter.onNext(1); emitter.onNext(2); emitter.onError(new Throwable("发生错误了")); &#125;&#125;).onErrorReturn(new Function&lt;Throwable, Integer&gt;() &#123; @Override public Integer apply(Throwable throwable) throws Exception &#123; // 捕捉错误异常 Log.e(TAG, "在onErrorReturn处理了错误: " + throwable.toString()); // 发生错误事件后，发送一个"666"事件，最终正常结束 return 666; &#125;&#125;).subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Integer value) &#123; Log.d(TAG, "接收到了事件" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, "对Error事件作出响应"); &#125; @Override public void onComplete() &#123; Log.d(TAG, "对Complete事件作出响应"); &#125;&#125;); 操作符：onErrorResumeNext()作用：遇到错误时，发送一个新的Observable。 注： onErrorResumeNext()拦截的错误为Throwable；若需拦截Exception，要用onExceptionResumeNext() 若onErrorResumeNext()拦截的错误为Exception，则会将错误传递给观察者的onError()方法 123456789101112131415161718192021222324252627282930313233343536373839Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onError(new Throwable("发生错误了")); &#125;&#125;).onErrorResumeNext(new Function&lt;Throwable, ObservableSource&lt;? extends Integer&gt;&gt;() &#123; @Override public ObservableSource&lt;? extends Integer&gt; apply(@NonNull Throwable throwable) throws Exception &#123; // 1. 捕捉错误异常 Log.e(TAG, "在onErrorReturn处理了错误: " + throwable.toString()); // 2. 发生错误事件后，发送一个新的被观察者 &amp; 发送事件序列 return Observable.just(11, 22); &#125;&#125;).subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Integer value) &#123; Log.d(TAG, "接收到了事件" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, "对Error事件作出响应"); &#125; @Override public void onComplete() &#123; Log.d(TAG, "对Complete事件作出响应"); &#125;&#125;); 操作符：onExceptionResumeNext()作用：遇到错误时，发送一个新的Observable。 注： onExceptionResumeNext()拦截的错误为Exception；若需拦截Throwable，要用onErrorResumeNext() 若onExceptionResumeNext()拦截的错误为Throwable，则会将错误传递给观察者的onError()方法 1234567891011121314151617181920212223242526272829303132333435Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onError(new Exception("发生错误了")); &#125;&#125;).onExceptionResumeNext(new Observable&lt;Integer&gt;() &#123; @Override protected void subscribeActual(Observer&lt;? super Integer&gt; observer) &#123; observer.onNext(11); observer.onNext(22); observer.onComplete(); &#125;&#125;).subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Integer value) &#123; Log.d(TAG, "接收到了事件" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, "对Error事件作出响应"); &#125; @Override public void onComplete() &#123; Log.d(TAG, "对Complete事件作出响应"); &#125;&#125;); 操作符：retry()作用：重试，当出现错误时，让被观察者oBservable重新发送数据 接收到onError()时，重新订阅并发送事件 Throwable和Exception都可拦截 12345678910111213141516171819// 出现错误时，让被观察者重新发送数据，若一直出现错误，就一直重新发送retry()// 出现错误时，让被观察者重新发送数据，有重试次数限制// @param times 重试次数retry(long times)// 出现错误时，判断是否需要重新发送数据，若需要重新发送，且持续遇到错误，则持续重试// @param predicate 判断逻辑retry(Predicate&lt;? super Throwable&gt; predicate)// 出现错误时，判断是否需要重新发送数据，若需要重新发送，且持续遇到错误，则持续重试// @param predicate 判断逻辑，传入当前重试次数和异常错误信息retry(BiPredicate&lt;? super Integer, ? super Throwable&gt; predicate)// 出现错误时，判断是否需要重新发送数据，若需要重新发送，且持续遇到错误，则持续重试// @param times 重试次数// @param predicate 判断逻辑retry(long times, Predicate&lt;? super Throwable&gt; predicate) 前面的三个方法很简单，看看后面两个方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; emitter.onNext(1); emitter.onNext(2); emitter.onError(new Exception("发生错误了")); emitter.onNext(3); &#125;&#125;) // 拦截错误后，判断是否需要重新发送请求 .retry(new BiPredicate&lt;Integer, Throwable&gt;() &#123; @Override public boolean test(Integer integer, Throwable throwable) throws Exception &#123; // 捕获异常 Log.e(TAG, "异常错误 = " + throwable.toString()); // 获取当前重试次数 Log.e(TAG, "当前重试次数 = " + integer); //返回false：不重新重新发送数据 &amp; 调用观察者的onError结束 //返回true：重新发送请求（若持续遇到错误，就持续重新发送） return true; &#125; &#125;).subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Integer value) &#123; Log.d(TAG, "接收到了事件" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, "对Error事件作出响应"); &#125; @Override public void onComplete() &#123; Log.d(TAG, "对Complete事件作出响应"); &#125;&#125;);Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onError(new Exception("发生错误了")); e.onNext(3); &#125;&#125;) // 拦截错误后，判断是否需要重新发送请求 .retry(3, new Predicate&lt;Throwable&gt;() &#123; @Override public boolean test(@NonNull Throwable throwable) throws Exception &#123; // 捕获异常 Log.e(TAG, "retry错误: " + throwable.toString()); //返回false：不重新重新发送数据 &amp; 调用观察者的onError（）结束 //返回true：重新发送请求（最多重新发送3次） return true; &#125; &#125;).subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Integer value) &#123; Log.d(TAG, "接收到了事件" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, "对Error事件作出响应"); &#125; @Override public void onComplete() &#123; Log.d(TAG, "对Complete事件作出响应"); &#125;&#125;); 操作符：retryUntil()作用：出现错误后，判断是否需要重新发送数据 若需要重新发送，且持续遇到错误，则持续重试 作用类似于：retry(Predicate predicate) 具体使用类似于retry(Predicate predicate)，唯一区别是：返回true，则不重新发送数据事件。 操作符：retryWhen()作用：遇到错误时，将发生的错误传递给一个新的被观察者Observable，并决定是否需要重新订阅原始被观察者并发送事件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onError(new Exception("发生错误了")); e.onNext(3); &#125;&#125;) // 遇到Error事件才会回调 .retryWhen(new Function&lt;Observable&lt;Throwable&gt;, ObservableSource&lt;?&gt;&gt;() &#123; @Override public ObservableSource&lt;?&gt; apply(Observable&lt;Throwable&gt; throwableObservable) throws Exception &#123; // 参数Observable&lt;Throwable&gt;中的泛型为上游操作抛出的异常，可通过该条件来判断异常的类型 // 返回ObservableSource&lt;?&gt;，为新的被观察者Observable，可以是任意类型的 // 这里有两种处理方式： // 1. 若新的Observable发送的事件为Error事件，那么原始Observable则不重新发送事件 // 2. 若新的Observable发送的事件为Next事件，那么原始Observable则重新发送事件 return throwableObservable.flatMap(new Function&lt;Throwable, ObservableSource&lt;?&gt;&gt;() &#123; @Override public ObservableSource&lt;?&gt; apply(Throwable throwable) throws Exception &#123; // 1. 若返回的Observable发送事件为Error事件，那么原始的Observable则不重新发送事件. // 该异常错误信息可以在观察者中的onError()中获得 return Observable.error(new Throwable("retryWhen终止")); // 2. 若新的Observable发送的事件为Next事件，那么原始Observable则重新发送事件， // 若持续遇到错误，则持续重试 // return Observable.just(1); &#125; &#125;); &#125; &#125;).subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Integer value) &#123; Log.d(TAG, "接收到了事件" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, "对Error事件作出响应" + e.toString()); // 获取异常错误信息 &#125; @Override public void onComplete() &#123; Log.d(TAG, "对Complete事件作出响应"); &#125;&#125;); 情况1： 情况2： 3.6 重复发送作用：重复不断地发送被观察者事件操作符：repeat和repeatWhen() 操作符：repeat()作用：无条件、重复发送被观察者事件，具备重载方法，可设置重复创建次数。 123456789101112131415161718192021222324Observable.just(1, 2, 3, 4) // 重复创建3次 .repeat(3) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, "开始采用subscribe连接"); &#125; @Override public void onNext(Integer value) &#123; Log.d(TAG, "接收到了事件" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, "对Error事件作出响应"); &#125; @Override public void onComplete() &#123; Log.d(TAG, "对Complete事件作出响应"); &#125; &#125;); 注： 接收到onComplete(0事件后，触发重新订阅和发送 默认运行在一个新的线程上 操作符：repeatWhen()作用：有条件地、重复发送被观察者事件原理：将原始Observable停止发送事件的标识（Complete()/Error()）转换成一个Object类型数据传递给一个新的Observable，以此决定是否重新订阅和发送原来的Observable。 如果新的Observable返回一个Complete/Error事件，则不重新订阅和发送原来的Observable 如果新的Observable返回其余事件时，则重新订阅并发送原来的Observable 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950Observable.just(1, 2, 4).repeatWhen(new Function&lt;Observable&lt;Object&gt;, ObservableSource&lt;?&gt;&gt;() &#123; @Override // 在Function函数中，必须对输入的 Observable&lt;Object&gt;进行处理，这里使用的是flatMap操作符接收上游的数据 public ObservableSource&lt;?&gt; apply(@NonNull Observable&lt;Object&gt; objectObservable) throws Exception &#123; // 将原始Observable停止发送事件的标识（Complete()/Error()）转换成一个Object类型数据传递给一个新的Observable // 以此决定是否重新订阅和发送原来的Observable // 此处有2种情况： // 1. 若新的Observable返回一个Complete()/Error()事件，则不重新订阅和发送原来的Observable // 2. 若新的Observable返回其余事件，则重新订阅并发送原来的Observable return objectObservable.flatMap(new Function&lt;Object, ObservableSource&lt;?&gt;&gt;() &#123; @Override public ObservableSource&lt;?&gt; apply(@NonNull Object throwable) throws Exception &#123; // 1. 若新的Observable返回一个Complete()/Error()事件，则不重新订阅和发送原来的Observable // Observable.empty()则发送Complete事件，但不会回调观察者的onComplete() return Observable.empty(); // 返回Error事件则回调onError()事件，并接收传过去的错误信息 // return Observable.error(new Throwable("不再重新订阅事件")); // 2. 若新的Observable返回其余事件，则重新订阅并发送原来的Observable // 仅仅是作为一个触发重新订阅被观察者的通知，发送的是什么数据并不重要，只要不是Complete()/Error()事件 // return Observable.just(1); &#125; &#125;); &#125;&#125;).subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, "开始采用subscribe连接"); &#125; @Override public void onNext(Integer value) &#123; Log.d(TAG, "接收到了事件" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, "对Error事件作出响应：" + e.toString()); &#125; @Override public void onComplete() &#123; Log.d(TAG, "对Complete事件作出响应"); &#125;&#125;); 4. 实际开发需求 线程操作，如切换/调度/控制 轮询 发送网络请求时的差错重试机制 4.1 线程操作详细请看下一篇。 4.2 轮询实例讲解中会有一篇结合Retrofit，实现轮询。 4.3 发送网络请求时的差错重试机制实例讲解中会有一篇结合Retrofit，实现该功能。]]></content>
      <categories>
        <category>Android</category>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android RxJava：组合/合并操作符]]></title>
    <url>%2F2019%2F08%2F15%2FAndroid-RxJava%EF%BC%9A%E7%BB%84%E5%90%88-%E5%90%88%E5%B9%B6%E6%93%8D%E4%BD%9C%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[1. 作用组合多个被观察者Observable，合并需要发送的事件。 2. 类型RxJava中常见的组合/合并操作符： 组合多个被观察者 按发送顺序：concat()、concatArray() 按时间：merge()、mergeArray() 错误处理：concatDelatError()、mergeDelayError() 合并多个事件 按数量：zip() 按时间：combineLatest()、combineLatestError() 合并成一个事件发送：reduce()、collect() 发送事件前追加发送事件：startWith()、startWithArray() 统计发送事件数量：count() 3. 详细说明3.1 组合多个被观察者该类型操作符的作用：组合多个被观察者。 concat()/concatArray()作用：组合多个被观察者一起发送数据，合并后按发送顺序串行执行。二者区别：组合被观察者的数量不同，concat()为≤4和，concatArray()为＞4个。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152Observable.concat(Observable.just(1, 2, 3), Observable.just(4, 5, 6), Observable.just(7, 8, 9), Observable.just(10, 11, 12)) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Integer value) &#123; Log.d(TAG, "接收到了事件" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, "对Error事件作出响应"); &#125; @Override public void onComplete() &#123; Log.d(TAG, "对Complete事件作出响应"); &#125; &#125;);Observable.concatArray(Observable.just(1, 2, 3), Observable.just(4, 5, 6), Observable.just(7, 8, 9), Observable.just(10, 11, 12), Observable.just(13, 14, 15)) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Integer value) &#123; Log.d(TAG, "接收到了事件" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, "对Error事件作出响应"); &#125; @Override public void onComplete() &#123; Log.d(TAG, "对Complete事件作出响应"); &#125; &#125;); merge()/mergeArray()作用：组合多个被观察者一起发送数据，合并后按时间线并行执行。二者区别：组合被观察者的数量不同，merge()为≤4和，mergeArray()为＞4个。与concat()的区别：合并后执行的方式不同。 123456789101112131415161718192021222324Observable.merge( Observable.intervalRange(0, 3, 1, 1, TimeUnit.SECONDS), Observable.intervalRange(2, 3, 1, 1, TimeUnit.SECONDS)).subscribe(new Observer&lt;Long&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Long value) &#123; Log.d(TAG, "接收到了事件" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, "对Error事件作出响应"); &#125; @Override public void onComplete() &#123; Log.d(TAG, "对Complete事件作出响应"); &#125;&#125;); 操作符：concatDelayError()/megerDelayError()作用： 背景：使用concat()和meger()操作符时，若其中一个b被观察者发出onError()事件，则会马上终止其他被观察者继续发送事件，造成冲突。 解决方案：若希望onError()事件推迟到其他被观察者发送事件结束之后触发，需要使用对用的concatDelayError()或megerDelayError()。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768Observable.concat( Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; emitter.onNext(1); emitter.onNext(2); emitter.onNext(3); // 发送Error事件，因为无使用concatDelayError，所以第2个Observable将不会发送事件 emitter.onError(new NullPointerException()); emitter.onComplete(); &#125; &#125;), Observable.just(4, 5, 6)) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Integer value) &#123; Log.d(TAG, "接收到了事件" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, "对Error事件作出响应"); &#125; @Override public void onComplete() &#123; Log.d(TAG, "对Complete事件作出响应"); &#125; &#125;);Observable.concatArrayDelayError( Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; emitter.onNext(1); emitter.onNext(2); emitter.onNext(3); // 发送Error事件，因为使用了concatDelayError，所以第2个Observable将会发送事件，等发送完毕后，再发送错误事件 emitter.onError(new NullPointerException()); emitter.onComplete(); &#125; &#125;), Observable.just(4, 5, 6)) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Integer value) &#123; Log.d(TAG, "接收到了事件" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, "对Error事件作出响应"); &#125; @Override public void onComplete() &#123; Log.d(TAG, "对Complete事件作出响应"); &#125; &#125;); 3.2 合并多个事件该类型的操作符主要是对多个被观察者中的事件进行合并处理。 操作符：zip()作用：合并多个被观察者Observable发送的事件，生成一个新的事件序列（即组合之后的事件序列），并发送。 原理： 特别注意： 事件组合方式：严格按照原先事件序列进行对位合并 最终合并的事件数量：多个被观察者Observable中数量最少的数量 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// 创建1个被观察者Observable&lt;Integer&gt; observable1 = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; Log.d(TAG, "被观察者1发送了事件1"); emitter.onNext(1); // 为了方便展示效果，所以在发送事件后加入2s的延迟 Thread.sleep(1000); Log.d(TAG, "被观察者1发送了事件2"); emitter.onNext(2); Thread.sleep(1000); Log.d(TAG, "被观察者1发送了事件3"); emitter.onNext(3); Thread.sleep(1000); emitter.onComplete(); &#125;&#125;) // 设置被观察者1在工作线程1中工作 .subscribeOn(Schedulers.io());// 创建第2个被观察者Observable&lt;String&gt; observable2 = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123; Log.d(TAG, "被观察者2发送了事件A"); emitter.onNext("A"); Thread.sleep(1000); Log.d(TAG, "被观察者2发送了事件B"); emitter.onNext("B"); Thread.sleep(1000); Log.d(TAG, "被观察者2发送了事件C"); emitter.onNext("C"); Thread.sleep(1000); Log.d(TAG, "被观察者2发送了事件D"); emitter.onNext("D"); Thread.sleep(1000); emitter.onComplete(); &#125;&#125;) // 设置被观察者2在工作线程2中工作 .subscribeOn(Schedulers.newThread());// 如果不做线程控制，两个被观察者会在同一个线程上工作，即发送事件存在先后顺序，而不是通同时发送。// 使用zip操作符进行事件合并// 创建BiFunction对象传入的第三个参数为合并后数据的数据类型Observable.zip(observable1, observable2, new BiFunction&lt;Integer, String, String&gt;() &#123; @Override public String apply(Integer integer, String s) throws Exception &#123; return integer + s; &#125;&#125;).subscribe(new Observer&lt;String&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, "onSubscribe"); &#125; @Override public void onNext(String value) &#123; Log.d(TAG, "最终接收到的事件 = " + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, "onError"); &#125; @Override public void onComplete() &#123; Log.d(TAG, "onComplete"); &#125;&#125;); 特别注意： 尽管被观察者2的事件D没有合并，但是还是会继续发送； 如果在被观察者1和被观察者2的事件序列最后发送onComplete()事件，则被观察者2的事件D也不会发送。 zip()总结： 定义：属于RxJava2中的组合/合并操作符 作用： 合并多个被观察者Observable发送的事件 生成一个新的事件序列，并发送 原理： 事件组合方式：严格按照原先事件序列进行对位合并 最终合并的事件数量：多个被观察者Observable中数量最少的数量 应用场景： 当需要展示的信息需要从多个地方获取，且要统一结合后再展示 如合并互联网请求的发送，并统一显示结果：Retrofit结合RxJava 操作符：combineLatest()作用：当两个Observable中的任何一个发送数据之后，将先发送数据的Observable的最新（最后）一个数据与另一个Observable发送的每个数据结合，最后基于该函数的结果发送数据。 与zip()的区别：zip()是按个数合并，一对一的合并；combineLatest()是按时间合并，即再同一个时间点上合并。 123456789101112131415161718Observable.combineLatest(Observable.just(1L, 2L, 3L), Observable.intervalRange(0, 3, 1, 1, TimeUnit.SECONDS), new BiFunction&lt;Long, Long, Long&gt;() &#123; @Override public Long apply(Long aLong1, Long aLong2) throws Exception &#123; // aLong1：第1个Observable发送的最新（最后）1个数据 // aLong2：第2个Observable发送的每1个数据 Log.e(TAG, "合并的数据是： " + aLong1 + " " + aLong2); // 合并的逻辑：相加 // 即第一个Observable发送的最后一个数据与第二个Observable发送的每个数据相加 return aLong1 + aLong2; &#125; &#125;).subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(Long s) throws Exception &#123; Log.e(TAG, "合并的结果是： " + s); &#125;&#125;); 操作符：combingLatestDelayError()类似concatDelayError()和mergeDelayError()，即错误处理，这里不再多做讲解。 操作符：reduce()作用：将被观察者需要发送的事件聚合成一个事件发送。 聚合的逻辑根据需求编写，但本质都是前两个数据聚合，然后与后一个数据继续进行聚合，依次类推。 12345678910111213141516Observable.just(1, 2, 3, 4) .reduce(new BiFunction&lt;Integer, Integer, Integer&gt;() &#123; // 在复写方法中加入聚合逻辑 @Override public Integer apply(Integer integer1, Integer integer2) throws Exception &#123; Log.e(TAG, "本次计算的数据是： " + integer1 + " 乘 " + integer2); // 本次聚合的逻辑是：全部数据相乘起来 // 原理：第1次取前2个数据相乘，之后每次获取到的数据 = 返回的数据x原始下1个数据每 return integer1 * integer2; &#125; &#125;).subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.e(TAG, "最终计算的结果是： " + integer); &#125;&#125;); 操作符：collect()作用：将被观察者Observable发送的数据事件收集到一个数据结构里。 1234567891011121314151617181920Observable.just(1, 2, 3, 4, 5, 6).collect( // 创建数据结构（容器），用于收集被观察者发送的数据 new Callable&lt;ArrayList&lt;Integer&gt;&gt;() &#123; @Override public ArrayList&lt;Integer&gt; call() throws Exception &#123; return new ArrayList&lt;&gt;(); &#125; &#125;, // 对发送的数据进行收集 new BiConsumer&lt;ArrayList&lt;Integer&gt;, Integer&gt;() &#123; @Override public void accept(ArrayList&lt;Integer&gt; integers, Integer integer) throws Exception &#123; integers.add(integer); &#125; &#125;).subscribe(new Consumer&lt;ArrayList&lt;Integer&gt;&gt;() &#123; @Override public void accept(ArrayList&lt;Integer&gt; integers) throws Exception &#123; Log.e(TAG, "本次发送的数据是： " + integers); &#125;&#125;); 3.3 发送事件前追加发送事件操作符：startWith()/startWithArray()作用：在一个被观察者发送事件之前，追加发送一些数据或者一个新的被观察者。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 在一个被观察者发送事件之前，追加发送一些数据// 注：追加数据顺序为后调用先追加Observable.just(4, 5, 6) .startWith(0) .startWithArray(1, 2, 3) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Integer value) &#123; Log.d(TAG, "接收到了事件" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, "对Error事件作出响应"); &#125; @Override public void onComplete() &#123; Log.d(TAG, "对Complete事件作出响应"); &#125; &#125;);// 在一个被观察者发送事件之前，追加发送一个被观察者并发送Observable.just(4, 5, 6) .startWith(Observable.just(1, 2, 3)) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Integer value) &#123; Log.d(TAG, "接收到了事件" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, "对Error事件作出响应"); &#125; @Override public void onComplete() &#123; Log.d(TAG, "对Complete事件作出响应"); &#125; &#125;); 3.4 统计发送事件数量操作符：count()作用：统计被观察者发送事件的数量。 123456789// 注：返回结果 = Long类型Observable.just(1, 2, 3, 4) .count() .subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(Long aLong) throws Exception &#123; Log.e(TAG, "发送的事件数量 = " + aLong); &#125; &#125;);]]></content>
      <categories>
        <category>Android</category>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android RxJava：变换操作符]]></title>
    <url>%2F2019%2F08%2F15%2FAndroid-RxJava%EF%BC%9A%E5%8F%98%E6%8D%A2%E6%93%8D%E4%BD%9C%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[1. 作用对事件序列中的事件/整个事件序列进行加工处理（即变换），使得其转变成不同的事件/整个事件序列。 基础原理： 使用变换操作符（针对事件）： 使用变换操作符（针对事件序列）： 2. 类型常见的变换操作符： Map() FlatMap() ContactMap() Buffer() 3. 详细说明3.1 Map()作用：对被观察者发送的每个事件都通过指定函数处理，从而变成另一个事件。即，将被观察者发送的事件转换为任意类型的事件。 应用场景：数据类型转换 12345678910111213141516171819202122Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; // 被观察者发送事件：整型 emitter.onNext(1); emitter.onNext(2); emitter.onNext(3); &#125;&#125;) // 使用Mapj变换操作符中的Function函数，对被观察者发送的事件进行统一变换，整型变成字符串类型 .map(new Function&lt;Integer, String&gt;() &#123; @Override public String apply(Integer integer) throws Exception &#123; return "使用Map变换操作符，将事件" + integer + "的参数从整型" + integer + " 变换成字符串类型" + integer; &#125; &#125;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; // 被观察者接收事件时，是接收到变换后的事件 Log.i(TAG, s); &#125;&#125;); 3.2 FlatMap()作用：将被观察者发送的事件序列进行拆分和单独转换，再合并成一个新的事件序列，最后再进行发送。 原理： 为事件序列中的每个事件都创建一个Observable对象 将对每个原始事件转换后的新事件都放入到对应的Observable对象 将新建的每个Observable都合并到一个新建的、总的Observable对象 新建的、总的Observable对象将新合并的事件序列发送给观察者Observer 应用场景：无序的将被观察者发送的整个事件序列进行变换 1234567891011121314151617181920212223242526Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; emitter.onNext(1); emitter.onNext(2); emitter.onNext(3); &#125;&#125;) // 采用flatMap（）变换操作符 .flatMap(new Function&lt;Integer, ObservableSource&lt;String&gt;&gt;() &#123; @Override public ObservableSource&lt;String&gt; apply(Integer integer) throws Exception &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int j = 0; j &lt; 3; j++) &#123; // 通过flatMap中将被观察者生成的事件序列先进行拆分，再将每个事件转换为一个新的发送三个String事件 // 最终合并，再发送给被观察者 list.add("我是事件 " + integer + "拆分后的子事件" + i); &#125; return Observable.fromIterable(list); &#125; &#125;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; Log.d(TAG, s); &#125;&#125;); 注：新合并的事件序列顺序是无序的，与旧序列发送事件的顺序无关。 3.3 ContactMap()作用：与FlatMap()类似，区别在于：拆分及重新合并生成的事件序列的顺序就是被观察者旧序列生产的序列。 应用场景：有序的将被观察者发送的整个事件序列进行变换。 1234567891011121314151617181920212223242526Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; emitter.onNext(1); emitter.onNext(2); emitter.onNext(3); &#125;&#125;) // 采用concatMap()变换操作符 .concatMap(new Function&lt;Integer, ObservableSource&lt;String&gt;&gt;() &#123; @Override public ObservableSource&lt;String&gt; apply(Integer integer) throws Exception &#123; final List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 3; i++) &#123; // 通过concatMap中将被观察者生产的事件序列先进行拆分，再将每个事件转换为一个新的发送三个String事件 // 最终合并，再发送给被观察者 list.add("我是事件 " + integer + "拆分后的子事件" + i); &#125; return Observable.fromIterable(list); &#125; &#125;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; Log.d(TAG, s); &#125;&#125;); 注：新合并的事件序列顺序是有序的，即严格按照旧序列发送事件的顺序。 3.4 Buffer()作用：定期从被观察者Observable需要发送的事件中获取一定数量的事件并放到缓存区中，最终发送。 原理： 应用场景：缓存被观察者发送的事件 Bufer()每次获取多少个事件放到缓存区中呢？下面看一个例子： 12345678910111213141516171819202122232425262728293031// 被观察者需要发送5个数字Observable.just(1, 2, 3, 4, 5) // 设置缓存区大小和步长 // 缓存区大小：每次从被观察者中获取的事件数量 // 步长：每次获取新事件的数量 .buffer(3, 1) .subscribe(new Observer&lt;List&lt;Integer&gt;&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(List&lt;Integer&gt; stringList) &#123; // Log.d(TAG, " 缓存区里的事件数量 = " + stringList.size()); for (Integer value : stringList) &#123; Log.d(TAG, " 事件 = " + value); &#125; &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, "对Error事件作出响应"); &#125; @Override public void onComplete() &#123; Log.d(TAG, "对Complete事件作出响应"); &#125; &#125;); 过程解释： Demo地址：Allen_Demo_Rx]]></content>
      <categories>
        <category>Android</category>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[香煎土豆片]]></title>
    <url>%2F2019%2F08%2F13%2F%E9%A6%99%E7%85%8E%E5%9C%9F%E8%B1%86%E7%89%87%2F</url>
    <content type="text"><![CDATA[食材土豆一个、豆瓣酱一勺、食用盐少许、生抽一勺、白芝麻一勺、孜然粉少许、香菜一根、小葱一根、蒜3瓣 步骤 土豆削皮洗净，切成均匀的片，不要太薄 把切好的土豆片放在清水中泡一下，去掉一部分淀粉，热量更低，将泡好的土豆片水沥干，或者用厨房用纸擦去表面的水分 将蒜、香菜切碎 锅里放油，把土豆片两面煎黄 将煎好的土豆片盛出备用 锅里留少许油，放入辣椒酱、大蒜爆炒出香味 加入土豆片 加入生抽、加适量清水焖煮土豆片能使其嫩香、熟透，并且稀释残留淀粉 最后加入孜然粉、白芝麻，小葱、香菜翻炒均匀 喜欢吃麻辣的，多加一些辣椒和花椒，鲜香麻辣，非常下饭]]></content>
      <categories>
        <category>美食</category>
      </categories>
      <tags>
        <tag>美食</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[绝味手撕鸡]]></title>
    <url>%2F2019%2F08%2F13%2F%E7%BB%9D%E5%91%B3%E6%89%8B%E6%92%95%E9%B8%A1%2F</url>
    <content type="text"><![CDATA[食材三黄鸡、香菜、小葱、大蒜、生姜、小米椒、麻油、生抽、豉油 步骤 将生姜切片，小葱洗净打结放入盘底 鸡清洗干净沥干放上盘，如果能放下整只鸡就不用切块，直接将生姜片和葱结放入鸡肚子就好 锅里放水，放上蒸架后，将整盘鸡放入锅中蒸30分钟左右 在蒸制的时候开始准备调料，将小米椒切圈，香菜切碎，蒜姜切末备用 倒入生抽、豉油、糖、香油，搅拌均匀 热锅入油，将蒜姜末和辣椒放入锅中煎至飘香 将煎好的蒜姜辣椒，趁烫倒入调好的酱汁中搅拌均匀 等鸡蒸好后从锅里拿出，用凉水冲去浮末，之后用厨房纸擦干，开始手撕鸡的过程，最好是连皮带肉地撕 最后将调好的酱汁，倒入撕好的鸡肉中搅拌均匀，在现有调料的基础上，还可以倒点香醋]]></content>
      <categories>
        <category>美食</category>
      </categories>
      <tags>
        <tag>美食</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[芋头焖排骨]]></title>
    <url>%2F2019%2F08%2F13%2F%E8%8A%8B%E5%A4%B4%E7%84%96%E6%8E%92%E9%AA%A8%2F</url>
    <content type="text"><![CDATA[1. 材料排骨、芋头、葱、蒜、盐、糖、料酒、酱油、油 2. 步骤 排骨切块，加盐、糖、料酒、酱油，腌制1小时。 芋头切块，放入炒锅，煎至表面金黄，然后盛起备用。 热锅入油，加入蒜爆炒，再加入排骨炒至上色，加入清水烧开。 加入芋头、酱油和盐，焖30分钟。 大火收汁]]></content>
      <categories>
        <category>美食</category>
      </categories>
      <tags>
        <tag>美食</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android RxJava：创建操作符]]></title>
    <url>%2F2019%2F08%2F12%2FAndroid-RxJava%EF%BC%9A%E5%88%9B%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[1. 作用创建被观察者Observable对象，发送事件。 2. 类型创建操作符包括： 3. 介绍及应用场景3.1 基本创建操作符：create()场景：完整的创建被观察者对象，RxJava中创建被观察者对象最基本的操作符。 123456789101112131415161718192021// 1. 创建被观察者Observable对象Observable&lt;Integer&gt; observable1 = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; // create()是RxJava最基本的创建事件序列的方法 // 此处传入一个OnSubscribe对象参数 // 当observable被订阅时，OnSubscribe的call()方法会自动被调用，即事件序列就会按照设定次序依次被触发 // 即观察者会依次调用对应事件的复写方法从而响应事件 // 从而实现被观察者调用了观察者的回调方法并由被观察者向观察者的事件传递，即观察者模式 // 2. 在复写的subscribe()中定义需要发送的事件 @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; // 通过ObservableEmitter类对象产生事件并通知观察者 // ObservableEmitter类介绍： // a. 定义：事件发射器 // b. 作用：定义需要发送的事件，并向观察者发送事件 emitter.onNext(1); emitter.onNext(2); emitter.onNext(3); emitter.onComplete(); &#125;&#125;); 采用链式调用：在补充示例地址中也可以看到示例。 3.2 快速创建和发送事件操作符：just()场景：快速的创建被观察者对象，发送事件的特点为直接发送传入的事件，最多只能发送10个参数。 12345678910111213141516171819202122232425262728// 创建时传入整型1,2,3,4// 在创建后就会发送这些对象，相当于执行了onNext(1)、onNext(2)、onNext(3)、onNext(4)Observable.just(1, 2, 3, 4) // 至此，已经创建一个完整的Observable对象 // 2. 通过通过订阅（subscribe）连接观察者和被观察者 // 3. 创建观察者，定义响应事件的行为 .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, "开始采用subscribe连接"); &#125; @Override public void onNext(Integer value) &#123; Log.d(TAG, "接收到了事件" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, "对Error事件作出响应"); &#125; @Override public void onComplete() &#123; Log.d(TAG, "对Complete事件作出响应"); &#125; &#125;); 操作符：fromArray()场景：快速创建被观察者Observable对象，以数组形式发送10个以上的事件，通过数组遍历元素。特点是直接发送传入的数组数据，在数组元素遍历时，会将数组中的数据转成Observable对象。 1234567891011121314151617181920212223242526272829// 1. 设置需要传入的数组Integer[] items = &#123;0, 1, 2, 3, 4, 5&#125;;// 2. 创建被观察者对象时传入数组// 在创建后会将该数组中的元素转成Observable对象，并发送对象中的所有数据Observable.fromArray(items) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, "开始采用subscribe连接"); Log.d(TAG, "数组遍历"); &#125; @Override public void onNext(Integer integer) &#123; Log.d(TAG, "接收到了事件" + integer); Log.d(TAG, "数组中的元素 = "+ integer ); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, "对Error事件作出响应"); &#125; @Override public void onComplete() &#123; Log.d(TAG, "对Complete事件作出响应"); &#125; &#125;); 操作符：fromIterable()场景：快速创建被观察者Observable对象，并以集合的形式发送10以上事件。特点是直接发送集合list数据，通过集合元素遍历，会将集合中的数据转成Observable对象。 123456789101112131415161718192021222324252627282930// 1. 设置一个集合List&lt;Integer&gt; list = new ArrayList&lt;&gt;();list.add(0);list.add(1);list.add(2);list.add(3);// 2. 通过fromIterable()将集合中的对象/数据发送出去Observable.fromIterable(list) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, "开始采用subscribe连接"); &#125; @Override public void onNext(Integer integer) &#123; Log.d(TAG, "接收到了事件" + integer); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, "对Error事件作出响应"); &#125; @Override public void onComplete() &#123; Log.d(TAG, "对Complete事件作出响应"); &#125; &#125;); 其他方法：以下方法一般用于测试： empty()：该方法创建的被观察者对象发送事件的特点：仅发送Complete事件，即观察者接收后直接调用onComplete()。 error()：特点是仅发送Error事件，直接通知异常，可以自定义异常，即观察者接收后直接调用onError()。 never()：特点是不发送任何事件，即观察者接收后什么都不调用。 3.3 延迟创建操作符：defer()场景：定时操作，在经过x秒后，自动执行y操作；周期性操作，每隔x秒后，自动执行y操作。 直到有观察者Observer订阅时，才动态创建被观察者对象Observable，并发送事件。 通过Osbervable工厂方法创建被观察者对象Observable 每次订阅后，都会得到一个刚创建的最新的Observable对象，这可以确保Observable对象里的数据是最新的。 1234567891011121314151617181920212223242526272829303132333435363738394041// 第一次对i赋值Integer i = 0;private void dodefer() &#123; // 通过defer()定义被观察者对象 // 注：此时被观察者还未被创建 Observable&lt;Integer&gt; observable = Observable.defer(new Callable&lt;ObservableSource&lt;? extends Integer&gt;&gt;() &#123; @Override public ObservableSource&lt;? extends Integer&gt; call() throws Exception &#123; return Observable.just(i); &#125; &#125;); // 第二次对i赋值 i = 15; // 观察者开始订阅 // 此时，才会调用defer()创建被观察者对象 observable.subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, "开始采用subscribe连接"); &#125; @Override public void onNext(Integer integer) &#123; Log.d(TAG, "接收到的整数是" + integer); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, "对Error事件作出响应"); &#125; @Override public void onComplete() &#123; Log.d(TAG, "对Complete事件作出响应"); &#125; &#125;);&#125; 因为在订阅时Observable才创建，所以i只会取第二次的赋值。 操作符：timer()场景：延迟指定时间，发送一个0，一般用于检测。快速创建一个Observable，特点是延迟指定时间后，发送一个数值0（Long类型），其本质就是延迟指定时间后，调用一次onNext(0)。 延迟指定事件，发送一个0，一般用于检测。 1234567891011121314151617181920212223// 延迟2秒后，发送一个long类型数值Observable.timer(2, TimeUnit.SECONDS) .subscribe(new Observer&lt;Long&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, "开始采用subscribe连接"); &#125; @Override public void onNext(Long aLong) &#123; Log.d(TAG, "接收到了事件" + aLong); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, "对Error事件作出响应"); &#125; @Override public void onComplete() &#123; Log.d(TAG, "对Complete事件作出响应"); &#125; &#125;); 操作符：interval()场景：快速创建一个被观察者对象Observable，发送事件的特点：每隔指定时间就发送事件。发送事件的序列为，从0开始，无限递增1的整数序列。 1234567891011121314151617181920212223242526272829// 参数说明：// 参数1：第1次延迟时间// 参数2：间隔时间数字// 参数3：时间单位Observable.interval(3, 1, TimeUnit.SECONDS) // 该例子发送的事件序列特点：延迟3s后发送事件，每隔1秒产生1个数字（从0开始递增1，无限个） .subscribe(new Observer&lt;Long&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, "开始采用subscribe连接"); &#125; // 默认最先调用复写的 onSubscribe（） @Override public void onNext(Long aLong) &#123; Log.d(TAG, "接收到了事件" + aLong); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, "对Error事件作出响应"); &#125; @Override public void onComplete() &#123; Log.d(TAG, "对Complete事件作出响应"); &#125; &#125;); 注：interval默认在computation调度器上执行，也可以自定义指定线程调度器（第三个参数）：interval(long, TimeUnit, Scheduler)。 操作符：intervalRange()场景：快速创建一个被观察者对象Observable，发送事件的特点：每隔指定时间就发送事件，可指定发送的数据的数量。发送的事件序列为从0开始，无限递增1的整数序列，作用类似interval()，不同的是intervalRange()可以指定发送数据的数量。 123456789101112131415161718192021222324252627282930313233// 参数说明：// 参数1:事件序列起始点// 参数2:事件数量// 参数3:第1次事件延迟发送时间// 参数4:间隔时间数字// 参数5:时间单位Observable.intervalRange(3, 10, 2, 1, TimeUnit.SECONDS) // 该例子发送的事件序列特点： // 1. 从3开始，一共发送10个事件； // 2. 第1次延迟2s发送，之后每隔2秒产生1个数字（从0开始递增1，无限个） .subscribe(new Observer&lt;Long&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, "开始采用subscribe连接"); &#125; // 默认最先调用复写的 onSubscribe（） @Override public void onNext(Long value) &#123; Log.d(TAG, "接收到了事件" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, "对Error事件作出响应"); &#125; @Override public void onComplete() &#123; Log.d(TAG, "对Complete事件作出响应"); &#125; &#125;); 操作符：range()场景：快速创建一个被观察者对象Observable，发送事件的特点：连续发送一个事件序列，可指定范围。发送的事件序列为从0开始、无限递增1的的整数序列，作用类似于intervalRange()，区别在于，无延迟发送事件。 1234567891011121314151617181920212223242526272829// 参数说明：// 参数1：事件序列起始点// 参数2：事件数量// 注：若设置为负数，则会抛出异常Observable.range(3, 10) // 该例子发送的事件序列特点：从3开始发送，每次发送事件递增1，一共发送10个事件 .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, "开始采用subscribe连接"); &#125; // 默认最先调用复写的 onSubscribe（） @Override public void onNext(Integer value) &#123; Log.d(TAG, "接收到了事件" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, "对Error事件作出响应"); &#125; @Override public void onComplete() &#123; Log.d(TAG, "对Complete事件作出响应"); &#125; &#125;); 操作符：rangeLong()场景：作用类似于range()，区别在于该方法支持数据类型Long。使用与range()类似。 Demo地址：Allen_Demo_Rx]]></content>
      <categories>
        <category>Android</category>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android RxJava：入门]]></title>
    <url>%2F2019%2F08%2F12%2FAndroid-RxJava%EF%BC%9A%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[前言RxJava是基于事件流的链式调用、逻辑简单且使用简单。 GitHub链接： RxJava RxAndroid 基于RxJava 2.0 在xJava 1.0上增加了一些新特性，基本原理和使用基本相同 后面还会介绍原理、操作符、应用场景、背压等 1. 定义在GitHub上的介绍： RxJava – Reactive Extensions for the JVM – a library for composing asynchronous and event-based programs using observable sequences for the Java VM.一个在Java JVM上使用可观测的序列来组成异步的、基于事件的程度的库。 总结：RxJava是基于事件流、实现异步操作的库 2. 作用实现异步操作，类似Andorid中的AsyncTask、Handler的作用。 3. 特点由于RxJava的使用方式是基于事件流的链式调用，所以RxJava： 逻辑简洁 实现优雅 使用简单 4. 原理顾客到饭店点菜吃饭： RxJava原理基于一种扩展的观察者模式，其中包含四个角色： 角色 作用 类比 被观察者Observable 产生事件 顾客 观察者Observer 接收事件并给出响应动作 厨房 订阅Subscribe 连接被观察者和观察者 服务员 事件Event 被观察者和观察者沟通的载体 菜式 总结：被观察者Observable通过订阅Subscribe按顺序发送事件Event给观察者Observer，观察者Observer按顺序接收事件并作出对应的响应。 5. 基本使用使用方式有两种： 分步骤实现：该方法主要是为了深入说明RxJava的原理和使用，用于演示 基于事件流的链式调用，用于实际开发 5.1 分步骤实现5.1.1 使用步骤 创建被观察者Observable并生产事件，对应顾客进入饭店-坐下-点菜 创建观察者Observer并定义响应事件的行为，即厨房确定对应菜式 通过订阅Subscribe连接观察者和被观察者，即顾客找到服务员-服务员下单到厨房-厨房烹制 5.1.2 步骤详解步骤1：创建被观察者Observable并生产事件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class RxJavaActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_rx_java); // 1. 创建被观察者Observable对象 Observable&lt;Integer&gt; observable1 = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; // create()是RxJava最基本的创建事件序列的方法 // 此处传入一个OnSubscribe对象参数 // 当observable被订阅时，OnSubscribe的call()方法会自动被调用，即事件序列就会按照设定次序依次被触发 // 即观察者会依次调用对应事件的复写方法从而响应事件 // 从而实现被观察者调用了观察者的回调方法并由被观察者向观察者的事件传递，即观察者模式 // 2. 在复写的subscribe()中定义需要发送的事件 @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; // 通过ObservableEmitter类对象产生事件并通知观察者 // ObservableEmitter类介绍： // a. 定义：事件发射器 // b. 作用：定义需要发送的事件，并向观察者发送事件 emitter.onNext(1); emitter.onNext(2); emitter.onNext(3); emitter.onComplete(); &#125; &#125;); // 扩展：RxJava提供了其他方法用于创建被观察者Observable // 方法1：just()：直接将传入的参数依次发送出来 Observable observable2 = Observable.just("A", "B", "C"); // 将会依次调用： // onNext("A"); // onNext("B"); // onNext("C"); // onCompleted(); // 方法2：from(T []) / from(Iterable&lt;? extends T&gt;)：将传入的数组 / Iterable拆分成具体对象后，依次发送出来 String[] words = &#123;"A", "B", "C"&#125;; Observable observable3 = Observable.fromArray(words); // 将会依次调用： // onNext("A"); // onNext("B"); // onNext("C"); // onCompleted(); &#125;&#125; 步骤2：创建观察者Observer并定义响应事件的行为发生的事件类型包括：Next事件、Complete事件、Error事件。 Next：onNext()，普通事件，用于向观察者发送需要响应事件的信号，被观察者可发送无限个Next事件，观察者可以接收无限个Next事件。 Complete：onCompleted()，事件队列完结事件，RxJava把所有事件当做队列处理，标志被观察者不再发送普通事件Next。当被观察者发送一个Complete事件后，被观察者在Complete事件后的事件将会继续发送，但观察者收到Complete之后将不会再接收任何事件；被观察者可以不发送Complete事件。 Error：onError()，事件队列异常事件，标志事件处理过程中出现异常，此时队列自动终止，不允许事件发出。当被观察者发送一个Error事件后，被观察者在Error事件后的事件将会继续发送，但观察者收到Error事件后将不再继续接收任何事件；被观察者可以不发送Error事件。 在一个正确运行的事件序列中，onCompleted()和onError()互斥，二者只能有一个。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 方式1：采用Observer接口// 1. 创建观察者Observer对象Observer&lt;Integer&gt; observer1 = new Observer&lt;Integer&gt;() &#123; // 2. 创建对象时通过对应复写对应事件方法 从而 响应对应事件 // 观察者接收事件前，默认最先调用复写onSubscribe() @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, "开始采用subscribe连接"); &#125; // 当被观察者生产Next事件，观察者接收到时，会调用该复写方法 @Override public void onNext(Integer integer) &#123; Log.d(TAG, "对Next事件作出响应" + integer); &#125; // 当被观察者生产Error事件，观察者接收到时，会调用该复写方法 @Override public void onError(Throwable e) &#123; Log.d(TAG, "对Error事件作出响应"); &#125; // 当被观察者生产Complete事件，观察者接收到时，会调用该复写方法 @Override public void onComplete() &#123; Log.d(TAG, "对Complete事件作出响应"); &#125;&#125;;// 方式2：采用Subscriber抽象类，没有找到，可能已经删除// Subscriber类是RxJava内置的一个实现了Observer的抽象类，对Observer接口进行了扩展// 1. 创建观察者Observer对象Subscriber&lt;Integer&gt; observer2 = new Subscriber&lt;Integer&gt;() &#123; // 2. 创建对象时通过对应复写对应事件方法，从而响应对应事件 @Override public void onSubscribe(Subscription s) &#123; Log.d(TAG, "开始采用subscribe连接"); &#125; @Override public void onNext(Integer integer) &#123; Log.d(TAG, "对Next事件作出响应" + integer); &#125; @Override public void onError(Throwable t) &#123; Log.d(TAG, "对Error事件作出响应"); &#125; @Override public void onComplete() &#123; Log.d(TAG, "对Complete事件作出响应"); &#125;&#125;; 两种方式的对比：相同点： 使用方式完全一致，实际上，在RxJava的subscribe()中，Observer会先转换成Subscriber后再使用。 不同点：Subscriber抽象类对Observer接口进行了扩展，新增了两个方法， onStart()：在还未响应事件前调用，用于做一些初始化操作 unsubscribe()：取消订阅、该方法被调用后，观察者将不再接收和响应事件。调用前，先使用isUnsubscribed()判断状态，确定被观察者Observable是否还持有观察者Subscriber的引用，如果引用不能及时释放，会造成内存泄露。 步骤3：通过订阅Subscribe连接观察者和被观察者1observable.subscribe(observer); 5.2 基于事件流的链式调用123456789101112131415161718192021222324252627282930313233// RxJava的链式操作Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; // 1. 创建被观察者，生产事件 @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; emitter.onNext(1); emitter.onNext(2); emitter.onNext(3); emitter.onComplete(); &#125;&#125;).subscribe(new Observer&lt;Integer&gt;() &#123; // 2. 通过订阅subscribe连接观察者和被观察者 // 3. 创建观察者，定义响应事件的行为 @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, "开始采用subscribe连接"); &#125; @Override public void onNext(Integer integer) &#123; Log.d(TAG, "对Next事件" + integer + "作出响应"); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, "对Error事件作出响应"); &#125; @Override public void onComplete() &#123; Log.d(TAG, "对Complete事件作出响应"); &#125;&#125;); 整体方法调用顺序：观察者.onSubscribe() -&gt; 被观察者.subscribe() -&gt; 观察者.onNext() -&gt; 观察者.onComplete()。 RxJava 2.X提供了多个函数式接口，用于实现观察者模式： 以Customer为例： 1234567Observable.just("hello").subscribe(new Consumer&lt;String&gt;() &#123; // 每次接收到Observable的事件都会调用Consumer.accept（） @Override public void accept(String s) throws Exception &#123; Log.d(TAG, s); &#125; &#125;); 6. 额外说明使用Disposable.dispose()切断观察者和被观察者之间的连接，即观察者无法继续接收被观察者的事件，但被观察者可以继续发送事件。 12345678910111213141516171819202122232425262728293031Observer&lt;Integer&gt; observer = new Observer&lt;Integer&gt;() &#123; // 定义Disposable private Disposable mDisposable; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, "开始采用subscribe连接"); // 对disposable赋值 mDisposable = d; &#125; @Override public void onNext(Integer integer) &#123; Log.d(TAG, "对Next事件" + integer + "作出响应"); if (integer == 2) &#123; // 设置在接收到第二个事件后切换观察者和被观察者的连接 mDisposable.dispose(); Log.d(TAG, "已经切断了连接：" + mDisposable.isDisposed()); &#125; &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, "对Error事件作出响应"); &#125; @Override public void onComplete() &#123; Log.d(TAG, "对Complete事件作出响应"); &#125; &#125;;]]></content>
      <categories>
        <category>Android</category>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Jetpack：WorkManager]]></title>
    <url>%2F2019%2F08%2F09%2FAndroid-Jetpack-WorkManager%2F</url>
    <content type="text"><![CDATA[这里的数据不是从网络请求获取的，而是从assets目录下的json读取出来的，通常，从文件读取数据不会放在主线程中执行，这里使用了WorkManager，使能够在后台线程进行数据初始化。 1. 介绍官方文档：WorkMangerWorkManger介绍视频：中文官方介绍视频 1.1 定义官方介绍： The WorkManager API makes it easy to schedule deferrable, asynchronous tasks that are expected to run even if the app exits or device restarts.直译：WorkManager API使调度可延迟的异步任务变得很容易，即使应用程序退出或设备重启，这些任务也会运行。 1.2 选择WorkManager的理由Android中处理后台任务的选择很多，如Service、DownloadManager、AlarmManager、JobScheduler等， 为什么还要有WorkManager？ 兼容性更强，可以兼容到API 14 可以指定约束条件，比如可以选择必须在有网络的条件下执行 可以定时执行，也可以单次执行 监听和管理任务状态 多个任务可以使用任务链 保证任务执行，如当前执行条件不满足或者APP进程被杀死，它会等到下次条件满足或者APP进行打开后执行 支持省电模式 1.3 多线程任务如何选择？后台任务会消耗设备的系统资源，若处理不当，可能会造成设备电量的消耗，给用户带来不好的体验。所以，选择正确的后台处理方式很重要，下面是官方给出的选择方式： 关于后台的的知识，需要补充阅读：[译]从Service到WorkManager。 2. Demo实现：选取一张图片，做模糊处理，然后显示在头像上。 2.1 添加依赖1implementation "androidx.work:work-runtime-ktx:2.2.0-rc01" 2.2 自定义Worker自定义worker之前，先看看WorkerManager中几个重要的类： Worker：需要继承Worker，并复写doWork()方法，在里面写入需要在后台执行的代码 WorkRequest：指后台工作的请求，可以在后台工作的请求中添加约束条件 WorkManager：真正让Worker在后台执行的类 WorkerManager的执行流程： WorkRequest生成以后，Internal TaskExecutor将它存入WorkManager的数据库中，这也是为什么即使在程序退出之后，WorkManager也能保证后台任务在下次启动后条件满足的情况下执行。 当约束条件满足的情况下，Internal TaskExecutor告诉WorkFactory生成Worker。 后台执行Worker任务。 下面自定义一个Worker，目标是生成一张模糊图片，包含：清除之前的缓存路径，、图片模糊处理和图片的生成。将这三个步骤分成三个后台任务，三个后台任务分别涉及到无变量的情况、往外传参数和读取参数三种情况。 2.2.1 清除缓存路径：无变量情况（通常情况）12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 清理临时文件的Worker * * @author Liuyang * @date 2019/8/9 */class CleanUpWorker(context: Context, params: WorkerParameters) : Worker(context, params) &#123; private val TAG by lazy &#123; this::class.java.simpleName &#125; override fun doWork(): Result &#123; // Makes a notification when the work starts and slows down the work so that // it's easier to see each WorkRequest start, even on emulated devices makeStatusNotification("Cleaning up old temporary files", applicationContext) // sleep() return try &#123; // 删除逻辑 val outputDir = File(applicationContext.filesDir, BaseConstant.OUTPUT_PATH) if (outputDir.exists()) &#123; val entries = outputDir.listFiles() if (entries != null) &#123; for (entry in entries) &#123; val name = entry.name if (name.isNotEmpty() &amp;&amp; name.endsWith(".png")) &#123; val deleted = entry.delete() Log.i(TAG, String.format("Deleted %s - %s", name, deleted)) &#125; &#125; &#125; &#125; // 成功 Result.success() &#125; catch (exception: Exception) &#123; Log.e(TAG, "Error cleaning up", exception) // 失败 Result.failure() &#125; &#125;&#125; 2.2.2 图片模糊处理：往外传参数（输出参数）123456789101112131415161718192021222324252627282930313233343536373839/** * 模糊处理的worker * * @author Liuyang * @date 2019/8/11 */class BlurWorker(context: Context, params: WorkerParameters) : Worker(context, params) &#123; private var TAG: String = this::class.java.simpleName override fun doWork(): Result &#123; val context = applicationContext val resultUri = inputData.getString(BaseConstant.KEY_IMAGE_URI) // 通知开始处理图片 makeStatusNotification("Blurring image", context) return try &#123; // 图片处理逻辑 if (TextUtils.isEmpty(resultUri)) &#123; Log.e(TAG, "Invalid input uri") throw IllegalArgumentException("Invalid input uri") &#125; val resolver = context.contentResolver val picture = BitmapFactory.decodeStream(resolver.openInputStream(Uri.parse(resultUri))) // 创建Bitmap文件 val output = blurBitmap(picture, context) // 存入路径 val outputUri = writeBitmapToFile(context, output) // 输出路径 val outputData = workDataOf(BaseConstant.KEY_IMAGE_URI to outputUri.toString()) makeStatusNotification("Output is $outputUri", context) Result.success(outputData) &#125; catch (throwable: Throwable) &#123; Log.e(TAG, "Error applying blur", throwable) Result.failure() &#125; &#125;&#125; 2.2.3 图片生成：读取参数1234567891011121314151617181920212223242526272829303132333435363738394041/** * 存储照片的worker * * @author Liuyang * @date 2019/8/11 */class SaveImageToFileWorker(context: Context, parameters: WorkerParameters) : Worker(context, parameters) &#123; private val TAG by lazy &#123; SaveImageToFileWorker::class.java.simpleName &#125; private val title = "Blurred Image" private val dateFormatter = SimpleDateFormat("yyyy.MM.dd 'at' HH:mm:ss z", Locale.getDefault()) override fun doWork(): Result &#123; // Makes a notification when the work starts and slows down the work so that // it's easier to see each WorkRequest start, even on emulated devices makeStatusNotification("Saving image", applicationContext) // sleep() val resolver = applicationContext.contentResolver return try &#123; // 获取从外部传入的参数 val resourceUri = inputData.getString(BaseConstant.KEY_IMAGE_URI) val bitmap = BitmapFactory.decodeStream(resolver.openInputStream(Uri.parse(resourceUri))) val imageUrl = MediaStore.Images.Media.insertImage(resolver, bitmap, title, dateFormatter.format(Date())) if (!imageUrl.isNullOrEmpty()) &#123; val output = workDataOf(BaseConstant.KEY_IMAGE_URI to imageUrl) Result.success() &#125; else &#123; Log.e(TAG, "Writing to MediaStore failed") Result.failure() &#125; &#125; catch (exception: Exception) &#123; Log.e(TAG, "Unable to save image to Gallery", exception) Result.failure() &#125; &#125;&#125; 2.3 创建WorkManager在model中单例获取： 123class MeModel(private val userRepository: UserRepository) : ViewModel() &#123; private val workManager = WorkManager.getInstance()&#125; 2.4 构建WorkRequestWorkRequest可以分为两类： PeriodicWorkRequest：Periodic，周期；多次、定时执行任务请求，不支持任务链 OneTimeWorkRequest：只执行一次的任务请求，支持任务链 执行一个任务以OneTimeWorkRequest为例，如果只有一个任务请求： 12val request = OneTimeWorkRequest.from(CleanUpWorker::class.java)workManager.enqueue(request) 执行多个任务例子中有三个Worker，并且里面有先后执行的顺序，所以可以使用任务链： 12345678// 多任务按顺序执行workManager.beginWith( mutableListOf( OneTimeWorkRequest.from(CleanUpWorker::class.java) )) .then(OneTimeWorkRequestBuilder&lt;BlurWorker&gt;().setInputData(createInputDataForUri()).build()) .then(OneTimeWorkRequestBuilder&lt;SaveImageToFileWorker&gt;().build()) .enqueue() 假设多次点击图片更换头像，提交多次请求，由于网络原因（Demo中没有网络请求部分），最后返回的很可能不是最后一次请求的图片，这显然是有问题的，WorkManager可能满足这样的需求，保证任务的唯一性： 12345678910// 多任务按顺序执行workManager.beginUniqueWork( IMAGE_MANIPULATION_WORK_NAME, // 任务名称 ExistingWorkPolicy.REPLACE, // 任务相同的执行策略 分为REPLACE，KEEP，APPEND mutableListOf( OneTimeWorkRequest.from(CleanUpWorker::class.java) )) .then(OneTimeWorkRequestBuilder&lt;BlurWorker&gt;().setInputData(createInputDataForUri()).build()) .then(OneTimeWorkRequestBuilder&lt;SaveImageToFileWorker&gt;().build()) .enqueue() 无顺序多任务 如果并行执行没有顺序的多个任务，无论是beginUniqueWork还是beginWith方法都可以接收一个List&lt;OneTimeWorkRequest&gt;。 使用约束假设需要将生成的图片上传到服务器，并且需要将图片同时保存到本地，这是就需要设备联网并且由足够的存储空间，这时，就可以给WorkRequest指明约束条件：12345678910111213// 构建约束条件val constraints = Constraints.Builder() .setRequiresBatteryNotLow(true)// 非电池低电量 .setRequiredNetworkType(NetworkType.CONNECTED)// 网络连接的情况 .setRequiresStorageNotLow(true)// 存储空间充足 .build()// 存储照片val save = OneTimeWorkRequestBuilder&lt;SaveImageToFileWorker&gt;() .setConstraints(constraints) .addTag(BaseConstant.TAG_OUTPUT) .build()continuation = continuation.then(save) 可以指明的约束条件有：电池电量、充电、网络、存储和延迟等。 下面是Demo中的具体使用： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class MeModel(private val userRepository: UserRepository) : ViewModel() &#123; private var imageUri: Uri? = null private var outPutUri: Uri? = null var outPutWorkInfo: LiveData&lt;List&lt;WorkInfo&gt;&gt; private val workManager = WorkManager.getInstance() val use = userRepository.findUserById(AppPrefsUtils.getLong(BaseConstant.SP_USER_ID)) init &#123; outPutWorkInfo = workManager.getWorkInfosByTagLiveData(BaseConstant.TAG_OUTPUT) &#125; internal fun applyBlur(blurLevel: Int) &#123; var continuation = workManager.beginUniqueWork( BaseConstant.IMAGE_MANIPULATION_WORK_NAME, ExistingWorkPolicy.REPLACE, OneTimeWorkRequest.from(CleanUpWorker::class.java) ) for (i in 0 until blurLevel) &#123; val builder = OneTimeWorkRequestBuilder&lt;BlurWorker&gt;() if (i == 0) &#123; builder.setInputData(createInputDataForUri()) &#125; continuation = continuation.then(builder.build()) &#125; // 构建约束条件 val constraints = Constraints.Builder() .setRequiresBatteryNotLow(true)// 非电池低电量 .setRequiredNetworkType(NetworkType.CONNECTED)// 网络连接的情况 .setRequiresStorageNotLow(true)// 存储空间充足 .build() // 存储照片 val save = OneTimeWorkRequestBuilder&lt;SaveImageToFileWorker&gt;() .setConstraints(constraints) .addTag(BaseConstant.TAG_OUTPUT) .build() continuation = continuation.then(save) continuation.enqueue() &#125; private fun createInputDataForUri(): Data &#123; val builder = Data.Builder() imageUri?.let &#123; builder.putString(BaseConstant.KEY_IMAGE_URI, imageUri.toString()) &#125; return builder.build() &#125; private fun uriOrNull(uriString: String?): Uri? &#123; return if (!uriString.isNullOrEmpty()) &#123; Uri.parse(uriString) &#125; else null &#125; internal fun setImageUri(uri: String?) &#123; imageUri = uriOrNull(uri) &#125; internal fun setOutputUri(uri: String?) &#123; outPutUri = uriOrNull(uri) val value = use.value value?.headImage = uri!! if (value != null) &#123; viewModelScope.launch &#123; userRepository.updateUser(value) &#125; &#125; &#125; fun cancelWork() &#123; workManager.cancelUniqueWork(BaseConstant.IMAGE_MANIPULATION_WORK_NAME) &#125;&#125; 2.5 取消任务如果要取消任务workManager.cancelAllWork()，如果要取消上面执行的唯一任务，需要上面唯一的任务名： 123fun cancelWork() &#123; workManager.cancelUniqueWork(BaseConstant.IMAGE_MANIPULATION_WORK_NAME)&#125; 2.6 观察任务状态任务状态的变化过程： 其中，SUCCESS、FAILED、CALCELLED都属于任务已经完成。观察任务状态需要使用到LiveData： 1234567891011class MeModel(private val userRepository: UserRepository) : ViewModel() &#123; private var imageUri: Uri? = null private var outPutUri: Uri? = null var outPutWorkInfo: LiveData&lt;List&lt;WorkInfo&gt;&gt; private val workManager = WorkManager.getInstance() val use = userRepository.findUserById(AppPrefsUtils.getLong(BaseConstant.SP_USER_ID)) init &#123; outPutWorkInfo = workManager.getWorkInfosByTagLiveData(BaseConstant.TAG_OUTPUT) &#125;&#125; 当图片处理时，程序弹出加载框，图片处理完成，程序会将图片路径保存到User里的headImage并存储到数据库中，任务状态观测参见MeFragment中的onSubscribeUi()中： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107/** * 我的界面 * * @author Liuyang * @date 2019/8/11 */class MeFragment : Fragment() &#123; private val TAG by lazy &#123; MeFragment::class.java.simpleName &#125; // Model懒加载 private val meModel: MeModel by viewModels &#123; CustomViewModelProvider.providerMeModel(requireContext()) &#125; // 选择图片的标识 private val REQUEST_CODE_IMAGE = 100 // 加载框 private val sweetAlertDialog: SweetAlertDialog by lazy &#123; SweetAlertDialog(requireContext(), SweetAlertDialog.PROGRESS_TYPE) .setTitleText(&quot;头像&quot;) .setContentText(&quot;更新中......&quot;)// .setCancelButton(&quot;取消&quot;) &#123;// meModel.cancelWork()// sweetAlertDialog.dismiss()// &#125; &#125; override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? &#123; val binding: FragmentMeBinding = FragmentMeBinding.inflate(inflater, container, false) initListener(binding) onSubscribeUi(binding) return binding.root &#125; /** * 初始化监听器 */ private fun initListener(binding: FragmentMeBinding) &#123; binding.ivHead.setOnClickListener &#123; // 选择处理的图片 val chooseIntent = Intent(Intent.ACTION_PICK, MediaStore.Images.Media.EXTERNAL_CONTENT_URI) startActivityForResult(chooseIntent, REQUEST_CODE_IMAGE) &#125; &#125; /** * binding绑定 */ private fun onSubscribeUi(binding: FragmentMeBinding) &#123; meModel.use.observe(this, Observer &#123; binding.user = it &#125;) // 任务状态的监测 meModel.outPutWorkInfo.observe(this, Observer &#123; if (it.isNullOrEmpty()) return@Observer val state = it[0] if (state.state.isFinished) &#123; // 更新头像 val outputImageUri = state.outputData.getString(BaseConstant.KEY_IMAGE_URI) if (!outputImageUri.isNullOrEmpty()) &#123; meModel.setOutputUri(outputImageUri) &#125; sweetAlertDialog.dismiss() &#125; &#125;) &#125; /** * 图片选择完成的回调 */ override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) &#123; if (resultCode == Activity.RESULT_OK) &#123; when (requestCode) &#123; REQUEST_CODE_IMAGE -&gt; data?.let &#123; handleImageRequestResult(data) &#125; else -&gt; Log.d(TAG, &quot;Unknown request code.&quot;) &#125; &#125; else &#123; Log.e(TAG, String.format(&quot;Unexpected Result code %s&quot;, resultCode)) &#125; &#125; /** * 图片处理 */ private fun handleImageRequestResult(data: Intent) &#123; val imageUri: Uri? = data.clipData?.let &#123; it.getItemAt(0).uri &#125; ?: data.data if (imageUri == null) &#123; Log.e(TAG, &quot;Invalid input image Uri.&quot;) return &#125; sweetAlertDialog.dismiss() // 图片模糊处理 meModel.setImageUri(imageUri.toString()) meModel.applyBlur(3) &#125;&#125; 3. 其他选择适合的Worker 谷歌提供了四种Worker： 自动运行在后台线程的Worker 结合协程的CoroutineWorker 结合RxJava的RxWorker 以上三个类的基类ListenableWorker 这里以CoroutineWorker为例，简单介绍，使用ShoeWorker从文中读取鞋子的数据并完成数据库的插入工作： 1234567891011121314151617181920212223242526272829303132333435class ShoeWorker(context: Context, workerParameters: WorkerParameters) : CoroutineWorker(context, workerParameters) &#123; private val TAG by lazy &#123; ShoeWorker::class.java.simpleName &#125; // 指定Dispatchers override val coroutineContext: CoroutineDispatcher get() = Dispatchers.IO override suspend fun doWork(): Result = coroutineScope &#123; try &#123; applicationContext.assets.open("shoes.json").use &#123; JsonReader(it.reader()).use &#123; val shoeType = object : TypeToken&lt;List&lt;Shoe&gt;&gt;() &#123;&#125;.type val shoeList: List&lt;Shoe&gt; = Gson().fromJson(it, shoeType) val shoeDao = RepositoryProvider.providerShoeRepository(applicationContext) shoeDao.insertShoes(shoeList) for (i in 0..2) &#123; for (shoe in shoeList) &#123; shoe.id += shoeList.size &#125; shoeDao.insertShoes(shoeList) &#125; Result.success() &#125; &#125; &#125; catch (e: Exception) &#123; Log.e(TAG, "Error seeding database", e) Result.failure() &#125; &#125;&#125; 延伸：Android Jetpack - 使用 WorkManager 管理后台任务]]></content>
      <categories>
        <category>Android</category>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>Jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你的儿女]]></title>
    <url>%2F2019%2F08%2F08%2F%E4%BD%A0%E7%9A%84%E5%84%BF%E5%A5%B3%2F</url>
    <content type="text"><![CDATA[你的儿女———— 纪伯伦（Khalil Gibran）Your children are not your children.你的子女，其实不是你的子女。 They are the sons and daughters of Life’s longing for itself.他们是生命对于自身渴望而诞生的孩子。 They come through you but not from you,他们借助你来到这个世界，却非因你而来， And though they are with you, yet they belong not to you.他们陪伴你，却并不属于你。 You may give them your love but not your thoughts,你可以给予他们你的爱，却不是你的想法， For they have their own thoughts.因为他们有自己的思想。 You may house their bodies but not their souls,你可以庇护的是他们的身体，却不是他们的灵魂， For their souls dwell in the house of tomorrow, which you cannot visit, not even in your dreams.因为他们的灵魂属于明天，属于你在梦境中也无法达到的明天。 You may strive to be like them, but seek not to make them like you,你可以拼尽全力，变得像他们一样，却不要让他们变得和你一样， For life goes not backward nor tarries with yesterday.因为生命不会后退，也不在过去停留。 You are the bows from which your children as living arrows are sent forth.你是弓，儿女是从你那里射出的箭。 The archer sees the mark upon the path of the infinite,弓箭手遥望未来之路上的箭靶， and He bends you with His might that His arrows may go swift and far.用尽力气将你拉开，使箭射得又快又远。 Let your bending in the archer’s hand be for gladness,怀着快乐的心情，在弓箭手的手中弯曲吧， For even as he loves the arrow that flies, so He loves also the bow that is stable.因为他爱一路飞翔的箭，也爱无比稳定的弓。]]></content>
      <categories>
        <category>美文</category>
      </categories>
      <tags>
        <tag>美文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Jetpack：Paging]]></title>
    <url>%2F2019%2F08%2F05%2FAndroid-Jetpack-Paging%2F</url>
    <content type="text"><![CDATA[在遇到RecyclerView加载大量数据的情况，如果是在数据库请求，需要消耗数据库资源并且需要花费较多的时间，同意，如果是发送网络请求，则需要消耗宽带和更多的时间，无论哪种情形，对于用户的体验都是糟糕的。这时，可以采用分段加载来缩短时间，给带来良好的体验，目前，对于加载大量数据的处理方式有两种： 借助刷新控件来实现用户手动请求数据 数据达到边界自动请求加载 谷歌的Android Jetpack也实现了自己的分页库——Paging。 1. 介绍官方文档：Paging官方Demo：网络方式，数据库方式 官方介绍： The Paging Library helps you load and display small chunks of data at a time. Loading partial data on demand reduces usage of network bandwidth and system resources.直译：分页库帮助您每次加载和显示小块数据。按需加载部分数据会减少网络带宽和系统资源的使用。 Paging架构： PagedList：一个可以以分页形式异步加载数据的容器，可以跟RecyclerView结合 DataSource或DataSource.Factory：数据源，DataSource将数据转变成PagedList，DataSource.Factory则用来创建DataSource LivePagedListBuilder：用来生成LiveData&lt;PagedList&gt;，需要DataSource.Factory参数 BoundaryCallback：数据达到边界的回调 PagedListAdapter：一种RecyclerView适配器 优点： RxJava以及Android Jetpack的支持，如LiveData、Room等 自定义分页策略 异步处理数据 结合RecyclerView等 2. Demo2.1 添加依赖：1234dependencies &#123; // paging implementation "androidx.paging:paging-runtime:2.1.0"&#125; 2.2 创建数据源 非Room数据库如果没有使用Room数据库，就需要自定义实现DataSource，通常实现DataSource有三种方式，分别继承三种抽象类，它们分别是： 名称 使用场景 PageKeyedDataSource&lt;Key, Value&gt; 分页请求数据的场景 ItemKeyedDataSource&lt;Key, Value&gt; 以表的某个列为Key，加载其后的N个数据 PositionalDataSource&lt;T&gt; 当数据源总数特定，根据指定位置请求数据的场景 这里以PageKeyedDataSource&lt;Key, Value&gt;为例，虽然这里的数据库使用的是Room，但查询数据以返回List代表着通常数据库的使用方式： 12345package com.ly.allendemojetpack.db.repositoryclass ShoeRepository private constructor(private val shoeDao: ShoeDao) &#123; fun getPageShoes(startIndex: Long, endIndex: Long): List&lt;Shoe&gt; = shoeDao.findShoesByIndexRange(startIndex, endIndex)&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.ly.allendemojetpack.db.datasourceimport android.util.Logimport androidx.paging.PageKeyedDataSourceimport com.ly.allendemojetpack.common.BaseConstantimport com.ly.allendemojetpack.db.data.Shoeimport com.ly.allendemojetpack.db.repository.ShoeRepository/** * 自定义PageKeyedDataSource * 演示Paging库的使用 */class CustomPageDataSource(private val shoeRepository: ShoeRepository) : PageKeyedDataSource&lt;Int, Shoe&gt;() &#123; private val TAG: String by lazy &#123; this::class.java.simpleName &#125; /** * 第一次加载时调用 */ override fun loadInitial(params: LoadInitialParams&lt;Int&gt;, callback: LoadInitialCallback&lt;Int, Shoe&gt;) &#123; val startIndex = 0L val endIndex: Long = 0L + params.requestedLoadSize val shoe = shoeRepository.getPageShoes(startIndex, endIndex) callback.onResult(shoe, null, 2) &#125; /** * 每次分页加载时调用 */ override fun loadAfter(params: LoadParams&lt;Int&gt;, callback: LoadCallback&lt;Int, Shoe&gt;) &#123; Log.e(TAG, "startPage:$&#123;params.key&#125;, size:$&#123;params.requestedLoadSize&#125;") val startPage = params.key val startIndex = ((startPage - 1) * BaseConstant.SINGLE_PAGE_SIZE).toLong() + 1 val endIndex = startIndex + params.requestedLoadSize - 1 val shoes = shoeRepository.getPageShoes(startIndex, endIndex) callback.onResult(shoes, params.key + 1) &#125; override fun loadBefore(params: LoadParams&lt;Int&gt;, callback: LoadCallback&lt;Int, Shoe&gt;) &#123; Log.e(TAG, "endPage:$&#123;params.key&#125;, size:$&#123;params.requestedLoadSize&#125;") val endPage = params.key val endIndex = ((endPage - 1) * BaseConstant.SINGLE_PAGE_SIZE).toLong() + 1 var startIndex = endIndex - params.requestedLoadSize startIndex = if (startIndex &lt; 0) &#123; 0L &#125; else &#123; startIndex &#125; val shoe = shoeRepository.getPageShoes(startIndex, endIndex) callback.onResult(shoe, params.key + 1) &#125;&#125; DataSource创建好了，再创建一个DataSource.Factory，返回对应的DataSource实例： 1234567891011121314package com.ly.allendemojetpack.db.datasourceimport androidx.paging.DataSourceimport com.ly.allendemojetpack.db.data.Shoeimport com.ly.allendemojetpack.db.repository.ShoeRepository/** * 构建CustomPageDataSource的工厂类 */class CustomPageDataSourceFactory(private val shoeRepository: ShoeRepository) : DataSource.Factory&lt;Int, Shoe&gt;() &#123; override fun create(): DataSource&lt;Int, Shoe&gt; &#123; return CustomPageDataSource(shoeRepository) &#125;&#125; Room数据库如果使用Room与Paging结合使用，可以直接在Room的Dao层使用：12345@Daointerface ShoeDao &#123; @Query("SELECT * FROM shoe") fun getAllShoesLD(): DataSource.Factory&lt;Int, Shoe&gt;&#125; 使用起来简单很多。 2.3 构建LiveData &lt;PagedList&gt;要想获得LiveData&lt;PagedList&gt;，需要先创建LivePagedListBuilder，LivePagedListbuilder有设分页数量和配置参数两种构造方法，设置分页数量比较简单，直接查看API即可，下面看看配置参数使用： 123456789101112class ShoeModel constructor(repository: ShoeRepository) : ViewModel() &#123; /** * 鞋子集合的观察类 */ val shoes: LiveData&lt;PagedList&lt;Shoe&gt;&gt; = LivePagedListBuilder&lt;Int, Shoe&gt;( CustomPageDataSourceFactory(repository), PagedList.Config.Builder() .setPageSize(10) .setEnablePlaceholders(false) .setInitialLoadSizeHint(10) .build() ).build() 2.4 创建PagedListAdapterPagedListAdapter是一个特殊的RecyclerView的RecyclerAdapter，使用方法类似，这里使用Data Binding： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.ly.allendemojetpack.ui.adapterimport android.content.Contextimport android.content.Intentimport android.view.LayoutInflaterimport android.view.Viewimport android.view.ViewGroupimport androidx.paging.PagedListAdapterimport androidx.recyclerview.widget.RecyclerViewimport com.ly.allendemojetpack.common.BaseConstantimport com.ly.allendemojetpack.databinding.ItemShoeBindingimport com.ly.allendemojetpack.db.data.Shoeimport com.ly.allendemojetpack.ui.activity.DetailActivity/** * 鞋子的适配器，配合Data Binding使用 * * @author Liuyang * @date 2019/8/3 */class ShoeAdapter constructor(val context: Context) : PagedListAdapter&lt;Shoe, ShoeAdapter.ViewHolder&gt;(ShoeDiffCallback()) &#123; override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder &#123; return ViewHolder(ItemShoeBinding.inflate(LayoutInflater.from(parent.context), parent, false)) &#125; override fun onBindViewHolder(holder: ViewHolder, position: Int) &#123; val shoe = getItem(position) holder.apply &#123; bind(onCreateListener(shoe!!.id), shoe) itemView.tag = shoe &#125; &#125; /** * Holder的点击事件 */ private fun onCreateListener(id: Long): View.OnClickListener &#123; return View.OnClickListener &#123; val intent = Intent(context, DetailActivity::class.java) intent.putExtra(BaseConstant.DETAIL_SHOE_ID, id) context.startActivity(intent) &#125; &#125; class ViewHolder(private val binding: ItemShoeBinding) : RecyclerView.ViewHolder(binding.root) &#123; fun bind(listener: View.OnClickListener, item: Shoe) &#123; binding.apply &#123; this.listener = listener this.shoe = item executePendingBindings() &#125; &#125; &#125;&#125; 1234567891011121314package com.ly.allendemojetpack.ui.adapterimport androidx.recyclerview.widget.DiffUtilimport com.ly.allendemojetpack.db.data.Shoeclass ShoeDiffCallback : DiffUtil.ItemCallback&lt;Shoe&gt;() &#123; override fun areItemsTheSame(oldItem: Shoe, newItem: Shoe): Boolean &#123; return oldItem.id == newItem.id &#125; override fun areContentsTheSame(oldItem: Shoe, newItem: Shoe): Boolean &#123; return oldItem == newItem &#125;&#125; 2.5 监听数据同样使用Data Binding，ShoeFragment： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.ly.allendemojetpack.ui.fragment.mainimport android.os.Bundleimport android.view.LayoutInflaterimport android.view.Viewimport android.view.ViewGroupimport androidx.fragment.app.Fragmentimport androidx.fragment.app.viewModelsimport androidx.lifecycle.Observerimport androidx.lifecycle.ViewModelProvidersimport com.ly.allendemojetpack.databinding.FragmentShoeBindingimport com.ly.allendemojetpack.ui.adapter.ShoeAdapterimport com.ly.allendemojetpack.viewmodel.CustomViewModelProviderimport com.ly.allendemojetpack.viewmodel.ShoeModel/** * 鞋子的Fragment * * @author Liuyang * @date 2019/8/3 */class ShoeFragment : Fragment() &#123; // by viewModels 需要依赖 "androidx.navigation:navigation-ui-ktx:$rootProject.navigationVersion" private val viewModel: ShoeModel by viewModels &#123; CustomViewModelProvider.providerShoeModel(requireContext()) &#125; override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? &#123; val binding: FragmentShoeBinding = FragmentShoeBinding.inflate(inflater, container, false) context ?: return binding.root // 适配器 val adapter = ShoeAdapter(context!!) binding.recycler.adapter = adapter onSubscribeUi(adapter) return binding.root &#125; /** * 鞋子数据更新的通知 */ private fun onSubscribeUi(adapter: ShoeAdapter) &#123; viewModel.shoes.observe(viewLifecycleOwner, Observer &#123; if (it != null) &#123; adapter.submitList(it) &#125; &#125;) &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>Jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Jetpack：Room]]></title>
    <url>%2F2019%2F08%2F05%2FAndroid-Jetpack-Room%2F</url>
    <content type="text"><![CDATA[1. 介绍官方网址：Room 官方介绍： The Room persistence library provides an abstraction layer over SQLite to allow for more robust database access while harnessing the full power of SQLite. 简单来说，Room是一个基于SQLite的强大数据库框架。 优点： 使用编译时注解，能够对@Query和@Entity里面的SQL语句进行验证 与SQL语句的使用更加贴近，能够降低学习成本 对RxJava2支持，对LiveData支持 @Embedded能减少表的创建 2. Demo目标结构： 三张表：用户表、鞋表和收藏记录表，用户表和鞋表存在多对多的关系。 2.1 步骤1：添加依赖在model的build.gradel添加： 1234567891011apply plugin: 'kotlin-kapt'dependencies &#123; ...... // room implementation "androidx.room:room-runtime:2.2.0-alpha01" implementation "androidx.room:room-ktx:2.2.0-alpha01" kapt "androidx.room:room-compiler:2.2.0-alpha01" androidTestImplementation "androidx.room:room-testing:2.2.0-alpha01"&#125; 2.2 步骤2：创建表（实体）用户表： 1234567891011121314151617181920212223package com.ly.allendemojetpack.db.dataimport android.location.Addressimport androidx.room.*/** * 用户表 * * @author Liuyang * @date 2019/8/3 */@Entity(tableName = "user")data class User( @ColumnInfo(name = "user_account") val account: String,// 账号 @ColumnInfo(name = "user_pwd") val pwd: String,// 摩玛 @ColumnInfo(name = "user_name") val name: String, @Embedded val address: Address,// 地址 @Ignore val state: Int) &#123; @PrimaryKey(autoGenerate = true) @ColumnInfo(name = "id") var id: Long = 0&#125; 收藏记录表： 12345678910111213141516171819202122232425262728package com.ly.allendemojetpack.db.dataimport androidx.room.ColumnInfoimport androidx.room.Entityimport androidx.room.ForeignKeyimport androidx.room.PrimaryKeyimport java.util.*/** * 喜欢的鞋 表 * * @author Liuyang * @date 2019/8/3 */@Entity( tableName = "fav_shoe", foreignKeys = [ForeignKey(entity = Shoe::class, parentColumns = ["id"], childColumns = ["shoe_id"]), ForeignKey(entity = User::class, parentColumns = ["id"], childColumns = ["user_id"])])data class FavouriteShoe( @ColumnInfo(name = "shoe_id") val shoeId: Long,// 外键 鞋子的id @ColumnInfo(name = "user_id") val userId: Long,// 外键 用户的id @ColumnInfo(name = "fav_date") val date: Date// 创建日期) &#123; @PrimaryKey(autoGenerate = true) @ColumnInfo(name = "id") var id: Long = 0&#125; 对于其中注解的解释： @Entity：声明这是一个表（实体），主要参数：tableName表名、foreignKeys外键、indices索引 ColumnInfo：主要用来修改在数据库中的字段名 PrimaryKey：声明该字段为主键，可以声明是否自动创建 Ignore：声明某个字段只是临时用，不存储在数据库中 Embedded：用于嵌套，里面的字段同样会存储在数据库中 最后一个，在User表中有一个变量address，它是一个Address类： 12345678package com.ly.allendemojetpack.db.data/** * 地址 */data class Address( val street: String, val state: String, val city: String, val postCode: String) 通常，如果想这些字段存储在数据库中，有两种方法： 重新创建一个表，进行一对一的关联，但是多创建一个表显得麻烦 在用户表中增加字段，但是这样映射出来的对象显得 不面向对象 @Embedded就是为了解决上面你的第2个问题，即不多创建一个表，又能将数据库中映射的对象看上去面向对象。 Shoe表： 123456789101112131415161718192021222324package com.ly.allendemojetpack.db.dataimport androidx.room.ColumnInfoimport androidx.room.Entityimport androidx.room.PrimaryKey/** * 鞋子表 * * @author Liuyang * @date 2019/8/3 */@Entity(tableName = "shoe")data class Shoe( @ColumnInfo(name = "shoe_name") val name: String, @ColumnInfo(name = "shoe_description") val description: String, @ColumnInfo(name = "shoe_price") val price: Float, @ColumnInfo(name = "shoe_brand") val brand: String, @ColumnInfo(name = "shoe_imgUrl") val imgUrl: String) &#123; @PrimaryKey(autoGenerate = true) @ColumnInfo(name = "id") var id: Long = 0&#125; 2.3 步骤3：创建Dao数据处理的方法，就是数据的增删改查。在抽象类或接口加一个@Dao注解即可。 2.3.1 增@Insert注解，声明当前的方法为新增的方法，并且可以设置当新增冲突的时候处理的方法。 1234567891011121314151617181920212223242526272829303132333435363738/** * 鞋子表的方法 * * @author Liuyang * @date 2019/8/3 */@Daointerface ShoeDao &#123; /** * 选择所有的鞋 */ @Query("SELECT * FROM shoe") fun getAllShoes(): LiveData&lt;List&lt;Shoe&gt;&gt; /** * 通过id查找鞋子 */ @Query("SELECT * FROM shoe WHERE id = :id") fun findShoeById(id: Long): LiveData&lt;Shoe&gt; /** * 通过品牌找鞋子 */ @Query("SELECT * FROM shoe WHERE shoe_brand = :brand") fun findShoeByBrand(brand: String): LiveData&lt;List&lt;Shoe&gt;&gt; /** * 插入一种鞋子 */ @Insert(onConflict = OnConflictStrategy.REPLACE) fun insertShoe(shoe: Shoe) /** * 插入多种鞋子 */ @Insert(onConflict = OnConflictStrategy.REPLACE) fun insertShoe(shoes: List&lt;Shoe&gt;)&#125; 2.3.2 删@Delete注解，声明当前的方法是一个删除方法。 2.3.3 改@Update注解，声明当前方法是一个更新方法 2.3.4 查@Query注解，不仅可以声明这是一个查询语句，也能用来删除和修改，不能用来新增。 简单查询除了简单查询，还能配合LiveData和RxJava。这里使用的是implementation &#39;io.reactivex.rxjava2:rxjava:2.2.3&#39;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.ly.allendemojetpack.db.daoimport androidx.lifecycle.LiveDataimport androidx.room.Daoimport androidx.room.Insertimport androidx.room.OnConflictStrategyimport androidx.room.Queryimport com.ly.allendemojetpack.db.data.Shoeimport io.reactivex.Flowable/** * 鞋子表的方法 * * @author Liuyang * @date 2019/8/3 */@Daointerface ShoeDao &#123; /** * 通过id查找鞋子 */ @Query("SELECT * FROM shoe WHERE id = :id") fun findShoeById(id: Long): Shoe? /** * 通过品牌找鞋子 */ @Query("SELECT * FROM shoe WHERE shoe_brand = :brand") fun findShoeByBrand(brand: String): List&lt;Shoe&gt; /** * 模糊查询 排序 同名鞋名查询鞋 */ @Query("SELECT * FROM shoe WHERE shoe_name LIKE :name ORDER BY shoe_brand ASC") fun findShoesByName(name: String): List&lt;Shoe&gt; /** * 配合LiveData，返回所有鞋子 */ @Query("SELECT * FROM shoe") fun getAllShoesLD(): LiveData&lt;List&lt;Shoe&gt;&gt; /** * 配合LiveData，通过id查找鞋子 */ @Query("SELECT * FROM shoe WHERE id = :id") fun findShoeByIdLD(id: Long): LiveData&lt;Shoe&gt; /** * 配合RxJava，通过id查询单款鞋子 */ @Query("SELECT * FROM shoe WHERE id=:id") fun findShoeByIdRx(id: Long): Flowable&lt;Shoe&gt;&#125; 查询多个的时候，可以返回List和数组，还可以配合LiveData和RxJava。 复合查询12345678910/** * 根据收藏结合，查询用户喜欢的鞋的集合 */@Query( "SELECT shoe.id,shoe.shoe_name,shoe.shoe_description,shoe.shoe_price,shoe.shoe_brand,shoe.shoe_imgUrl " + "FROM shoe " + "INNER JOIN fav_shoe ON fav_shoe.shoe_id = shoe.id " + "WHERE fav_shoe.user_id = :userId")fun findShoesByUserId(userId: Long): LiveData&lt;List&lt;Shoe&gt;&gt; 2.4 步骤4：创建数据库创建一个数据库对象非常消耗资源，使用单例模式可以避免更多的资源消耗。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.ly.allendemojetpack.dbimport android.content.Contextimport androidx.room.Databaseimport androidx.room.Roomimport androidx.room.RoomDatabaseimport androidx.sqlite.db.SupportSQLiteDatabaseimport androidx.work.OneTimeWorkRequestBuilderimport androidx.work.WorkManagerimport com.ly.allendemojetpack.db.dao.FavouriteShoeDaoimport com.ly.allendemojetpack.db.dao.ShoeDaoimport com.ly.allendemojetpack.db.dao.UserDaoimport com.ly.allendemojetpack.db.data.Shoeimport com.ly.allendemojetpack.db.data.Userimport com.ly.allendemojetpack.utils.ShoeWorker/** * 数据库文件 * * @author Liuyang * @date 2019/8/2 */@Database(entities = [User::class, Shoe::class], version = 1, exportSchema = false)abstract class AppDataBase : RoomDatabase() &#123; abstract fun userDao(): UserDao abstract fun shoeDao(): ShoeDao abstract fun favouriteShoeDao(): FavouriteShoeDao companion object &#123; @Volatile private var instance: AppDataBase? = null fun getInstance(context: Context): AppDataBase &#123; return instance ?: synchronized(this) &#123; instance ?: buildDataBase(context) .also &#123; instance = it &#125; &#125; &#125; private fun buildDataBase(context: Context): AppDataBase &#123; return Room.databaseBuilder(context, AppDataBase::class.java, "jetpack_db") .addCallback(object : RoomDatabase.Callback() &#123; override fun onCreate(db: SupportSQLiteDatabase) &#123; super.onCreate(db) // 读取鞋的集合 val request = OneTimeWorkRequestBuilder&lt;ShoeWorker&gt;().build() WorkManager.getInstance(context).enqueue(request) &#125; &#125; ) .build() &#125; &#125;&#125; @Database注解声明当前是一个数据库文件，注解中entities变量声明数据库中的表（实体），以及版本等变量。同时，获取的Dao也必须在数据库类中。完成之后，make project一下工程，系统后自动创建AppDataBase和xxxDao的实现类。 2.5 步骤5：简单封装在不使用LiveData和RxJava前提下，Room的操作不能放在主线程中。这里看看UserRepository： 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.ly.allendemojetpack.db.repositoryimport com.ly.allendemojetpack.db.dao.UserDaoimport com.ly.allendemojetpack.db.data.Userimport kotlinx.coroutines.Dispatchers.IOimport kotlinx.coroutines.withContextclass UserRepository private constructor(private val userDao: UserDao) &#123; /** *用户登录 */ fun login(account: String, pwd: String) = userDao.login(account, pwd) /** * 用户注册 */ suspend fun register(email: String, account: String, pwd: String): Long &#123; return withContext(IO) &#123; userDao.insertUser(User(account, pwd, email)) &#125; &#125; /** * 获取所有用户 */ fun getAllUsers() = userDao.getAllUsers() /** * 通过id获取用户 */ fun findUserById(id: Long) = userDao.findUserById(id) companion object &#123; @Volatile private var instance: UserRepository? = null fun getInstance(userDao: UserDao): UserRepository = instance ?: synchronized(this) &#123; instance ?: UserRepository(userDao).also &#123; instance = it &#125; &#125; &#125;&#125; register()是一个普通方法，所以需要在子线程中使用，这里通过协程实现。login()是配合LiveData使用的， 不需要额外创建子线程，但是其核心数据库操作还在子线程中实现的。 这时，就可以操作本地数据库了。 3. 其他3.1 类型转换器SQLite支持的类型有：NULL、INTEGER、REAL、TEXT和BLOB，对于Data类，SQLite还可以将其转化为TEXT、REAL或者INTEGER，如果是Calendar类呢？Room提供了这一解决方法，使用@TypeConverter注解，谷歌官方示例：android-sunflower： 123456class Converters &#123; @TypeConverter fun calendarToDatestamp(calendar: Calendar): Long = calendar.timeInMillis @TypeConverter fun datestampToCalendar(value: Long): Calendar = Calendar.getInstance().apply &#123; timeInMillis = value &#125;&#125; 然后在数据库声明的时候，加上@TypeConverter(COnverter::class)即可： 12345@Database(...)@TypeConverters(Converters::class)abstract class AppDatabase : RoomDatabase() &#123; //...&#125; 3.2 数据库迁移：这个还需要查找资料Android Room 框架学习]]></content>
      <categories>
        <category>Android</category>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>Jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Jetpack：ViewModel&LiveData]]></title>
    <url>%2F2019%2F08%2F02%2FAndroid-Jetpack-ViewModel-LiveData%2F</url>
    <content type="text"><![CDATA[在Android-Jetpack-DataBinding中，讨论了MVVM模式和Data Binding组件，这里继续学习跟MVVM有关的Android Jetpack组件——ViewModel和LiveData。 1. LiveData官方文档：LiveData 先来看看LiveData和ViewMOdel的作用： 从上图可以看出，LiveData和ViewModel在整个MVVM中担任数据驱动的职责，这也是MVVM中ViewMoel层的作用。 1.1 介绍官网介绍： LiveData is an observable data holder class. Unlike a regular observable, LiveData is lifecycle-aware, meaning it respects the lifecycle of other app components, such as activities, fragments, or services. This awareness ensures LiveData only updates app component observers that are in an active lifecycle state.直译：LiveData是一个可观察的数据持有者类。与常规的可观察对象不同，LiveData是生命周期感知的，这意味着它尊重其他应用程序组件的生命周期，比如活动、片段或服务。这种意识确保LiveData只更新处于活动生命周期状态的应用程序组件观察者。 可以看出LiveData作用和RxJava类似，是观察数据的类，相比RxJava，LiveData能在Activity、Fragment和Service中正确处理声明周期。LiveData的优点： 数据变更时更新UI 没有内存泄露 不会因为停止Activity崩溃 无需手动处理生命周期 共享资源 1.2 使用方式常用的API： observe(@NotNull LifeCycleOwner owner, @NotNull Observe&lt;? super T&gt; observer)：最常用的方法，需要提供Observer数据变更后的处理。LifeCycleOwner是能够正确处理生命周期的关键 setValue(T value)：设置数据 getValue():T：获取数据 postValue(T value)：在主线程更新数据 1.3 使用场景配合Android Jetpack的其他组件使用，如ViewModel和Room。 2. ViewModel官方文档：ViewModel MVVM中ViewModel层是用来逻辑处理的，Android Jetpack中的ViewModel是否一样呢？ 2.1 介绍官网介绍： The ViewModel class is designed to store and manage UI-related data in a lifecycle conscious way. The ViewModel class allows data to survive configuration changes such as screen rotations. ViewModel同样具有生命周期，用来处理跟UI相关的数据，并且，当设备的一些配置信息改变（如屏幕旋转）时，它的数据不会消失。通常，如果不做特殊处理，当屏幕旋转时，数据会消失，ViewModel管理数据为什么不会消失？因为ViewModel的生命周期： ViewModel的另一个特点就是实现Actiivty和Framgent之间的数据共享。 2.2 使用方法继承ViewMoel即可。 2.3 Demo2.3.1 步骤1：添加依赖12345// liveDataimplementation "androidx.lifecycle:lifecycle-livedata-ktx:2.2.0-alpha02"// viewModelimplementation "androidx.lifecycle:lifecycle-viewmodel-ktx:2.2.0-alpha02"implementation "androidx.lifecycle:lifecycle-extensions:2.2.0-alpha02" 2.3.2 步骤2：创建Model继承ViewModel，分别创建品牌名的观察对象brand:MutableliveData&lt;String&gt;和对鞋子集合的观察对象shose:LiveData&lt;List&lt;Shoe&gt;&gt;： 1234567891011121314151617181920212223242526272829303132package com.ly.allendemojetpack.viewmodelimport androidx.lifecycle.*import com.ly.allendemojetpack.db.data.Shoeimport com.ly.allendemojetpack.db.repository.ShoeRepositoryclass ShoeModel constructor(repository: ShoeRepository) : ViewModel() &#123; companion object &#123; private const val ALL = "所有" &#125; /** * 品牌的观察对象，默认观察所有的品牌 */ private val brand = MutableLiveData&lt;String&gt;().apply &#123; value = ALL &#125; /** * 鞋子集合的观察类 */ val shoes: LiveData&lt;List&lt;Shoe&gt;&gt; = brand.switchMap &#123; // Room数据库查询，只要知道返回的是LiveData&lt;List&lt;Shoe&gt;&gt;即可 if (it == ALL) &#123; repository.getAllShoes() &#125; else &#123; repository.getShoeByBrand(it) &#125; &#125; ......&#125; 2.3.3 步骤3：获取ViewModel 无构造参数获取：构造函数没有参数的情况下，获取ShoeModel很简单，ViewModelProvider.of(this).get(ShoeModel::class.java)就能返回需要的ShoeModel。 有构造参数获取：上面的ShoeModel需要传入一个参数ShoeRepository，这时，就需要自定义实现Factory：1234567891011121314package com.ly.allendemojetpack.viewmodel.factoryimport androidx.lifecycle.ViewModelimport androidx.lifecycle.ViewModelProviderimport com.ly.allendemojetpack.db.repository.ShoeRepositoryimport com.ly.allendemojetpack.viewmodel.ShoeModelclass ShoeModelFactory( private val repository: ShoeRepository) : ViewModelProvider.NewInstanceFactory() &#123; override fun &lt;T : ViewModel?&gt; create(modelClass: Class&lt;T&gt;): T &#123; return ShoeModel(repository) as T &#125;&#125; 为了方便使用，这里写了一个统一的工具类CustomViewModelProvider： 12345678910111213141516171819202122232425package com.ly.allendemojetpack.viewmodelimport android.content.Contextimport androidx.navigation.NavControllerimport com.ly.allendemojetpack.db.RepositoryProviderimport com.ly.allendemojetpack.db.repository.ShoeRepositoryimport com.ly.allendemojetpack.db.repository.UserRepositoryimport com.ly.allendemojetpack.viewmodel.factory.LoginModelFactoryimport com.ly.allendemojetpack.viewmodel.factory.RegisterModelFactoryimport com.ly.allendemojetpack.viewmodel.factory.ShoeModelFactory/** * ViewModel提供者 * * @author Liuyang * @date 2019/8/3 */object CustomViewModelProvider &#123; ...... fun providerShoeModel(context: Context): ShoeModelFactory &#123; val repository: ShoeRepository = RepositoryProvider.providerShoeRepository(context) return ShoeModelFactory(repository) &#125;&#125; 最后就能在ShoeFragemnt中获取ShoeModel： 1234// by viewModels 需要依赖 "androidx.navigation:navigation-ui-ktx:$rootProject.navigationVersion"private val viewModel: ShoeModel by viewModels &#123; CustomViewModelProvider.providerShoeModel(requireContext())&#125; 2.3.4 步骤4：使用ViewModelViewModel的使用需要结合具体的业务，这里的ShoeModel在ShoeFragment中的使用如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.ly.allendemojetpack.ui.fragment.mainimport android.os.Bundleimport android.view.LayoutInflaterimport android.view.Viewimport android.view.ViewGroupimport androidx.fragment.app.Fragmentimport androidx.fragment.app.viewModelsimport androidx.lifecycle.Observerimport androidx.lifecycle.ViewModelProvidersimport com.ly.allendemojetpack.databinding.FragmentShoeBindingimport com.ly.allendemojetpack.ui.adapter.ShoeAdapterimport com.ly.allendemojetpack.viewmodel.CustomViewModelProviderimport com.ly.allendemojetpack.viewmodel.ShoeModel/** * 鞋子的Fragment * * @author Liuyang * @date 2019/8/3 */class ShoeFragment : Fragment() &#123; // by viewModels 需要依赖 "androidx.navigation:navigation-ui-ktx:$rootProject.navigationVersion" private val viewModel: ShoeModel by viewModels &#123; CustomViewModelProvider.providerShoeModel(requireContext()) &#125; override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? &#123; val binding: FragmentShoeBinding = FragmentShoeBinding.inflate(inflater, container, false) context ?: return binding.root ViewModelProviders.of(this).get(ShoeModel::class.java) // 适配器 val adapter = ShoeAdapter() binding.recycler.adapter = adapter onSubscribeUi(adapter) return binding.root &#125; /** * 鞋子数据更新的通知 */ private fun onSubscribeUi(adapter: ShoeAdapter) &#123; viewModel.shoes.observe(viewLifecycleOwner, Observer &#123; if (it != null) &#123; adapter.submitList(it) &#125; &#125;) &#125;&#125; 在onSubscribeUi()中，使用ShoeModel的LiveData进行观察通知，当鞋子集合更新数据时，就会更新到当前的适配器中。 布局文件framgent_shoe.xml很简单，虽然使用了Data Binding，但是没有变量，只有一个RecyclerView。 Demo地址：Allen_Demo_Jetpack 3. 其他3.1 LiveData数据变换LiveData中数据变换方法有map()和switchMap()，switchMap()在上面已经看到了： 1234567891011121314151617181920212223242526272829303132333435363738394041// 本地数据仓库class ShoeRepository private constructor(private val shoeDao: ShoeDao) &#123; fun getAllShoes() = shoeDao.getAllShoes() /** * 通过品牌查询鞋子，返回LiveData&lt;List&lt;Shoe&gt;&gt; */ fun getShoeByBrand(brand: String) = shoeDao.findShoeByBrand(brand) /** * 插入鞋子的集合，返回LiveData&lt;List&lt;Shoe&gt;&gt; */ fun insertShoes(shoes: List&lt;Shoe&gt;) = shoeDao.insertShoe(shoes) ......&#125;class ShoeModel constructor(repository: ShoeRepository) : ViewModel() &#123; companion object &#123; private const val ALL = "所有" &#125; /** * 品牌的观察对象，默认观察所有的品牌 */ private val brand = MutableLiveData&lt;String&gt;().apply &#123; value = ALL &#125; /** * 鞋子集合的观察类 */ val shoes: LiveData&lt;List&lt;Shoe&gt;&gt; = brand.switchMap &#123; // Room数据库查询，只要知道返回的是LiveData&lt;List&lt;Shoe&gt;&gt;即可 if (it == ALL) &#123; repository.getAllShoes() &#125; else &#123; repository.getShoeByBrand(it) &#125; &#125;&#125; map()的使用借用官方的例子： 1234val userLiveData: LiveData&lt;User&gt; = UserLiveData()val userName: LiveData&lt;String&gt; = Transformations.map(userLiveData) &#123; user -&gt; "$&#123;user.name&#125; $&#123;user.lastName&#125;"&#125; 可以看到，map()也可以实现将A变成B，二者有什么区别呢？ map()中只有一个LiveData&lt;A&gt;，它在LiveData&lt;A&gt;发送数据的时候将A变成B switchMap()中同时存在LiveData&lt;A&gt;和LiveData&lt;B&gt;，LiveData&lt;A&gt;更新之后，通知LiveData&lt;B&gt;更新。 3.2 LiveData如何共享数据如果有这样的需求：注册页需要记录信息，注册完成跳转到登录页，并将账号和密码显示在登录页。这时，可以定义一个类然后继承LiveData，并使用单例模式即可： 123456789package com.ly.allendemojetpack.common.livedata/** * 登录信息 * * @author Liuyang * @date 2019/8/3 */data class LoginInfo constructor(val account: String, val pwd: String, val email: String) 12345678910111213141516171819202122package com.ly.allendemojetpack.common.livedataimport androidx.annotation.MainThreadimport androidx.lifecycle.LiveData/** * 自定义单例LiveData * * @author Liuyang * @date 2019/8/3 */class LoginLiveData : LiveData&lt;LoginInfo&gt;() &#123; companion object &#123; private lateinit var sInstance: LoginLiveData @MainThread fun get(): LoginLiveData &#123; sInstance = if (::sInstance.isInitialized) sInstance else LoginLiveData() return sInstance &#125; &#125;&#125; 3.3 使用ViewModel在同一个Activity中的Fragment之间共享数据要想利用ViewModel实现Fragment之间数据共享，前提是Fragment中的FragmentActivity要相同，这里看看官方示例： 123456789101112131415161718192021222324252627282930313233343536373839class SharedViewModel : ViewModel() &#123; val selected = MutableLiveData&lt;Item&gt;() fun select(item: Item) &#123; selected.value = item &#125;&#125;class MasterFragment : Fragment() &#123; private lateinit var itemSelector: Selector private lateinit var model: SharedViewModel override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) model = activity?.run &#123; ViewModelProviders.of(this).get(SharedViewModel::class.java) &#125; ?: throw Exception("Invalid Activity") itemSelector.setOnClickListener &#123; item -&gt; // Update the UI &#125; &#125;&#125;class DetailFragment : Fragment() &#123; private lateinit var model: SharedViewModel override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) model = activity?.run &#123; ViewModelProviders.of(this).get(SharedViewModel::class.java) &#125; ?: throw Exception("Invalid Activity") model.selected.observe(this, Observer&lt;Item&gt; &#123; item -&gt; // Update the UI &#125;) &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>Jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Jetpack：DataBinding]]></title>
    <url>%2F2019%2F07%2F31%2FAndroid-Jetpack-DataBinding%2F</url>
    <content type="text"><![CDATA[Android Jetpack一系类的内容，适合使用MVVM，这里先看看MVVM。 1. 介绍1.1 MVVM介绍MVVM，全称Model-View-ViewModel，和MVC和MVP一样，是逻辑分层解耦的模式。 1.1.1 结构图 MVVM三要素： View层：xml、Activity、Framgent、Adapter和View等 Model层：数据源（包括本地数据和网络数据等） ViewModel层：View层处理数据以及逻辑处理 1.2 Data Binding介绍MVVM是一种架构模式，Data Binding是一种实现数据和UI绑定的框架，是构建MVVM模式的一个工具。 官方文档：Data Binding 官方Demo地址：android-databinding 2. Demo这里会在前一篇Android-Jetpack-Navigation的基础上进行扩展，如果要查看之前的可以使用git进行版本回退，本文会在注册和登录模块上进行修改。 2.1 步骤1：在module的build.gradle中添加如下：1234567android &#123; ...... dataBinding &#123; enabled true &#125;&#125; 2.2 步骤2：构建LoginModel创建登录的LoginModel，主要负责登录逻辑的处理以及两个输入框内容改变时数据的更新： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.ly.allendemojetpack.viewmodelimport android.content.Contextimport android.content.Intentimport android.text.Editableimport android.widget.EditTextimport android.widget.Toastimport androidx.databinding.BindingAdapterimport androidx.databinding.ObservableFieldimport com.ly.allendemojetpack.MainActivityimport com.ly.allendemojetpack.common.Constantimport com.ly.allendemojetpack.common.listener.SimpleWatcherclass LoginModel constructor(name: String, pwd: String, context: Context) &#123; val n = ObservableField&lt;String&gt;(name) val p = ObservableField&lt;String&gt;(pwd) val context: Context = context /** * 用户名改变时的回调 */ fun onNameChanged(s: CharSequence) &#123; n.set(s.toString()) &#125; /** * 密码改变时的回调 */ fun onPwdChanged(s: CharSequence, start: Int, before: Int, count: Int) &#123; p.set(s.toString()) &#125; /** * 登录的逻辑 */ fun login() &#123; if (n.get().equals(Constant.USERNAME) &amp;&amp; p.get().equals(Constant.PASSWORD)) &#123; Toast.makeText(context, "账号密码正确", Toast.LENGTH_SHORT).show() val intent = Intent(context, MainActivity::class.java) context.startActivity(intent) &#125; &#125; val nameWatcher = object : SimpleWatcher() &#123; override fun afterTextChanged(s: Editable) &#123; super.afterTextChanged(s) n.set(s.toString()) &#125; &#125; val pwdWatcher = object : SimpleWatcher() &#123; override fun afterTextChanged(s: Editable) &#123; super.afterTextChanged(s) p.set(s.toString()) &#125; &#125; @BindingAdapter("addTextChangedListener") fun addTextChangedListener(editText: EditText, simpleWatcher: SimpleWatcher) &#123; editText.addTextChangedListener(simpleWatcher) &#125;&#125; ObservableField是一个可观察的域，通过泛型来使用，可以使用的方法有三个： ObservableField(T value)：构造函数，设置可观察的域 T get()：获取可观察的域的内容，可以使用UI控件监测它的值 set(T value)：设置可观察的域，设置成功后，会通知UI控件进行更新 再来看看LoginModel，里面包含了用来观察name和pws的两个成员变量n和p，以及一个登录的逻辑处理方法。 2.3 步骤3：创建布局文件使用Data Binding之后的布局文件和之前的会有很大不同，里面包含了一些新的标签： layout：布局根节点，只能包裹一个View标签，且不能包裹merge标签。 data：Data Binding的数据，只能存放一个data标签。 variable：在data标签中使用，数据的变量标签。type属性指明变量的类。name属性指明变量的名字，方便布局中使用。 import：在data标签中使用，需要使用静态方法和静态常量，如果需要使用view.visible属性的时候，需要导入&lt;import type=&quot;android.view.View&quot;/&gt;。type属性指明类的路径，如果两个import标签带入的类名相同，可以使用alias属性声明别名，使用时直接用别名即可。 来看看LoginFragment的布局文件fragment_login.xml： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools"&gt; &lt;data&gt; &lt;!--ViewModel，通过mBinding.vm=mViewMode注入--&gt; &lt;variable name="model" type="com.ly.allendemojetpack.viewmodel.LoginModel"/&gt; &lt;variable name="activity" type="androidx.fragment.app.FragmentActivity"/&gt; &lt;/data&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:id="@+id/txt_cancel" android:layout_width="wrap_content" android:layout_height="wrap_content" android:onClick="@&#123;()-&gt; activity.onBackPressed()&#125;" ...... /&gt; &lt;TextView android:id="@+id/txt_title" app:layout_constraintTop_toTopOf="parent" ...... /&gt; &lt;EditText android:id="@+id/et_account" android:layout_width="0dp" android:layout_height="0dp" android:text="@&#123;model.n.get()&#125;" android:onTextChanged="@&#123;(text, start, before, count)-&gt;model.onNameChanged(text)&#125;" ...... /&gt; &lt;EditText android:id="@+id/et_pwd" android:layout_width="0dp" android:layout_height="0dp" android:text="@&#123;model.p.get()&#125;" android:onTextChanged="@&#123;model::onPwdChanged&#125;" ...... /&gt; &lt;Button android:id="@+id/btn_login" android:layout_width="0dp" android:layout_height="0dp" android:onClick="@&#123;()-&gt; model.login()&#125;" android:enabled="@&#123;(model.p.get().isEmpty()||model.n.get().isEmpty()) ? false : true&#125;" ...... /&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;&lt;/layout&gt; variable有了两个： model：类型为com.ly.allendemojetpack.viewmodel.LoginModel，绑定用户名。 activity：类型为androidx.fragment.app.FragmentActivity，主要用来处理返回按钮事件。 知识点讲解： 属性的引用如果想使用ViewModel中成员变量，直接使用model.p即可。 事件绑定事件绑定包括方法引用和监听绑定： 方法引用：参数类型和返回类型要一致，参考et_pwd的android:onTextChanged引用 监听绑定：要求没有方法引用高，可以使用自定义函数，参考et_account的android:onTextChanged引用。 表达式btn_login按钮在账号或密码为空的时候，是灰色的： 这是因为在代码中设置了android:enabled=&quot;@{(model.p.get().isEmpty()||model.n.get().isEmpty()) ? false : true}&quot;，意思是用户名或密码为空时，设置android:enable属性设置为flase，这是一个三元表达式，除了上面的||和三元表达式，Data Binding还支持： 运算符 + - / * % 字符串连接 + 逻辑与或 &amp;&amp; || 二进制 &amp; | ^ 一元 + - ! ~ 移位 &gt;&gt; &gt;&gt;&gt; &lt;&lt; 比较 == &gt; &lt; &gt;= &lt;= (Note that &lt; needs to be escaped as &lt;) instanceof Grouping () Literals - character, String, numeric, null Cast 方法调用 域访问 数组访问 三元操作符 除了上述，Data Binding还新增了空合并操作符??，例如androud:text=&quot;@{user.displayName ?? user.lastName}&quot;等价于android:text=&quot;@{user.displayName != null ? user.displayName : user.lastName}&quot; 2.4 生成绑定类创建完布局文件之后，点击Make Project按钮，系统会自动生成绑定类： 下面只需要在LoginFragment中完成绑定操作即可，既可以使用生成的FragmentLoginBinding，也可以使用自带的BindingUtil。 使用BindingUtilBindingUtil常用的API： setContentView()：进行Activity下面的绑定 inflate：进行Fragment下面的绑定 bind：进行View的绑定 LoginFragemnt绑定代码如下： 12345678910override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? &#123; val binding: FragmentLoginBinding = DataBindingUtil.inflate( inflater, R.layout.fragment_login, container, false ) loginModel = LoginModel("", "", context!!) binding.model = loginModel binding.activity = activity return binding.root&#125; 使用生产的FragmentLoginBinding使用方法与DataBindingUtil类似：1234567override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? &#123; val binding = FragmentLoginBinding.inflate(inflater, container, false) loginModel = LoginModel("", "", context!!) binding.model = loginModel binding.activity = activity return binding.root&#125; 3. Data Binding的一些其他功能3.1 布局中属性的设置3.1.1 有属性有setter如果一个XXXView类中有成员变量borderColor，并且XXXView类中有setBorderColor(int color)方法，那么在布局文件中，可以借助Data Binding直接使用app:borderColor属性。 3.1.2 没有setter，但有相关方法以XXXView为例，内有有成员变量borderColor，这次设置borderColor的方法是setBorder()（或者其他，总之不是标准的set方法，setBorderColor()），还使用app:borderColor肯定不行的。这时，可以通过BindingMethods注解实现app:borderColor的使用，如下： 12345@BindingMethods(value = [ BindingMethod( type = 包名.XXXView::class, attribute = "app:borderColor", method = "setBColor")]) 3.1.3 自定义属性现在不仅没有setter方法，甚至成员变量都没有。例如现在要给EditText添加文本监听器，这样，现在LoginModel中自定义个监听器，并使用@BindingAdapter注解： 123456789101112val nameWatcher = object : SimpleWatcher() &#123; override fun afterTextChanged(s: Editable) &#123; super.afterTextChanged(s) n.set(s.toString()) &#125;&#125;@BindingAdapter("addTextChangedListener")fun addTextChangedListener(editText: EditText, simpleWatcher: SimpleWatcher) &#123; editText.addTextChangedListener(simpleWatcher)&#125; 这样就可以在布局文件中使用app:addTextChangedListener属性了： 123456&lt;EditText android:id="@+id/et_account" android:text="@&#123;model.n.get()&#125;" app:addTextChangedListener="@&#123;model.nameWatcher&#125;" ... /&gt; 效果和之前的一样。 3.2 数据双向绑定数据双向绑定可以分为两种情况：数据刷新视图和视图刷新数据。 3.2.1 数据刷新视图需要数据变化时视图也跟着变化。有了两种实现方式： 自定义继承BaseObservable 使用ObservableField 继承BaseObservable123456789101112131415161718192021222324252627282930313233package com.ly.allendemojetpack;import androidx.databinding.BaseObservable;import androidx.databinding.Bindable;public class ObservableUser extends BaseObservable &#123; private String firstName; private String lastName; /** * 注解才会自动在build目录BR类中生成entry, 要求方法名必须以get开头 */ @Bindable public String getFirstName() &#123; return firstName; &#125; @Bindable public String getLastName() &#123; return lastName; &#125; public void setFirstName(String firstName) &#123; this.firstName = firstName; // 手动刷新 notifyPropertyChanged(BR.firstName); &#125; public void setLastName(String lastName) &#123; this.lastName = lastName; notifyPropertyChanged(BR.lastName); &#125;&#125; BaseObservable和Observable的区别： BaseObservable是实现了Observable的类，帮助实现监听器的线程安全问题； BaseObservable使用了addPropertyChangeRegistry()来执行OnPropertyChangedCallback()； 不建议直接实现Observable。 使用ObservableFieldData Binding默认实现了一系列Observable接口的字段：123456789101112BaseObservable,ObservableBoolean,ObservableByte,ObservableChar,ObservableDouble,ObservableField&lt;T&gt;,ObservableFloat,ObservableInt,ObservableLong,ObservableParcelable&lt;T extends Parcelable&gt;,ObservableShort,ViewDataBinding 示例： 12345public class PlainUser &#123; public final ObservableField&lt;String&gt; firstName = new ObservableField&lt;&gt;(); public final ObservableField&lt;String&gt; lastName = new ObservableField&lt;&gt;(); public final ObservableInt age = new ObservableInt();&#125; 对于集合类型，可以使用ObservableArryMap、ObservableArryList、ObservableMap等集合类型： 1234ObservableArrayMap&lt;String, Object&gt; user = new ObservableArrayMap&lt;&gt;();user.put("firstName", "Google");user.put("lastName", "Inc.");user.put("age", 17); 使用 12345678910111213&lt;data&gt; &lt;import type="android.databinding.ObservableMap"/&gt; &lt;variable name="user" type="ObservableMap&lt;String, Object&gt;"/&gt;&lt;/data&gt;…&lt;TextView android:text='@&#123;user["lastName"]&#125;' android:layout_width="wrap_content" android:layout_height="wrap_content"/&gt;&lt;TextView android:text='@&#123;String.valueOf(1 + (Integer)user["age"])&#125;' android:layout_width="wrap_content" android:layout_height="wrap_content"/&gt; 还支持ObservableParcelable&lt;Object&gt;序列化数据类型； ObservableField同样可以使用addPropertyChangedCallback监听属性变化。 3.2.2 视图刷新数据通过使用表达式@=就可以在视图刷新时自动刷新数据，但是要求数据实现以下 两种方式修改才会触发刷新： 12345&lt;EditText android:layout_width="match_parent" android:layout_height="wrap_content" android:inputType="textNoSuggestions" android:text="@=&#123;model.name&#125;"/&gt; 这种双向绑定会存在一个死循环的问题，即数据变化（回调监听器）触发了视图变化，视图变化又会触发数据变化（再次回调监听），一直循环，设置相同的数据也会视为数据变化。 所以需要判断当前变化的数据是否等于旧数据： 123456789101112131415161718192021222324252627282930313233343536373839package com.ly.allendemojetpack;import android.widget.TextView;import androidx.databinding.BindingAdapter;public class CustomBindingAdapter &#123; @BindingAdapter("android:text") public static void setText(TextView view, CharSequence text) &#123; CharSequence oldText = view.getText(); if (!haveContentChanged(text, oldText)) &#123; // 数据没有变化时，不进行视图刷新 return; &#125; view.setText(text); &#125; /** * 本方法使用的是官方源码 */ private static boolean haveContentChanged(CharSequence str1, CharSequence str2) &#123; if ((str1 == null) != (str2 == null)) &#123; return true; &#125; else if (str1 == null) &#123; return false; &#125; final int length = str1.length(); if (length != str2.length()) &#123; return true; &#125; for (int i = 0; i &lt; length; i++) &#123; if (str1.charAt(i) != str2.charAt(i)) &#123; return true; &#125; &#125; return false; &#125;&#125; 下面这种判断是无效的，因为String参数传递属于引用类型变量，不是常量，需要使用equals()： 1234// 本段截取官方源码，是错误的if (text == oldText || (text == null &amp;&amp; oldText.length() == 0)) &#123; return; &#125; 正确写法： 123if (text == null || text.equals(oldText) || oldText.length() == 0) &#123; return;&#125; 回到本例，比如上面的EditText在实现双向绑定后，既不需要添加SimpleWatcher，也不需要用方法调用，实现代码如下： 1234567&lt;EditText android:id="@+id/et_account" android:layout_width="0dp" android:layout_height="0dp" android:text="@=&#123;model.n.get()&#125;" ...... /&gt; 仅仅将@{model.n.get()}换为@={model.n.get()},需要注意，属性必须是可观察的，即使用上面提到的ObservableField，也可以自定义实现BaseObservable接口。 4. 注解4.1 @Bindable用于数据更新自动刷新视图。 4.2 BindingAdapter创建一个XML属性和函数，然后在属性中进行设置数据操作会进入该函数。图片加载框架可以使用此方法。 1234@BindingAdapter(value = &#123; "imageUrl", "error" &#125;, requireAll = false)public static void loadImage(ImageView view, String url, Drawable error) &#123; Glide.with(view.getContext()).load(url).into(view);&#125; 方法必须是public static； 第一个参数必须是控件或其父类 方法名随意 最后一个boolean类型是可选参数，可以要求是否所有参数都要填写，默认为true 如果requireAll为false，没有填的属性将默认为null，所以需要做非空判断 使用： 123456&lt;ImageView android:layout_width="match_parent" android:layout_height="200dp" app:error="@&#123;@drawable/error&#125;" allen:imageUrl="@&#123;imageUrl&#125;" app:onClickListener="@&#123;activity.avatarClickListener&#125;"/&gt; 命名空间可以是随意的，但如果在BindingAdapter的数组内定义了命名空间，就必须遵守。 例如： 123456// 这里省略了一个注解参数. @BindingAdapter(&#123; "android:imageUrl", "error" &#125;)public static void loadImage(ImageView view, String url, Drawable error) &#123; if(url == null) return; Glide.with(view.getContext()).load(url).into(view);&#125; 如果数据初始化在异步，会回调方法，但数据为null（成员默认值），所以要先进行非空判断。 Kotlin有两种实现方式： 单例 + @JvmStatic注解 123456object ProgressAdapter &#123; @JvmStatic @BindingAdapter("android:bindName") fun setBindName(view: View, name:String)&#123; &#125;&#125; 顶级函数 12345678@BindingAdapter("android:bindName")fun setBindName(view: View, name:String)&#123;&#125;// 由于顶级函数太多影响代码补全建议使用顶级扩展函数, 之后也可以在代码中方便使用@BindingAdapter("android:bindName")fun View.setBindName( name:String)&#123;&#125; 4.3 @BindingMethods如果想创建一个XML属性并且和View中函数关联（即自动使用属性值作为参数调用该函数），就可以使用@BindingMethods注解这个类（也可以是一个接口）。 该注解属于一个容器，内部参数是一个@BindingMethods数组，只能用于修饰类或接口。 官方Demo： 1234567@BindingMethods(&#123; @BindingMethod(type = android.widget.ProgressBar.class, attribute = "android:indeterminateTint", method = "setIndeterminateTintList"), @BindingMethod(type = android.widget.ProgressBar.class, attribute = "android:progressTint", method = "setProgressTintList"), @BindingMethod(type = android.widget.ProgressBar.class, attribute = "android:secondaryProgressTint", method = "setSecondaryProgressTintList"),&#125;)public class ProgressBarBindingAdapter &#123;&#125; @BindingMethods注解参数（必选）： type：字节码，即控件类型 attribute：XML属性 method：函数名，即控件中的函数名称 注意： 如果属性名和@BindingAdapter定义的XML属性相同，会冲突报错 如果控件类中已经存在一个和定义的属性相关联的函数（例如setName函数和android:name属性就相关联），则会优先执行该函数。 4.4 @BindingConversion属性值自动进行类型转换。 只能修饰public static方法 任意位置任意方法名都不受限制 Data Binding自动匹配被该注解修饰的方法和参数类型 返回值类型必须和属性setter方法匹配，且参数只有一个 要求属性值必须是@{}Data Binding表达式 官方示例： 12345678910public class Converters &#123; @BindingConversion public static ColorDrawable convertColorToDrawable(int color) &#123; return new ColorDrawable(color); &#125; @BindingConversion public static ColorStateList convertColorToColorStateList(int color) &#123; return ColorStateList.valueOf(color); &#125;&#125; kotlin示例： 123456@BindingConversionfun int2string(integer:Int):String&#123; Log.d("日志", "(CusView.kt:92) int2string ___ integer = [$integer]") return integer.toString()&#125; XML 1234567891011121314151617181920212223242526&lt;layout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools"&gt; &lt;data&gt; &lt;variable name="m" type="com.example.architecture.Model" /&gt; &lt;/data&gt; &lt;FrameLayout android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity"&gt; &lt;com.example.architecture.CusView android:bindName="@=&#123;m.age&#125;" android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt; &lt;/FrameLayout&gt;&lt;/layout&gt; 上面这段代码会报错，因为涉及双向数据绑定，@BindingConversion只会在数据设置视图时生效，但是如果是视图设置数据则会走其他函数（如get()），如果该函数返回的类型和Model中的类型不匹配会报异常，除非将函数改为类型匹配，或者去掉=，不使用双向数据绑定。 android:text不能使用int转为String，因为它本身能正常接收int（作为resouceId），会报： 1android.content.res.Resources$NotFoundException: String resource ID #0xa 4.5 @InverseMethodAndroid Studio 3.0提供了inverse系列新的注解，都是针对数据双向绑定的。 在数据和视图的数据不统一时可以使用该注解@InverseMethod解决数据转换问题。 例如，数据模型存储的是用户id，但视图不显示id，而是显示用户名（数据和视图类型不一样），就需要进行二者的转换。 需要两个函数：设置数据到视图的函数set()和设置视图变更到数据的函数get() set()和get()都至少有一个参数 自身参数必须和另一个函数的返回值对应 简单示例：在用户id和用户名称之间转换，存储的是id，但显示的是用户名。 12345678910111213141516package com.ly.allendemojetpack.DataBindingOtherimport androidx.databinding.InverseMethodclass Model &#123; var name = "设计师" @InverseMethod("ui2data") fun data2ui(): String &#123; return "设计师1" &#125; fun ui2data(): String &#123; return "设计师2" &#125;&#125; 使用： 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools"&gt; &lt;data&gt; &lt;variable name="model" type="com.ly.allendemojetpack.DataBindingOther.Model"/&gt; &lt;/data&gt; &lt;FrameLayout android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity"&gt; &lt;com.ly.allendemojetpack.DataBindingOther.CusView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@&#123;model.data2ui(model.name)&#125;"/&gt; &lt;/FrameLayout&gt;&lt;/layout&gt; 4.6 @InverseBindingAdapter参数： String attribute：属性值，必填 String event：默认值，非必填，属性值 + AttrChanged后缀 和@BindingAdapter配合，实现双向绑定。 完全的双向绑定需要三个函数： set()：数据到视图 get()：视图到数据 notify()：通知Data Binding视图已经刷新，可以更新数据（Model）了 set()函数： 123456@BindingAdapter("android:bindName")fun TextView.setBindName(name:String?)&#123; if (name.isNullOrEmpty() &amp;&amp; name != text) &#123; text = name &#125;&#125; get()函数： 12345@InverseBindingAdapter(attribute = "android:bindName", event = "cus_event")fun TextView.getBindName():String&#123; // 这里你可以对视图上的数据进行处理最终设置给Model层 return text.toString()&#125; 不允许有更多参数 返回值类型必须是绑定的数据类型 notify()视图变化后要通知Data Binding开始设置Model层，也要用到@BindingAdapter。 1234567@BindingAdapter("cus_event")fun TextView.notifyBindName( inverseBindingListener: InverseBindingListener)&#123; // 这个函数是监听TextWatch官方源码 doAfterTextChanged &#123; inverseBindingListener.onChange() &#125;&#125; InverseBindingListener是一个接口，里面只有一个函数，它是notify()函数必要的参数： 123456public interface InverseBindingListener &#123; /** * Notifies the data binding system that the attribute value has changed. */ void onChange();&#125; 4.7 @InverseBindingMethods和@BindingMethods类似，但是@InverseBindingMethods是视图变更数据（get()函数）,而@BindingMethods是数据到视图（set()函数）。 1234567891011121314151617181920212223242526272829@Target(ElementType.ANNOTATION_TYPE)public @interface InverseBindingMethod &#123; /** * 控件的类字节码 * The View type that is associated with the attribute. */ Class type(); /** * 自定义的属性 * The attribute that supports two-way binding. */ String attribute(); /** * notify函数的名称，即用于通知数据更新的函数 * The event used to notify the data binding system that the attribute value has changed. * Defaults to attribute() + "AttrChanged" */ String event() default ""; /** * 控件自身的函数名称，如果省略，即自动生成为&#123;attribute&#125;AttrChanged * The getter method to retrieve the attribute value from the View. The default is * the bean method name based on the attribute name. */ String method() default "";&#125; 如果说@BindingMethods是关联setter方法和自定义属性，那么@InverseBindingMethods就是关联getter方法和自定义属性。setter是更新视图时使用的，getter是更新数据时使用的。比@BindingMethods只是多了一个用于通知数据更新的notify()。示例： 123456789@InverseBindingMethods( InverseBindingMethod( type = CusView::class, attribute = "android:bindName", method = "getName", event = "cus_event" ))object Adapter &#123;&#125; 查看生成类中用于视图更新数据的代码： 12345678910111213141516171819private android.databinding.InverseBindingListener ivandroidTextAttr = new android.databinding.InverseBindingListener() &#123; @Override public void onChange() &#123; // Inverse of data.name // is data.setName((java.lang.String) callbackArg_0) java.lang.String callbackArg_0 = com.liangjingkanji.databinding.MyInverseBindingAdapter.getTextString(iv); // 拿到变化的属性 // localize variables for thread safety // data != null boolean dataJavaLangObjectNull = false; // data.name java.lang.String dataName = null; // data com.liangjingkanji.databinding.Bean data = mData; // 拿到数据 dataJavaLangObjectNull = (data) != (null); if (dataJavaLangObjectNull) &#123; data.setName(((java.lang.String) (callbackArg_0))); // 存储到数据 &#125; &#125;&#125;; 如果没有重写Inverse的数据变更方法，将无法让视图通知数据更新。 12345678910111213141516171819202122232425262728// 该方法会在绑定布局的时候回调 @Override protected void executeBindings() &#123; long dirtyFlags = 0; synchronized(this) &#123; dirtyFlags = mDirtyFlags; mDirtyFlags = 0; &#125; java.lang.String dataName = null; com.liangjingkanji.databinding.Bean data = mData; if ((dirtyFlags &amp; 0x1aL) != 0) &#123; if (data != null) &#123; // read data.name dataName = data.getName(); &#125; &#125; // batch finished if ((dirtyFlags &amp; 0x1aL) != 0) &#123; // api target 1 com.liangjingkanji.databinding.MyInverseBindingAdapter.setText(this.iv, dataName); &#125; if ((dirtyFlags &amp; 0x10L) != 0) &#123; // api target 1 // 重点是这段代码, 将上面创建的监听器传入setTextWatcher方法 com.liangjingkanji.databinding.MyInverseBindingAdapter.setTextWatcher(this.iv, (com.liangjingkanji.databinding.MyInverseBindingAdapter.BeforeTextChanged)null, (com.liangjingkanji.databinding.MyInverseBindingAdapter.OnTextChanged)null, (com.liangjingkanji.databinding.MyInverseBindingAdapter.AfterTextChanged)null, ivandroidTextAttr); &#125; &#125; 4.8 总结@BindingBuildInfo和Untaggable两个注解是Data Binding自动生成Java类时使用的。 @Bindable：设置数据刷新视图，自动生成BR的id @BindingAdapter：设置自定义属性，可以覆盖系统原有属性 @BindingMethod/BindingMethods：关联自定义属性到控件原有的setter方法 @BindingConversion：如果属性不能匹配类型，参数将自动根据类型参数匹配该注解修饰的方法来转换。 @InverseMethod：负责实现视图和数据之间的转换 @InverseBindingAdapter：视图通知数据刷新 @InverseBindingMethod/InverseBindingMethods：视图通知数据刷新（如果存在已有getter()方法可用的情况下） BindingMethods系统优先级高于BindingAdapter系列 所有注解的功能都是基于XML属性值为Data Binding表达式才生效（即@{}） 5. 表达式前面也列举了，这里着重讲几个。 5.1 避免空指针variable的值即使设置null，或者没有设置，也不会报空指针异常。因为谷歌已经用Data Binding的@BindingAdapter注解重写了很多属性，并且在里面进行了判空处理。 1234567&lt;variable name="userName" type="String"/&gt;.....android:text="@&#123;userName&#125;" 1dataBinding.setUserName(null); 不会报空指针，并且还支持特有的非空多元表达式： 1android:text="@&#123;user.displayName ?? user.lastName&#125;" 等价于 1android:text="@&#123;user.displayName !=null user.displayName :: user.lastName&#125;" 但是要注意数组越界。 5.2 集合集合不属于java.lang.*下的，需要导入全路径 1234567&lt;variable name="list" type="java.util.List&amp;lt;String&amp;gt;"/&gt;&lt;variable name="map" type="java.util.Map&lt;String, String&gt;"/&gt; 上面的写法是错误的：Error:与元素类型 “variable” 相关联的 “type” 属性值不能包含 ‘&lt;’ 字符。因为&lt;符号需要转义。 常用的转义符： 12345678 空格 &amp;nbsp 或 &amp;#160；&lt; 小于号 &amp;lt; 或 &amp;#60;&gt; 大于号 &amp;gt; 或 &amp;#62;&amp; 与号 &amp;amp; 或 &amp;#38;&quot; 引号 &amp;quot; 或 &amp;#34;‘ 撇号 &amp;apos; 或 &amp;#39;× 乘号 &amp;times; 或 &amp;#215;÷ 除号 &amp;divide; 或 &amp;#247; 正确写法： 1234567&lt;variable name="list" type="java.util.List&amp;lt;String&amp;gt;"/&gt;&lt;variable name="map" type="java.util.Map&amp;lt;String, String&amp;gt;"/&gt; 集合数组都可以用[]来得到元素： 1android:text="@&#123;map["firstName"]&#125;" 5.3 字符串如果要在@{}中使用字符串，有三种方式： 12345678// 方式1：android:text="@&#123;"XXX"&#125;"// 方式2：android:text="@&#123;'XXX'&#125;"// 方式3：android:text="@&#123;@string/name&#125;" 同样也支持@color和@drawable。 5.4 格式化字符串首先在stirngs文件中定义&lt;string&gt;： 1&lt;string name="string_format"&gt;名字：%s 性别：%s&lt;/string&gt; 然后就可以使用Data Binding表达式了： 1android:text="@&#123;@string/string_format('XXX', '男')&#125;" 输出内容： 1名字：XXX 性别：男 5.5 默认值如果variable还没有赋值，就会先使用默认值。 1android:text="@&#123;user.integral, default=`30`&#125;" 5.6 上下文Data Binding提供了一个名为context的variable，可以直接使用。等价于View的getContext()。 1android:color="@&#123;context.getApplication().toString()&#125;" 5.7 引用其他控件12345678910111213141516&lt;TextView android:id="@+id/datingName" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_centerVertical="true" android:layout_marginLeft="8dp" android:layout_toRightOf="@id/iv_dating" android:text="活动"/&gt;&lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_centerVertical="true" android:layout_marginLeft="8dp" android:layout_toRightOf="@id/iv_order" android:text="@&#123;datingName.text&#125;"/&gt; 引用包含_的控件id，可以直接忽略该符号，如tv_name直接写tvName。 5.8 使用Class如果想使用Class作为参数，那么该Class不能直接通过静态导入来使用，需要作为字段常量来使用。 6. Data Binding组件6.1 ViewDataBinding自动生成的Data Binding类都继承自该类，里面的主要方法有： 1234567891011121314151617181920212223// 添加绑定监听器, 可以在Variable被设置的时候回调void addOnRebindCallback(OnRebindCallback listener)// 删除绑定监听器void removeOnRebindCallback(OnRebindCallback listener)// 返回被绑定的视图对象View getRoot()// 使所有的表达式无效并且立刻重新设置表达式. 会重新触发OnRebindCallback回调(可以看做重置)abstract void invalidateAll()// 可以根据字段id来设置变量abstract boolean setVariable(int variableId, Object value)// 解绑布局, ui不会根据数据来变化, 但是监听器还是会触发的void unbind()// 当ui需要根据当前数据变化时就会返回true(数据变化后有一瞬间)abstract boolean hasPendingBindings()// 强制ui立刻刷新数据void executePendingBindings() 当改变数据以后（在设置了Observable观察者的情况下）会马上刷新UI，但是会在下一帧才会刷新UI，存在一定的延迟。在这段时间内，hasPendingBindings()会返回true。 如果想要同步刷新UI，可以调用executePendingBindings()。OnRebindCallback()：该监听器可以监听布局绑定的生命周期。 123456789101112131415161718192021222324public abstract class OnRebindCallback&lt;T extends ViewDataBinding&gt; &#123; /** * 绑定前 * @param binding * @return 如果返回true，就会绑定布局，；返回fasle，则取消绑定 */ public boolean onPreBind(T binding) &#123; return true; &#125; /** * 如果取消绑定则回调该方法，取决于onPreBind()的返回值 * @param binding */ public void onCanceled(T binding) &#123; &#125; /** * 绑定完成 * @param binding */ public void onBound(T binding) &#123; &#125;&#125; Data Binding也有一个数据变更监听器，可以监听variable的设置事件： 1234567891011121314151617mDataBinding.addOnPropertyChangedCallback(new Observable.OnPropertyChangedCallback() &#123; /** * 会在DataBinding设置数据的时候回调 * @param sender DataBinding生成的类 * @param propertyId Variable的id */ @Override public void onPropertyChanged(Observable sender, int propertyId) &#123; ActivityMainBinding databinding = (ActivityMainBinding) sender; switch (propertyId) &#123; case BR.data: Log.d("日志", "(MainActivity.java:54) ___ Result = " + databinding.getData().getName()); break; case BR.dataSecond: break; &#125; &#125;&#125;); 6.2 DataBindingUtilData Binding不仅可以绑定Activity，还可以绑定视图内容（View）。 123456789101112131415// 视图static &lt;T extends ViewDataBinding&gt; T bind(View root)static &lt;T extends ViewDataBinding&gt; T bind(View root, DataBindingComponent bindingComponent) // 布局static &lt;T extends ViewDataBinding&gt; T inflate(LayoutInflater inflater, int layoutId, ViewGroup parent, boolean attachToParent, DataBindingComponent bindingComponent)// 组件static &lt;T extends ViewDataBinding&gt; T inflate(LayoutInflater inflater, int layoutId, ViewGroup parent, boolean attachToParent)// activitystatic &lt;T extends ViewDataBinding&gt; T setContentView(Activity activity, int layoutId)static &lt;T extends ViewDataBinding&gt; T setContentView(Activity activity, int layoutId, DataBindingComponent bindingComponent) 还有两个不常用的方法，用于检索糊涂是否被绑定，如果没有绑定，返回null。 1234static &lt;T extends ViewDataBinding&gt; T getBinding(View view)// 和getBinding不同的是如果视图没有绑定会去检查父容器是否被绑定static &lt;T extends ViewDataBinding&gt; T findBinding(View view) 其他方法： 12// 根据传的BR的id来返回字符串类型. 可能用于日志输出static String convertBrIdToString(int id) 6.3 DataBindingComponent每个Data Binding都可以拥有一个组件或者说设置一个默认的全局组件。创建DataBindingComponent的步骤： 创建一个类，类中写入@BindingAdapter注解（需设置静态），这时Android Studio会扫描自动生成对应的DataBindingComponent接口； 创建一个类实现DataBindingComponent，这时会提示有方法需要覆写，如果省略第一步，则不会有。 第一步： 123456789101112131415161718192021222324252627package com.ly.allendemojetpack.databindingotherimport android.widget.TextViewimport androidx.databinding.BindingAdapterimport androidx.databinding.InverseBindingAdapterimport androidx.databinding.InverseBindingListenerclass PinkComponent &#123; @BindingAdapter("android:bindName") fun TextView.setBindName(name: String) &#123; if (name.isNotEmpty() &amp;&amp; name != text) &#123; text = "数据体" &#125; &#125; @BindingAdapter("android:bindNameAttrChanged") fun TextView.notifyBindName(inverseBindingListener: InverseBindingListener) &#123; doAfterTextChanged &#123; inverseBindingListener.onChange() &#125; &#125; @InverseBindingAdapter(attribute = "android:bindName") fun TextView.getBindName(): String &#123; return text.toString() &#125;&#125; 第二步： 12345678package com.ly.allendemojetpack.databindingotherclass CusComponent : androidx.databinding.DataBindingComponent &#123; override fun getPinkComponent(): PinkComponent &#123; // 此处不能返回null return PinkComponent() &#125;&#125; 设置默认组件都是由DataBindingUtil设置，但是方法有所不同： 123static void setDefaultComponent(DataBindingComponent bindingComponent)static DataBindingComponent getDefaultComponent() 以上这种设置必须在绑定视图之前设置，并且默认全局的，只需要设置一次。 1static &lt;T extends ViewDataBinding&gt; T setContentView(Activity activity, int layoutId, DataBindingComponent bindingComponent) 如果没有执行setDefaultComponent()，则选择通过函数单独传入，则每次都要传入，否则报错。或者可以将@BindingAdapter注解的方法变为static修饰。DataBindingComponent只能使用@BindingAdapter注解。 7. 注意 可以使用include，但是不能作为root布局，merge不能使用； 如果没有自动生成DataBinding类，可以先写一个variable（或者make module一下）； 即使没有绑定数据（可能会等到网络请求成功之后再去绑定数据），但是只要视图创建完成，就会自动绑定数据，这是数据是一个空对象。空对象的字段也有默认值（String的默认值是null，TextView就会显示null）；并且，如果用了三元表达式，空对象的三元表达式都为fasle，所以建议不考虑空对象的情况； 如果给一个要求值是bolean类型的值自定义属性（@BindingAdapter）赋值一个函数，空指针的情况会返回false。]]></content>
      <categories>
        <category>Android</category>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>Jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Jetpack：Navigation]]></title>
    <url>%2F2019%2F07%2F29%2FAndroid-Jetpack-Navigation%2F</url>
    <content type="text"><![CDATA[前言Android Jetpack是谷歌在2018年的I/O大会上发布的，官网,主要包含一下模块，系列文章主要介绍架构部分的内容： 这里先学习Navigation。 官方Demo：android-architecture-components。 1. 简介1.1 定义Navigation是一个可简化Android导航和库的插件。更确切来说，Navigation是用来管理Fragment切换的，并且可以通过可视化的方式，看见App的交互流程。 1.2 优点 处理Fragment的切换 默认情况下正确处理Fragment的前进和后退 为过渡和动画提供标准化的资源 实现和处理深层连接 可以绑定Toolbar、BottomNavigationView和ActionBar等 SafeArgs（Gradle插件）数据传递时提供类型安全性 ViewModel的支持 2. 具体学习Navigation三个关键组成部分： Navigation Graph：导航图，一个XML资源，包含集中在一个位置的所有和导航相关的信息。包括应用程序中所有单独的内容区域（也成目的地），以及用户可以通过应用程序访问的可能路径。 NavHost：一个存储前面目的地的容器，Navigation组件包含了一个默认的实现了NavHostFragment的NavHost，用来显示Fragment的目的地。 NavController：导航控制者，在NavHost中，管理应用程序导航的对象。当用户在app中进行切换页面等操作时，NavController在NavHost中协调目标内容的切换。 2.1 步骤1：添加依赖在module的build.gradle中添加依赖： 1234567dependencies &#123; ...... implementation 'androidx.fragment:fragment-ktx:1.2.0-alpha01' implementation 'androidx.navigation:navigation-fragment-ktx:2.1.0-beta02' implementation 'androidx.navigation:navigation-ui-ktx:2.1.0-beta02'&#125; 要加上kotlin依赖，在项目的build.gradle： 1234567891011buildscript &#123; repositories &#123; google() jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:3.4.0' classpath 'org.jetbrains.kotlin:kotlin-gradle-plugin:1.3.31' &#125;&#125; 如果要使用SafeArgs插件，可以在项目的build.gradle中添加： 12345buildscript &#123; dependencies &#123; classpath 'androidx.navigation:navigation-safe-args-gradle-plugin:2.0.0' &#125;&#125; 以及module下的build.gradle中添加： 12apply plugin: 'kotlin-android-extensions'apply plugin: 'androidx.navigation.safeargs' 2.2 步骤2：创建Navigation导航 创建基础目录：资源文件res目录下创建navigation目录； 创建一个Destination，如果说navigation是导航工具，Destination就是目的地，在此之前已经写好了需要用到的Fragment——SplashFragment、LoginFragment和RegisterFragment，添加Desination，如下示图： 除了上面的可视化界面，也能通过代码进行编辑，login_navigation.xml： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;navigation xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/login_navigation" app:startDestination="@id/splash" tools:ignore="UnusedNavigation"&gt; &lt;fragment android:id="@+id/login" android:name="com.ly.allendemojetpack.ui.fragment.login.LoginFragment" android:label="LoginFragment" tools:layout="@layout/fragment_login"/&gt; &lt;fragment android:id="@+id/splash" android:name="com.ly.allendemojetpack.ui.fragment.login.SplashFragment" android:label="LoginFragment" tools:layout="@layout/fragment_splash"&gt; &lt;action android:id="@+id/action_welcome_to_login" app:destination="@id/login"/&gt; &lt;action android:id="@+id/action_welcome_to_register" app:enterAnim="@anim/common_fade_in" app:exitAnim="@anim/common_slide_out_left" app:popEnterAnim="@anim/common_slide_in_left" app:popExitAnim="@anim/common_slide_out_right" app:destination="@id/register"/&gt; &lt;/fragment&gt; &lt;fragment android:id="@+id/register" android:name="com.ly.allendemojetpack.ui.fragment.login.RegisterFragment" android:label="LoginFragment" tools:layout="@layout/fragment_register"&gt; &lt;argument android:name="EMAIL" android:defaultValue="2019" app:argType="string"/&gt; &lt;/fragment&gt;&lt;/navigation&gt; 这里看看navigation标签的属性，app:startDestination，即默认的起始位置。 2.3 步骤3：创建NavHostFragment这里创建一个新的LoginActivity作为NavHostFragment，在activity_login.xml中： 123456789101112131415161718&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".ui.activity.LoginActivity"&gt; &lt;fragment android:id="@+id/my_nav_host_fragment" android:name="androidx.navigation.fragment.NavHostFragment" android:layout_width="match_parent" android:layout_height="match_parent" app:navGraph="@navigation/login_navigation" app:defaultNavHost="true"/&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; android:name：值必须是androidx.navigation.fragment.NavHostFragment，声明这是一个NavHostFragemnt。 app:navGraph：存放导航的资源文件，确定Navgation Graph。 app:defaultNavHost：关联系统的返回按钮 。 2.4 步骤4：界面跳转、参数传递和动画在SplashFragment中，点击登录按钮和注册按钮可以分别跳转到LoginFragment和RegisterFragment。 有两种实现方式： 2.4.1 方式1：利用ID导航目标：SplashFragment携带key为name的数据跳转到LoginFragment，LoginFragment接收后显示。 登录按钮的点击事件如下： 123456789101112131415btnLogin.setOnClickListener &#123; // 设置动画参数 val navOption = navOptions &#123; anim &#123; enter = R.anim.common_slide_in_right exit = R.anim.common_slide_out_left popEnter = R.anim.common_slide_in_left popExit = R.anim.common_slide_out_right &#125; &#125; // 参数设置 val bundle = Bundle() bundle.putString("name", "TeaOf") findNavController().navigate(R.id.login, bundle, navOption)&#125; 在LoginFragment中就可以通过Fragment的Bundle直接获取传来的参数。代码如下：LoginFragment.kt 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.ly.allendemojetpack.ui.fragment.loginimport android.content.Intentimport android.os.Bundleimport android.view.LayoutInflaterimport android.view.Viewimport android.view.ViewGroupimport android.widget.Buttonimport android.widget.EditTextimport android.widget.TextViewimport androidx.fragment.app.Fragmentimport com.ly.allendemojetpack.MainActivityimport com.ly.allendemojetpack.Rclass LoginFragment : Fragment() &#123; override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? &#123; return inflater.inflate(R.layout.fragment_login, container, false) &#125; lateinit var cancel: TextView lateinit var login: Button lateinit var account: EditText override fun onViewCreated(view: View, savedInstanceState: Bundle?) &#123; super.onViewCreated(view, savedInstanceState) cancel = view.findViewById(R.id.txt_cancel) login = view.findViewById(R.id.btn_login) account = view.findViewById(R.id.et_account) login.setOnClickListener &#123; val intent = Intent(context, MainActivity::class.java) context!!.startActivity(intent) &#125; cancel.setOnClickListener &#123; activity?.onBackPressed() &#125; val name = arguments?.getString("name") account.setText(name) &#125;&#125; 效果图： 2.4.2 利用Safe Args目标：SplashFragment通过Safe Args将数据传到RegisterFragment，RegisterFragment接收后显示。 在前面的login_navigation.xml中可以看到里面还有action标签和argument标签。 action标签里面的属性 app:destination：跳转完成到达的fragment的id app:popUpTo：将fragment从栈中弹出，直到某个id的fragment argument标签里面的属性 android:name：标签名字 app:argType：标签的类型 android:defaultValue：默认值 点击Make Project按钮，Android Studio会自动生成两个类： SplashFragment的注册按钮点击事件： 123456btnRegister.setOnClickListener &#123; val action = SplashFragmentDirections .actionWelcomeToRegister() .setEMAIL("TeaOf1995@Gamil.com") findNavController().navigate(action)&#125; RegisterFragment中的接收： 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.ly.allendemojetpack.ui.fragment.loginimport android.os.Bundleimport android.view.LayoutInflaterimport android.view.Viewimport android.view.ViewGroupimport android.widget.Buttonimport android.widget.EditTextimport android.widget.TextViewimport android.widget.Toastimport androidx.fragment.app.Fragmentimport androidx.navigation.fragment.navArgsimport com.ly.allendemojetpack.Rclass RegisterFragment : Fragment() &#123; override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? &#123; return inflater.inflate(R.layout.fragment_register, container, false) &#125; lateinit var cancel: TextView lateinit var register: Button lateinit var emailEt: EditText override fun onViewCreated(view: View, savedInstanceState: Bundle?) &#123; super.onViewCreated(view, savedInstanceState) cancel = view.findViewById(R.id.txt_cancel) register = view.findViewById(R.id.btn_register) emailEt = view.findViewById(R.id.et_email) register.setOnClickListener &#123; Toast.makeText(context, "Register", Toast.LENGTH_SHORT).show() &#125; cancel.setOnClickListener &#123; activity?.onBackPressed() &#125; val safeArgs: RegisterFragmentArgs by navArgs() val email = safeArgs.email emailEt.setText(email) &#125;&#125; 注意这里的navArgs()必须在JVM 1.8 以上，低于此版本会报错，Cannot inline bytecode built with JVM target 1.8 into bytecode that is being built with JVM target 1.6，在Android Studio中，Settings -&gt; Other Settings -&gt; Kotlin Compiler -&gt; Target JVM version，选择1.8及以上，同时在module的build.gradle添加以下： 1234567891011121314android &#123; ...... // 这里也要添加，否则报错 Error: Invoke-customs are only supported starting with Android O (--min-api compileOptions &#123; sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 &#125;&#125;tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).all &#123; kotlinOptions &#123; jvmTarget = "1.8" &#125;&#125; 效果图： 3. 其他Navigation还可以绑定其他，如menu、drawables和bottom navigation，这里以bototm navigation为例，先在navigation目录下创建main_navigation.xml，用之前的MainActivity，修改activity_main.xml如下： 1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity"&gt; &lt;fragment android:id="@+id/my_nav_host_fragment" android:name="androidx.navigation.fragment.NavHostFragment" app:navGraph="@navigation/main_navigation" app:defaultNavHost="true" android:layout_width="match_parent" android:layout_height="0dp" android:layout_weight="1"/&gt; &lt;com.google.android.material.bottomnavigation.BottomNavigationView android:id="@+id/navigation_view" android:layout_width="match_parent" android:layout_height="wrap_content" android:background="@android:color/white" app:itemIconTint="@color/colorAccent" app:itemTextColor="@color/colorPrimary" app:menu="@menu/menu_main"/&gt;&lt;/LinearLayout&gt; MainActivity中的处理也很简单： 12345678910111213141516171819202122232425262728293031323334package com.ly.allendemojetpackimport android.os.Bundleimport androidx.appcompat.app.AppCompatActivityimport androidx.navigation.NavControllerimport androidx.navigation.fragment.NavHostFragmentimport androidx.navigation.ui.setupWithNavControllerimport com.google.android.material.bottomnavigation.BottomNavigationViewclass MainActivity : AppCompatActivity() &#123; lateinit var bottomNavigationView: BottomNavigationView override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) val host: NavHostFragment = supportFragmentManager.findFragmentById(R.id.my_nav_host_fragment) as NavHostFragment val navController = host.navController initWidget() initBottomNavigationView(bottomNavigationView, navController) &#125; private fun initBottomNavigationView(bottomNavigationView: BottomNavigationView, navController: NavController) &#123; bottomNavigationView.setupWithNavController(navController) &#125; private fun initWidget() &#123; bottomNavigationView = findViewById(R.id.navigation_view) &#125;&#125; 效果图： 4. 总结 定义：可简化Android导航的库和插件 功能： 处理Fragment的切换 实现和处理深层连接 绑定Toolbar、BottomNavigationView和DrawableLayout 支持ViewModel Safe Args 准备：Android Studio 3.2及以上 三要素 Navigation Graph 地图 关键标签： navigation fragment action：可以设置动画 argument NavHostFragment：容器 NavController：控制器 跳转 通过fragment id实现跳转 action实现跳转 传参 fragment自带的Bundle Safe Args：类型安全 绑定View：Toolbar、BottomNavigationView和DrawableLayout 深层连接（本文未涉及） Demo地址：Allen_Demo_WebService]]></content>
      <categories>
        <category>Android</category>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>Jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android热修复 Tinker接入与源码浅析（有问题）]]></title>
    <url>%2F2019%2F07%2F29%2FAndroid%E7%83%AD%E4%BF%AE%E5%A4%8D-Tinker%E6%8E%A5%E5%85%A5%E4%B8%8E%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1. 概述现在主流热修复：阿里的AndFix、腾讯的QZone的方案、美团的Robust和腾讯的Tinker。 其中AndFix接入是最简单的，不过兼容性还是问题；QZone对性能有一定影响，在在Art模式下出现内存错乱的问题；美团的Robust是基于Instant Run原理的，兼容性好；Tinker就是用在微信上面的热修复，性能和兼容性不用多说。 这里主要学习腾讯的Tinker和美团的Robust。 本文主要学习Tinker的接入以及对Tinker大致原理的分析。 2. Tinker的接入接入前提（开启混淆模式）： 对于API，一般来说，接入热修复，会在Application的onCreate()中进行一些初始化操，然后在某个地方去调用类似loadPatch这样的API去加载patch文件。 对于patch最简单的生成方式就是通过对比两个APK然后生成；注意，两个APK做对比，需要的前提是，第二次打包混淆使用的mapping.txt文件应该和线上的APK是一致的。 最后看看该项目有没有需要配置混淆的。 Tinker官方文档 2.1 步骤1：添加gradle插件依赖gradle远程仓库依赖jcenter： 123456789buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; // TinkerPatch 插件 classpath "com.tinkerpatch.sdk:tinkerpatch-gradle-plugin:1.2.13.3" &#125;&#125; 注意，在这里SDK使用了fat打包模式，不能再引用任何Tinker的相关 依赖，否则会造成版本冲突。 2.2 步骤2：集成TinkerPatch SDK添加TinkerPatch SDK库的依赖，可以参考Sample中的app/build.gradle： 12345678dependencies &#123; ...... //若使用annotation需要单独引用,对于tinker的其他库都无需再引用 // 可选，用于生成application类 compileOnly("com.tinkerpatch.tinker:tinker-android-anno:1.9.13.3") &#123; changing = true &#125; annotationProcessor("com.tinkerpatch.tinker:tinker-android-anno:1.9.13.3") &#123; changing = true &#125; implementation("com.tinkerpatch.sdk:tinkerpatch-android-sdk:1.2.13.3") &#123; changing = true &#125;&#125; 若使用annotation自动生成Application，需要单独引入Tinker的tiner-android-anno库。除此之外，不需要单独引入tinker的其他库。 为了方便，已经将TinkerPatch相关的配置放到了tinkerpatch.gradle中，所以需要引用：（注释：这块内容还需要整理，有报错！！） 1apply from: 'tinkerpatch.gradle' 2.3 步骤3：配置tinkerpatchSupport参数：（可以不配置，使用默认的）打开前面的tinkerpatcch.gradle文件可以看到如下参数： 123456789101112131415161718192021222324252627tinkerpatchSupport &#123; /** 可以在debug的时候关闭 tinkerPatch **/ tinkerEnable = true /** 是否使用一键接入功能 **/ reflectApplication = true /** 是否开启加固模式，只有在使用加固时才能开启此开关 **/ protectedApp = false /** 补丁是否支持新增 Activity (新增Activity的exported属性必须为false)**/ supportComponent = false autoBackupApkPath = "$&#123;bakPath&#125;" /** 在tinkerpatch.com得到的appKey **/ appKey = "yourAppKey" /** 注意: 若发布新的全量包, appVersion一定要更新 **/ appVersion = "1.0.0" def pathPrefix = "$&#123;bakPath&#125;/$&#123;baseInfo&#125;/$&#123;variantName&#125;/" def name = "$&#123;project.name&#125;-$&#123;variantName&#125;" baseApkFile = "$&#123;pathPrefix&#125;/$&#123;name&#125;.apk" baseProguardMappingFile = "$&#123;pathPrefix&#125;/$&#123;name&#125;-mapping.txt" baseResourceRFile = "$&#123;pathPrefix&#125;/$&#123;name&#125;-R.txt"&#125; 具体含义如下： 参数 默认值 描述 tinkerEnable true 是否开启tinkerpatchSupport插件功能 appKey “” 在TinkerPatch平台申请的appKey appVersion “” 在TinkerPatch平台输入的版本号。注意：使用appVerison作为TinkerId，需要保证每个发布出去的基础安装包的appVersion都不一样。 reflectApplication false 是否反射Application autoBackupAppPath “” 将每次编译产生的apk/mapping.txt/R.txt归档存储的位置 baseApkFile “” 基准包的文件路径，对应tinker插件中的oldApk参数；编译补丁包时，必须指定基准版本的apk，默认值为空，表示不进行补丁包的编译 baseProguardMappingFile “” 基准包的Proguard mapping.txt文件路径，对应tinker插件appliMapping参数；在编译新的apk时，希望通过基准apk的proguard混淆方式，从而减小补丁包的大小。编译补丁包时，推荐输入基准apk生成的mapping.txt文件 baseResourceRFile “” 基准包的资源R.txt文件路径，对应tinker插件applyResourceMapping参数；在编译新的apk时，希望通过基准apk的R.txt文件来保存Resource Id的分配，这样不仅可以减少补丁包的大小，同时也能避免由于Resource Id改变导致remote view异常 protectedApp false 是否开启加固支持，注意：只有在使用加固支持时才能开启此开关 supportComponent false 是否开启支持在补丁包中动态增加Activity，注意：新增Activity的exported属性必须设置为false backupFileNameFormat ‘${appName}-${variantName}’ 格式化命名备份文件，这里要使用单引号 一般来说，不需要修改引用Android的编译配置，也不用修改tinker插件原来的配置。对于需要特殊配置，参考接入指南 2.4 初始化TinkerPatch SDK reflectApplication = true：这时，无需为Tinker而改造Application。12345678910111213141516171819202122public class SampleApplication extends Application &#123; ... @Override public void onCreate() &#123; super.onCreate(); // 我们可以从这里获得Tinker加载过程的信息 tinkerApplicationLike = TinkerPatchApplicationLike.getTinkerPatchApplicationLike(); // 初始化TinkerPatch SDK, 更多配置可参照API章节中的,初始化SDK TinkerPatch.init(tinkerApplicationLike) .reflectPatchLibrary() .setPatchRollbackOnScreenOff(true) .setPatchRestartOnSrceenOff(true) .setFetchPatchIntervalByHours(3); // 每隔3个小时(通过setFetchPatchIntervalByHours设置)去访问后台时候有更新,通过handler实现轮训的效果 TinkerPatch.with().fetchPatchUpdateAndPollWithInterval(); &#125; ... 将Tinker加载补丁过程的结果放在TinkerPatchApplicationLike中。 reflectApplication = false（一般使用）：API主要就是初始化和loadPatch()。 通常情况下，会考虑在Application的onCreate()中初始化，但Tinker推荐下面的写法： 123456789101112131415161718192021222324252627282930313233343536373839package com.ly.allendemotinker;import android.app.Application;import android.content.Context;import android.content.Intent;import com.tencent.tinker.anno.DefaultLifeCycle;import com.tencent.tinker.entry.DefaultApplicationLike;import com.tencent.tinker.lib.tinker.TinkerInstaller;import com.tencent.tinker.loader.shareutil.ShareConstants;/** * 初始化TinkerPatch SDK * * @author Liuyang * @date 2019/7/29 */@DefaultLifeCycle(application = ".SampleApplication", flags = ShareConstants.TINKER_ENABLE_ALL, loadVerifyFlag = false)public class SampleApplicationLike extends DefaultApplicationLike &#123; public SampleApplicationLike(Application application, int tinkerFlags, boolean tinkerLoadVerifyFlag, long applicationStartElapsedTime, long applicationStartMillisTime, Intent tinkerResultIntent) &#123; super(application, tinkerFlags, tinkerLoadVerifyFlag, applicationStartElapsedTime, applicationStartMillisTime , tinkerResultIntent); &#125; @Override public void onBaseContextAttached(Context base) &#123; super.onBaseContextAttached(base); &#125; @Override public void onCreate() &#123; super.onCreate(); TinkerManager.installedTinker(this); &#125;&#125; Tinker建议编写一个ApplicationLike的子类，可以当成Application去使用，顶部的注解@DefaultLifeCycle，其中application属性，会在编译期生成一个SimpleTinkerInApplication类。 所以，实际上Application会在编译期生成，所以AndroidManifest.xml中是这样的： 123&lt;application android:name=".SampleApplication" .../&gt; 编译报红，build一下就可以。 实际上，注解的背后有一个Annotation Processor的处理，具体原理可以查看Android 如何编写基于编译时注解的项目。 2.5 创建一个ApplicationLike代理类：实现对Tinker的管理，TinkerManager： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.ly.allendemotinker;import android.content.Context;import com.tencent.tinker.lib.tinker.Tinker;import com.tencent.tinker.lib.tinker.TinkerInstaller;/** * Tinker管理类 * * @author Liuyang * @date 2019/7/29 */public class TinkerManager &#123; private static boolean mIsInstalled = false; private static ApplicationLike mApplicationLike; /** * 完成Tinker初始化 */ public static void installedTinker(ApplicationLike applicationLike) &#123; mApplicationLike = applicationLike; if (mIsInstalled) &#123; return; &#125; TinkerInstaller.install(mApplicationLike); mIsInstalled = true; &#125; /** * 完成patch文件的加载 * * @param path 补丁文件路径 */ public static void loadPatch(String path) &#123; // 是否已经安装过 if (Tinker.isTinkerInstalled()) &#123; TinkerInstaller.onReceiveUpgradePatch(getApplicationContext(), path); &#125; &#125; /** * 利用Tinker代理Application 获取应用全局的上下文 * * @return 全局的上下文 */ private static Context getApplicationContext() &#123; if (mApplicationLike != null) return mApplicationLike.getApplication().getApplicationContext(); return null; &#125;&#125; 2.6 AndroidManifest.xml配置123456789101112131415161718192021222324252627282930313233&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" package="com.ly.allendemotinker"&gt; &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt; &lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" /&gt; &lt;application android:name=".Application" android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:roundIcon="@mipmap/ic_launcher_round" android:supportsRtl="true" android:theme="@style/AppTheme" tools:ignore="GoogleAppIndexingWarning"&gt; &lt;activity android:name=".MainActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;!-- 这个标签开判断我们生成的patch的.apk文件中的tinker_id_XXX 与我们的版本号tinker_id_XXX比较。相同合法，不同则不会进行更新 --&gt; &lt;meta-data android:name="TINKER_ID" android:value="tinker_id_6235657" /&gt; &lt;/application&gt;&lt;/manifest&gt; 在这里加上必要的权限，然后设置andorid:name = &quot;.Application&quot;，最后配置TINKER_ID属性，里面的数字部分一般是versionCode。 2.7 生成差异apk文件首先生成old.apk。布局文件：activity_main.xml： 123456789101112131415161718&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity"&gt; &lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:onClick="loadPatch" android:text="热修复" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent" app:layout_constraintTop_toTopOf="parent" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 代码文件：MainActivity.java： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.ly.allendemotinker;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import java.io.File;/** * @author Liuyang * @date 2019/7/29 */public class MainActivity extends AppCompatActivity &#123; /** * 文件后缀 */ private static final String FILE_END = ".apk"; /** * 文件路径 */ private String mFileDir; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // /storage/emulated/0/Android/data/com.ly.allendemotinker/cache/demo_patch/ mFileDir = getExternalCacheDir().getAbsolutePath() + "/demo_patch/"; // 创建路径对应的文件夹 File file = new File(mFileDir); if (!file.exists()) &#123; file.mkdir(); &#125; &#125; public void loadPatch(View view) &#123; TinkerManager.loadPatch(getPatchName()); &#125; public String getPatchName() &#123; return mFileDir.concat("tinker").concat(FILE_END); &#125;&#125; 打包成old.apk，然后修改布局代码如下： 1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity"&gt; &lt;Button android:id="@+id/button" android:layout_width="wrap_content" android:layout_height="wrap_content" android:onClick="loadPatch" android:text="热修复" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent" app:layout_constraintTop_toTopOf="parent" /&gt; &lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="测试" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toBottomOf="@+id/button" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 其他不用修改，打包成new.apk。 2.8 命令行生成补丁文件Tinker官方提供了命令行工具： 将前面生成的两个apk文件和签名文件复制到该目录下（.keystore是eclipse的签名文件，.jks是Andorid Studio的签名文件，可以直接修改后缀，不影响使用），然后输入下面的命令： 参考： https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650821993&amp;idx=1&amp;sn=550a90e30a398bbb652ecd65209b62e2&amp;chksm=80b781f7b7c008e17d9f5a59542f46329d28cbcd2ec075d4c2d44784f789135166a4e1949303&amp;scene=38#wechat_redirect https://www.jianshu.com/p/d649fc014919]]></content>
      <categories>
        <category>Android</category>
        <category>热修复</category>
      </categories>
      <tags>
        <tag>热修复</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android代码混淆]]></title>
    <url>%2F2019%2F07%2F27%2FAndroid%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%2F</url>
    <content type="text"><![CDATA[在Android日常开发中，混淆是必不可少的。 1. 混淆简介代码混淆：Obfuscated code，是将程序中的代码以某种规则转换为难以阅读和理解的代码的一种行为。 1.1 混淆的好处好处就是目的：令APK难以被逆向工程，即很大程度上增加反编译的成本。此外，Android中的“混淆”还能在打包时移除没用的资源，显著减小APK的体积。最后，还能以变通方式避免Anddroid中常见的64k方法数引用的限制。 先看看APK混淆前后的结构对比： 从上面两张图可以看出：经过混淆后，APK中的包名、类名、成员名等都被替换为随机、无意义的名称，增加了代码阅读和理解的难度，提高反编译的成本。混淆前后APK的大小也从2.7M下降到1.4M。 2. Android中的混淆在Android中，平时说的“混淆”其实包含两层意思，一是Java代码的混淆，二是资源的压缩。 2.1 开启混淆12345678910......android &#123; buildTypes &#123; release &#123; minifyEnabled true shrinkResources true proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125;&#125; 以上就是开启混淆的基本操作，通过minifyEnabled设置为true来开启混淆。同时，可以设置shrinkResources为true来开启资源的压缩。一般在打release包时才会开启混淆，因为混淆会增加额外的编译时间，所以不建议在debug下启用。此外，需要注意：只有在开启混淆的前提下开启资源压缩才有效果。以上代码中的proguard-android.txt表示Android系统提供的默认混淆规则文件，而proguard-rules.pro是我们自定义的混淆规则。下面讲解如何自定义混淆规则。 2.2 代码混淆Java平台提供了Proguard工具来帮助我们快速地对代码进行混淆。根据Java官方介绍，Proguard对应的具体中文定义如下： 它是一个包含代码文件压缩、优化、混淆和校验等功能的工具； 它能检测并删除无用的类、变量、方法和属性； 它能优化字节码并删除未使用的指令； 它能将类、变量和方法的名字重命名为无意义的名称从而达到混淆效果； 它会校验处理后的代码，只有针对Java 6及以上的版本和Java ME。 2.3 资源压缩在Android中，编译提供了另一个功能：资源压缩。资源压缩能帮助移除项目和仓库中未使用到的资源，有效降低APK的大小，。由于资源压缩与代码混淆是协同工作，所以，如果要开启资源压缩，一定要先开启代码混淆，否则会报错： 12ERROR: Removing unused resources requires unused code shrinking to be turned on. See http://d.android.com/r/tools/shrink-resources.html for more information.Affected Modules: app 2.4 自定义要保留的资源开启资源压缩后，系统默认会移除所有未使用的资源，如果要保留特定的资源，可以在项目中创建一个被&lt;resources&gt;标记的XML文件（如，res/raw/keep.xml），并在tools:keep属性中指定每个要保留的资源，在tools:discard属性中指定每个要舍弃的资源。这两个属性都接受逗号分隔的资源名称列表。同样，可以使用*作为通配符。如： 1234&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources xmlns:tools="http://schemas.android.com/tools" tools:keep="@layout/activity_video*,@layout/dialog_update_v2" tools:discard="@layout/unused_layout,@drawable/unused_selector" /&gt; 2.5 启用严格检查模式通常， 资源压缩器可以准确判定系统是否使用了资源。但，如果代码（包含库）调用了Resources.getIdentifier()，这就表示代码将根据动态生成的字符串查询名称。这时，资源压缩器会采取防御性行为，将所有具有匹配名称格式的资源标记为可能已使用，无法移除。如，以下代码会使所有带img_前缀的资源标记为已使用： 12String name = String.format("img_%1d", angle + 1);res = getResources().getIdentifier(name, "drawable", getPackageName()); 这时，可以启用严格检查模式，只会保留确定已经使用的资源。 2.6 移除备用资源Gradle资源压缩器只会移除未被应用引用的资源，意味着它不会移除用于不同设备配置的备用资源。必要时，可以使用Android Gradle插件的resCOnfigs属性来移除应用中不需要的备用资源文件（常见的有用于国际化支持的strings.xml，适配用的layout.xml等）。 1234567android &#123; defaultConfig &#123; ... //保留中文和英文国际化支持 resConfigs "en", "zh" &#125;&#125; 3. 自定义混淆规则先了解常用的混淆命令： 3.1 keep命令指一系列以-keep开头的命令，主要是用来保留Java中不需要进行混淆的元素。以下是常见的-keep命令： -keep：作用：保留指定的类和成员，防止被混淆处理。如： 12345# 保留包：com.moos.media.entity 下面的类以及类成员-keep public class com.moos.media.entity.**# 保留类：NumberProgressBar-keep public class com.moos.media.widget.NumberProgressBar &#123;*;&#125; -keepclassmembers：作用：保留指定的类的成员（变量/方法），它们将不会被混淆。如： 12345# 保留类的成员：MediaUtils类中的特定成员方法-keepclassmembers class com.moos.media.MediaUtils &#123; public static *** getLocalVideos(android.content.Context); public static *** getLocalPictures(android.content.Context);&#125; -keepclasseswithmembers：作用：保留指定的类及其成员（变量/方法），前提是它们在压缩阶段没有被删除。与-keep使用方式类似： 12345# 保留类：BaseMediaEntity 的子类-keepclasseswithmembers public class * extends com.moos.media.entity.BaseMediaEntity&#123;*;&#125;# 保留类：OnProgressBarListener接口的实现类-keep public class * implements com.moos.media.widget.OnProgressBarListener &#123;*;&#125; @keep：除了以上的方式，还可以使用@keep注解来保留代码，防止它们被混淆处理。比如，通过@keep来修饰一个类来保留它不被混淆： 123456@Keepdata class CloudMusicBean(var createDate: String, var id: Long, var name: String, var url: String, val imgUrl: String) 也可以修饰方法或字段进行保留。 3.2 其他命令 dontwarn-dontwarn命令一般在引入新的library时会用到，常用于处理library中无法解决的警告。如： 123-keep class twitter4j.** &#123; *; &#125;-dontwarn twitter4j.** 其他命令用法可以参考Android系统提供的默认混淆规则： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#混淆时不生成大小写混合的类名-dontusemixedcaseclassnames#不跳过非公共的库的类-dontskipnonpubliclibraryclasses#混淆过程中记录日志-verbose#关闭预校验-dontpreverify#关闭优化-dontoptimize#保留注解-keepattributes *Annotation*#保留所有拥有本地方法的类名及本地方法名-keepclasseswithmembernames class * &#123; native &lt;methods&gt;;&#125;#保留自定义View的get和set方法-keepclassmembers public class * extends android.view.View &#123; void set*(***); *** get*();&#125;#保留Activity中View及其子类入参的方法，如: onClick(android.view.View)-keepclassmembers class * extends android.app.Activity &#123; public void *(android.view.View);&#125;#保留枚举-keepclassmembers enum * &#123; **[] $VALUES; public *;&#125;#保留序列化的类-keepclassmembers class * implements android.os.Parcelable &#123; public static final android.os.Parcelable$Creator CREATOR;&#125;#保留R文件的静态成员-keepclassmembers class **.R$* &#123; public static &lt;fields&gt;;&#125;-dontwarn android.support.**-keep class android.support.annotation.Keep-keep @android.support.annotation.Keep class * &#123;*;&#125;-keepclasseswithmembers class * &#123; @android.support.annotation.Keep &lt;methods&gt;;&#125;-keepclasseswithmembers class * &#123; @android.support.annotation.Keep &lt;fields&gt;;&#125;-keepclasseswithmembers class * &#123; @android.support.annotation.Keep &lt;init&gt;(...);&#125; 更多混淆命令可以参考文章：ProGuard 最全混淆规则说明 4. 不能混淆的部分哪些内容应该混淆？其实，在使用代码混淆时，ProGuard对项目大部分代码进行了混淆操作，为防止编译出错，应该通过-keep命令保留一些元素不被混淆。所以需要知道哪些元素不应该被混淆： 4.1 枚举枚举不能参与到混淆中，原因是：枚举内部存在values方法，混淆后该方法会被重新命名，并抛出NoSuchMethodException。Android系统默认的混淆规则中已经添加了对枚举类的处理，无需额外进行处理。 4.2 被反射的元素被反射使用的类、方法、变量、包名等不能被混淆，原因是：代码混淆过程中，被反射的元素会被重命名，而反射依旧按照先前的名称去查找元素，会发生NoSuchMethodException和NoSuchFieldException。 4.3 实体类实体类通常会伴随着序列化和反序列化操作。混合是将原本有特定含义的“元素”转成无意义的名称，所以，经过混淆之后，序列化之后的value对应的key已经变成没有意义的字段。同时，反序列化的过程创建对象从根本上还是借助反射，混淆后key会被改变，所以实体类通常也不能混淆。 4.4 四大组件Android中的四大组件也不能被混淆，原因是： 四大组件使用前都需要在AndroidManifest.xml文件中进行注册声明，然而混淆处理后，四大组件的类名就会被更改，实际使用的类与AndroidMainifest.xml中注册的类不匹配，会报错。 其他应用程序访问组件时，可能会用到类的包名和类名，经过混淆，可能会找不到对应的组件而产生异常。 4.5 JNI调用的Java方法当JNI调用的Java方法被混淆后，方法名会变成无意义的名称，这就与C++中原本的Java方法名不匹配，因而无法找到所调用的方法。 4.6 其他不应被混淆的 自定义控件不能被混淆 JavaScript调用Java的方法不应被混淆 Java的native方法不应被混淆 项目中引用的第三方库不建议混淆 5. 混淆后的堆栈跟踪代码经过ProGuard混淆处理后，想要读取StackTrace（堆栈追踪）信息就会变得困难。由于方法名和类名都经过混淆处理，即使程序崩溃，也很难定位问题。但是，ProGuard提供了补救的措施，先来看看ProGuard每次构建后生成哪些内容。 5.1 混淆输出结果混淆构建完成之后，会在&lt;module-name&gt;/build/outputs/mapping/release/目录下生成以下文件： dump.txt：说明APK内所有类文件的内部结构。 mapping.txt：提供混淆前后的内容对照表，内容主要包括类、方法和类的成员变量。 seeds.txt：罗列出未进行混淆处理的类和成员。 usage.txt：罗列出从APK移除的代码。 5.2 恢复堆栈跟踪前面的遗留问题：混淆处理后，StackTrace定位困难。如何恢复StackTrace的定位能力？系统提供了retrace工具，结合上面定义的mapping.txt文件，就可以将混淆后的崩溃堆栈追踪器信息还原成正常情况下的StackTrace信息。主要有两种方式来恢复SrackTrace，为了方便理解，以下面的崩溃信息为例，协助两种方式分别进行还原： 123456java.lang.RuntimeException: Unable to start activity Caused by: kotlin.KotlinNullPointerException at com.moos.media.ui.ImageSelectActivity.k(ImageSelectActivity.kt:71) at com.moos.media.ui.ImageSelectActivity.onCreate(ImageSelectActivity.kt:58) at android.app.Activity.performCreate(Activity.java:6237) at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1107) 通过retrace脚本工具 首先进入Android SDK路径的tools/proguard/bin中： 可以看到里面有三个文件，而proguardgui.bat就是需要的retrace脚本。双加该脚本文件，运行，即可看到： 选择Retrace栏，添加项目中混淆生成的mapping.txt文件所在位置，然后将混淆后的崩溃信息复制到Obfuscated stack trace一栏，点击Retrace，即可还原出崩溃日志信息。 通过retrace命令行首先将崩溃信息复制到.txt文件中，然后执行下面命令：1retrace.bat -verbose mapping.txt proguard_stacktrace.txt 最终还原结果和之前效果相同： 在对stackTrace进行恢复时，发现unknown Source问题： 在混淆规则上添加如下配置来提升StackSource查找效率， 12# 保留源文件名和具体代码行号-keepattributes SourceFile,LineNumberTable 此外，每次使用ProGuard创建发布构建时都会覆盖之前版本的mapping.txt文件，因此，每次发布一个新版本时，建议保存一个副本。通过为每个发布构建保留一个mapping.txt文件副本，就可以在用户提交的已混淆的StackTrace来对旧版本应用的问题进行调试和修复。 6. 其他操作前面介绍到，APK在经过代码混淆处理后，包名、类名、成员名被转化为无意义、难以理解的名称，增加反编译的成本。Android ProGuard提供了默认的“混淆字典”，即将元素名称转为英文小写字母的形式。那么，可以定义自己的混淆字典吗？先看一张效果图： 只要生成一套自己的.txt格式的混淆字典，然后在混淆规则Proguard-rules.pro中应用下即可：]]></content>
      <categories>
        <category>Android</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>代码混淆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android实现RecyclerView自动滚动]]></title>
    <url>%2F2019%2F07%2F27%2FAndroid%E5%AE%9E%E7%8E%B0RecyclerView%E8%87%AA%E5%8A%A8%E6%BB%9A%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[实现功能：使用RecyclerView实现垂直滚动效果。 1. 自定义RecyclerView实现滚动效果12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package com.ly.allendemoautopollrecyclerview;import android.annotation.SuppressLint;import android.content.Context;import android.support.annotation.NonNull;import android.support.annotation.Nullable;import android.support.v7.widget.RecyclerView;import android.util.AttributeSet;import android.view.MotionEvent;import java.lang.ref.WeakReference;/** * 自定义垂直滚动RecyclerView * * @author Liuyang * @date 2019/7/27 */public class AutoPollRecyclerView extends RecyclerView &#123; private static final long TIME_AUTO_POLL = 16; private AutoPollTask mAutoPollTask; /** * 标示是否正在自动轮询 */ private boolean mRunning; /** * 标示是否可以自动轮询，可在不需要的是否置false */ private boolean mCanRun; public AutoPollRecyclerView(@NonNull Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); mAutoPollTask = new AutoPollTask(this); &#125; static class AutoPollTask implements Runnable &#123; private final WeakReference&lt;AutoPollRecyclerView&gt; mReference; /** * 使用弱引用持有外部引用，放置内存泄露 */ AutoPollTask(AutoPollRecyclerView reference) &#123; mReference = new WeakReference&lt;&gt;(reference); &#125; @Override public void run() &#123; AutoPollRecyclerView recyclerView = mReference.get(); if (recyclerView != null &amp;&amp; recyclerView.mRunning &amp;&amp; recyclerView.mCanRun) &#123; recyclerView.scrollBy(2, 2); recyclerView.postDelayed(recyclerView.mAutoPollTask, TIME_AUTO_POLL); &#125; &#125; &#125; /** * 开启：如果正在运行，则先停止，再开始 */ public void start() &#123; if (mRunning) &#123; stop(); &#125; mCanRun = true; mRunning = true; postDelayed(mAutoPollTask, TIME_AUTO_POLL); &#125; /** * 停止 */ public void stop() &#123; mRunning = false; removeCallbacks(mAutoPollTask); &#125; @SuppressLint("ClickableViewAccessibility") @Override public boolean onTouchEvent(MotionEvent e) &#123; switch (e.getAction()) &#123; case MotionEvent.ACTION_DOWN: if (mRunning) &#123; stop(); &#125; break; case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: case MotionEvent.ACTION_OUTSIDE: if (mCanRun) &#123; start(); &#125; break; default: break; &#125; return super.onTouchEvent(e); &#125;&#125; 2. 实现Adapter1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.ly.allendemoautopollrecyclerview;import android.annotation.SuppressLint;import android.content.Context;import android.support.annotation.NonNull;import android.support.v7.widget.RecyclerView;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.TextView;import java.util.List;public class AutoPollAdapter extends RecyclerView.Adapter&lt;AutoPollAdapter.BaseViewHolder&gt; &#123; private final Context mContext; private final List&lt;AutoScrollLuckyListReq.DatasBean&gt; mData; public AutoPollAdapter(Context context, List&lt;AutoScrollLuckyListReq.DatasBean&gt; data) &#123; mContext = context; mData = data; &#125; @NonNull @Override public BaseViewHolder onCreateViewHolder(@NonNull ViewGroup viewGroup, int i) &#123; View view = LayoutInflater.from(mContext).inflate(R.layout.auto_list_item, viewGroup, false); return new BaseViewHolder(view); &#125; @SuppressLint("SetTextI18n") @Override public void onBindViewHolder(@NonNull BaseViewHolder baseViewHolder, int position) &#123; AutoScrollLuckyListReq.DatasBean datasBean = mData.get(position % mData.size()); baseViewHolder.content.setText(datasBean.getPhone() + " 获得 " + datasBean.getGiftName()); &#125; @Override public int getItemCount() &#123; return Integer.MAX_VALUE; &#125; class BaseViewHolder extends RecyclerView.ViewHolder &#123; TextView content; BaseViewHolder(View itemView) &#123; super(itemView); content = itemView.findViewById(R.id.content); &#125; &#125;&#125; 3. 适配器布局文件12345678910111213141516171819202122&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="wrap_content" android:background="#fffcf5" android:orientation="vertical"&gt; &lt;TextView android:id="@+id/content" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginTop="8dp" android:layout_marginBottom="8dp" android:text="135xxxx8888 获得 8积分" android:textColor="#797762" android:textSize="14sp" /&gt; &lt;View android:layout_width="match_parent" android:layout_height="1dp" android:background="#797762" /&gt;&lt;/LinearLayout&gt; 4. 调用布局文件：activity_main.xml： 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity"&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="150dp" android:layout_centerInParent="true" android:layout_marginLeft="15dp" android:layout_marginTop="15dp" android:layout_marginRight="15dp" android:background="@drawable/luckyer_bg"&gt; &lt;RelativeLayout android:layout_width="40dp" android:layout_height="wrap_content" android:layout_marginStart="23dp" android:layout_marginTop="1dp" android:layout_marginBottom="1dp" android:background="#fff6ea"&gt; &lt;ImageView android:layout_width="wrap_content" android:layout_height="match_parent" android:layout_centerInParent="true" android:padding="10dp" android:src="@drawable/zhongjiangzhemingdan" /&gt; &lt;/RelativeLayout&gt; &lt;com.ly.allendemoautopollrecyclerview.AutoPollRecyclerView android:id="@+id/recyclerview" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_margin="20dp" /&gt; &lt;/LinearLayout&gt;&lt;/RelativeLayout&gt; Java文件：MainActivity.java： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129package com.ly.allendemoautopollrecyclerview;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.support.v7.widget.LinearLayoutManager;import com.alibaba.fastjson.JSON;/** * @author Liuyang * @date 2019/7/27 */public class MainActivity extends AppCompatActivity &#123; private AutoPollRecyclerView mRecyclerView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); initData(); &#125; private void initView() &#123; mRecyclerView = findViewById(R.id.recyclerview); mRecyclerView.setLayoutManager(new LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false)); &#125; private void initData() &#123; String response = "&#123;\n" + " \"datas\": [\n" + " &#123;\n" + " \"giftName\": \"20个积分\",\n" + " \"phone\": \"****\"\n" + " &#125;,\n" + " &#123;\n" + " \"giftName\": \"20个积分\",\n" + " \"phone\": \"****\"\n" + " &#125;,\n" + " &#123;\n" + " \"giftName\": \"满10减1元\",\n" + " \"phone\": \"****\"\n" + " &#125;,\n" + " &#123;\n" + " \"giftName\": \"20个积分\",\n" + " \"phone\": \"****\"\n" + " &#125;,\n" + " &#123;\n" + " \"giftName\": \"20个积分\",\n" + " \"phone\": \"****\"\n" + " &#125;,\n" + " &#123;\n" + " \"giftName\": \"满10减1元\",\n" + " \"phone\": \"****\"\n" + " &#125;,\n" + " &#123;\n" + " \"giftName\": \"20个积分\",\n" + " \"phone\": \"****\"\n" + " &#125;,\n" + " &#123;\n" + " \"giftName\": \"满10减1元\",\n" + " \"phone\": \"****\"\n" + " &#125;,\n" + " &#123;\n" + " \"giftName\": \"满10减1元\",\n" + " \"phone\": \"****\"\n" + " &#125;,\n" + " &#123;\n" + " \"giftName\": \"三花便签（20枚）\",\n" + " \"phone\": \"****\"\n" + " &#125;,\n" + " &#123;\n" + " \"giftName\": \"三花便签（20枚）\",\n" + " \"phone\": \"****\"\n" + " &#125;,\n" + " &#123;\n" + " \"giftName\": \"满10减1元\",\n" + " \"phone\": \"****\"\n" + " &#125;,\n" + " &#123;\n" + " \"giftName\": \"20个积分\",\n" + " \"phone\": \"****\"\n" + " &#125;,\n" + " &#123;\n" + " \"giftName\": \"满10减1元\",\n" + " \"phone\": \"****\"\n" + " &#125;,\n" + " &#123;\n" + " \"giftName\": \"20个积分\",\n" + " \"phone\": \"****\"\n" + " &#125;,\n" + " &#123;\n" + " \"giftName\": \"三花便签（20枚）\",\n" + " \"phone\": \"****\"\n" + " &#125;,\n" + " &#123;\n" + " \"giftName\": \"三花便签（20枚）\",\n" + " \"phone\": \"****\"\n" + " &#125;,\n" + " &#123;\n" + " \"giftName\": \"满10减1元\",\n" + " \"phone\": \"****\"\n" + " &#125;,\n" + " &#123;\n" + " \"giftName\": \"20个积分\",\n" + " \"phone\": \"****\"\n" + " &#125;,\n" + " &#123;\n" + " \"giftName\": \"20个积分\",\n" + " \"phone\": \"****\"\n" + " &#125;\n" + " ],\n" + " \"msg\": \"success\",\n" + " \"ret\": 0\n" + "&#125;"; AutoScrollLuckyListReq autoScrollLuckyListReq = JSON.parseObject(response, AutoScrollLuckyListReq.class); // 0为请求成功 if (autoScrollLuckyListReq.getRet() == 0) &#123; AutoPollAdapter autoPollAdapter = new AutoPollAdapter(getApplicationContext(), autoScrollLuckyListReq.getDatas()); mRecyclerView.setAdapter(autoPollAdapter); // 启动滚动 mRecyclerView.start(); &#125; &#125;&#125; 5. 效果和Demo地址 Demo地址：Allen_Demo_AutoPollRecyclerView]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蘸水牛肉]]></title>
    <url>%2F2019%2F07%2F27%2F%E8%98%B8%E6%B0%B4%E7%89%9B%E8%82%89%2F</url>
    <content type="text"><![CDATA[【食材】：牛腱子两斤，老姜一大块，花椒四五十粒， 食盐适量，大蒜泥适量、调味盐、味精适量，红油辣子一大勺，花椒面适量，藤椒油适量，芝麻油适量，香葱花适量。 流程： 牛腱子用洗水浸泡两三个小时，尽量泡出肉的的血水，因为肉中血水多，肉的腥味就比较重，不好吃； 浸泡好的牛肉入冷水锅，中火煮开后，再煮两分钟； 经过稍稍煮过的牛肉会紧缩一团，我们从锅中取出肉，再用温水冲洗干净牛肉表面的血污，再控干水分，以上几个步骤的目的都是尽量去除肉中的血污，让肉的味道更鲜美，而没有腥味； 砂锅中放入前面处理好的牛肉，再加入纯净水或矿泉水，再加入一块用刀拍破的老姜和花椒粒，以及适量的食盐，开 大火烧开后，转小火盖上锅盖煮，大约一个小时左右； 煮一个小时左右，我们用一根筷子插肉，如果可以轻松插入牛肉肉中就差不多了； 我们再把牛肉从锅中取出，彻底晾凉后再切成薄片备用； 取一个碗，碗中加入大蒜泥，红油辣子（最好是近期制作的在，时间长了不香），适量的花面和藤椒油卡 ，还要加上适量的调味盐（虽然前面煮肉时加过盐，但比较淡，这里还是需要加少量的调味盐），最后我们还要加入，适量的味精、芝麻油、香葱花，再搅拌匀就可以蘸牛肉了。]]></content>
      <categories>
        <category>美食</category>
      </categories>
      <tags>
        <tag>美食</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[豆角焖面]]></title>
    <url>%2F2019%2F07%2F27%2F%E8%B1%86%E8%A7%92%E7%84%96%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[主料：圆滚豆角一小把切成丁，五花肉适量切成末，细刀切面适量 配料：泡发好的香菇4、5朵切丁，胡萝卜一小段切丁，葱末、姜米、蒜米，香菜碎，八角一朵，干红辣椒4、5只 酱汁：另准备4、5瓣大蒜切米放入碗中，加适量青葱碎，里面放入两匙酱油，一匙陈醋，1\3匙白糖 调成酱汁备用 流程： 热锅凉油，油温7、8层热时放入八角爆香，下肉末煸炒，肉末变色断生后放入干红辣椒翻炒几下，依次加入姜末、葱末、蒜末，翻炒出香味后加入适量酱油和少许盐，加稍多些水，烧开后慢火炖煮10分钟； 冲调酱汁：10分钟后将锅里面的汤一勺一勺舀出，冲倒在酱汁碗中； 锅内留少许汤汁，以不没过豆角为限，将刀切面疏散的铺在豆角上面，尽量不要贴在锅壁上，防粘和糊； 将冲调好的酱汁分三次均匀淋在面条上，每次间隔3分钟； 9分钟后关火，在面条上淋少许香油，撒上香菜碎，用筷子轻轻将面条拨散拌匀，装盘上桌。 搭配上橄榄油沙拉和花生米，营养很均衡。]]></content>
      <categories>
        <category>美食</category>
      </categories>
      <tags>
        <tag>美食</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二、Android XML数据解析]]></title>
    <url>%2F2019%2F07%2F26%2F%E4%BA%8C%E3%80%81Android-XML%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1. XML数据要点介绍XML，可扩展标记语言。可以用来存储数据，可以看做是一个小型的数据库，SharedPreference就是使用XML文件存储数据的，SQLite底层也是一个XML文件，而在网络应用方面，通常作为信息的载体，通常把数据包装成XML来传递。 123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt; -----文档开始&lt;persons&gt; -----开始元素(persons) &lt;person id = "11"&gt; -----文本节点（空白文本） 开始元素(person)属性 &lt;name&gt;Coder-pig&lt;/name&gt; -----文本节点（空白文本） 开始元素(name)属性 结束元素 &lt;age&gt;18&lt;/age&gt; -----文本节点（空白文本） 开始元素(age)属性 结束元素 &lt;/person&gt; -----文本节点（空白文本） 结束元素 &lt;person id = "13"&gt; &lt;name&gt;Jay&lt;/name&gt; &lt;age&gt;20&lt;/age&gt; &lt;/person&gt;&lt;/persons&gt; -----结束元素(persons) -----文档结束 上面就简单的定义了一个存储person对象的xml文件的编码，注意，外面的空白区域也是文本节点。 2. 三种解析XML方法的比较2.1 SAX解析XML对文档进行顺序扫描，当扫描到文档(doucument)开始与结束、元素(element)开始与结束等地方时，通知事件处理函数，由事件处理函数做相对应动作，然后继续进行同样的扫描，直至文档结束。解释速度快，占用内存小，，每需要解析一类XML，就需要编写新的适合该类的XML处理类，比较麻烦。采用的是流式解析，解析是同步的，读到哪就处理到哪。 2.2 Dom解析XML先把XML文档读取到内存中，然后再用DOM API来访问树形结构，并获取数据。这个写起来很简单，但是很消耗内存，假如读取的数据量大，手机内存不够的话，可能导致手机死机。不建议在Android设备中使用，解析简单的XML可以。常用的五个接口与类：Docculem、Element、Node、NodeList、DOMParser，Don是整个文件解析到内存中，供用户需要的节点信息，支持随机访问。 2.3 pull解析XMLXML pull提供了开始元素和结束元素。当某个元素开始时，可以调用parser、nextText从XML文档中提取所有字符数据。当解析到文档结束时，自动生成EndDocument。常用接口和类：XmlPullParser、XmlSerializer、XmlPullParserFactory。和SAX差不多，代码实现比较简单，非常适合移动设备，Android系统内置pull解析器，而且Android系统内部默认使用pull来解析XML文件。 3. SAX解析XMLSAX是一个解析速度快且占用内存少的XML解析器，非常适合用于Android等移动设备；SAX解析XML文件采用的是事件驱动，也就是说不需要解析整个文档，而是在解析过程中，判断读取的字符是否符合XML语法的某部分（文档开头，文档结束，或者标签开头和标签结束），符合的话就会触发事件（回调方法），而这些方法都定义在ContentHandler接口中，而ContentHandler是一个接口， 使用起来不方便，所以Android准备了一个帮助类DefaultHandler，只需要继承这个类，重写里面对应的方法即可。 可以重写的方法： startDocument()：当读取到文文档开始标志时触发，通常在这里完成一些初始化操作。 endDocument()：文档结束部分，在这里完成一些善后工作。 startElement(names, paceURI, localName, qName, atts)：参数依次问命名空间，不带命名空间的前缀标签名，带命名空间的前缀标签名，通过atts可以得到所有的属性名和相应的值；SAX中一个重要的特点就是它的流式处理，当遇到一个标签时，它并不会记录下以前遇到的标签，就是说，在startElement()中，所有知道的信息就是标签的名字和属性，至于标签的嵌套结构，上层标签的名字，是否有子元素等其他与结构相关的信息，都不知道，需要程序来完成，这使得SAX在编程处理上没有DOM方便。 endElement(uri, localName, name)：在遇到结束标签的时候，调用该方法。 characters(ch, start, length)：这个方法用来处理在XML文件中读到的内容，第一个参数用于存放文件的内容，后面两个参数是读到的字符串在这个数组中的起始位置和长度，使用new String(ch, start, length)就可以获取内容。 核心代码：SAX解析类——SaxHelper.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package com.ly.allendemowebservice;import android.util.Log;import org.xml.sax.Attributes;import org.xml.sax.SAXException;import org.xml.sax.helpers.DefaultHandler;import java.util.ArrayList;/** * SAX解析XML * * @author Liuyang * @date 2019/7/26 */public class SaxHelper extends DefaultHandler &#123; private static final String TAG = "SaxHelper"; private Person mPerson; private ArrayList&lt;Person&gt; mPersons; /** * 当前解析的元素标签 */ private String mTagName = null; /** * 当读取到文档开始标志时触发，通常在里面完成一些初始化操作 */ @Override public void startDocument() throws SAXException &#123; this.mPersons = new ArrayList&lt;&gt;(); Log.i(TAG, "读取到文档头,开始解析xml"); &#125; private static final String ELEMENT = "person"; /** * 读到一个开始标签时触发，第二个参数为标签名，最后一个参数为属性数组 */ @Override public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException &#123; if (ELEMENT.equals(localName)) &#123; mPerson = new Person(); mPerson.setId(Integer.parseInt(attributes.getValue("id"))); Log.i(TAG, "开始处理person元素~"); &#125; mTagName = localName; &#125; private static final String TAG_NAME1 = "name"; private static final String TAG_NAME2 = "age"; /** * 读取标签里面的内容，第一个参数为字符串内容，后面依次为起始位置和长度 */ @Override public void characters(char[] ch, int start, int length) throws SAXException &#123; // 判断当前标签是否有效 if (mTagName != null) &#123; String data = new String(ch, start, length); // 读取标签内容 if (TAG_NAME1.equals(mTagName)) &#123; mPerson.setName(data); Log.i(TAG, "处理name元素内容"); &#125; else if (TAG_NAME2.equals(mTagName)) &#123; mPerson.setAge(Integer.parseInt(data)); Log.i(TAG, "处理age元素内容"); &#125; &#125; &#125; /** * 读取到元素结束时触发，这里将对象添加到集合中 */ @Override public void endElement(String uri, String localName, String qName) throws SAXException &#123; if (ELEMENT.equals(localName)) &#123; mPersons.add(mPerson); mPerson = null; Log.i(TAG, "处理person元素结束~"); &#125; mTagName = null; &#125; /** * 读取到文档结束时触发， */ @Override public void endDocument() throws SAXException &#123; super.endDocument(); Log.i(TAG, "处理person元素结束~"); &#125; /** * 获取persons集合 */ public ArrayList&lt;Person&gt; getPersons() &#123; return mPersons; &#125;&#125; 1234567891011121314private ArrayList&lt;Person&gt; readXmlForSax() throws IOException, ParserConfigurationException, SAXException &#123; // 获取文件资源建立输入流对象，可能是从网络获取 InputStream inputStream = getAssets().open("person1.xml"); // 创建XML解析器 SaxHelper helper = new SaxHelper(); // 得到SAX解析工厂 SAXParserFactory factory = SAXParserFactory.newInstance(); // 创建SAX解析器 SAXParser parser = factory.newSAXParser(); // 将XML解析器分配给解析器，对文档进行解析，将事件发送给处理器 parser.parse(inputStream, helper); inputStream.close(); return helper.getPersons();&#125; 在项目assets目录下有一个文件person1.xml。 1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;persons&gt; &lt;person id = "11"&gt; &lt;name&gt;SAX解析&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;/person&gt; &lt;person id = "13"&gt; &lt;name&gt;XML1&lt;/name&gt; &lt;age&gt;43&lt;/age&gt; &lt;/person&gt;&lt;/persons&gt; Demo地址：Allen_Demo_WebService 4. DOM解析XML数据DOM解析XML文件时会将文件所有的内容以文档树的形式存放在内存中，可以使用DOM API遍历XML树，检索到需要的数据。使用DOM操作XML的代码比较直观，并且在编码方面比基于SAX的实现更加简单。但是DOM需要将XML文件的所有内容存放到内存中，所以内存消耗大，特别是对于Android设备而言，内存资源有限，因此建议使用前面的SAX解析。如果解析的内容比较小，也可以使用DOM来解析。 DOM API： DocumentBuilderFactory（解析器工厂类）：创建方法DoucmentBuilderFactory factory = DoucmentBuilderFactory.newInstance(); DocumentBuilder（解析器类）：创建方法：通过解析器工厂类来获得DocumentBuidler builder = factory.newDocumentBuilder(); Document（文档树模型）：将需要解析的XML文件读入DOM解析器：Document doc = builder.parse(context.getAssets().open(&quot;person2.xml&quot;)); Document对象代表了一个XML文档的模型，所有的其他Node都以一定的顺序包含在Document对象内，排列成树状，以后对XML文档的所有操作都与解析器无关。 NodeList（列表类）：代表一个包含一个或多个Node的列表，有以下两个方法： item(index)：返回集合的第index个Node项； getLength()：列表的节点数 Node（节点类）：DOM中最基本的对象，代表文档树中的抽象节点，很少会直接使用；通常调用其子对象的Element、Attr、Text等。 Element（元素类）：Node最主要的子对象，在元素中可以包含属性，因此有获取属性的方法： getAttrbute()：获取属性值 getTagName()：获取元素名称 Attr（属性类）：代表某个元素的属性，虽然Attr继承自Node接口，但因为Attr是包含在Element中的，但并不能将其看做是Element的子对象，因为Attr并不是DOM树的一部分。 核心代码：DOM解析类——DomHelper.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.ly.allendemowebservice;import android.content.Context;import android.util.Log;import org.w3c.dom.Document;import org.w3c.dom.Element;import org.w3c.dom.Node;import org.w3c.dom.NodeList;import org.xml.sax.SAXException;import java.io.IOException;import java.util.ArrayList;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.parsers.ParserConfigurationException;/** * DOM解析XML * * @author Liuyang * @date 2019/7/26 */public class DomHelper &#123; private static final String TAG = "DomHelper"; private static final String TAG_NAME = "name"; private static final String TAG_AGE = "age"; public static ArrayList&lt;Person&gt; queryXML(Context context) &#123; ArrayList&lt;Person&gt; persons = new ArrayList&lt;&gt;(); try &#123; // 1. 获取DOM解析器工厂 DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); // 2. 获取DOM解析器 DocumentBuilder builder = factory.newDocumentBuilder(); // 3. 将要解析的XML文件读入DOM解析器 Document document = builder.parse(context.getAssets().open("person2.xml")); Log.i(TAG, "处理该文档的DomImplementation对象 = " + document.getImplementation()); // 4. 得到文档中名称为person的元素的节点元素 NodeList nodeList = document.getElementsByTagName("person"); // 5. 遍历集合，显示集合中的元素以及子元素的名字 for (int i = 0; i &lt; nodeList.getLength(); i++) &#123; // 先从person元素开始解析 Element personElement = (Element) nodeList.item(i); Person person = new Person(); person.setId(Integer.valueOf(personElement.getAttribute("id"))); // 获取person下的name和age的Note集合 NodeList childNodeList = personElement.getChildNodes(); for (int j = 0; j &lt; childNodeList.getLength(); j++) &#123; Node childNode = childNodeList.item(j); // 判断子Node类型是否为元素的Node if (childNode.getNodeType() == Node.ELEMENT_NODE) &#123; Element childElement = (Element) childNode; if (TAG_NAME.equals(childElement.getNodeName())) &#123; person.setName(childElement.getFirstChild().getNodeValue()); &#125; else if (TAG_AGE.equals(childElement.getNodeName())) &#123; person.setAge(Integer.valueOf(childElement.getFirstChild().getNodeValue())); &#125; &#125; &#125; persons.add(person); &#125; &#125; catch (ParserConfigurationException e) &#123; e.printStackTrace(); &#125; catch (SAXException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return persons; &#125;&#125; 5. PULL解析XML数据除了SAX和DOM解析XML之外，Android系统内置了Pull解析器用来解析XML，比如SharedPreference就是使用内置的pull解析配置文件的。它的使用和SAX类似，都是采用事件驱动来完成XML的解析，而pull代码比较简单，只需处理开始和结束的事件，通常使用switch语句，根据事件不同的类型，匹配不同的处理方式，有五种事件：START_DOCUMENT、START_TAG、TEXT、END_TAG、END_DUCOMENT。 XML pull 提供了开始元素和结束元素。当某个元素开始的时候，可以调用paser.nextText从XML文档中提取所有字符数据。当解析到一个文档结束时，自动生成EndDocument事件。在PULL解析过程中返回的是数字，且需要自己获取产生事件然后做出相应的操作，而不像SAX那样由处理器触发一种事件的方法，执行我们的代码：读取到XML的声明返回START_DOCUMENT；结束返回END_DOCUMENT；开始标签返回START_TAG；结束标签返回END_TAG；文本返回TEXT。使用PULL解析XML的流程： 获取一个XmlPullPaser类的引用： 1234// 方式1：通过xml解析工厂获得实体类XmlPullPaserFactory factory = XmlPullPaserFactory.newInstance(); XmlPullPaser paser = factory.newPullPaser();// 方式2：直接获得实体类XmlPullPaser paser = Xml.newPullPaser(); 为paser解析器对象提供xml流与编码格式： 1paser.setInput(xml, "UTF-8"); 获得事件的类型： 1int eventType = paser.getEventType(); 用switch对不同的事件类型进行不同的处理： START_DUCUMENT：开始读文档时触发，在这里完成初始化操作； START_TAG:开始读标签，通过paser的getName()方法获得标签名信息比较，使用getAttributeValue(index)获取属性值； 对于文字节点TEXT可以使用paser.nextText()获得节点内容； END_TAG：标签结束； paser.next()：循环解析下一个元素。 核心代码：PULL解析XML——PullHelper.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.ly.allendemowebservice;import org.xmlpull.v1.XmlPullParser;import org.xmlpull.v1.XmlPullParserException;import org.xmlpull.v1.XmlPullParserFactory;import java.io.IOException;import java.io.InputStream;import java.util.ArrayList;/** * PULL解析XML * * @author Liuyang * @date 2019/7/27 */public class PullHelper &#123; public static ArrayList&lt;Person&gt; getPersons(InputStream xml) throws XmlPullParserException, IOException &#123; ArrayList&lt;Person&gt; persons = null; Person person = null; // 创建一个XML解析工厂 XmlPullParserFactory factory = XmlPullParserFactory.newInstance(); // 获得XML解析类的引用 XmlPullParser parser = factory.newPullParser(); parser.setInput(xml, "UTF_8"); // 获得事件类型 int eventType = parser.getEventType(); while (eventType != XmlPullParser.END_DOCUMENT) &#123; switch (eventType) &#123; case XmlPullParser.START_DOCUMENT: persons = new ArrayList&lt;&gt;(); break; case XmlPullParser.START_TAG: if ("person".equals(parser.getName())) &#123; person = new Person(); // 取出属性值 int id = Integer.parseInt(parser.getAttributeValue(0)); person.setId(id); &#125; else if ("name".equals(parser.getName())) &#123; // 获取该节点的内容 String name = parser.nextText(); assert person != null; person.setName(name); &#125; else if ("age".equals(parser.getName())) &#123; int age = Integer.parseInt(parser.nextText()); assert person != null; person.setAge(age); &#125; break; case XmlPullParser.END_TAG: if ("person".equals(parser.getName())) &#123; assert persons != null; persons.add(person); person = null; &#125; break; default: break; &#125; eventType = parser.next(); &#125; return persons; &#125;&#125; 使用： 1234567891011try &#123; InputStream inputStream = getAssets().open("person3.xml"); ArrayList&lt;Person&gt; persons = PullHelper.getPersons(inputStream); for (int i = 0; i &lt; persons.size(); i++) &#123; Log.i(TAG, i + " == " + persons.get(i).toString()); &#125;&#125; catch (IOException e) &#123; e.printStackTrace();&#125; catch (XmlPullParserException e) &#123; e.printStackTrace();&#125; 使用PULL生成XML数据的流程： 创建XMlSerializer（XML序列化类）的实例： 1XmlSerializer serializer = Xml.newSerializer(); 为XmlSerializer设置输出流与编码格式： 1serializersetOutput(out, "UTF-8"); 为XMlSerializer设置XML的编码格式： 1serializer.startDocument("UTF-8", true); 设置根元素： 1serializer.startTag(null, "person"); 使用foreach循环遍历persons集合中所有的元素，同时依次写入标签与属性： 1234567891011for(Person p: persons)&#123; serializer.startTag(null, "person"); serializer.attribute(null, "id", p.getId() + ""); serializer.startTag(null, "name"); serializer.text(p.getName()); serializer.endTag(null, "name"); serializer.startTag(null, "age"); serializer.text(p.getAge() + ""); serializer.endTag(null, "age"); serializer.endTag(null, "person");&#125; 设置跟踪完结元素： 1serializer.endTag(null, "persons"); 结束文档编写： 1serializer.endDocument(); 调用flush()，将内存中的数据写入文件中并关闭输出流 12out.flush();out.close(); 核心代码： 12345678910111213141516171819202122public static void save(List&lt;Person&gt; persons, OutputStream out) throws Exception &#123; XmlSerializer serializer = Xml.newSerializer(); serializer.setOutput(out, "UTF-8"); serializer.startDocument("UTF-8", true); serializer.startTag(null, "persons"); for (Person p : persons) &#123; serializer.startTag(null, "person"); serializer.attribute(null, "id", p.getId() + ""); serializer.startTag(null, "name"); serializer.text(p.getName()); serializer.endTag(null, "name"); serializer.startTag(null, "age"); serializer.text(p.getAge() + ""); serializer.endTag(null, "age"); serializer.endTag(null, "person"); &#125; serializer.endTag(null, "persons"); serializer.endDocument(); out.flush(); out.close();&#125; Demo地址：Allen_Demo_WebService]]></content>
      <categories>
        <category>Android</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>WebService</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一、Android调用WebService]]></title>
    <url>%2F2019%2F07%2F26%2F%E4%B8%80%E3%80%81Android%E8%B0%83%E7%94%A8WebService%2F</url>
    <content type="text"><![CDATA[Android调用WebService类似于一些给我们提供了原始数据API服务的数据平台，比如聚合数据。而WebService则用到了XML和SOAP，通过HTTP协议即可完成与远程机器的交互。 1. WebService简介1.1 WebService的引入手机硬件资源是有限的，对于一些复杂的数据处理和计算，通常都是部署在远程服务器上，然后安卓手机作为对应的客户端。为了让Android APP与远程服务器进行交互，肯定需要一些技术，这里使用WebService就可以了。 什么是WebService？ 简单来说，就是某些站点开放出来的服务，当然也可以自己开发一个service，也就是一些方法，通过URI，指定某一个方法名，发出请求，站点的这个服务（方法），接收请求后，根据传入的参数进行一些处理，然后将处理的结果以XML的形式返回。客户端收到这些XML并进行解析，然后显示或者进行其他操作。 例如，很多大的站点提供天气预报的WebSwevice、查询某网站的数据的WebService，只要发送请求，它就返回天气预报、某网站的数据，然后在客户端就能显示出来。 1.2 主要采用的四个技术1.2.1 XML可扩展的标记语言。同时采用XML Schema。正式因为WebWervice采用了XML，才使得它可以跨越各种编程语言。 1.2.2 SOAP简单对象访问协议。提供了标准的RPC（Remote Procedure Call，远程调用过程）方法来调用WebService。SOAP规范中定义了SOAP消息格式，以及怎样通过HTTP协议来使用SOAP。SOAP是基于XML语言和XSD标准的，其中XML是SOAP的数据编码方式。 1.2.3 WSDLWSDL是一种基于XML的用于描述WenService及其操作、参数和返回值的语言。因为是基于XML，一些IDE可以根据WenService来生成WSDL文档，又能通过导入WSDL文档 ，生成调用相应WebWervice的代码。 1.2.4 UDDI用于在网上自动查找WebService，一旦WebService注册到UDDI，客户就可以很方便的查找和定位所需要的WebService。 1.3 WebService模型 服务提供者：把自己的服务注册到“服务注册中心”。 服务请求者：到“服务注册中心”查找相应的服务，然后定位到“服务提供者”。 服务提供者：开始为“服务请求者”提供相应的服务。 2. 去哪里获取WebService网上有很多WebService的站点，这里选取了WebXmlu为例。 WebXml：http://www.webxml.com.cn/zh_cn/index.aspx 3. 第三方jar包准备首先如果想在Android平台上调用WebService，需要依赖第三方库ksoap2，而在Android平台上使用的是ksoap2-android-releases，一个高效、轻量级的SOAP开发包。 ksoap2-Android项目网站：https://simpligility.github.io/ksoap2-android/index.html ksoap2-android-assembly发布版本列表(包含所有可用版本jar包)：https://oss.sonatype.org/content/repositories/ksoap2-android-releases/com/google/code/ksoap2-android/ksoap2-android-assembly/ 4. 获取相关参数首先找到需要获取的服务，然后记录相关的参数：NameSpace（命名空间）、SoapAction以及URL。 比如这里查找天气的查询参数，点击去可以看到一个参数文档： 假设这里需要的是天气查询部分的功能： 这里可以拿到SoapAction和NameSpace。 这是一个测试页，可以不用填id信息，点击查询，可以看到这样一个页面： 这就是返回的XML文件，下面就需要去解析这个文件，这里的.gif表示天气的图标。 上面的查询号码归属地也是同理操作。 5. 注册 6. Demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234package com.ly.allendemowebservice;import android.annotation.SuppressLint;import android.os.Handler;import android.os.Message;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.TextView;import android.widget.Toast;import org.ksoap2.SoapEnvelope;import org.ksoap2.serialization.SoapObject;import org.ksoap2.serialization.SoapPrimitive;import org.ksoap2.serialization.SoapSerializationEnvelope;import org.ksoap2.transport.HttpTransportSE;import org.xmlpull.v1.XmlPullParserException;import java.io.IOException;import java.lang.reflect.Method;/** * WebService demo * * @author Liuyang * @date 2019/7/24 */public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private static final String TAG = "MainActivity"; private EditText mEtParam; private TextView mTvResult; private String mResult; private static final String USER_ID = "1e3c36a0f18b4da4affa98cdd26ab0b4"; /** * 定义获取手机信息的SoapAction与命名空间,作为常量 */ private static final String NAME_SPACE = "http://WebXml.com.cn/"; /** * 天气查询相关参数 */ private static final String WEATHER_URL = "http://ws.webxml.com.cn/WebServices/WeatherWS.asmx"; private static final String WEATHER_METHOD = "getWeather"; private static final String WEATHER_SOAP_ACTION = "http://WebXml.com.cn/getWeather"; /** * 号码归属地查询相关参数 */ private static final String ADDRESS_URL = "http://ws.webxml.com.cn/WebServices/MobileCodeWS.asmx"; private static final String ADDRESS_METHOD = "getMobileCodeInfo"; private static final String ADDRESS_SOAP_ACTION = "http://WebXml.com.cn/getMobileCodeInfo"; /** * 定义一个Handler用来更新页面 */ @SuppressLint("HandlerLeak") private Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case 0x001: mTvResult.setText(mResult); Toast.makeText(MainActivity.this, "获取天气信息成功", Toast.LENGTH_SHORT).show(); break; case 0x002: mTvResult.setText(mResult); Toast.makeText(MainActivity.this, "号码归属地查询成功", Toast.LENGTH_SHORT).show(); break; default: break; &#125; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); bindViews(); &#125; private void bindViews() &#123; mEtParam = findViewById(R.id.et_param); Button btnAttribution = findViewById(R.id.btn_attribution); Button btnWeather = findViewById(R.id.btn_weather); mTvResult = findViewById(R.id.tv_result); btnAttribution.setOnClickListener(this); btnWeather.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.btn_attribution: new Thread() &#123; @Override public void run() &#123; getLand(); &#125; &#125;.start(); break; case R.id.btn_weather: new Thread() &#123; @Override public void run() &#123; getWeather();// getWeather1(); &#125; &#125;.start(); break; default: break; &#125; &#125; /** * 获取某个号码的归属地信息 */ private void getLand() &#123; mResult = ""; // 根据命名空间和方法得到SoapObject对象 SoapObject soapObject = new SoapObject(NAME_SPACE, ADDRESS_METHOD); soapObject.addProperty("mobileCode", mEtParam.getText().toString()); soapObject.addProperty("userID", USER_ID); // 通过SOAP1.1协议得到envelop对象 SoapSerializationEnvelope envelope = new SoapSerializationEnvelope(SoapEnvelope.VER11); // 将soapObject对象设置为envelop对象，传出消息 envelope.bodyOut = soapObject; // 设置是否调用的是dotNet开发的WebService // 指定webservice的类型的（java，PHP，dotNet） envelope.dotNet = true; // 等价于envelop.bodyOut = soapObject; envelope.setOutputSoapObject(soapObject); HttpTransportSE httpTransportSe = new HttpTransportSE(ADDRESS_URL); Log.i(TAG, "号码服务设置完毕,准备开启服务"); // 开始调用远程方法 try &#123; // 得到远程方法返回的SOAP对象 httpTransportSe.call(ADDRESS_SOAP_ACTION, envelope); Log.i(TAG, "调用号码归属地查询WebService服务成功"); &#125; catch (IOException e) &#123; e.printStackTrace(); Log.i(TAG, "调用号码归属地查询WebService服务失败 = IOException"); &#125; catch (XmlPullParserException e) &#123; e.printStackTrace(); Log.i(TAG, "调用号码归属地查询WebService服务失败 = XmlPullParserException"); &#125; // 获取返回的数据，并开始解析 SoapObject object = (SoapObject) envelope.bodyIn; mResult = object.getProperty(0).toString(); int count = object.getPropertyCount(); Log.i(TAG, "count = " + count); for (int i = 0; i &lt; count; i++) &#123; Log.i(TAG, i + " === " + object.getProperty(i).toString()); &#125; mHandler.sendEmptyMessage(0x002); Log.i(TAG, "发送号码归属地数据完毕"); &#125; /** * 获取某个城市的天气信息，使用封装的工具类 */ private void getWeather1() &#123;// SoapNetUtils.getInstance().doSoapRequest(); &#125; /** * 获取某个城市的天气信息 */ private void getWeather() &#123; mResult = ""; // 根据命名空间和方法得到SoapObject对象 SoapObject soapObject = new SoapObject(NAME_SPACE, WEATHER_METHOD); soapObject.addProperty("theCityCode", mEtParam.getText().toString()); soapObject.addProperty("theUserID", USER_ID); // 通过SOAP1.1协议得到envelop对象 SoapSerializationEnvelope envelope = new SoapSerializationEnvelope(SoapEnvelope.VER11); // 将soapObject对象设置为envelop对象，传出消息 envelope.bodyOut = soapObject; // 设置是否调用的是dotNet开发的WebService // 指定webservice的类型的（java，PHP，dotNet） envelope.dotNet = true; // 等价于envelop.bodyOut = soapObject; envelope.setOutputSoapObject(soapObject); HttpTransportSE httpTransportSe = new HttpTransportSE(WEATHER_URL); Log.i(TAG, "天气服务设置完毕,准备开启服务"); // 开始调用远程方法 try &#123; // 得到远程方法返回的SOAP对象 httpTransportSe.call(WEATHER_SOAP_ACTION, envelope); Log.i(TAG, "调用天气查询WebService服务成功"); &#125; catch (IOException e) &#123; e.printStackTrace(); Log.i(TAG, "调用天气查询WebService服务失败 = IOException"); &#125; catch (XmlPullParserException e) &#123; e.printStackTrace(); Log.i(TAG, "调用天气查询WebService服务失败 = XmlPullParserException"); &#125; // 获取返回的数据，并开始解析，以下都通过getClass()直到数据的类型，才去进行强制类型转换的 SoapObject object = (SoapObject) envelope.bodyIn; SoapPrimitive primitive; int count = object.getPropertyCount(); for (int i = 0; i &lt; count; i++) &#123; SoapObject object1 = (SoapObject) object.getProperty(i); for (int j = 0; j &lt; object1.getPropertyCount(); j++) &#123; primitive = (SoapPrimitive) object1.getProperty(j); Log.i(TAG, "第" + j + "个数据为：" + primitive.getName() + " = " + primitive.getValue()); &#125; &#125; primitive = (SoapPrimitive) ((SoapObject) object.getProperty(0)).getProperty(37); mResult = (String) primitive.getValue(); mHandler.sendEmptyMessage(0x001); Log.i(TAG, "发送天气数据完毕"); &#125;&#125; Demo地址：Allen_Demo_WebService]]></content>
      <categories>
        <category>Android</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>WebService</tag>
      </tags>
  </entry>
</search>
