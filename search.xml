<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android RxJava：入门]]></title>
    <url>%2F2019%2F08%2F12%2FAndroid-RxJava%EF%BC%9A%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[前言RxJava是基于事件流的链式调用、逻辑简单且使用简单。 GitHub链接： RxJava RxAndroid 基于RxJava 2.0 在xJava 1.0上增加了一些新特性，基本原理和使用基本相同 后面还会介绍原理、操作符、应用场景、背压等 1. 定义在GitHub上的介绍： RxJava – Reactive Extensions for the JVM – a library for composing asynchronous and event-based programs using observable sequences for the Java VM.一个在Java JVM上使用可观测的序列来组成异步的、基于事件的程度的库。 总结：RxJava是基于事件流、实现异步操作的库 2. 作用实现异步操作，类似Andorid中的AsyncTask、Handler的作用。 3. 特点由于RxJava的使用方式是基于事件流的链式调用，所以RxJava： 逻辑简洁 实现优雅 使用简单 4. 原理顾客到饭店点菜吃饭： RxJava原理基于一种扩展的观察者模式，其中包含四个角色： 角色 作用 类比 被观察者Observable 产生事件 顾客 观察者Observer 接收事件并给出响应动作 厨房 订阅Subscribe 连接被观察者和观察者 服务员 事件Event 被观察者和观察者沟通的载体 菜式 总结：被观察者Observable通过订阅Subscribe按顺序发送事件Event给观察者Observer，观察者Observer按顺序接收事件并作出对应的响应。 5. 基本使用使用方式有两种： 分步骤实现：该方法主要是为了深入说明RxJava的原理和使用，用于演示 基于事件流的链式调用，用于实际开发 5.1 分步骤实现5.1.1 使用步骤 创建被观察者Observable并生产事件，对应顾客进入饭店-坐下-点菜 创建观察者Observer并定义响应事件的行为，即厨房确定对应菜式 通过订阅Subscribe连接观察者和被观察者，即顾客找到服务员-服务员下单到厨房-厨房烹制 5.1.2 步骤详解步骤1：创建被观察者Observable并生产事件]]></content>
      <categories>
        <category>Android</category>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Jetpack-WorkManager]]></title>
    <url>%2F2019%2F08%2F09%2FAndroid-Jetpack-WorkManager%2F</url>
    <content type="text"><![CDATA[这里的数据不是从网络请求获取的，而是从assets目录下的json读取出来的，通常，从文件读取数据不会放在主线程中执行，这里使用了WorkManager，使能够在后台线程进行数据初始化。 1. 介绍官方文档：WorkMangerWorkManger介绍视频：中文官方介绍视频 1.1 定义官方介绍： The WorkManager API makes it easy to schedule deferrable, asynchronous tasks that are expected to run even if the app exits or device restarts.直译：WorkManager API使调度可延迟的异步任务变得很容易，即使应用程序退出或设备重启，这些任务也会运行。 1.2 选择WorkManager的理由Android中处理后台任务的选择很多，如Service、DownloadManager、AlarmManager、JobScheduler等， 为什么还要有WorkManager？ 兼容性更强，可以兼容到API 14 可以指定约束条件，比如可以选择必须在有网络的条件下执行 可以定时执行，也可以单次执行 监听和管理任务状态 多个任务可以使用任务链 保证任务执行，如当前执行条件不满足或者APP进程被杀死，它会等到下次条件满足或者APP进行打开后执行 支持省电模式 1.3 多线程任务如何选择？后台任务会消耗设备的系统资源，若处理不当，可能会造成设备电量的消耗，给用户带来不好的体验。所以，选择正确的后台处理方式很重要，下面是官方给出的选择方式： 关于后台的的知识，需要补充阅读：[译]从Service到WorkManager。 2. Demo实现：选取一张图片，做模糊处理，然后显示在头像上。 2.1 添加依赖1implementation "androidx.work:work-runtime-ktx:2.2.0-rc01" 2.2 自定义Worker自定义worker之前，先看看WorkerManager中几个重要的类： Worker：需要继承Worker，并复写doWork()方法，在里面写入需要在后台执行的代码 WorkRequest：指后台工作的请求，可以在后台工作的请求中添加约束条件 WorkManager：真正让Worker在后台执行的类 WorkerManager的执行流程： WorkRequest生成以后，Internal TaskExecutor将它存入WorkManager的数据库中，这也是为什么即使在程序退出之后，WorkManager也能保证后台任务在下次启动后条件满足的情况下执行。 当约束条件满足的情况下，Internal TaskExecutor告诉WorkFactory生成Worker。 后台执行Worker任务。 下面自定义一个Worker，目标是生成一张模糊图片，包含：清除之前的缓存路径，、图片模糊处理和图片的生成。将这三个步骤分成三个后台任务，三个后台任务分别涉及到无变量的情况、往外传参数和读取参数三种情况。 2.2.1 清除缓存路径：无变量情况（通常情况）12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 清理临时文件的Worker * * @author Liuyang * @date 2019/8/9 */class CleanUpWorker(context: Context, params: WorkerParameters) : Worker(context, params) &#123; private val TAG by lazy &#123; this::class.java.simpleName &#125; override fun doWork(): Result &#123; // Makes a notification when the work starts and slows down the work so that // it's easier to see each WorkRequest start, even on emulated devices makeStatusNotification("Cleaning up old temporary files", applicationContext) // sleep() return try &#123; // 删除逻辑 val outputDir = File(applicationContext.filesDir, BaseConstant.OUTPUT_PATH) if (outputDir.exists()) &#123; val entries = outputDir.listFiles() if (entries != null) &#123; for (entry in entries) &#123; val name = entry.name if (name.isNotEmpty() &amp;&amp; name.endsWith(".png")) &#123; val deleted = entry.delete() Log.i(TAG, String.format("Deleted %s - %s", name, deleted)) &#125; &#125; &#125; &#125; // 成功 Result.success() &#125; catch (exception: Exception) &#123; Log.e(TAG, "Error cleaning up", exception) // 失败 Result.failure() &#125; &#125;&#125; 2.2.2 图片模糊处理：往外传参数（输出参数）123456789101112131415161718192021222324252627282930313233343536373839/** * 模糊处理的worker * * @author Liuyang * @date 2019/8/11 */class BlurWorker(context: Context, params: WorkerParameters) : Worker(context, params) &#123; private var TAG: String = this::class.java.simpleName override fun doWork(): Result &#123; val context = applicationContext val resultUri = inputData.getString(BaseConstant.KEY_IMAGE_URI) // 通知开始处理图片 makeStatusNotification("Blurring image", context) return try &#123; // 图片处理逻辑 if (TextUtils.isEmpty(resultUri)) &#123; Log.e(TAG, "Invalid input uri") throw IllegalArgumentException("Invalid input uri") &#125; val resolver = context.contentResolver val picture = BitmapFactory.decodeStream(resolver.openInputStream(Uri.parse(resultUri))) // 创建Bitmap文件 val output = blurBitmap(picture, context) // 存入路径 val outputUri = writeBitmapToFile(context, output) // 输出路径 val outputData = workDataOf(BaseConstant.KEY_IMAGE_URI to outputUri.toString()) makeStatusNotification("Output is $outputUri", context) Result.success(outputData) &#125; catch (throwable: Throwable) &#123; Log.e(TAG, "Error applying blur", throwable) Result.failure() &#125; &#125;&#125; 2.2.3 图片生成：读取参数1234567891011121314151617181920212223242526272829303132333435363738394041/** * 存储照片的worker * * @author Liuyang * @date 2019/8/11 */class SaveImageToFileWorker(context: Context, parameters: WorkerParameters) : Worker(context, parameters) &#123; private val TAG by lazy &#123; SaveImageToFileWorker::class.java.simpleName &#125; private val title = "Blurred Image" private val dateFormatter = SimpleDateFormat("yyyy.MM.dd 'at' HH:mm:ss z", Locale.getDefault()) override fun doWork(): Result &#123; // Makes a notification when the work starts and slows down the work so that // it's easier to see each WorkRequest start, even on emulated devices makeStatusNotification("Saving image", applicationContext) // sleep() val resolver = applicationContext.contentResolver return try &#123; // 获取从外部传入的参数 val resourceUri = inputData.getString(BaseConstant.KEY_IMAGE_URI) val bitmap = BitmapFactory.decodeStream(resolver.openInputStream(Uri.parse(resourceUri))) val imageUrl = MediaStore.Images.Media.insertImage(resolver, bitmap, title, dateFormatter.format(Date())) if (!imageUrl.isNullOrEmpty()) &#123; val output = workDataOf(BaseConstant.KEY_IMAGE_URI to imageUrl) Result.success() &#125; else &#123; Log.e(TAG, "Writing to MediaStore failed") Result.failure() &#125; &#125; catch (exception: Exception) &#123; Log.e(TAG, "Unable to save image to Gallery", exception) Result.failure() &#125; &#125;&#125; 2.3 创建WorkManager在model中单例获取： 123class MeModel(private val userRepository: UserRepository) : ViewModel() &#123; private val workManager = WorkManager.getInstance()&#125; 2.4 构建WorkRequestWorkRequest可以分为两类： PeriodicWorkRequest：Periodic，周期；多次、定时执行任务请求，不支持任务链 OneTimeWorkRequest：只执行一次的任务请求，支持任务链 执行一个任务以OneTimeWorkRequest为例，如果只有一个任务请求： 12val request = OneTimeWorkRequest.from(CleanUpWorker::class.java)workManager.enqueue(request) 执行多个任务例子中有三个Worker，并且里面有先后执行的顺序，所以可以使用任务链： 12345678// 多任务按顺序执行workManager.beginWith( mutableListOf( OneTimeWorkRequest.from(CleanUpWorker::class.java) )) .then(OneTimeWorkRequestBuilder&lt;BlurWorker&gt;().setInputData(createInputDataForUri()).build()) .then(OneTimeWorkRequestBuilder&lt;SaveImageToFileWorker&gt;().build()) .enqueue() 假设多次点击图片更换头像，提交多次请求，由于网络原因（Demo中没有网络请求部分），最后返回的很可能不是最后一次请求的图片，这显然是有问题的，WorkManager可能满足这样的需求，保证任务的唯一性： 12345678910// 多任务按顺序执行workManager.beginUniqueWork( IMAGE_MANIPULATION_WORK_NAME, // 任务名称 ExistingWorkPolicy.REPLACE, // 任务相同的执行策略 分为REPLACE，KEEP，APPEND mutableListOf( OneTimeWorkRequest.from(CleanUpWorker::class.java) )) .then(OneTimeWorkRequestBuilder&lt;BlurWorker&gt;().setInputData(createInputDataForUri()).build()) .then(OneTimeWorkRequestBuilder&lt;SaveImageToFileWorker&gt;().build()) .enqueue() 无顺序多任务 如果并行执行没有顺序的多个任务，无论是beginUniqueWork还是beginWith方法都可以接收一个List&lt;OneTimeWorkRequest&gt;。 使用约束假设需要将生成的图片上传到服务器，并且需要将图片同时保存到本地，这是就需要设备联网并且由足够的存储空间，这时，就可以给WorkRequest指明约束条件：12345678910111213// 构建约束条件val constraints = Constraints.Builder() .setRequiresBatteryNotLow(true)// 非电池低电量 .setRequiredNetworkType(NetworkType.CONNECTED)// 网络连接的情况 .setRequiresStorageNotLow(true)// 存储空间充足 .build()// 存储照片val save = OneTimeWorkRequestBuilder&lt;SaveImageToFileWorker&gt;() .setConstraints(constraints) .addTag(BaseConstant.TAG_OUTPUT) .build()continuation = continuation.then(save) 可以指明的约束条件有：电池电量、充电、网络、存储和延迟等。 下面是Demo中的具体使用： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class MeModel(private val userRepository: UserRepository) : ViewModel() &#123; private var imageUri: Uri? = null private var outPutUri: Uri? = null var outPutWorkInfo: LiveData&lt;List&lt;WorkInfo&gt;&gt; private val workManager = WorkManager.getInstance() val use = userRepository.findUserById(AppPrefsUtils.getLong(BaseConstant.SP_USER_ID)) init &#123; outPutWorkInfo = workManager.getWorkInfosByTagLiveData(BaseConstant.TAG_OUTPUT) &#125; internal fun applyBlur(blurLevel: Int) &#123; var continuation = workManager.beginUniqueWork( BaseConstant.IMAGE_MANIPULATION_WORK_NAME, ExistingWorkPolicy.REPLACE, OneTimeWorkRequest.from(CleanUpWorker::class.java) ) for (i in 0 until blurLevel) &#123; val builder = OneTimeWorkRequestBuilder&lt;BlurWorker&gt;() if (i == 0) &#123; builder.setInputData(createInputDataForUri()) &#125; continuation = continuation.then(builder.build()) &#125; // 构建约束条件 val constraints = Constraints.Builder() .setRequiresBatteryNotLow(true)// 非电池低电量 .setRequiredNetworkType(NetworkType.CONNECTED)// 网络连接的情况 .setRequiresStorageNotLow(true)// 存储空间充足 .build() // 存储照片 val save = OneTimeWorkRequestBuilder&lt;SaveImageToFileWorker&gt;() .setConstraints(constraints) .addTag(BaseConstant.TAG_OUTPUT) .build() continuation = continuation.then(save) continuation.enqueue() &#125; private fun createInputDataForUri(): Data &#123; val builder = Data.Builder() imageUri?.let &#123; builder.putString(BaseConstant.KEY_IMAGE_URI, imageUri.toString()) &#125; return builder.build() &#125; private fun uriOrNull(uriString: String?): Uri? &#123; return if (!uriString.isNullOrEmpty()) &#123; Uri.parse(uriString) &#125; else null &#125; internal fun setImageUri(uri: String?) &#123; imageUri = uriOrNull(uri) &#125; internal fun setOutputUri(uri: String?) &#123; outPutUri = uriOrNull(uri) val value = use.value value?.headImage = uri!! if (value != null) &#123; viewModelScope.launch &#123; userRepository.updateUser(value) &#125; &#125; &#125; fun cancelWork() &#123; workManager.cancelUniqueWork(BaseConstant.IMAGE_MANIPULATION_WORK_NAME) &#125;&#125; 2.5 取消任务如果要取消任务workManager.cancelAllWork()，如果要取消上面执行的唯一任务，需要上面唯一的任务名： 123fun cancelWork() &#123; workManager.cancelUniqueWork(BaseConstant.IMAGE_MANIPULATION_WORK_NAME)&#125; 2.6 观察任务状态任务状态的变化过程： 其中，SUCCESS、FAILED、CALCELLED都属于任务已经完成。观察任务状态需要使用到LiveData： 1234567891011class MeModel(private val userRepository: UserRepository) : ViewModel() &#123; private var imageUri: Uri? = null private var outPutUri: Uri? = null var outPutWorkInfo: LiveData&lt;List&lt;WorkInfo&gt;&gt; private val workManager = WorkManager.getInstance() val use = userRepository.findUserById(AppPrefsUtils.getLong(BaseConstant.SP_USER_ID)) init &#123; outPutWorkInfo = workManager.getWorkInfosByTagLiveData(BaseConstant.TAG_OUTPUT) &#125;&#125; 当图片处理时，程序弹出加载框，图片处理完成，程序会将图片路径保存到User里的headImage并存储到数据库中，任务状态观测参见MeFragment中的onSubscribeUi()中： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107/** * 我的界面 * * @author Liuyang * @date 2019/8/11 */class MeFragment : Fragment() &#123; private val TAG by lazy &#123; MeFragment::class.java.simpleName &#125; // Model懒加载 private val meModel: MeModel by viewModels &#123; CustomViewModelProvider.providerMeModel(requireContext()) &#125; // 选择图片的标识 private val REQUEST_CODE_IMAGE = 100 // 加载框 private val sweetAlertDialog: SweetAlertDialog by lazy &#123; SweetAlertDialog(requireContext(), SweetAlertDialog.PROGRESS_TYPE) .setTitleText(&quot;头像&quot;) .setContentText(&quot;更新中......&quot;)// .setCancelButton(&quot;取消&quot;) &#123;// meModel.cancelWork()// sweetAlertDialog.dismiss()// &#125; &#125; override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? &#123; val binding: FragmentMeBinding = FragmentMeBinding.inflate(inflater, container, false) initListener(binding) onSubscribeUi(binding) return binding.root &#125; /** * 初始化监听器 */ private fun initListener(binding: FragmentMeBinding) &#123; binding.ivHead.setOnClickListener &#123; // 选择处理的图片 val chooseIntent = Intent(Intent.ACTION_PICK, MediaStore.Images.Media.EXTERNAL_CONTENT_URI) startActivityForResult(chooseIntent, REQUEST_CODE_IMAGE) &#125; &#125; /** * binding绑定 */ private fun onSubscribeUi(binding: FragmentMeBinding) &#123; meModel.use.observe(this, Observer &#123; binding.user = it &#125;) // 任务状态的监测 meModel.outPutWorkInfo.observe(this, Observer &#123; if (it.isNullOrEmpty()) return@Observer val state = it[0] if (state.state.isFinished) &#123; // 更新头像 val outputImageUri = state.outputData.getString(BaseConstant.KEY_IMAGE_URI) if (!outputImageUri.isNullOrEmpty()) &#123; meModel.setOutputUri(outputImageUri) &#125; sweetAlertDialog.dismiss() &#125; &#125;) &#125; /** * 图片选择完成的回调 */ override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) &#123; if (resultCode == Activity.RESULT_OK) &#123; when (requestCode) &#123; REQUEST_CODE_IMAGE -&gt; data?.let &#123; handleImageRequestResult(data) &#125; else -&gt; Log.d(TAG, &quot;Unknown request code.&quot;) &#125; &#125; else &#123; Log.e(TAG, String.format(&quot;Unexpected Result code %s&quot;, resultCode)) &#125; &#125; /** * 图片处理 */ private fun handleImageRequestResult(data: Intent) &#123; val imageUri: Uri? = data.clipData?.let &#123; it.getItemAt(0).uri &#125; ?: data.data if (imageUri == null) &#123; Log.e(TAG, &quot;Invalid input image Uri.&quot;) return &#125; sweetAlertDialog.dismiss() // 图片模糊处理 meModel.setImageUri(imageUri.toString()) meModel.applyBlur(3) &#125;&#125; 3. 其他选择适合的Worker 谷歌提供了四种Worker： 自动运行在后台线程的Worker 结合协程的CoroutineWorker 结合RxJava的RxWorker 以上三个类的基类ListenableWorker 这里以CoroutineWorker为例，简单介绍，使用ShoeWorker从文中读取鞋子的数据并完成数据库的插入工作： 1234567891011121314151617181920212223242526272829303132333435class ShoeWorker(context: Context, workerParameters: WorkerParameters) : CoroutineWorker(context, workerParameters) &#123; private val TAG by lazy &#123; ShoeWorker::class.java.simpleName &#125; // 指定Dispatchers override val coroutineContext: CoroutineDispatcher get() = Dispatchers.IO override suspend fun doWork(): Result = coroutineScope &#123; try &#123; applicationContext.assets.open("shoes.json").use &#123; JsonReader(it.reader()).use &#123; val shoeType = object : TypeToken&lt;List&lt;Shoe&gt;&gt;() &#123;&#125;.type val shoeList: List&lt;Shoe&gt; = Gson().fromJson(it, shoeType) val shoeDao = RepositoryProvider.providerShoeRepository(applicationContext) shoeDao.insertShoes(shoeList) for (i in 0..2) &#123; for (shoe in shoeList) &#123; shoe.id += shoeList.size &#125; shoeDao.insertShoes(shoeList) &#125; Result.success() &#125; &#125; &#125; catch (e: Exception) &#123; Log.e(TAG, "Error seeding database", e) Result.failure() &#125; &#125;&#125; 延伸：Android Jetpack - 使用 WorkManager 管理后台任务]]></content>
      <categories>
        <category>Android</category>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>Jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你的儿女]]></title>
    <url>%2F2019%2F08%2F08%2F%E4%BD%A0%E7%9A%84%E5%84%BF%E5%A5%B3%2F</url>
    <content type="text"><![CDATA[你的儿女———— 纪伯伦（Khalil Gibran）Your children are not your children.你的子女，其实不是你的子女。 They are the sons and daughters of Life’s longing for itself.他们是生命对于自身渴望而诞生的孩子。 They come through you but not from you,他们借助你来到这个世界，却非因你而来， And though they are with you, yet they belong not to you.他们陪伴你，却并不属于你。 You may give them your love but not your thoughts,你可以给予他们你的爱，却不是你的想法， For they have their own thoughts.因为他们有自己的思想。 You may house their bodies but not their souls,你可以庇护的是他们的身体，却不是他们的灵魂， For their souls dwell in the house of tomorrow, which you cannot visit, not even in your dreams.因为他们的灵魂属于明天，属于你在梦境中也无法达到的明天。 You may strive to be like them, but seek not to make them like you,你可以拼尽全力，变得像他们一样，却不要让他们变得和你一样， For life goes not backward nor tarries with yesterday.因为生命不会后退，也不在过去停留。 You are the bows from which your children as living arrows are sent forth.你是弓，儿女是从你那里射出的箭。 The archer sees the mark upon the path of the infinite,弓箭手遥望未来之路上的箭靶， and He bends you with His might that His arrows may go swift and far.用尽力气将你拉开，使箭射得又快又远。 Let your bending in the archer’s hand be for gladness,怀着快乐的心情，在弓箭手的手中弯曲吧， For even as he loves the arrow that flies, so He loves also the bow that is stable.因为他爱一路飞翔的箭，也爱无比稳定的弓。]]></content>
      <categories>
        <category>美文</category>
      </categories>
      <tags>
        <tag>美文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Jetpack-Paging]]></title>
    <url>%2F2019%2F08%2F05%2FAndroid-Jetpack-Paging%2F</url>
    <content type="text"><![CDATA[在遇到RecyclerView加载大量数据的情况，如果是在数据库请求，需要消耗数据库资源并且需要花费较多的时间，同意，如果是发送网络请求，则需要消耗宽带和更多的时间，无论哪种情形，对于用户的体验都是糟糕的。这时，可以采用分段加载来缩短时间，给带来良好的体验，目前，对于加载大量数据的处理方式有两种： 借助刷新控件来实现用户手动请求数据 数据达到边界自动请求加载 谷歌的Android Jetpack也实现了自己的分页库——Paging。 1. 介绍官方文档：Paging官方Demo：网络方式，数据库方式 官方介绍： The Paging Library helps you load and display small chunks of data at a time. Loading partial data on demand reduces usage of network bandwidth and system resources.直译：分页库帮助您每次加载和显示小块数据。按需加载部分数据会减少网络带宽和系统资源的使用。 Paging架构： PagedList：一个可以以分页形式异步加载数据的容器，可以跟RecyclerView结合 DataSource或DataSource.Factory：数据源，DataSource将数据转变成PagedList，DataSource.Factory则用来创建DataSource LivePagedListBuilder：用来生成LiveData&lt;PagedList&gt;，需要DataSource.Factory参数 BoundaryCallback：数据达到边界的回调 PagedListAdapter：一种RecyclerView适配器 优点： RxJava以及Android Jetpack的支持，如LiveData、Room等 自定义分页策略 异步处理数据 结合RecyclerView等 2. Demo2.1 添加依赖：1234dependencies &#123; // paging implementation "androidx.paging:paging-runtime:2.1.0"&#125; 2.2 创建数据源 非Room数据库如果没有使用Room数据库，就需要自定义实现DataSource，通常实现DataSource有三种方式，分别继承三种抽象类，它们分别是： 名称 使用场景 PageKeyedDataSource&lt;Key, Value&gt; 分页请求数据的场景 ItemKeyedDataSource&lt;Key, Value&gt; 以表的某个列为Key，加载其后的N个数据 PositionalDataSource&lt;T&gt; 当数据源总数特定，根据指定位置请求数据的场景 这里以PageKeyedDataSource&lt;Key, Value&gt;为例，虽然这里的数据库使用的是Room，但查询数据以返回List代表着通常数据库的使用方式： 12345package com.ly.allendemojetpack.db.repositoryclass ShoeRepository private constructor(private val shoeDao: ShoeDao) &#123; fun getPageShoes(startIndex: Long, endIndex: Long): List&lt;Shoe&gt; = shoeDao.findShoesByIndexRange(startIndex, endIndex)&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.ly.allendemojetpack.db.datasourceimport android.util.Logimport androidx.paging.PageKeyedDataSourceimport com.ly.allendemojetpack.common.BaseConstantimport com.ly.allendemojetpack.db.data.Shoeimport com.ly.allendemojetpack.db.repository.ShoeRepository/** * 自定义PageKeyedDataSource * 演示Paging库的使用 */class CustomPageDataSource(private val shoeRepository: ShoeRepository) : PageKeyedDataSource&lt;Int, Shoe&gt;() &#123; private val TAG: String by lazy &#123; this::class.java.simpleName &#125; /** * 第一次加载时调用 */ override fun loadInitial(params: LoadInitialParams&lt;Int&gt;, callback: LoadInitialCallback&lt;Int, Shoe&gt;) &#123; val startIndex = 0L val endIndex: Long = 0L + params.requestedLoadSize val shoe = shoeRepository.getPageShoes(startIndex, endIndex) callback.onResult(shoe, null, 2) &#125; /** * 每次分页加载时调用 */ override fun loadAfter(params: LoadParams&lt;Int&gt;, callback: LoadCallback&lt;Int, Shoe&gt;) &#123; Log.e(TAG, "startPage:$&#123;params.key&#125;, size:$&#123;params.requestedLoadSize&#125;") val startPage = params.key val startIndex = ((startPage - 1) * BaseConstant.SINGLE_PAGE_SIZE).toLong() + 1 val endIndex = startIndex + params.requestedLoadSize - 1 val shoes = shoeRepository.getPageShoes(startIndex, endIndex) callback.onResult(shoes, params.key + 1) &#125; override fun loadBefore(params: LoadParams&lt;Int&gt;, callback: LoadCallback&lt;Int, Shoe&gt;) &#123; Log.e(TAG, "endPage:$&#123;params.key&#125;, size:$&#123;params.requestedLoadSize&#125;") val endPage = params.key val endIndex = ((endPage - 1) * BaseConstant.SINGLE_PAGE_SIZE).toLong() + 1 var startIndex = endIndex - params.requestedLoadSize startIndex = if (startIndex &lt; 0) &#123; 0L &#125; else &#123; startIndex &#125; val shoe = shoeRepository.getPageShoes(startIndex, endIndex) callback.onResult(shoe, params.key + 1) &#125;&#125; DataSource创建好了，再创建一个DataSource.Factory，返回对应的DataSource实例： 1234567891011121314package com.ly.allendemojetpack.db.datasourceimport androidx.paging.DataSourceimport com.ly.allendemojetpack.db.data.Shoeimport com.ly.allendemojetpack.db.repository.ShoeRepository/** * 构建CustomPageDataSource的工厂类 */class CustomPageDataSourceFactory(private val shoeRepository: ShoeRepository) : DataSource.Factory&lt;Int, Shoe&gt;() &#123; override fun create(): DataSource&lt;Int, Shoe&gt; &#123; return CustomPageDataSource(shoeRepository) &#125;&#125; Room数据库如果使用Room与Paging结合使用，可以直接在Room的Dao层使用：12345@Daointerface ShoeDao &#123; @Query("SELECT * FROM shoe") fun getAllShoesLD(): DataSource.Factory&lt;Int, Shoe&gt;&#125; 使用起来简单很多。 2.3 构建LiveData &lt;PagedList&gt;要想获得LiveData&lt;PagedList&gt;，需要先创建LivePagedListBuilder，LivePagedListbuilder有设分页数量和配置参数两种构造方法，设置分页数量比较简单，直接查看API即可，下面看看配置参数使用： 123456789101112class ShoeModel constructor(repository: ShoeRepository) : ViewModel() &#123; /** * 鞋子集合的观察类 */ val shoes: LiveData&lt;PagedList&lt;Shoe&gt;&gt; = LivePagedListBuilder&lt;Int, Shoe&gt;( CustomPageDataSourceFactory(repository), PagedList.Config.Builder() .setPageSize(10) .setEnablePlaceholders(false) .setInitialLoadSizeHint(10) .build() ).build() 2.4 创建PagedListAdapterPagedListAdapter是一个特殊的RecyclerView的RecyclerAdapter，使用方法类似，这里使用Data Binding： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.ly.allendemojetpack.ui.adapterimport android.content.Contextimport android.content.Intentimport android.view.LayoutInflaterimport android.view.Viewimport android.view.ViewGroupimport androidx.paging.PagedListAdapterimport androidx.recyclerview.widget.RecyclerViewimport com.ly.allendemojetpack.common.BaseConstantimport com.ly.allendemojetpack.databinding.ItemShoeBindingimport com.ly.allendemojetpack.db.data.Shoeimport com.ly.allendemojetpack.ui.activity.DetailActivity/** * 鞋子的适配器，配合Data Binding使用 * * @author Liuyang * @date 2019/8/3 */class ShoeAdapter constructor(val context: Context) : PagedListAdapter&lt;Shoe, ShoeAdapter.ViewHolder&gt;(ShoeDiffCallback()) &#123; override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder &#123; return ViewHolder(ItemShoeBinding.inflate(LayoutInflater.from(parent.context), parent, false)) &#125; override fun onBindViewHolder(holder: ViewHolder, position: Int) &#123; val shoe = getItem(position) holder.apply &#123; bind(onCreateListener(shoe!!.id), shoe) itemView.tag = shoe &#125; &#125; /** * Holder的点击事件 */ private fun onCreateListener(id: Long): View.OnClickListener &#123; return View.OnClickListener &#123; val intent = Intent(context, DetailActivity::class.java) intent.putExtra(BaseConstant.DETAIL_SHOE_ID, id) context.startActivity(intent) &#125; &#125; class ViewHolder(private val binding: ItemShoeBinding) : RecyclerView.ViewHolder(binding.root) &#123; fun bind(listener: View.OnClickListener, item: Shoe) &#123; binding.apply &#123; this.listener = listener this.shoe = item executePendingBindings() &#125; &#125; &#125;&#125; 1234567891011121314package com.ly.allendemojetpack.ui.adapterimport androidx.recyclerview.widget.DiffUtilimport com.ly.allendemojetpack.db.data.Shoeclass ShoeDiffCallback : DiffUtil.ItemCallback&lt;Shoe&gt;() &#123; override fun areItemsTheSame(oldItem: Shoe, newItem: Shoe): Boolean &#123; return oldItem.id == newItem.id &#125; override fun areContentsTheSame(oldItem: Shoe, newItem: Shoe): Boolean &#123; return oldItem == newItem &#125;&#125; 2.5 监听数据同样使用Data Binding，ShoeFragment： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.ly.allendemojetpack.ui.fragment.mainimport android.os.Bundleimport android.view.LayoutInflaterimport android.view.Viewimport android.view.ViewGroupimport androidx.fragment.app.Fragmentimport androidx.fragment.app.viewModelsimport androidx.lifecycle.Observerimport androidx.lifecycle.ViewModelProvidersimport com.ly.allendemojetpack.databinding.FragmentShoeBindingimport com.ly.allendemojetpack.ui.adapter.ShoeAdapterimport com.ly.allendemojetpack.viewmodel.CustomViewModelProviderimport com.ly.allendemojetpack.viewmodel.ShoeModel/** * 鞋子的Fragment * * @author Liuyang * @date 2019/8/3 */class ShoeFragment : Fragment() &#123; // by viewModels 需要依赖 "androidx.navigation:navigation-ui-ktx:$rootProject.navigationVersion" private val viewModel: ShoeModel by viewModels &#123; CustomViewModelProvider.providerShoeModel(requireContext()) &#125; override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? &#123; val binding: FragmentShoeBinding = FragmentShoeBinding.inflate(inflater, container, false) context ?: return binding.root // 适配器 val adapter = ShoeAdapter(context!!) binding.recycler.adapter = adapter onSubscribeUi(adapter) return binding.root &#125; /** * 鞋子数据更新的通知 */ private fun onSubscribeUi(adapter: ShoeAdapter) &#123; viewModel.shoes.observe(viewLifecycleOwner, Observer &#123; if (it != null) &#123; adapter.submitList(it) &#125; &#125;) &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>Jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Jetpack-Room]]></title>
    <url>%2F2019%2F08%2F05%2FAndroid-Jetpack-Room%2F</url>
    <content type="text"><![CDATA[1. 介绍官方网址：Room 官方介绍： The Room persistence library provides an abstraction layer over SQLite to allow for more robust database access while harnessing the full power of SQLite. 简单来说，Room是一个基于SQLite的强大数据库框架。 优点： 使用编译时注解，能够对@Query和@Entity里面的SQL语句进行验证 与SQL语句的使用更加贴近，能够降低学习成本 对RxJava2支持，对LiveData支持 @Embedded能减少表的创建 2. Demo目标结构： 三张表：用户表、鞋表和收藏记录表，用户表和鞋表存在多对多的关系。 2.1 步骤1：添加依赖在model的build.gradel添加： 1234567891011apply plugin: 'kotlin-kapt'dependencies &#123; ...... // room implementation "androidx.room:room-runtime:2.2.0-alpha01" implementation "androidx.room:room-ktx:2.2.0-alpha01" kapt "androidx.room:room-compiler:2.2.0-alpha01" androidTestImplementation "androidx.room:room-testing:2.2.0-alpha01"&#125; 2.2 步骤2：创建表（实体）用户表： 1234567891011121314151617181920212223package com.ly.allendemojetpack.db.dataimport android.location.Addressimport androidx.room.*/** * 用户表 * * @author Liuyang * @date 2019/8/3 */@Entity(tableName = "user")data class User( @ColumnInfo(name = "user_account") val account: String,// 账号 @ColumnInfo(name = "user_pwd") val pwd: String,// 摩玛 @ColumnInfo(name = "user_name") val name: String, @Embedded val address: Address,// 地址 @Ignore val state: Int) &#123; @PrimaryKey(autoGenerate = true) @ColumnInfo(name = "id") var id: Long = 0&#125; 收藏记录表： 12345678910111213141516171819202122232425262728package com.ly.allendemojetpack.db.dataimport androidx.room.ColumnInfoimport androidx.room.Entityimport androidx.room.ForeignKeyimport androidx.room.PrimaryKeyimport java.util.*/** * 喜欢的鞋 表 * * @author Liuyang * @date 2019/8/3 */@Entity( tableName = "fav_shoe", foreignKeys = [ForeignKey(entity = Shoe::class, parentColumns = ["id"], childColumns = ["shoe_id"]), ForeignKey(entity = User::class, parentColumns = ["id"], childColumns = ["user_id"])])data class FavouriteShoe( @ColumnInfo(name = "shoe_id") val shoeId: Long,// 外键 鞋子的id @ColumnInfo(name = "user_id") val userId: Long,// 外键 用户的id @ColumnInfo(name = "fav_date") val date: Date// 创建日期) &#123; @PrimaryKey(autoGenerate = true) @ColumnInfo(name = "id") var id: Long = 0&#125; 对于其中注解的解释： @Entity：声明这是一个表（实体），主要参数：tableName表名、foreignKeys外键、indices索引 ColumnInfo：主要用来修改在数据库中的字段名 PrimaryKey：声明该字段为主键，可以声明是否自动创建 Ignore：声明某个字段只是临时用，不存储在数据库中 Embedded：用于嵌套，里面的字段同样会存储在数据库中 最后一个，在User表中有一个变量address，它是一个Address类： 12345678package com.ly.allendemojetpack.db.data/** * 地址 */data class Address( val street: String, val state: String, val city: String, val postCode: String) 通常，如果想这些字段存储在数据库中，有两种方法： 重新创建一个表，进行一对一的关联，但是多创建一个表显得麻烦 在用户表中增加字段，但是这样映射出来的对象显得 不面向对象 @Embedded就是为了解决上面你的第2个问题，即不多创建一个表，又能将数据库中映射的对象看上去面向对象。 Shoe表： 123456789101112131415161718192021222324package com.ly.allendemojetpack.db.dataimport androidx.room.ColumnInfoimport androidx.room.Entityimport androidx.room.PrimaryKey/** * 鞋子表 * * @author Liuyang * @date 2019/8/3 */@Entity(tableName = "shoe")data class Shoe( @ColumnInfo(name = "shoe_name") val name: String, @ColumnInfo(name = "shoe_description") val description: String, @ColumnInfo(name = "shoe_price") val price: Float, @ColumnInfo(name = "shoe_brand") val brand: String, @ColumnInfo(name = "shoe_imgUrl") val imgUrl: String) &#123; @PrimaryKey(autoGenerate = true) @ColumnInfo(name = "id") var id: Long = 0&#125; 2.3 步骤3：创建Dao数据处理的方法，就是数据的增删改查。在抽象类或接口加一个@Dao注解即可。 2.3.1 增@Insert注解，声明当前的方法为新增的方法，并且可以设置当新增冲突的时候处理的方法。 1234567891011121314151617181920212223242526272829303132333435363738/** * 鞋子表的方法 * * @author Liuyang * @date 2019/8/3 */@Daointerface ShoeDao &#123; /** * 选择所有的鞋 */ @Query("SELECT * FROM shoe") fun getAllShoes(): LiveData&lt;List&lt;Shoe&gt;&gt; /** * 通过id查找鞋子 */ @Query("SELECT * FROM shoe WHERE id = :id") fun findShoeById(id: Long): LiveData&lt;Shoe&gt; /** * 通过品牌找鞋子 */ @Query("SELECT * FROM shoe WHERE shoe_brand = :brand") fun findShoeByBrand(brand: String): LiveData&lt;List&lt;Shoe&gt;&gt; /** * 插入一种鞋子 */ @Insert(onConflict = OnConflictStrategy.REPLACE) fun insertShoe(shoe: Shoe) /** * 插入多种鞋子 */ @Insert(onConflict = OnConflictStrategy.REPLACE) fun insertShoe(shoes: List&lt;Shoe&gt;)&#125; 2.3.2 删@Delete注解，声明当前的方法是一个删除方法。 2.3.3 改@Update注解，声明当前方法是一个更新方法 2.3.4 查@Query注解，不仅可以声明这是一个查询语句，也能用来删除和修改，不能用来新增。 简单查询除了简单查询，还能配合LiveData和RxJava。这里使用的是implementation &#39;io.reactivex.rxjava2:rxjava:2.2.3&#39;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.ly.allendemojetpack.db.daoimport androidx.lifecycle.LiveDataimport androidx.room.Daoimport androidx.room.Insertimport androidx.room.OnConflictStrategyimport androidx.room.Queryimport com.ly.allendemojetpack.db.data.Shoeimport io.reactivex.Flowable/** * 鞋子表的方法 * * @author Liuyang * @date 2019/8/3 */@Daointerface ShoeDao &#123; /** * 通过id查找鞋子 */ @Query("SELECT * FROM shoe WHERE id = :id") fun findShoeById(id: Long): Shoe? /** * 通过品牌找鞋子 */ @Query("SELECT * FROM shoe WHERE shoe_brand = :brand") fun findShoeByBrand(brand: String): List&lt;Shoe&gt; /** * 模糊查询 排序 同名鞋名查询鞋 */ @Query("SELECT * FROM shoe WHERE shoe_name LIKE :name ORDER BY shoe_brand ASC") fun findShoesByName(name: String): List&lt;Shoe&gt; /** * 配合LiveData，返回所有鞋子 */ @Query("SELECT * FROM shoe") fun getAllShoesLD(): LiveData&lt;List&lt;Shoe&gt;&gt; /** * 配合LiveData，通过id查找鞋子 */ @Query("SELECT * FROM shoe WHERE id = :id") fun findShoeByIdLD(id: Long): LiveData&lt;Shoe&gt; /** * 配合RxJava，通过id查询单款鞋子 */ @Query("SELECT * FROM shoe WHERE id=:id") fun findShoeByIdRx(id: Long): Flowable&lt;Shoe&gt;&#125; 查询多个的时候，可以返回List和数组，还可以配合LiveData和RxJava。 复合查询12345678910/** * 根据收藏结合，查询用户喜欢的鞋的集合 */@Query( "SELECT shoe.id,shoe.shoe_name,shoe.shoe_description,shoe.shoe_price,shoe.shoe_brand,shoe.shoe_imgUrl " + "FROM shoe " + "INNER JOIN fav_shoe ON fav_shoe.shoe_id = shoe.id " + "WHERE fav_shoe.user_id = :userId")fun findShoesByUserId(userId: Long): LiveData&lt;List&lt;Shoe&gt;&gt; 2.4 步骤4：创建数据库创建一个数据库对象非常消耗资源，使用单例模式可以避免更多的资源消耗。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.ly.allendemojetpack.dbimport android.content.Contextimport androidx.room.Databaseimport androidx.room.Roomimport androidx.room.RoomDatabaseimport androidx.sqlite.db.SupportSQLiteDatabaseimport androidx.work.OneTimeWorkRequestBuilderimport androidx.work.WorkManagerimport com.ly.allendemojetpack.db.dao.FavouriteShoeDaoimport com.ly.allendemojetpack.db.dao.ShoeDaoimport com.ly.allendemojetpack.db.dao.UserDaoimport com.ly.allendemojetpack.db.data.Shoeimport com.ly.allendemojetpack.db.data.Userimport com.ly.allendemojetpack.utils.ShoeWorker/** * 数据库文件 * * @author Liuyang * @date 2019/8/2 */@Database(entities = [User::class, Shoe::class], version = 1, exportSchema = false)abstract class AppDataBase : RoomDatabase() &#123; abstract fun userDao(): UserDao abstract fun shoeDao(): ShoeDao abstract fun favouriteShoeDao(): FavouriteShoeDao companion object &#123; @Volatile private var instance: AppDataBase? = null fun getInstance(context: Context): AppDataBase &#123; return instance ?: synchronized(this) &#123; instance ?: buildDataBase(context) .also &#123; instance = it &#125; &#125; &#125; private fun buildDataBase(context: Context): AppDataBase &#123; return Room.databaseBuilder(context, AppDataBase::class.java, "jetpack_db") .addCallback(object : RoomDatabase.Callback() &#123; override fun onCreate(db: SupportSQLiteDatabase) &#123; super.onCreate(db) // 读取鞋的集合 val request = OneTimeWorkRequestBuilder&lt;ShoeWorker&gt;().build() WorkManager.getInstance(context).enqueue(request) &#125; &#125; ) .build() &#125; &#125;&#125; @Database注解声明当前是一个数据库文件，注解中entities变量声明数据库中的表（实体），以及版本等变量。同时，获取的Dao也必须在数据库类中。完成之后，make project一下工程，系统后自动创建AppDataBase和xxxDao的实现类。 2.5 步骤5：简单封装在不使用LiveData和RxJava前提下，Room的操作不能放在主线程中。这里看看UserRepository： 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.ly.allendemojetpack.db.repositoryimport com.ly.allendemojetpack.db.dao.UserDaoimport com.ly.allendemojetpack.db.data.Userimport kotlinx.coroutines.Dispatchers.IOimport kotlinx.coroutines.withContextclass UserRepository private constructor(private val userDao: UserDao) &#123; /** *用户登录 */ fun login(account: String, pwd: String) = userDao.login(account, pwd) /** * 用户注册 */ suspend fun register(email: String, account: String, pwd: String): Long &#123; return withContext(IO) &#123; userDao.insertUser(User(account, pwd, email)) &#125; &#125; /** * 获取所有用户 */ fun getAllUsers() = userDao.getAllUsers() /** * 通过id获取用户 */ fun findUserById(id: Long) = userDao.findUserById(id) companion object &#123; @Volatile private var instance: UserRepository? = null fun getInstance(userDao: UserDao): UserRepository = instance ?: synchronized(this) &#123; instance ?: UserRepository(userDao).also &#123; instance = it &#125; &#125; &#125;&#125; register()是一个普通方法，所以需要在子线程中使用，这里通过协程实现。login()是配合LiveData使用的， 不需要额外创建子线程，但是其核心数据库操作还在子线程中实现的。 这时，就可以操作本地数据库了。 3. 其他3.1 类型转换器SQLite支持的类型有：NULL、INTEGER、REAL、TEXT和BLOB，对于Data类，SQLite还可以将其转化为TEXT、REAL或者INTEGER，如果是Calendar类呢？Room提供了这一解决方法，使用@TypeConverter注解，谷歌官方示例：android-sunflower： 123456class Converters &#123; @TypeConverter fun calendarToDatestamp(calendar: Calendar): Long = calendar.timeInMillis @TypeConverter fun datestampToCalendar(value: Long): Calendar = Calendar.getInstance().apply &#123; timeInMillis = value &#125;&#125; 然后在数据库声明的时候，加上@TypeConverter(COnverter::class)即可： 12345@Database(...)@TypeConverters(Converters::class)abstract class AppDatabase : RoomDatabase() &#123; //...&#125; 3.2 数据库迁移：这个还需要查找资料Android Room 框架学习]]></content>
      <categories>
        <category>Android</category>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>Jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Jetpack-ViewModel&LiveData]]></title>
    <url>%2F2019%2F08%2F02%2FAndroid-Jetpack-ViewModel-LiveData%2F</url>
    <content type="text"><![CDATA[在Android-Jetpack-DataBinding中，讨论了MVVM模式和Data Binding组件，这里继续学习跟MVVM有关的Android Jetpack组件——ViewModel和LiveData。 1. LiveData官方文档：LiveData 先来看看LiveData和ViewMOdel的作用： 从上图可以看出，LiveData和ViewModel在整个MVVM中担任数据驱动的职责，这也是MVVM中ViewMoel层的作用。 1.1 介绍官网介绍： LiveData is an observable data holder class. Unlike a regular observable, LiveData is lifecycle-aware, meaning it respects the lifecycle of other app components, such as activities, fragments, or services. This awareness ensures LiveData only updates app component observers that are in an active lifecycle state.直译：LiveData是一个可观察的数据持有者类。与常规的可观察对象不同，LiveData是生命周期感知的，这意味着它尊重其他应用程序组件的生命周期，比如活动、片段或服务。这种意识确保LiveData只更新处于活动生命周期状态的应用程序组件观察者。 可以看出LiveData作用和RxJava类似，是观察数据的类，相比RxJava，LiveData能在Activity、Fragment和Service中正确处理声明周期。LiveData的优点： 数据变更时更新UI 没有内存泄露 不会因为停止Activity崩溃 无需手动处理生命周期 共享资源 1.2 使用方式常用的API： observe(@NotNull LifeCycleOwner owner, @NotNull Observe&lt;? super T&gt; observer)：最常用的方法，需要提供Observer数据变更后的处理。LifeCycleOwner是能够正确处理生命周期的关键 setValue(T value)：设置数据 getValue():T：获取数据 postValue(T value)：在主线程更新数据 1.3 使用场景配合Android Jetpack的其他组件使用，如ViewModel和Room。 2. ViewModel官方文档：ViewModel MVVM中ViewModel层是用来逻辑处理的，Android Jetpack中的ViewModel是否一样呢？ 2.1 介绍官网介绍： The ViewModel class is designed to store and manage UI-related data in a lifecycle conscious way. The ViewModel class allows data to survive configuration changes such as screen rotations. ViewModel同样具有生命周期，用来处理跟UI相关的数据，并且，当设备的一些配置信息改变（如屏幕旋转）时，它的数据不会消失。通常，如果不做特殊处理，当屏幕旋转时，数据会消失，ViewModel管理数据为什么不会消失？因为ViewModel的生命周期： ViewModel的另一个特点就是实现Actiivty和Framgent之间的数据共享。 2.2 使用方法继承ViewMoel即可。 2.3 Demo2.3.1 步骤1：添加依赖12345// liveDataimplementation "androidx.lifecycle:lifecycle-livedata-ktx:2.2.0-alpha02"// viewModelimplementation "androidx.lifecycle:lifecycle-viewmodel-ktx:2.2.0-alpha02"implementation "androidx.lifecycle:lifecycle-extensions:2.2.0-alpha02" 2.3.2 步骤2：创建Model继承ViewModel，分别创建品牌名的观察对象brand:MutableliveData&lt;String&gt;和对鞋子集合的观察对象shose:LiveData&lt;List&lt;Shoe&gt;&gt;： 1234567891011121314151617181920212223242526272829303132package com.ly.allendemojetpack.viewmodelimport androidx.lifecycle.*import com.ly.allendemojetpack.db.data.Shoeimport com.ly.allendemojetpack.db.repository.ShoeRepositoryclass ShoeModel constructor(repository: ShoeRepository) : ViewModel() &#123; companion object &#123; private const val ALL = "所有" &#125; /** * 品牌的观察对象，默认观察所有的品牌 */ private val brand = MutableLiveData&lt;String&gt;().apply &#123; value = ALL &#125; /** * 鞋子集合的观察类 */ val shoes: LiveData&lt;List&lt;Shoe&gt;&gt; = brand.switchMap &#123; // Room数据库查询，只要知道返回的是LiveData&lt;List&lt;Shoe&gt;&gt;即可 if (it == ALL) &#123; repository.getAllShoes() &#125; else &#123; repository.getShoeByBrand(it) &#125; &#125; ......&#125; 2.3.3 步骤3：获取ViewModel 无构造参数获取：构造函数没有参数的情况下，获取ShoeModel很简单，ViewModelProvider.of(this).get(ShoeModel::class.java)就能返回需要的ShoeModel。 有构造参数获取：上面的ShoeModel需要传入一个参数ShoeRepository，这时，就需要自定义实现Factory：1234567891011121314package com.ly.allendemojetpack.viewmodel.factoryimport androidx.lifecycle.ViewModelimport androidx.lifecycle.ViewModelProviderimport com.ly.allendemojetpack.db.repository.ShoeRepositoryimport com.ly.allendemojetpack.viewmodel.ShoeModelclass ShoeModelFactory( private val repository: ShoeRepository) : ViewModelProvider.NewInstanceFactory() &#123; override fun &lt;T : ViewModel?&gt; create(modelClass: Class&lt;T&gt;): T &#123; return ShoeModel(repository) as T &#125;&#125; 为了方便使用，这里写了一个统一的工具类CustomViewModelProvider： 12345678910111213141516171819202122232425package com.ly.allendemojetpack.viewmodelimport android.content.Contextimport androidx.navigation.NavControllerimport com.ly.allendemojetpack.db.RepositoryProviderimport com.ly.allendemojetpack.db.repository.ShoeRepositoryimport com.ly.allendemojetpack.db.repository.UserRepositoryimport com.ly.allendemojetpack.viewmodel.factory.LoginModelFactoryimport com.ly.allendemojetpack.viewmodel.factory.RegisterModelFactoryimport com.ly.allendemojetpack.viewmodel.factory.ShoeModelFactory/** * ViewModel提供者 * * @author Liuyang * @date 2019/8/3 */object CustomViewModelProvider &#123; ...... fun providerShoeModel(context: Context): ShoeModelFactory &#123; val repository: ShoeRepository = RepositoryProvider.providerShoeRepository(context) return ShoeModelFactory(repository) &#125;&#125; 最后就能在ShoeFragemnt中获取ShoeModel： 1234// by viewModels 需要依赖 "androidx.navigation:navigation-ui-ktx:$rootProject.navigationVersion"private val viewModel: ShoeModel by viewModels &#123; CustomViewModelProvider.providerShoeModel(requireContext())&#125; 2.3.4 步骤4：使用ViewModelViewModel的使用需要结合具体的业务，这里的ShoeModel在ShoeFragment中的使用如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.ly.allendemojetpack.ui.fragment.mainimport android.os.Bundleimport android.view.LayoutInflaterimport android.view.Viewimport android.view.ViewGroupimport androidx.fragment.app.Fragmentimport androidx.fragment.app.viewModelsimport androidx.lifecycle.Observerimport androidx.lifecycle.ViewModelProvidersimport com.ly.allendemojetpack.databinding.FragmentShoeBindingimport com.ly.allendemojetpack.ui.adapter.ShoeAdapterimport com.ly.allendemojetpack.viewmodel.CustomViewModelProviderimport com.ly.allendemojetpack.viewmodel.ShoeModel/** * 鞋子的Fragment * * @author Liuyang * @date 2019/8/3 */class ShoeFragment : Fragment() &#123; // by viewModels 需要依赖 "androidx.navigation:navigation-ui-ktx:$rootProject.navigationVersion" private val viewModel: ShoeModel by viewModels &#123; CustomViewModelProvider.providerShoeModel(requireContext()) &#125; override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? &#123; val binding: FragmentShoeBinding = FragmentShoeBinding.inflate(inflater, container, false) context ?: return binding.root ViewModelProviders.of(this).get(ShoeModel::class.java) // 适配器 val adapter = ShoeAdapter() binding.recycler.adapter = adapter onSubscribeUi(adapter) return binding.root &#125; /** * 鞋子数据更新的通知 */ private fun onSubscribeUi(adapter: ShoeAdapter) &#123; viewModel.shoes.observe(viewLifecycleOwner, Observer &#123; if (it != null) &#123; adapter.submitList(it) &#125; &#125;) &#125;&#125; 在onSubscribeUi()中，使用ShoeModel的LiveData进行观察通知，当鞋子集合更新数据时，就会更新到当前的适配器中。 布局文件framgent_shoe.xml很简单，虽然使用了Data Binding，但是没有变量，只有一个RecyclerView。 Demo地址：Allen_Demo_Jetpack 3. 其他3.1 LiveData数据变换LiveData中数据变换方法有map()和switchMap()，switchMap()在上面已经看到了： 1234567891011121314151617181920212223242526272829303132333435363738394041// 本地数据仓库class ShoeRepository private constructor(private val shoeDao: ShoeDao) &#123; fun getAllShoes() = shoeDao.getAllShoes() /** * 通过品牌查询鞋子，返回LiveData&lt;List&lt;Shoe&gt;&gt; */ fun getShoeByBrand(brand: String) = shoeDao.findShoeByBrand(brand) /** * 插入鞋子的集合，返回LiveData&lt;List&lt;Shoe&gt;&gt; */ fun insertShoes(shoes: List&lt;Shoe&gt;) = shoeDao.insertShoe(shoes) ......&#125;class ShoeModel constructor(repository: ShoeRepository) : ViewModel() &#123; companion object &#123; private const val ALL = "所有" &#125; /** * 品牌的观察对象，默认观察所有的品牌 */ private val brand = MutableLiveData&lt;String&gt;().apply &#123; value = ALL &#125; /** * 鞋子集合的观察类 */ val shoes: LiveData&lt;List&lt;Shoe&gt;&gt; = brand.switchMap &#123; // Room数据库查询，只要知道返回的是LiveData&lt;List&lt;Shoe&gt;&gt;即可 if (it == ALL) &#123; repository.getAllShoes() &#125; else &#123; repository.getShoeByBrand(it) &#125; &#125;&#125; map()的使用借用官方的例子： 1234val userLiveData: LiveData&lt;User&gt; = UserLiveData()val userName: LiveData&lt;String&gt; = Transformations.map(userLiveData) &#123; user -&gt; "$&#123;user.name&#125; $&#123;user.lastName&#125;"&#125; 可以看到，map()也可以实现将A变成B，二者有什么区别呢？ map()中只有一个LiveData&lt;A&gt;，它在LiveData&lt;A&gt;发送数据的时候将A变成B switchMap()中同时存在LiveData&lt;A&gt;和LiveData&lt;B&gt;，LiveData&lt;A&gt;更新之后，通知LiveData&lt;B&gt;更新。 3.2 LiveData如何共享数据如果有这样的需求：注册页需要记录信息，注册完成跳转到登录页，并将账号和密码显示在登录页。这时，可以定义一个类然后继承LiveData，并使用单例模式即可： 123456789package com.ly.allendemojetpack.common.livedata/** * 登录信息 * * @author Liuyang * @date 2019/8/3 */data class LoginInfo constructor(val account: String, val pwd: String, val email: String) 12345678910111213141516171819202122package com.ly.allendemojetpack.common.livedataimport androidx.annotation.MainThreadimport androidx.lifecycle.LiveData/** * 自定义单例LiveData * * @author Liuyang * @date 2019/8/3 */class LoginLiveData : LiveData&lt;LoginInfo&gt;() &#123; companion object &#123; private lateinit var sInstance: LoginLiveData @MainThread fun get(): LoginLiveData &#123; sInstance = if (::sInstance.isInitialized) sInstance else LoginLiveData() return sInstance &#125; &#125;&#125; 3.3 使用ViewModel在同一个Activity中的Fragment之间共享数据要想利用ViewModel实现Fragment之间数据共享，前提是Fragment中的FragmentActivity要相同，这里看看官方示例： 123456789101112131415161718192021222324252627282930313233343536373839class SharedViewModel : ViewModel() &#123; val selected = MutableLiveData&lt;Item&gt;() fun select(item: Item) &#123; selected.value = item &#125;&#125;class MasterFragment : Fragment() &#123; private lateinit var itemSelector: Selector private lateinit var model: SharedViewModel override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) model = activity?.run &#123; ViewModelProviders.of(this).get(SharedViewModel::class.java) &#125; ?: throw Exception("Invalid Activity") itemSelector.setOnClickListener &#123; item -&gt; // Update the UI &#125; &#125;&#125;class DetailFragment : Fragment() &#123; private lateinit var model: SharedViewModel override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) model = activity?.run &#123; ViewModelProviders.of(this).get(SharedViewModel::class.java) &#125; ?: throw Exception("Invalid Activity") model.selected.observe(this, Observer&lt;Item&gt; &#123; item -&gt; // Update the UI &#125;) &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>Jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Jetpack-DataBinding]]></title>
    <url>%2F2019%2F07%2F31%2FAndroid-Jetpack-DataBinding%2F</url>
    <content type="text"><![CDATA[Android Jetpack一系类的内容，适合使用MVVM，这里先看看MVVM。 1. 介绍1.1 MVVM介绍MVVM，全称Model-View-ViewModel，和MVC和MVP一样，是逻辑分层解耦的模式。 1.1.1 结构图 MVVM三要素： View层：xml、Activity、Framgent、Adapter和View等 Model层：数据源（包括本地数据和网络数据等） ViewModel层：View层处理数据以及逻辑处理 1.2 Data Binding介绍MVVM是一种架构模式，Data Binding是一种实现数据和UI绑定的框架，是构建MVVM模式的一个工具。 官方文档：Data Binding 官方Demo地址：android-databinding 2. Demo这里会在前一篇Android-Jetpack-Navigation的基础上进行扩展，如果要查看之前的可以使用git进行版本回退，本文会在注册和登录模块上进行修改。 2.1 步骤1：在module的build.gradle中添加如下：1234567android &#123; ...... dataBinding &#123; enabled true &#125;&#125; 2.2 步骤2：构建LoginModel创建登录的LoginModel，主要负责登录逻辑的处理以及两个输入框内容改变时数据的更新： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.ly.allendemojetpack.viewmodelimport android.content.Contextimport android.content.Intentimport android.text.Editableimport android.widget.EditTextimport android.widget.Toastimport androidx.databinding.BindingAdapterimport androidx.databinding.ObservableFieldimport com.ly.allendemojetpack.MainActivityimport com.ly.allendemojetpack.common.Constantimport com.ly.allendemojetpack.common.listener.SimpleWatcherclass LoginModel constructor(name: String, pwd: String, context: Context) &#123; val n = ObservableField&lt;String&gt;(name) val p = ObservableField&lt;String&gt;(pwd) val context: Context = context /** * 用户名改变时的回调 */ fun onNameChanged(s: CharSequence) &#123; n.set(s.toString()) &#125; /** * 密码改变时的回调 */ fun onPwdChanged(s: CharSequence, start: Int, before: Int, count: Int) &#123; p.set(s.toString()) &#125; /** * 登录的逻辑 */ fun login() &#123; if (n.get().equals(Constant.USERNAME) &amp;&amp; p.get().equals(Constant.PASSWORD)) &#123; Toast.makeText(context, "账号密码正确", Toast.LENGTH_SHORT).show() val intent = Intent(context, MainActivity::class.java) context.startActivity(intent) &#125; &#125; val nameWatcher = object : SimpleWatcher() &#123; override fun afterTextChanged(s: Editable) &#123; super.afterTextChanged(s) n.set(s.toString()) &#125; &#125; val pwdWatcher = object : SimpleWatcher() &#123; override fun afterTextChanged(s: Editable) &#123; super.afterTextChanged(s) p.set(s.toString()) &#125; &#125; @BindingAdapter("addTextChangedListener") fun addTextChangedListener(editText: EditText, simpleWatcher: SimpleWatcher) &#123; editText.addTextChangedListener(simpleWatcher) &#125;&#125; ObservableField是一个可观察的域，通过泛型来使用，可以使用的方法有三个： ObservableField(T value)：构造函数，设置可观察的域 T get()：获取可观察的域的内容，可以使用UI控件监测它的值 set(T value)：设置可观察的域，设置成功后，会通知UI控件进行更新 再来看看LoginModel，里面包含了用来观察name和pws的两个成员变量n和p，以及一个登录的逻辑处理方法。 2.3 步骤3：创建布局文件使用Data Binding之后的布局文件和之前的会有很大不同，里面包含了一些新的标签： layout：布局根节点，只能包裹一个View标签，且不能包裹merge标签。 data：Data Binding的数据，只能存放一个data标签。 variable：在data标签中使用，数据的变量标签。type属性指明变量的类。name属性指明变量的名字，方便布局中使用。 import：在data标签中使用，需要使用静态方法和静态常量，如果需要使用view.visible属性的时候，需要导入&lt;import type=&quot;android.view.View&quot;/&gt;。type属性指明类的路径，如果两个import标签带入的类名相同，可以使用alias属性声明别名，使用时直接用别名即可。 来看看LoginFragment的布局文件fragment_login.xml： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools"&gt; &lt;data&gt; &lt;!--ViewModel，通过mBinding.vm=mViewMode注入--&gt; &lt;variable name="model" type="com.ly.allendemojetpack.viewmodel.LoginModel"/&gt; &lt;variable name="activity" type="androidx.fragment.app.FragmentActivity"/&gt; &lt;/data&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:id="@+id/txt_cancel" android:layout_width="wrap_content" android:layout_height="wrap_content" android:onClick="@&#123;()-&gt; activity.onBackPressed()&#125;" ...... /&gt; &lt;TextView android:id="@+id/txt_title" app:layout_constraintTop_toTopOf="parent" ...... /&gt; &lt;EditText android:id="@+id/et_account" android:layout_width="0dp" android:layout_height="0dp" android:text="@&#123;model.n.get()&#125;" android:onTextChanged="@&#123;(text, start, before, count)-&gt;model.onNameChanged(text)&#125;" ...... /&gt; &lt;EditText android:id="@+id/et_pwd" android:layout_width="0dp" android:layout_height="0dp" android:text="@&#123;model.p.get()&#125;" android:onTextChanged="@&#123;model::onPwdChanged&#125;" ...... /&gt; &lt;Button android:id="@+id/btn_login" android:layout_width="0dp" android:layout_height="0dp" android:onClick="@&#123;()-&gt; model.login()&#125;" android:enabled="@&#123;(model.p.get().isEmpty()||model.n.get().isEmpty()) ? false : true&#125;" ...... /&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;&lt;/layout&gt; variable有了两个： model：类型为com.ly.allendemojetpack.viewmodel.LoginModel，绑定用户名。 activity：类型为androidx.fragment.app.FragmentActivity，主要用来处理返回按钮事件。 知识点讲解： 属性的引用如果想使用ViewModel中成员变量，直接使用model.p即可。 事件绑定事件绑定包括方法引用和监听绑定： 方法引用：参数类型和返回类型要一致，参考et_pwd的android:onTextChanged引用 监听绑定：要求没有方法引用高，可以使用自定义函数，参考et_account的android:onTextChanged引用。 表达式btn_login按钮在账号或密码为空的时候，是灰色的： 这是因为在代码中设置了android:enabled=&quot;@{(model.p.get().isEmpty()||model.n.get().isEmpty()) ? false : true}&quot;，意思是用户名或密码为空时，设置android:enable属性设置为flase，这是一个三元表达式，除了上面的||和三元表达式，Data Binding还支持： 运算符 + - / * % 字符串连接 + 逻辑与或 &amp;&amp; || 二进制 &amp; | ^ 一元 + - ! ~ 移位 &gt;&gt; &gt;&gt;&gt; &lt;&lt; 比较 == &gt; &lt; &gt;= &lt;= (Note that &lt; needs to be escaped as &lt;) instanceof Grouping () Literals - character, String, numeric, null Cast 方法调用 域访问 数组访问 三元操作符 除了上述，Data Binding还新增了空合并操作符??，例如androud:text=&quot;@{user.displayName ?? user.lastName}&quot;等价于android:text=&quot;@{user.displayName != null ? user.displayName : user.lastName}&quot; 2.4 生成绑定类创建完布局文件之后，点击Make Project按钮，系统会自动生成绑定类： 下面只需要在LoginFragment中完成绑定操作即可，既可以使用生成的FragmentLoginBinding，也可以使用自带的BindingUtil。 使用BindingUtilBindingUtil常用的API： setContentView()：进行Activity下面的绑定 inflate：进行Fragment下面的绑定 bind：进行View的绑定 LoginFragemnt绑定代码如下： 12345678910override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? &#123; val binding: FragmentLoginBinding = DataBindingUtil.inflate( inflater, R.layout.fragment_login, container, false ) loginModel = LoginModel("", "", context!!) binding.model = loginModel binding.activity = activity return binding.root&#125; 使用生产的FragmentLoginBinding使用方法与DataBindingUtil类似：1234567override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? &#123; val binding = FragmentLoginBinding.inflate(inflater, container, false) loginModel = LoginModel("", "", context!!) binding.model = loginModel binding.activity = activity return binding.root&#125; 3. Data Binding的一些其他功能3.1 布局中属性的设置3.1.1 有属性有setter如果一个XXXView类中有成员变量borderColor，并且XXXView类中有setBorderColor(int color)方法，那么在布局文件中，可以借助Data Binding直接使用app:borderColor属性。 3.1.2 没有setter，但有相关方法以XXXView为例，内有有成员变量borderColor，这次设置borderColor的方法是setBorder()（或者其他，总之不是标准的set方法，setBorderColor()），还使用app:borderColor肯定不行的。这时，可以通过BindingMethods注解实现app:borderColor的使用，如下： 12345@BindingMethods(value = [ BindingMethod( type = 包名.XXXView::class, attribute = "app:borderColor", method = "setBColor")]) 3.1.3 自定义属性现在不仅没有setter方法，甚至成员变量都没有。例如现在要给EditText添加文本监听器，这样，现在LoginModel中自定义个监听器，并使用@BindingAdapter注解： 123456789101112val nameWatcher = object : SimpleWatcher() &#123; override fun afterTextChanged(s: Editable) &#123; super.afterTextChanged(s) n.set(s.toString()) &#125;&#125;@BindingAdapter("addTextChangedListener")fun addTextChangedListener(editText: EditText, simpleWatcher: SimpleWatcher) &#123; editText.addTextChangedListener(simpleWatcher)&#125; 这样就可以在布局文件中使用app:addTextChangedListener属性了： 123456&lt;EditText android:id="@+id/et_account" android:text="@&#123;model.n.get()&#125;" app:addTextChangedListener="@&#123;model.nameWatcher&#125;" ... /&gt; 效果和之前的一样。 3.2 数据双向绑定数据双向绑定可以分为两种情况：数据刷新视图和视图刷新数据。 3.2.1 数据刷新视图需要数据变化时视图也跟着变化。有了两种实现方式： 自定义继承BaseObservable 使用ObservableField 继承BaseObservable123456789101112131415161718192021222324252627282930313233package com.ly.allendemojetpack;import androidx.databinding.BaseObservable;import androidx.databinding.Bindable;public class ObservableUser extends BaseObservable &#123; private String firstName; private String lastName; /** * 注解才会自动在build目录BR类中生成entry, 要求方法名必须以get开头 */ @Bindable public String getFirstName() &#123; return firstName; &#125; @Bindable public String getLastName() &#123; return lastName; &#125; public void setFirstName(String firstName) &#123; this.firstName = firstName; // 手动刷新 notifyPropertyChanged(BR.firstName); &#125; public void setLastName(String lastName) &#123; this.lastName = lastName; notifyPropertyChanged(BR.lastName); &#125;&#125; BaseObservable和Observable的区别： BaseObservable是实现了Observable的类，帮助实现监听器的线程安全问题； BaseObservable使用了addPropertyChangeRegistry()来执行OnPropertyChangedCallback()； 不建议直接实现Observable。 使用ObservableFieldData Binding默认实现了一系列Observable接口的字段：123456789101112BaseObservable,ObservableBoolean,ObservableByte,ObservableChar,ObservableDouble,ObservableField&lt;T&gt;,ObservableFloat,ObservableInt,ObservableLong,ObservableParcelable&lt;T extends Parcelable&gt;,ObservableShort,ViewDataBinding 示例： 12345public class PlainUser &#123; public final ObservableField&lt;String&gt; firstName = new ObservableField&lt;&gt;(); public final ObservableField&lt;String&gt; lastName = new ObservableField&lt;&gt;(); public final ObservableInt age = new ObservableInt();&#125; 对于集合类型，可以使用ObservableArryMap、ObservableArryList、ObservableMap等集合类型： 1234ObservableArrayMap&lt;String, Object&gt; user = new ObservableArrayMap&lt;&gt;();user.put("firstName", "Google");user.put("lastName", "Inc.");user.put("age", 17); 使用 12345678910111213&lt;data&gt; &lt;import type="android.databinding.ObservableMap"/&gt; &lt;variable name="user" type="ObservableMap&lt;String, Object&gt;"/&gt;&lt;/data&gt;…&lt;TextView android:text='@&#123;user["lastName"]&#125;' android:layout_width="wrap_content" android:layout_height="wrap_content"/&gt;&lt;TextView android:text='@&#123;String.valueOf(1 + (Integer)user["age"])&#125;' android:layout_width="wrap_content" android:layout_height="wrap_content"/&gt; 还支持ObservableParcelable&lt;Object&gt;序列化数据类型； ObservableField同样可以使用addPropertyChangedCallback监听属性变化。 3.2.2 视图刷新数据通过使用表达式@=就可以在视图刷新时自动刷新数据，但是要求数据实现以下 两种方式修改才会触发刷新： 12345&lt;EditText android:layout_width="match_parent" android:layout_height="wrap_content" android:inputType="textNoSuggestions" android:text="@=&#123;model.name&#125;"/&gt; 这种双向绑定会存在一个死循环的问题，即数据变化（回调监听器）触发了视图变化，视图变化又会触发数据变化（再次回调监听），一直循环，设置相同的数据也会视为数据变化。 所以需要判断当前变化的数据是否等于旧数据： 123456789101112131415161718192021222324252627282930313233343536373839package com.ly.allendemojetpack;import android.widget.TextView;import androidx.databinding.BindingAdapter;public class CustomBindingAdapter &#123; @BindingAdapter("android:text") public static void setText(TextView view, CharSequence text) &#123; CharSequence oldText = view.getText(); if (!haveContentChanged(text, oldText)) &#123; // 数据没有变化时，不进行视图刷新 return; &#125; view.setText(text); &#125; /** * 本方法使用的是官方源码 */ private static boolean haveContentChanged(CharSequence str1, CharSequence str2) &#123; if ((str1 == null) != (str2 == null)) &#123; return true; &#125; else if (str1 == null) &#123; return false; &#125; final int length = str1.length(); if (length != str2.length()) &#123; return true; &#125; for (int i = 0; i &lt; length; i++) &#123; if (str1.charAt(i) != str2.charAt(i)) &#123; return true; &#125; &#125; return false; &#125;&#125; 下面这种判断是无效的，因为String参数传递属于引用类型变量，不是常量，需要使用equals()： 1234// 本段截取官方源码，是错误的if (text == oldText || (text == null &amp;&amp; oldText.length() == 0)) &#123; return; &#125; 正确写法： 123if (text == null || text.equals(oldText) || oldText.length() == 0) &#123; return;&#125; 回到本例，比如上面的EditText在实现双向绑定后，既不需要添加SimpleWatcher，也不需要用方法调用，实现代码如下： 1234567&lt;EditText android:id="@+id/et_account" android:layout_width="0dp" android:layout_height="0dp" android:text="@=&#123;model.n.get()&#125;" ...... /&gt; 仅仅将@{model.n.get()}换为@={model.n.get()},需要注意，属性必须是可观察的，即使用上面提到的ObservableField，也可以自定义实现BaseObservable接口。 4. 注解4.1 @Bindable用于数据更新自动刷新视图。 4.2 BindingAdapter创建一个XML属性和函数，然后在属性中进行设置数据操作会进入该函数。图片加载框架可以使用此方法。 1234@BindingAdapter(value = &#123; "imageUrl", "error" &#125;, requireAll = false)public static void loadImage(ImageView view, String url, Drawable error) &#123; Glide.with(view.getContext()).load(url).into(view);&#125; 方法必须是public static； 第一个参数必须是控件或其父类 方法名随意 最后一个boolean类型是可选参数，可以要求是否所有参数都要填写，默认为true 如果requireAll为false，没有填的属性将默认为null，所以需要做非空判断 使用： 123456&lt;ImageView android:layout_width="match_parent" android:layout_height="200dp" app:error="@&#123;@drawable/error&#125;" allen:imageUrl="@&#123;imageUrl&#125;" app:onClickListener="@&#123;activity.avatarClickListener&#125;"/&gt; 命名空间可以是随意的，但如果在BindingAdapter的数组内定义了命名空间，就必须遵守。 例如： 123456// 这里省略了一个注解参数. @BindingAdapter(&#123; "android:imageUrl", "error" &#125;)public static void loadImage(ImageView view, String url, Drawable error) &#123; if(url == null) return; Glide.with(view.getContext()).load(url).into(view);&#125; 如果数据初始化在异步，会回调方法，但数据为null（成员默认值），所以要先进行非空判断。 Kotlin有两种实现方式： 单例 + @JvmStatic注解 123456object ProgressAdapter &#123; @JvmStatic @BindingAdapter("android:bindName") fun setBindName(view: View, name:String)&#123; &#125;&#125; 顶级函数 12345678@BindingAdapter("android:bindName")fun setBindName(view: View, name:String)&#123;&#125;// 由于顶级函数太多影响代码补全建议使用顶级扩展函数, 之后也可以在代码中方便使用@BindingAdapter("android:bindName")fun View.setBindName( name:String)&#123;&#125; 4.3 @BindingMethods如果想创建一个XML属性并且和View中函数关联（即自动使用属性值作为参数调用该函数），就可以使用@BindingMethods注解这个类（也可以是一个接口）。 该注解属于一个容器，内部参数是一个@BindingMethods数组，只能用于修饰类或接口。 官方Demo： 1234567@BindingMethods(&#123; @BindingMethod(type = android.widget.ProgressBar.class, attribute = "android:indeterminateTint", method = "setIndeterminateTintList"), @BindingMethod(type = android.widget.ProgressBar.class, attribute = "android:progressTint", method = "setProgressTintList"), @BindingMethod(type = android.widget.ProgressBar.class, attribute = "android:secondaryProgressTint", method = "setSecondaryProgressTintList"),&#125;)public class ProgressBarBindingAdapter &#123;&#125; @BindingMethods注解参数（必选）： type：字节码，即控件类型 attribute：XML属性 method：函数名，即控件中的函数名称 注意： 如果属性名和@BindingAdapter定义的XML属性相同，会冲突报错 如果控件类中已经存在一个和定义的属性相关联的函数（例如setName函数和android:name属性就相关联），则会优先执行该函数。 4.4 @BindingConversion属性值自动进行类型转换。 只能修饰public static方法 任意位置任意方法名都不受限制 Data Binding自动匹配被该注解修饰的方法和参数类型 返回值类型必须和属性setter方法匹配，且参数只有一个 要求属性值必须是@{}Data Binding表达式 官方示例： 12345678910public class Converters &#123; @BindingConversion public static ColorDrawable convertColorToDrawable(int color) &#123; return new ColorDrawable(color); &#125; @BindingConversion public static ColorStateList convertColorToColorStateList(int color) &#123; return ColorStateList.valueOf(color); &#125;&#125; kotlin示例： 123456@BindingConversionfun int2string(integer:Int):String&#123; Log.d("日志", "(CusView.kt:92) int2string ___ integer = [$integer]") return integer.toString()&#125; XML 1234567891011121314151617181920212223242526&lt;layout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools"&gt; &lt;data&gt; &lt;variable name="m" type="com.example.architecture.Model" /&gt; &lt;/data&gt; &lt;FrameLayout android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity"&gt; &lt;com.example.architecture.CusView android:bindName="@=&#123;m.age&#125;" android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt; &lt;/FrameLayout&gt;&lt;/layout&gt; 上面这段代码会报错，因为涉及双向数据绑定，@BindingConversion只会在数据设置视图时生效，但是如果是视图设置数据则会走其他函数（如get()），如果该函数返回的类型和Model中的类型不匹配会报异常，除非将函数改为类型匹配，或者去掉=，不使用双向数据绑定。 android:text不能使用int转为String，因为它本身能正常接收int（作为resouceId），会报： 1android.content.res.Resources$NotFoundException: String resource ID #0xa 4.5 @InverseMethodAndroid Studio 3.0提供了inverse系列新的注解，都是针对数据双向绑定的。 在数据和视图的数据不统一时可以使用该注解@InverseMethod解决数据转换问题。 例如，数据模型存储的是用户id，但视图不显示id，而是显示用户名（数据和视图类型不一样），就需要进行二者的转换。 需要两个函数：设置数据到视图的函数set()和设置视图变更到数据的函数get() set()和get()都至少有一个参数 自身参数必须和另一个函数的返回值对应 简单示例：在用户id和用户名称之间转换，存储的是id，但显示的是用户名。 12345678910111213141516package com.ly.allendemojetpack.DataBindingOtherimport androidx.databinding.InverseMethodclass Model &#123; var name = "设计师" @InverseMethod("ui2data") fun data2ui(): String &#123; return "设计师1" &#125; fun ui2data(): String &#123; return "设计师2" &#125;&#125; 使用： 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools"&gt; &lt;data&gt; &lt;variable name="model" type="com.ly.allendemojetpack.DataBindingOther.Model"/&gt; &lt;/data&gt; &lt;FrameLayout android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity"&gt; &lt;com.ly.allendemojetpack.DataBindingOther.CusView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@&#123;model.data2ui(model.name)&#125;"/&gt; &lt;/FrameLayout&gt;&lt;/layout&gt; 4.6 @InverseBindingAdapter参数： String attribute：属性值，必填 String event：默认值，非必填，属性值 + AttrChanged后缀 和@BindingAdapter配合，实现双向绑定。 完全的双向绑定需要三个函数： set()：数据到视图 get()：视图到数据 notify()：通知Data Binding视图已经刷新，可以更新数据（Model）了 set()函数： 123456@BindingAdapter("android:bindName")fun TextView.setBindName(name:String?)&#123; if (name.isNullOrEmpty() &amp;&amp; name != text) &#123; text = name &#125;&#125; get()函数： 12345@InverseBindingAdapter(attribute = "android:bindName", event = "cus_event")fun TextView.getBindName():String&#123; // 这里你可以对视图上的数据进行处理最终设置给Model层 return text.toString()&#125; 不允许有更多参数 返回值类型必须是绑定的数据类型 notify()视图变化后要通知Data Binding开始设置Model层，也要用到@BindingAdapter。 1234567@BindingAdapter("cus_event")fun TextView.notifyBindName( inverseBindingListener: InverseBindingListener)&#123; // 这个函数是监听TextWatch官方源码 doAfterTextChanged &#123; inverseBindingListener.onChange() &#125;&#125; InverseBindingListener是一个接口，里面只有一个函数，它是notify()函数必要的参数： 123456public interface InverseBindingListener &#123; /** * Notifies the data binding system that the attribute value has changed. */ void onChange();&#125; 4.7 @InverseBindingMethods和@BindingMethods类似，但是@InverseBindingMethods是视图变更数据（get()函数）,而@BindingMethods是数据到视图（set()函数）。 1234567891011121314151617181920212223242526272829@Target(ElementType.ANNOTATION_TYPE)public @interface InverseBindingMethod &#123; /** * 控件的类字节码 * The View type that is associated with the attribute. */ Class type(); /** * 自定义的属性 * The attribute that supports two-way binding. */ String attribute(); /** * notify函数的名称，即用于通知数据更新的函数 * The event used to notify the data binding system that the attribute value has changed. * Defaults to attribute() + "AttrChanged" */ String event() default ""; /** * 控件自身的函数名称，如果省略，即自动生成为&#123;attribute&#125;AttrChanged * The getter method to retrieve the attribute value from the View. The default is * the bean method name based on the attribute name. */ String method() default "";&#125; 如果说@BindingMethods是关联setter方法和自定义属性，那么@InverseBindingMethods就是关联getter方法和自定义属性。setter是更新视图时使用的，getter是更新数据时使用的。比@BindingMethods只是多了一个用于通知数据更新的notify()。示例： 123456789@InverseBindingMethods( InverseBindingMethod( type = CusView::class, attribute = "android:bindName", method = "getName", event = "cus_event" ))object Adapter &#123;&#125; 查看生成类中用于视图更新数据的代码： 12345678910111213141516171819private android.databinding.InverseBindingListener ivandroidTextAttr = new android.databinding.InverseBindingListener() &#123; @Override public void onChange() &#123; // Inverse of data.name // is data.setName((java.lang.String) callbackArg_0) java.lang.String callbackArg_0 = com.liangjingkanji.databinding.MyInverseBindingAdapter.getTextString(iv); // 拿到变化的属性 // localize variables for thread safety // data != null boolean dataJavaLangObjectNull = false; // data.name java.lang.String dataName = null; // data com.liangjingkanji.databinding.Bean data = mData; // 拿到数据 dataJavaLangObjectNull = (data) != (null); if (dataJavaLangObjectNull) &#123; data.setName(((java.lang.String) (callbackArg_0))); // 存储到数据 &#125; &#125;&#125;; 如果没有重写Inverse的数据变更方法，将无法让视图通知数据更新。 12345678910111213141516171819202122232425262728// 该方法会在绑定布局的时候回调 @Override protected void executeBindings() &#123; long dirtyFlags = 0; synchronized(this) &#123; dirtyFlags = mDirtyFlags; mDirtyFlags = 0; &#125; java.lang.String dataName = null; com.liangjingkanji.databinding.Bean data = mData; if ((dirtyFlags &amp; 0x1aL) != 0) &#123; if (data != null) &#123; // read data.name dataName = data.getName(); &#125; &#125; // batch finished if ((dirtyFlags &amp; 0x1aL) != 0) &#123; // api target 1 com.liangjingkanji.databinding.MyInverseBindingAdapter.setText(this.iv, dataName); &#125; if ((dirtyFlags &amp; 0x10L) != 0) &#123; // api target 1 // 重点是这段代码, 将上面创建的监听器传入setTextWatcher方法 com.liangjingkanji.databinding.MyInverseBindingAdapter.setTextWatcher(this.iv, (com.liangjingkanji.databinding.MyInverseBindingAdapter.BeforeTextChanged)null, (com.liangjingkanji.databinding.MyInverseBindingAdapter.OnTextChanged)null, (com.liangjingkanji.databinding.MyInverseBindingAdapter.AfterTextChanged)null, ivandroidTextAttr); &#125; &#125; 4.8 总结@BindingBuildInfo和Untaggable两个注解是Data Binding自动生成Java类时使用的。 @Bindable：设置数据刷新视图，自动生成BR的id @BindingAdapter：设置自定义属性，可以覆盖系统原有属性 @BindingMethod/BindingMethods：关联自定义属性到控件原有的setter方法 @BindingConversion：如果属性不能匹配类型，参数将自动根据类型参数匹配该注解修饰的方法来转换。 @InverseMethod：负责实现视图和数据之间的转换 @InverseBindingAdapter：视图通知数据刷新 @InverseBindingMethod/InverseBindingMethods：视图通知数据刷新（如果存在已有getter()方法可用的情况下） BindingMethods系统优先级高于BindingAdapter系列 所有注解的功能都是基于XML属性值为Data Binding表达式才生效（即@{}） 5. 表达式前面也列举了，这里着重讲几个。 5.1 避免空指针variable的值即使设置null，或者没有设置，也不会报空指针异常。因为谷歌已经用Data Binding的@BindingAdapter注解重写了很多属性，并且在里面进行了判空处理。 1234567&lt;variable name="userName" type="String"/&gt;.....android:text="@&#123;userName&#125;" 1dataBinding.setUserName(null); 不会报空指针，并且还支持特有的非空多元表达式： 1android:text="@&#123;user.displayName ?? user.lastName&#125;" 等价于 1android:text="@&#123;user.displayName !=null user.displayName :: user.lastName&#125;" 但是要注意数组越界。 5.2 集合集合不属于java.lang.*下的，需要导入全路径 1234567&lt;variable name="list" type="java.util.List&amp;lt;String&amp;gt;"/&gt;&lt;variable name="map" type="java.util.Map&lt;String, String&gt;"/&gt; 上面的写法是错误的：Error:与元素类型 “variable” 相关联的 “type” 属性值不能包含 ‘&lt;’ 字符。因为&lt;符号需要转义。 常用的转义符： 12345678 空格 &amp;nbsp 或 &amp;#160；&lt; 小于号 &amp;lt; 或 &amp;#60;&gt; 大于号 &amp;gt; 或 &amp;#62;&amp; 与号 &amp;amp; 或 &amp;#38;&quot; 引号 &amp;quot; 或 &amp;#34;‘ 撇号 &amp;apos; 或 &amp;#39;× 乘号 &amp;times; 或 &amp;#215;÷ 除号 &amp;divide; 或 &amp;#247; 正确写法： 1234567&lt;variable name="list" type="java.util.List&amp;lt;String&amp;gt;"/&gt;&lt;variable name="map" type="java.util.Map&amp;lt;String, String&amp;gt;"/&gt; 集合数组都可以用[]来得到元素： 1android:text="@&#123;map["firstName"]&#125;" 5.3 字符串如果要在@{}中使用字符串，有三种方式： 12345678// 方式1：android:text="@&#123;"XXX"&#125;"// 方式2：android:text="@&#123;'XXX'&#125;"// 方式3：android:text="@&#123;@string/name&#125;" 同样也支持@color和@drawable。 5.4 格式化字符串首先在stirngs文件中定义&lt;string&gt;： 1&lt;string name="string_format"&gt;名字：%s 性别：%s&lt;/string&gt; 然后就可以使用Data Binding表达式了： 1android:text="@&#123;@string/string_format('XXX', '男')&#125;" 输出内容： 1名字：XXX 性别：男 5.5 默认值如果variable还没有赋值，就会先使用默认值。 1android:text="@&#123;user.integral, default=`30`&#125;" 5.6 上下文Data Binding提供了一个名为context的variable，可以直接使用。等价于View的getContext()。 1android:color="@&#123;context.getApplication().toString()&#125;" 5.7 引用其他控件12345678910111213141516&lt;TextView android:id="@+id/datingName" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_centerVertical="true" android:layout_marginLeft="8dp" android:layout_toRightOf="@id/iv_dating" android:text="活动"/&gt;&lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_centerVertical="true" android:layout_marginLeft="8dp" android:layout_toRightOf="@id/iv_order" android:text="@&#123;datingName.text&#125;"/&gt; 引用包含_的控件id，可以直接忽略该符号，如tv_name直接写tvName。 5.8 使用Class如果想使用Class作为参数，那么该Class不能直接通过静态导入来使用，需要作为字段常量来使用。 6. Data Binding组件6.1 ViewDataBinding自动生成的Data Binding类都继承自该类，里面的主要方法有： 1234567891011121314151617181920212223// 添加绑定监听器, 可以在Variable被设置的时候回调void addOnRebindCallback(OnRebindCallback listener)// 删除绑定监听器void removeOnRebindCallback(OnRebindCallback listener)// 返回被绑定的视图对象View getRoot()// 使所有的表达式无效并且立刻重新设置表达式. 会重新触发OnRebindCallback回调(可以看做重置)abstract void invalidateAll()// 可以根据字段id来设置变量abstract boolean setVariable(int variableId, Object value)// 解绑布局, ui不会根据数据来变化, 但是监听器还是会触发的void unbind()// 当ui需要根据当前数据变化时就会返回true(数据变化后有一瞬间)abstract boolean hasPendingBindings()// 强制ui立刻刷新数据void executePendingBindings() 当改变数据以后（在设置了Observable观察者的情况下）会马上刷新UI，但是会在下一帧才会刷新UI，存在一定的延迟。在这段时间内，hasPendingBindings()会返回true。 如果想要同步刷新UI，可以调用executePendingBindings()。OnRebindCallback()：该监听器可以监听布局绑定的生命周期。 123456789101112131415161718192021222324public abstract class OnRebindCallback&lt;T extends ViewDataBinding&gt; &#123; /** * 绑定前 * @param binding * @return 如果返回true，就会绑定布局，；返回fasle，则取消绑定 */ public boolean onPreBind(T binding) &#123; return true; &#125; /** * 如果取消绑定则回调该方法，取决于onPreBind()的返回值 * @param binding */ public void onCanceled(T binding) &#123; &#125; /** * 绑定完成 * @param binding */ public void onBound(T binding) &#123; &#125;&#125; Data Binding也有一个数据变更监听器，可以监听variable的设置事件： 1234567891011121314151617mDataBinding.addOnPropertyChangedCallback(new Observable.OnPropertyChangedCallback() &#123; /** * 会在DataBinding设置数据的时候回调 * @param sender DataBinding生成的类 * @param propertyId Variable的id */ @Override public void onPropertyChanged(Observable sender, int propertyId) &#123; ActivityMainBinding databinding = (ActivityMainBinding) sender; switch (propertyId) &#123; case BR.data: Log.d("日志", "(MainActivity.java:54) ___ Result = " + databinding.getData().getName()); break; case BR.dataSecond: break; &#125; &#125;&#125;); 6.2 DataBindingUtilData Binding不仅可以绑定Activity，还可以绑定视图内容（View）。 123456789101112131415// 视图static &lt;T extends ViewDataBinding&gt; T bind(View root)static &lt;T extends ViewDataBinding&gt; T bind(View root, DataBindingComponent bindingComponent) // 布局static &lt;T extends ViewDataBinding&gt; T inflate(LayoutInflater inflater, int layoutId, ViewGroup parent, boolean attachToParent, DataBindingComponent bindingComponent)// 组件static &lt;T extends ViewDataBinding&gt; T inflate(LayoutInflater inflater, int layoutId, ViewGroup parent, boolean attachToParent)// activitystatic &lt;T extends ViewDataBinding&gt; T setContentView(Activity activity, int layoutId)static &lt;T extends ViewDataBinding&gt; T setContentView(Activity activity, int layoutId, DataBindingComponent bindingComponent) 还有两个不常用的方法，用于检索糊涂是否被绑定，如果没有绑定，返回null。 1234static &lt;T extends ViewDataBinding&gt; T getBinding(View view)// 和getBinding不同的是如果视图没有绑定会去检查父容器是否被绑定static &lt;T extends ViewDataBinding&gt; T findBinding(View view) 其他方法： 12// 根据传的BR的id来返回字符串类型. 可能用于日志输出static String convertBrIdToString(int id) 6.3 DataBindingComponent每个Data Binding都可以拥有一个组件或者说设置一个默认的全局组件。创建DataBindingComponent的步骤： 创建一个类，类中写入@BindingAdapter注解（需设置静态），这时Android Studio会扫描自动生成对应的DataBindingComponent接口； 创建一个类实现DataBindingComponent，这时会提示有方法需要覆写，如果省略第一步，则不会有。 第一步： 123456789101112131415161718192021222324252627package com.ly.allendemojetpack.databindingotherimport android.widget.TextViewimport androidx.databinding.BindingAdapterimport androidx.databinding.InverseBindingAdapterimport androidx.databinding.InverseBindingListenerclass PinkComponent &#123; @BindingAdapter("android:bindName") fun TextView.setBindName(name: String) &#123; if (name.isNotEmpty() &amp;&amp; name != text) &#123; text = "数据体" &#125; &#125; @BindingAdapter("android:bindNameAttrChanged") fun TextView.notifyBindName(inverseBindingListener: InverseBindingListener) &#123; doAfterTextChanged &#123; inverseBindingListener.onChange() &#125; &#125; @InverseBindingAdapter(attribute = "android:bindName") fun TextView.getBindName(): String &#123; return text.toString() &#125;&#125; 第二步： 12345678package com.ly.allendemojetpack.databindingotherclass CusComponent : androidx.databinding.DataBindingComponent &#123; override fun getPinkComponent(): PinkComponent &#123; // 此处不能返回null return PinkComponent() &#125;&#125; 设置默认组件都是由DataBindingUtil设置，但是方法有所不同： 123static void setDefaultComponent(DataBindingComponent bindingComponent)static DataBindingComponent getDefaultComponent() 以上这种设置必须在绑定视图之前设置，并且默认全局的，只需要设置一次。 1static &lt;T extends ViewDataBinding&gt; T setContentView(Activity activity, int layoutId, DataBindingComponent bindingComponent) 如果没有执行setDefaultComponent()，则选择通过函数单独传入，则每次都要传入，否则报错。或者可以将@BindingAdapter注解的方法变为static修饰。DataBindingComponent只能使用@BindingAdapter注解。 7. 注意 可以使用include，但是不能作为root布局，merge不能使用； 如果没有自动生成DataBinding类，可以先写一个variable（或者make module一下）； 即使没有绑定数据（可能会等到网络请求成功之后再去绑定数据），但是只要视图创建完成，就会自动绑定数据，这是数据是一个空对象。空对象的字段也有默认值（String的默认值是null，TextView就会显示null）；并且，如果用了三元表达式，空对象的三元表达式都为fasle，所以建议不考虑空对象的情况； 如果给一个要求值是bolean类型的值自定义属性（@BindingAdapter）赋值一个函数，空指针的情况会返回false。]]></content>
      <categories>
        <category>Android</category>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>Jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Jetpack-Navigation]]></title>
    <url>%2F2019%2F07%2F29%2FAndroid-Jetpack-Navigation%2F</url>
    <content type="text"><![CDATA[前言Android Jetpack是谷歌在2018年的I/O大会上发布的，官网,主要包含一下模块，系列文章主要介绍架构部分的内容： 这里先学习Navigation。 官方Demo：android-architecture-components。 1. 简介1.1 定义Navigation是一个可简化Android导航和库的插件。更确切来说，Navigation是用来管理Fragment切换的，并且可以通过可视化的方式，看见App的交互流程。 1.2 优点 处理Fragment的切换 默认情况下正确处理Fragment的前进和后退 为过渡和动画提供标准化的资源 实现和处理深层连接 可以绑定Toolbar、BottomNavigationView和ActionBar等 SafeArgs（Gradle插件）数据传递时提供类型安全性 ViewModel的支持 2. 具体学习Navigation三个关键组成部分： Navigation Graph：导航图，一个XML资源，包含集中在一个位置的所有和导航相关的信息。包括应用程序中所有单独的内容区域（也成目的地），以及用户可以通过应用程序访问的可能路径。 NavHost：一个存储前面目的地的容器，Navigation组件包含了一个默认的实现了NavHostFragment的NavHost，用来显示Fragment的目的地。 NavController：导航控制者，在NavHost中，管理应用程序导航的对象。当用户在app中进行切换页面等操作时，NavController在NavHost中协调目标内容的切换。 2.1 步骤1：添加依赖在module的build.gradle中添加依赖： 1234567dependencies &#123; ...... implementation 'androidx.fragment:fragment-ktx:1.2.0-alpha01' implementation 'androidx.navigation:navigation-fragment-ktx:2.1.0-beta02' implementation 'androidx.navigation:navigation-ui-ktx:2.1.0-beta02'&#125; 要加上kotlin依赖，在项目的build.gradle： 1234567891011buildscript &#123; repositories &#123; google() jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:3.4.0' classpath 'org.jetbrains.kotlin:kotlin-gradle-plugin:1.3.31' &#125;&#125; 如果要使用SafeArgs插件，可以在项目的build.gradle中添加： 12345buildscript &#123; dependencies &#123; classpath 'androidx.navigation:navigation-safe-args-gradle-plugin:2.0.0' &#125;&#125; 以及module下的build.gradle中添加： 12apply plugin: 'kotlin-android-extensions'apply plugin: 'androidx.navigation.safeargs' 2.2 步骤2：创建Navigation导航 创建基础目录：资源文件res目录下创建navigation目录； 创建一个Destination，如果说navigation是导航工具，Destination就是目的地，在此之前已经写好了需要用到的Fragment——SplashFragment、LoginFragment和RegisterFragment，添加Desination，如下示图： 除了上面的可视化界面，也能通过代码进行编辑，login_navigation.xml： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;navigation xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/login_navigation" app:startDestination="@id/splash" tools:ignore="UnusedNavigation"&gt; &lt;fragment android:id="@+id/login" android:name="com.ly.allendemojetpack.ui.fragment.login.LoginFragment" android:label="LoginFragment" tools:layout="@layout/fragment_login"/&gt; &lt;fragment android:id="@+id/splash" android:name="com.ly.allendemojetpack.ui.fragment.login.SplashFragment" android:label="LoginFragment" tools:layout="@layout/fragment_splash"&gt; &lt;action android:id="@+id/action_welcome_to_login" app:destination="@id/login"/&gt; &lt;action android:id="@+id/action_welcome_to_register" app:enterAnim="@anim/common_fade_in" app:exitAnim="@anim/common_slide_out_left" app:popEnterAnim="@anim/common_slide_in_left" app:popExitAnim="@anim/common_slide_out_right" app:destination="@id/register"/&gt; &lt;/fragment&gt; &lt;fragment android:id="@+id/register" android:name="com.ly.allendemojetpack.ui.fragment.login.RegisterFragment" android:label="LoginFragment" tools:layout="@layout/fragment_register"&gt; &lt;argument android:name="EMAIL" android:defaultValue="2019" app:argType="string"/&gt; &lt;/fragment&gt;&lt;/navigation&gt; 这里看看navigation标签的属性，app:startDestination，即默认的起始位置。 2.3 步骤3：创建NavHostFragment这里创建一个新的LoginActivity作为NavHostFragment，在activity_login.xml中： 123456789101112131415161718&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".ui.activity.LoginActivity"&gt; &lt;fragment android:id="@+id/my_nav_host_fragment" android:name="androidx.navigation.fragment.NavHostFragment" android:layout_width="match_parent" android:layout_height="match_parent" app:navGraph="@navigation/login_navigation" app:defaultNavHost="true"/&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; android:name：值必须是androidx.navigation.fragment.NavHostFragment，声明这是一个NavHostFragemnt。 app:navGraph：存放导航的资源文件，确定Navgation Graph。 app:defaultNavHost：关联系统的返回按钮 。 2.4 步骤4：界面跳转、参数传递和动画在SplashFragment中，点击登录按钮和注册按钮可以分别跳转到LoginFragment和RegisterFragment。 有两种实现方式： 2.4.1 方式1：利用ID导航目标：SplashFragment携带key为name的数据跳转到LoginFragment，LoginFragment接收后显示。 登录按钮的点击事件如下： 123456789101112131415btnLogin.setOnClickListener &#123; // 设置动画参数 val navOption = navOptions &#123; anim &#123; enter = R.anim.common_slide_in_right exit = R.anim.common_slide_out_left popEnter = R.anim.common_slide_in_left popExit = R.anim.common_slide_out_right &#125; &#125; // 参数设置 val bundle = Bundle() bundle.putString("name", "TeaOf") findNavController().navigate(R.id.login, bundle, navOption)&#125; 在LoginFragment中就可以通过Fragment的Bundle直接获取传来的参数。代码如下：LoginFragment.kt 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.ly.allendemojetpack.ui.fragment.loginimport android.content.Intentimport android.os.Bundleimport android.view.LayoutInflaterimport android.view.Viewimport android.view.ViewGroupimport android.widget.Buttonimport android.widget.EditTextimport android.widget.TextViewimport androidx.fragment.app.Fragmentimport com.ly.allendemojetpack.MainActivityimport com.ly.allendemojetpack.Rclass LoginFragment : Fragment() &#123; override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? &#123; return inflater.inflate(R.layout.fragment_login, container, false) &#125; lateinit var cancel: TextView lateinit var login: Button lateinit var account: EditText override fun onViewCreated(view: View, savedInstanceState: Bundle?) &#123; super.onViewCreated(view, savedInstanceState) cancel = view.findViewById(R.id.txt_cancel) login = view.findViewById(R.id.btn_login) account = view.findViewById(R.id.et_account) login.setOnClickListener &#123; val intent = Intent(context, MainActivity::class.java) context!!.startActivity(intent) &#125; cancel.setOnClickListener &#123; activity?.onBackPressed() &#125; val name = arguments?.getString("name") account.setText(name) &#125;&#125; 效果图： 2.4.2 利用Safe Args目标：SplashFragment通过Safe Args将数据传到RegisterFragment，RegisterFragment接收后显示。 在前面的login_navigation.xml中可以看到里面还有action标签和argument标签。 action标签里面的属性 app:destination：跳转完成到达的fragment的id app:popUpTo：将fragment从栈中弹出，直到某个id的fragment argument标签里面的属性 android:name：标签名字 app:argType：标签的类型 android:defaultValue：默认值 点击Make Project按钮，Android Studio会自动生成两个类： SplashFragment的注册按钮点击事件： 123456btnRegister.setOnClickListener &#123; val action = SplashFragmentDirections .actionWelcomeToRegister() .setEMAIL("TeaOf1995@Gamil.com") findNavController().navigate(action)&#125; RegisterFragment中的接收： 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.ly.allendemojetpack.ui.fragment.loginimport android.os.Bundleimport android.view.LayoutInflaterimport android.view.Viewimport android.view.ViewGroupimport android.widget.Buttonimport android.widget.EditTextimport android.widget.TextViewimport android.widget.Toastimport androidx.fragment.app.Fragmentimport androidx.navigation.fragment.navArgsimport com.ly.allendemojetpack.Rclass RegisterFragment : Fragment() &#123; override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? &#123; return inflater.inflate(R.layout.fragment_register, container, false) &#125; lateinit var cancel: TextView lateinit var register: Button lateinit var emailEt: EditText override fun onViewCreated(view: View, savedInstanceState: Bundle?) &#123; super.onViewCreated(view, savedInstanceState) cancel = view.findViewById(R.id.txt_cancel) register = view.findViewById(R.id.btn_register) emailEt = view.findViewById(R.id.et_email) register.setOnClickListener &#123; Toast.makeText(context, "Register", Toast.LENGTH_SHORT).show() &#125; cancel.setOnClickListener &#123; activity?.onBackPressed() &#125; val safeArgs: RegisterFragmentArgs by navArgs() val email = safeArgs.email emailEt.setText(email) &#125;&#125; 注意这里的navArgs()必须在JVM 1.8 以上，低于此版本会报错，Cannot inline bytecode built with JVM target 1.8 into bytecode that is being built with JVM target 1.6，在Android Studio中，Settings -&gt; Other Settings -&gt; Kotlin Compiler -&gt; Target JVM version，选择1.8及以上，同时在module的build.gradle添加以下： 1234567891011121314android &#123; ...... // 这里也要添加，否则报错 Error: Invoke-customs are only supported starting with Android O (--min-api compileOptions &#123; sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 &#125;&#125;tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).all &#123; kotlinOptions &#123; jvmTarget = "1.8" &#125;&#125; 效果图： 3. 其他Navigation还可以绑定其他，如menu、drawables和bottom navigation，这里以bototm navigation为例，先在navigation目录下创建main_navigation.xml，用之前的MainActivity，修改activity_main.xml如下： 1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity"&gt; &lt;fragment android:id="@+id/my_nav_host_fragment" android:name="androidx.navigation.fragment.NavHostFragment" app:navGraph="@navigation/main_navigation" app:defaultNavHost="true" android:layout_width="match_parent" android:layout_height="0dp" android:layout_weight="1"/&gt; &lt;com.google.android.material.bottomnavigation.BottomNavigationView android:id="@+id/navigation_view" android:layout_width="match_parent" android:layout_height="wrap_content" android:background="@android:color/white" app:itemIconTint="@color/colorAccent" app:itemTextColor="@color/colorPrimary" app:menu="@menu/menu_main"/&gt;&lt;/LinearLayout&gt; MainActivity中的处理也很简单： 12345678910111213141516171819202122232425262728293031323334package com.ly.allendemojetpackimport android.os.Bundleimport androidx.appcompat.app.AppCompatActivityimport androidx.navigation.NavControllerimport androidx.navigation.fragment.NavHostFragmentimport androidx.navigation.ui.setupWithNavControllerimport com.google.android.material.bottomnavigation.BottomNavigationViewclass MainActivity : AppCompatActivity() &#123; lateinit var bottomNavigationView: BottomNavigationView override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) val host: NavHostFragment = supportFragmentManager.findFragmentById(R.id.my_nav_host_fragment) as NavHostFragment val navController = host.navController initWidget() initBottomNavigationView(bottomNavigationView, navController) &#125; private fun initBottomNavigationView(bottomNavigationView: BottomNavigationView, navController: NavController) &#123; bottomNavigationView.setupWithNavController(navController) &#125; private fun initWidget() &#123; bottomNavigationView = findViewById(R.id.navigation_view) &#125;&#125; 效果图： 4. 总结 定义：可简化Android导航的库和插件 功能： 处理Fragment的切换 实现和处理深层连接 绑定Toolbar、BottomNavigationView和DrawableLayout 支持ViewModel Safe Args 准备：Android Studio 3.2及以上 三要素 Navigation Graph 地图 关键标签： navigation fragment action：可以设置动画 argument NavHostFragment：容器 NavController：控制器 跳转 通过fragment id实现跳转 action实现跳转 传参 fragment自带的Bundle Safe Args：类型安全 绑定View：Toolbar、BottomNavigationView和DrawableLayout 深层连接（本文未涉及） Demo地址：Allen_Demo_WebService]]></content>
      <categories>
        <category>Android</category>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>Jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android热修复 Tinker接入与源码浅析（有问题）]]></title>
    <url>%2F2019%2F07%2F29%2FAndroid%E7%83%AD%E4%BF%AE%E5%A4%8D-Tinker%E6%8E%A5%E5%85%A5%E4%B8%8E%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1. 概述现在主流热修复：阿里的AndFix、腾讯的QZone的方案、美团的Robust和腾讯的Tinker。 其中AndFix接入是最简单的，不过兼容性还是问题；QZone对性能有一定影响，在在Art模式下出现内存错乱的问题；美团的Robust是基于Instant Run原理的，兼容性好；Tinker就是用在微信上面的热修复，性能和兼容性不用多说。 这里主要学习腾讯的Tinker和美团的Robust。 本文主要学习Tinker的接入以及对Tinker大致原理的分析。 2. Tinker的接入接入前提（开启混淆模式）： 对于API，一般来说，接入热修复，会在Application的onCreate()中进行一些初始化操，然后在某个地方去调用类似loadPatch这样的API去加载patch文件。 对于patch最简单的生成方式就是通过对比两个APK然后生成；注意，两个APK做对比，需要的前提是，第二次打包混淆使用的mapping.txt文件应该和线上的APK是一致的。 最后看看该项目有没有需要配置混淆的。 Tinker官方文档 2.1 步骤1：添加gradle插件依赖gradle远程仓库依赖jcenter： 123456789buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; // TinkerPatch 插件 classpath "com.tinkerpatch.sdk:tinkerpatch-gradle-plugin:1.2.13.3" &#125;&#125; 注意，在这里SDK使用了fat打包模式，不能再引用任何Tinker的相关 依赖，否则会造成版本冲突。 2.2 步骤2：集成TinkerPatch SDK添加TinkerPatch SDK库的依赖，可以参考Sample中的app/build.gradle： 12345678dependencies &#123; ...... //若使用annotation需要单独引用,对于tinker的其他库都无需再引用 // 可选，用于生成application类 compileOnly("com.tinkerpatch.tinker:tinker-android-anno:1.9.13.3") &#123; changing = true &#125; annotationProcessor("com.tinkerpatch.tinker:tinker-android-anno:1.9.13.3") &#123; changing = true &#125; implementation("com.tinkerpatch.sdk:tinkerpatch-android-sdk:1.2.13.3") &#123; changing = true &#125;&#125; 若使用annotation自动生成Application，需要单独引入Tinker的tiner-android-anno库。除此之外，不需要单独引入tinker的其他库。 为了方便，已经将TinkerPatch相关的配置放到了tinkerpatch.gradle中，所以需要引用：（注释：这块内容还需要整理，有报错！！） 1apply from: 'tinkerpatch.gradle' 2.3 步骤3：配置tinkerpatchSupport参数：（可以不配置，使用默认的）打开前面的tinkerpatcch.gradle文件可以看到如下参数： 123456789101112131415161718192021222324252627tinkerpatchSupport &#123; /** 可以在debug的时候关闭 tinkerPatch **/ tinkerEnable = true /** 是否使用一键接入功能 **/ reflectApplication = true /** 是否开启加固模式，只有在使用加固时才能开启此开关 **/ protectedApp = false /** 补丁是否支持新增 Activity (新增Activity的exported属性必须为false)**/ supportComponent = false autoBackupApkPath = "$&#123;bakPath&#125;" /** 在tinkerpatch.com得到的appKey **/ appKey = "yourAppKey" /** 注意: 若发布新的全量包, appVersion一定要更新 **/ appVersion = "1.0.0" def pathPrefix = "$&#123;bakPath&#125;/$&#123;baseInfo&#125;/$&#123;variantName&#125;/" def name = "$&#123;project.name&#125;-$&#123;variantName&#125;" baseApkFile = "$&#123;pathPrefix&#125;/$&#123;name&#125;.apk" baseProguardMappingFile = "$&#123;pathPrefix&#125;/$&#123;name&#125;-mapping.txt" baseResourceRFile = "$&#123;pathPrefix&#125;/$&#123;name&#125;-R.txt"&#125; 具体含义如下： 参数 默认值 描述 tinkerEnable true 是否开启tinkerpatchSupport插件功能 appKey “” 在TinkerPatch平台申请的appKey appVersion “” 在TinkerPatch平台输入的版本号。注意：使用appVerison作为TinkerId，需要保证每个发布出去的基础安装包的appVersion都不一样。 reflectApplication false 是否反射Application autoBackupAppPath “” 将每次编译产生的apk/mapping.txt/R.txt归档存储的位置 baseApkFile “” 基准包的文件路径，对应tinker插件中的oldApk参数；编译补丁包时，必须指定基准版本的apk，默认值为空，表示不进行补丁包的编译 baseProguardMappingFile “” 基准包的Proguard mapping.txt文件路径，对应tinker插件appliMapping参数；在编译新的apk时，希望通过基准apk的proguard混淆方式，从而减小补丁包的大小。编译补丁包时，推荐输入基准apk生成的mapping.txt文件 baseResourceRFile “” 基准包的资源R.txt文件路径，对应tinker插件applyResourceMapping参数；在编译新的apk时，希望通过基准apk的R.txt文件来保存Resource Id的分配，这样不仅可以减少补丁包的大小，同时也能避免由于Resource Id改变导致remote view异常 protectedApp false 是否开启加固支持，注意：只有在使用加固支持时才能开启此开关 supportComponent false 是否开启支持在补丁包中动态增加Activity，注意：新增Activity的exported属性必须设置为false backupFileNameFormat ‘${appName}-${variantName}’ 格式化命名备份文件，这里要使用单引号 一般来说，不需要修改引用Android的编译配置，也不用修改tinker插件原来的配置。对于需要特殊配置，参考接入指南 2.4 初始化TinkerPatch SDK reflectApplication = true：这时，无需为Tinker而改造Application。12345678910111213141516171819202122public class SampleApplication extends Application &#123; ... @Override public void onCreate() &#123; super.onCreate(); // 我们可以从这里获得Tinker加载过程的信息 tinkerApplicationLike = TinkerPatchApplicationLike.getTinkerPatchApplicationLike(); // 初始化TinkerPatch SDK, 更多配置可参照API章节中的,初始化SDK TinkerPatch.init(tinkerApplicationLike) .reflectPatchLibrary() .setPatchRollbackOnScreenOff(true) .setPatchRestartOnSrceenOff(true) .setFetchPatchIntervalByHours(3); // 每隔3个小时(通过setFetchPatchIntervalByHours设置)去访问后台时候有更新,通过handler实现轮训的效果 TinkerPatch.with().fetchPatchUpdateAndPollWithInterval(); &#125; ... 将Tinker加载补丁过程的结果放在TinkerPatchApplicationLike中。 reflectApplication = false（一般使用）：API主要就是初始化和loadPatch()。 通常情况下，会考虑在Application的onCreate()中初始化，但Tinker推荐下面的写法： 123456789101112131415161718192021222324252627282930313233343536373839package com.ly.allendemotinker;import android.app.Application;import android.content.Context;import android.content.Intent;import com.tencent.tinker.anno.DefaultLifeCycle;import com.tencent.tinker.entry.DefaultApplicationLike;import com.tencent.tinker.lib.tinker.TinkerInstaller;import com.tencent.tinker.loader.shareutil.ShareConstants;/** * 初始化TinkerPatch SDK * * @author Liuyang * @date 2019/7/29 */@DefaultLifeCycle(application = ".SampleApplication", flags = ShareConstants.TINKER_ENABLE_ALL, loadVerifyFlag = false)public class SampleApplicationLike extends DefaultApplicationLike &#123; public SampleApplicationLike(Application application, int tinkerFlags, boolean tinkerLoadVerifyFlag, long applicationStartElapsedTime, long applicationStartMillisTime, Intent tinkerResultIntent) &#123; super(application, tinkerFlags, tinkerLoadVerifyFlag, applicationStartElapsedTime, applicationStartMillisTime , tinkerResultIntent); &#125; @Override public void onBaseContextAttached(Context base) &#123; super.onBaseContextAttached(base); &#125; @Override public void onCreate() &#123; super.onCreate(); TinkerManager.installedTinker(this); &#125;&#125; Tinker建议编写一个ApplicationLike的子类，可以当成Application去使用，顶部的注解@DefaultLifeCycle，其中application属性，会在编译期生成一个SimpleTinkerInApplication类。 所以，实际上Application会在编译期生成，所以AndroidManifest.xml中是这样的： 123&lt;application android:name=".SampleApplication" .../&gt; 编译报红，build一下就可以。 实际上，注解的背后有一个Annotation Processor的处理，具体原理可以查看Android 如何编写基于编译时注解的项目。 2.5 创建一个ApplicationLike代理类：实现对Tinker的管理，TinkerManager： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.ly.allendemotinker;import android.content.Context;import com.tencent.tinker.lib.tinker.Tinker;import com.tencent.tinker.lib.tinker.TinkerInstaller;/** * Tinker管理类 * * @author Liuyang * @date 2019/7/29 */public class TinkerManager &#123; private static boolean mIsInstalled = false; private static ApplicationLike mApplicationLike; /** * 完成Tinker初始化 */ public static void installedTinker(ApplicationLike applicationLike) &#123; mApplicationLike = applicationLike; if (mIsInstalled) &#123; return; &#125; TinkerInstaller.install(mApplicationLike); mIsInstalled = true; &#125; /** * 完成patch文件的加载 * * @param path 补丁文件路径 */ public static void loadPatch(String path) &#123; // 是否已经安装过 if (Tinker.isTinkerInstalled()) &#123; TinkerInstaller.onReceiveUpgradePatch(getApplicationContext(), path); &#125; &#125; /** * 利用Tinker代理Application 获取应用全局的上下文 * * @return 全局的上下文 */ private static Context getApplicationContext() &#123; if (mApplicationLike != null) return mApplicationLike.getApplication().getApplicationContext(); return null; &#125;&#125; 2.6 AndroidManifest.xml配置123456789101112131415161718192021222324252627282930313233&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" package="com.ly.allendemotinker"&gt; &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt; &lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" /&gt; &lt;application android:name=".Application" android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:roundIcon="@mipmap/ic_launcher_round" android:supportsRtl="true" android:theme="@style/AppTheme" tools:ignore="GoogleAppIndexingWarning"&gt; &lt;activity android:name=".MainActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;!-- 这个标签开判断我们生成的patch的.apk文件中的tinker_id_XXX 与我们的版本号tinker_id_XXX比较。相同合法，不同则不会进行更新 --&gt; &lt;meta-data android:name="TINKER_ID" android:value="tinker_id_6235657" /&gt; &lt;/application&gt;&lt;/manifest&gt; 在这里加上必要的权限，然后设置andorid:name = &quot;.Application&quot;，最后配置TINKER_ID属性，里面的数字部分一般是versionCode。 2.7 生成差异apk文件首先生成old.apk。布局文件：activity_main.xml： 123456789101112131415161718&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity"&gt; &lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:onClick="loadPatch" android:text="热修复" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent" app:layout_constraintTop_toTopOf="parent" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 代码文件：MainActivity.java： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.ly.allendemotinker;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import java.io.File;/** * @author Liuyang * @date 2019/7/29 */public class MainActivity extends AppCompatActivity &#123; /** * 文件后缀 */ private static final String FILE_END = ".apk"; /** * 文件路径 */ private String mFileDir; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // /storage/emulated/0/Android/data/com.ly.allendemotinker/cache/demo_patch/ mFileDir = getExternalCacheDir().getAbsolutePath() + "/demo_patch/"; // 创建路径对应的文件夹 File file = new File(mFileDir); if (!file.exists()) &#123; file.mkdir(); &#125; &#125; public void loadPatch(View view) &#123; TinkerManager.loadPatch(getPatchName()); &#125; public String getPatchName() &#123; return mFileDir.concat("tinker").concat(FILE_END); &#125;&#125; 打包成old.apk，然后修改布局代码如下： 1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity"&gt; &lt;Button android:id="@+id/button" android:layout_width="wrap_content" android:layout_height="wrap_content" android:onClick="loadPatch" android:text="热修复" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent" app:layout_constraintTop_toTopOf="parent" /&gt; &lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="测试" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toBottomOf="@+id/button" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 其他不用修改，打包成new.apk。 2.8 命令行生成补丁文件Tinker官方提供了命令行工具： 将前面生成的两个apk文件和签名文件复制到该目录下（.keystore是eclipse的签名文件，.jks是Andorid Studio的签名文件，可以直接修改后缀，不影响使用），然后输入下面的命令： 参考： https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650821993&amp;idx=1&amp;sn=550a90e30a398bbb652ecd65209b62e2&amp;chksm=80b781f7b7c008e17d9f5a59542f46329d28cbcd2ec075d4c2d44784f789135166a4e1949303&amp;scene=38#wechat_redirect https://www.jianshu.com/p/d649fc014919]]></content>
      <categories>
        <category>Android</category>
        <category>热修复</category>
      </categories>
      <tags>
        <tag>热修复</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android代码混淆]]></title>
    <url>%2F2019%2F07%2F27%2FAndroid%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%2F</url>
    <content type="text"><![CDATA[在Android日常开发中，混淆是必不可少的。 1. 混淆简介代码混淆：Obfuscated code，是将程序中的代码以某种规则转换为难以阅读和理解的代码的一种行为。 1.1 混淆的好处好处就是目的：令APK难以被逆向工程，即很大程度上增加反编译的成本。此外，Android中的“混淆”还能在打包时移除没用的资源，显著减小APK的体积。最后，还能以变通方式避免Anddroid中常见的64k方法数引用的限制。 先看看APK混淆前后的结构对比： 从上面两张图可以看出：经过混淆后，APK中的包名、类名、成员名等都被替换为随机、无意义的名称，增加了代码阅读和理解的难度，提高反编译的成本。混淆前后APK的大小也从2.7M下降到1.4M。 2. Android中的混淆在Android中，平时说的“混淆”其实包含两层意思，一是Java代码的混淆，二是资源的压缩。 2.1 开启混淆12345678910......android &#123; buildTypes &#123; release &#123; minifyEnabled true shrinkResources true proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125;&#125; 以上就是开启混淆的基本操作，通过minifyEnabled设置为true来开启混淆。同时，可以设置shrinkResources为true来开启资源的压缩。一般在打release包时才会开启混淆，因为混淆会增加额外的编译时间，所以不建议在debug下启用。此外，需要注意：只有在开启混淆的前提下开启资源压缩才有效果。以上代码中的proguard-android.txt表示Android系统提供的默认混淆规则文件，而proguard-rules.pro是我们自定义的混淆规则。下面讲解如何自定义混淆规则。 2.2 代码混淆Java平台提供了Proguard工具来帮助我们快速地对代码进行混淆。根据Java官方介绍，Proguard对应的具体中文定义如下： 它是一个包含代码文件压缩、优化、混淆和校验等功能的工具； 它能检测并删除无用的类、变量、方法和属性； 它能优化字节码并删除未使用的指令； 它能将类、变量和方法的名字重命名为无意义的名称从而达到混淆效果； 它会校验处理后的代码，只有针对Java 6及以上的版本和Java ME。 2.3 资源压缩在Android中，编译提供了另一个功能：资源压缩。资源压缩能帮助移除项目和仓库中未使用到的资源，有效降低APK的大小，。由于资源压缩与代码混淆是协同工作，所以，如果要开启资源压缩，一定要先开启代码混淆，否则会报错： 12ERROR: Removing unused resources requires unused code shrinking to be turned on. See http://d.android.com/r/tools/shrink-resources.html for more information.Affected Modules: app 2.4 自定义要保留的资源开启资源压缩后，系统默认会移除所有未使用的资源，如果要保留特定的资源，可以在项目中创建一个被&lt;resources&gt;标记的XML文件（如，res/raw/keep.xml），并在tools:keep属性中指定每个要保留的资源，在tools:discard属性中指定每个要舍弃的资源。这两个属性都接受逗号分隔的资源名称列表。同样，可以使用*作为通配符。如： 1234&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources xmlns:tools="http://schemas.android.com/tools" tools:keep="@layout/activity_video*,@layout/dialog_update_v2" tools:discard="@layout/unused_layout,@drawable/unused_selector" /&gt; 2.5 启用严格检查模式通常， 资源压缩器可以准确判定系统是否使用了资源。但，如果代码（包含库）调用了Resources.getIdentifier()，这就表示代码将根据动态生成的字符串查询名称。这时，资源压缩器会采取防御性行为，将所有具有匹配名称格式的资源标记为可能已使用，无法移除。如，以下代码会使所有带img_前缀的资源标记为已使用： 12String name = String.format("img_%1d", angle + 1);res = getResources().getIdentifier(name, "drawable", getPackageName()); 这时，可以启用严格检查模式，只会保留确定已经使用的资源。 2.6 移除备用资源Gradle资源压缩器只会移除未被应用引用的资源，意味着它不会移除用于不同设备配置的备用资源。必要时，可以使用Android Gradle插件的resCOnfigs属性来移除应用中不需要的备用资源文件（常见的有用于国际化支持的strings.xml，适配用的layout.xml等）。 1234567android &#123; defaultConfig &#123; ... //保留中文和英文国际化支持 resConfigs "en", "zh" &#125;&#125; 3. 自定义混淆规则先了解常用的混淆命令： 3.1 keep命令指一系列以-keep开头的命令，主要是用来保留Java中不需要进行混淆的元素。以下是常见的-keep命令： -keep：作用：保留指定的类和成员，防止被混淆处理。如： 12345# 保留包：com.moos.media.entity 下面的类以及类成员-keep public class com.moos.media.entity.**# 保留类：NumberProgressBar-keep public class com.moos.media.widget.NumberProgressBar &#123;*;&#125; -keepclassmembers：作用：保留指定的类的成员（变量/方法），它们将不会被混淆。如： 12345# 保留类的成员：MediaUtils类中的特定成员方法-keepclassmembers class com.moos.media.MediaUtils &#123; public static *** getLocalVideos(android.content.Context); public static *** getLocalPictures(android.content.Context);&#125; -keepclasseswithmembers：作用：保留指定的类及其成员（变量/方法），前提是它们在压缩阶段没有被删除。与-keep使用方式类似： 12345# 保留类：BaseMediaEntity 的子类-keepclasseswithmembers public class * extends com.moos.media.entity.BaseMediaEntity&#123;*;&#125;# 保留类：OnProgressBarListener接口的实现类-keep public class * implements com.moos.media.widget.OnProgressBarListener &#123;*;&#125; @keep：除了以上的方式，还可以使用@keep注解来保留代码，防止它们被混淆处理。比如，通过@keep来修饰一个类来保留它不被混淆： 123456@Keepdata class CloudMusicBean(var createDate: String, var id: Long, var name: String, var url: String, val imgUrl: String) 也可以修饰方法或字段进行保留。 3.2 其他命令 dontwarn-dontwarn命令一般在引入新的library时会用到，常用于处理library中无法解决的警告。如： 123-keep class twitter4j.** &#123; *; &#125;-dontwarn twitter4j.** 其他命令用法可以参考Android系统提供的默认混淆规则： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#混淆时不生成大小写混合的类名-dontusemixedcaseclassnames#不跳过非公共的库的类-dontskipnonpubliclibraryclasses#混淆过程中记录日志-verbose#关闭预校验-dontpreverify#关闭优化-dontoptimize#保留注解-keepattributes *Annotation*#保留所有拥有本地方法的类名及本地方法名-keepclasseswithmembernames class * &#123; native &lt;methods&gt;;&#125;#保留自定义View的get和set方法-keepclassmembers public class * extends android.view.View &#123; void set*(***); *** get*();&#125;#保留Activity中View及其子类入参的方法，如: onClick(android.view.View)-keepclassmembers class * extends android.app.Activity &#123; public void *(android.view.View);&#125;#保留枚举-keepclassmembers enum * &#123; **[] $VALUES; public *;&#125;#保留序列化的类-keepclassmembers class * implements android.os.Parcelable &#123; public static final android.os.Parcelable$Creator CREATOR;&#125;#保留R文件的静态成员-keepclassmembers class **.R$* &#123; public static &lt;fields&gt;;&#125;-dontwarn android.support.**-keep class android.support.annotation.Keep-keep @android.support.annotation.Keep class * &#123;*;&#125;-keepclasseswithmembers class * &#123; @android.support.annotation.Keep &lt;methods&gt;;&#125;-keepclasseswithmembers class * &#123; @android.support.annotation.Keep &lt;fields&gt;;&#125;-keepclasseswithmembers class * &#123; @android.support.annotation.Keep &lt;init&gt;(...);&#125; 更多混淆命令可以参考文章：ProGuard 最全混淆规则说明 4. 不能混淆的部分哪些内容应该混淆？其实，在使用代码混淆时，ProGuard对项目大部分代码进行了混淆操作，为防止编译出错，应该通过-keep命令保留一些元素不被混淆。所以需要知道哪些元素不应该被混淆： 4.1 枚举枚举不能参与到混淆中，原因是：枚举内部存在values方法，混淆后该方法会被重新命名，并抛出NoSuchMethodException。Android系统默认的混淆规则中已经添加了对枚举类的处理，无需额外进行处理。 4.2 被反射的元素被反射使用的类、方法、变量、包名等不能被混淆，原因是：代码混淆过程中，被反射的元素会被重命名，而反射依旧按照先前的名称去查找元素，会发生NoSuchMethodException和NoSuchFieldException。 4.3 实体类实体类通常会伴随着序列化和反序列化操作。混合是将原本有特定含义的“元素”转成无意义的名称，所以，经过混淆之后，序列化之后的value对应的key已经变成没有意义的字段。同时，反序列化的过程创建对象从根本上还是借助反射，混淆后key会被改变，所以实体类通常也不能混淆。 4.4 四大组件Android中的四大组件也不能被混淆，原因是： 四大组件使用前都需要在AndroidManifest.xml文件中进行注册声明，然而混淆处理后，四大组件的类名就会被更改，实际使用的类与AndroidMainifest.xml中注册的类不匹配，会报错。 其他应用程序访问组件时，可能会用到类的包名和类名，经过混淆，可能会找不到对应的组件而产生异常。 4.5 JNI调用的Java方法当JNI调用的Java方法被混淆后，方法名会变成无意义的名称，这就与C++中原本的Java方法名不匹配，因而无法找到所调用的方法。 4.6 其他不应被混淆的 自定义控件不能被混淆 JavaScript调用Java的方法不应被混淆 Java的native方法不应被混淆 项目中引用的第三方库不建议混淆 5. 混淆后的堆栈跟踪代码经过ProGuard混淆处理后，想要读取StackTrace（堆栈追踪）信息就会变得困难。由于方法名和类名都经过混淆处理，即使程序崩溃，也很难定位问题。但是，ProGuard提供了补救的措施，先来看看ProGuard每次构建后生成哪些内容。 5.1 混淆输出结果混淆构建完成之后，会在&lt;module-name&gt;/build/outputs/mapping/release/目录下生成以下文件： dump.txt：说明APK内所有类文件的内部结构。 mapping.txt：提供混淆前后的内容对照表，内容主要包括类、方法和类的成员变量。 seeds.txt：罗列出未进行混淆处理的类和成员。 usage.txt：罗列出从APK移除的代码。 5.2 恢复堆栈跟踪前面的遗留问题：混淆处理后，StackTrace定位困难。如何恢复StackTrace的定位能力？系统提供了retrace工具，结合上面定义的mapping.txt文件，就可以将混淆后的崩溃堆栈追踪器信息还原成正常情况下的StackTrace信息。主要有两种方式来恢复SrackTrace，为了方便理解，以下面的崩溃信息为例，协助两种方式分别进行还原： 123456java.lang.RuntimeException: Unable to start activity Caused by: kotlin.KotlinNullPointerException at com.moos.media.ui.ImageSelectActivity.k(ImageSelectActivity.kt:71) at com.moos.media.ui.ImageSelectActivity.onCreate(ImageSelectActivity.kt:58) at android.app.Activity.performCreate(Activity.java:6237) at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1107) 通过retrace脚本工具 首先进入Android SDK路径的tools/proguard/bin中： 可以看到里面有三个文件，而proguardgui.bat就是需要的retrace脚本。双加该脚本文件，运行，即可看到： 选择Retrace栏，添加项目中混淆生成的mapping.txt文件所在位置，然后将混淆后的崩溃信息复制到Obfuscated stack trace一栏，点击Retrace，即可还原出崩溃日志信息。 通过retrace命令行首先将崩溃信息复制到.txt文件中，然后执行下面命令：1retrace.bat -verbose mapping.txt proguard_stacktrace.txt 最终还原结果和之前效果相同： 在对stackTrace进行恢复时，发现unknown Source问题： 在混淆规则上添加如下配置来提升StackSource查找效率， 12# 保留源文件名和具体代码行号-keepattributes SourceFile,LineNumberTable 此外，每次使用ProGuard创建发布构建时都会覆盖之前版本的mapping.txt文件，因此，每次发布一个新版本时，建议保存一个副本。通过为每个发布构建保留一个mapping.txt文件副本，就可以在用户提交的已混淆的StackTrace来对旧版本应用的问题进行调试和修复。 6. 其他操作前面介绍到，APK在经过代码混淆处理后，包名、类名、成员名被转化为无意义、难以理解的名称，增加反编译的成本。Android ProGuard提供了默认的“混淆字典”，即将元素名称转为英文小写字母的形式。那么，可以定义自己的混淆字典吗？先看一张效果图： 只要生成一套自己的.txt格式的混淆字典，然后在混淆规则Proguard-rules.pro中应用下即可：]]></content>
      <categories>
        <category>Android</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>代码混淆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android实现RecyclerView自动滚动]]></title>
    <url>%2F2019%2F07%2F27%2FAndroid%E5%AE%9E%E7%8E%B0RecyclerView%E8%87%AA%E5%8A%A8%E6%BB%9A%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[实现功能：使用RecyclerView实现垂直滚动效果。 1. 自定义RecyclerView实现滚动效果12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package com.ly.allendemoautopollrecyclerview;import android.annotation.SuppressLint;import android.content.Context;import android.support.annotation.NonNull;import android.support.annotation.Nullable;import android.support.v7.widget.RecyclerView;import android.util.AttributeSet;import android.view.MotionEvent;import java.lang.ref.WeakReference;/** * 自定义垂直滚动RecyclerView * * @author Liuyang * @date 2019/7/27 */public class AutoPollRecyclerView extends RecyclerView &#123; private static final long TIME_AUTO_POLL = 16; private AutoPollTask mAutoPollTask; /** * 标示是否正在自动轮询 */ private boolean mRunning; /** * 标示是否可以自动轮询，可在不需要的是否置false */ private boolean mCanRun; public AutoPollRecyclerView(@NonNull Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); mAutoPollTask = new AutoPollTask(this); &#125; static class AutoPollTask implements Runnable &#123; private final WeakReference&lt;AutoPollRecyclerView&gt; mReference; /** * 使用弱引用持有外部引用，放置内存泄露 */ AutoPollTask(AutoPollRecyclerView reference) &#123; mReference = new WeakReference&lt;&gt;(reference); &#125; @Override public void run() &#123; AutoPollRecyclerView recyclerView = mReference.get(); if (recyclerView != null &amp;&amp; recyclerView.mRunning &amp;&amp; recyclerView.mCanRun) &#123; recyclerView.scrollBy(2, 2); recyclerView.postDelayed(recyclerView.mAutoPollTask, TIME_AUTO_POLL); &#125; &#125; &#125; /** * 开启：如果正在运行，则先停止，再开始 */ public void start() &#123; if (mRunning) &#123; stop(); &#125; mCanRun = true; mRunning = true; postDelayed(mAutoPollTask, TIME_AUTO_POLL); &#125; /** * 停止 */ public void stop() &#123; mRunning = false; removeCallbacks(mAutoPollTask); &#125; @SuppressLint("ClickableViewAccessibility") @Override public boolean onTouchEvent(MotionEvent e) &#123; switch (e.getAction()) &#123; case MotionEvent.ACTION_DOWN: if (mRunning) &#123; stop(); &#125; break; case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: case MotionEvent.ACTION_OUTSIDE: if (mCanRun) &#123; start(); &#125; break; default: break; &#125; return super.onTouchEvent(e); &#125;&#125; 2. 实现Adapter1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.ly.allendemoautopollrecyclerview;import android.annotation.SuppressLint;import android.content.Context;import android.support.annotation.NonNull;import android.support.v7.widget.RecyclerView;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.TextView;import java.util.List;public class AutoPollAdapter extends RecyclerView.Adapter&lt;AutoPollAdapter.BaseViewHolder&gt; &#123; private final Context mContext; private final List&lt;AutoScrollLuckyListReq.DatasBean&gt; mData; public AutoPollAdapter(Context context, List&lt;AutoScrollLuckyListReq.DatasBean&gt; data) &#123; mContext = context; mData = data; &#125; @NonNull @Override public BaseViewHolder onCreateViewHolder(@NonNull ViewGroup viewGroup, int i) &#123; View view = LayoutInflater.from(mContext).inflate(R.layout.auto_list_item, viewGroup, false); return new BaseViewHolder(view); &#125; @SuppressLint("SetTextI18n") @Override public void onBindViewHolder(@NonNull BaseViewHolder baseViewHolder, int position) &#123; AutoScrollLuckyListReq.DatasBean datasBean = mData.get(position % mData.size()); baseViewHolder.content.setText(datasBean.getPhone() + " 获得 " + datasBean.getGiftName()); &#125; @Override public int getItemCount() &#123; return Integer.MAX_VALUE; &#125; class BaseViewHolder extends RecyclerView.ViewHolder &#123; TextView content; BaseViewHolder(View itemView) &#123; super(itemView); content = itemView.findViewById(R.id.content); &#125; &#125;&#125; 3. 适配器布局文件12345678910111213141516171819202122&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="wrap_content" android:background="#fffcf5" android:orientation="vertical"&gt; &lt;TextView android:id="@+id/content" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginTop="8dp" android:layout_marginBottom="8dp" android:text="135xxxx8888 获得 8积分" android:textColor="#797762" android:textSize="14sp" /&gt; &lt;View android:layout_width="match_parent" android:layout_height="1dp" android:background="#797762" /&gt;&lt;/LinearLayout&gt; 4. 调用布局文件：activity_main.xml： 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity"&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="150dp" android:layout_centerInParent="true" android:layout_marginLeft="15dp" android:layout_marginTop="15dp" android:layout_marginRight="15dp" android:background="@drawable/luckyer_bg"&gt; &lt;RelativeLayout android:layout_width="40dp" android:layout_height="wrap_content" android:layout_marginStart="23dp" android:layout_marginTop="1dp" android:layout_marginBottom="1dp" android:background="#fff6ea"&gt; &lt;ImageView android:layout_width="wrap_content" android:layout_height="match_parent" android:layout_centerInParent="true" android:padding="10dp" android:src="@drawable/zhongjiangzhemingdan" /&gt; &lt;/RelativeLayout&gt; &lt;com.ly.allendemoautopollrecyclerview.AutoPollRecyclerView android:id="@+id/recyclerview" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_margin="20dp" /&gt; &lt;/LinearLayout&gt;&lt;/RelativeLayout&gt; Java文件：MainActivity.java： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129package com.ly.allendemoautopollrecyclerview;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.support.v7.widget.LinearLayoutManager;import com.alibaba.fastjson.JSON;/** * @author Liuyang * @date 2019/7/27 */public class MainActivity extends AppCompatActivity &#123; private AutoPollRecyclerView mRecyclerView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); initData(); &#125; private void initView() &#123; mRecyclerView = findViewById(R.id.recyclerview); mRecyclerView.setLayoutManager(new LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false)); &#125; private void initData() &#123; String response = "&#123;\n" + " \"datas\": [\n" + " &#123;\n" + " \"giftName\": \"20个积分\",\n" + " \"phone\": \"****\"\n" + " &#125;,\n" + " &#123;\n" + " \"giftName\": \"20个积分\",\n" + " \"phone\": \"****\"\n" + " &#125;,\n" + " &#123;\n" + " \"giftName\": \"满10减1元\",\n" + " \"phone\": \"****\"\n" + " &#125;,\n" + " &#123;\n" + " \"giftName\": \"20个积分\",\n" + " \"phone\": \"****\"\n" + " &#125;,\n" + " &#123;\n" + " \"giftName\": \"20个积分\",\n" + " \"phone\": \"****\"\n" + " &#125;,\n" + " &#123;\n" + " \"giftName\": \"满10减1元\",\n" + " \"phone\": \"****\"\n" + " &#125;,\n" + " &#123;\n" + " \"giftName\": \"20个积分\",\n" + " \"phone\": \"****\"\n" + " &#125;,\n" + " &#123;\n" + " \"giftName\": \"满10减1元\",\n" + " \"phone\": \"****\"\n" + " &#125;,\n" + " &#123;\n" + " \"giftName\": \"满10减1元\",\n" + " \"phone\": \"****\"\n" + " &#125;,\n" + " &#123;\n" + " \"giftName\": \"三花便签（20枚）\",\n" + " \"phone\": \"****\"\n" + " &#125;,\n" + " &#123;\n" + " \"giftName\": \"三花便签（20枚）\",\n" + " \"phone\": \"****\"\n" + " &#125;,\n" + " &#123;\n" + " \"giftName\": \"满10减1元\",\n" + " \"phone\": \"****\"\n" + " &#125;,\n" + " &#123;\n" + " \"giftName\": \"20个积分\",\n" + " \"phone\": \"****\"\n" + " &#125;,\n" + " &#123;\n" + " \"giftName\": \"满10减1元\",\n" + " \"phone\": \"****\"\n" + " &#125;,\n" + " &#123;\n" + " \"giftName\": \"20个积分\",\n" + " \"phone\": \"****\"\n" + " &#125;,\n" + " &#123;\n" + " \"giftName\": \"三花便签（20枚）\",\n" + " \"phone\": \"****\"\n" + " &#125;,\n" + " &#123;\n" + " \"giftName\": \"三花便签（20枚）\",\n" + " \"phone\": \"****\"\n" + " &#125;,\n" + " &#123;\n" + " \"giftName\": \"满10减1元\",\n" + " \"phone\": \"****\"\n" + " &#125;,\n" + " &#123;\n" + " \"giftName\": \"20个积分\",\n" + " \"phone\": \"****\"\n" + " &#125;,\n" + " &#123;\n" + " \"giftName\": \"20个积分\",\n" + " \"phone\": \"****\"\n" + " &#125;\n" + " ],\n" + " \"msg\": \"success\",\n" + " \"ret\": 0\n" + "&#125;"; AutoScrollLuckyListReq autoScrollLuckyListReq = JSON.parseObject(response, AutoScrollLuckyListReq.class); // 0为请求成功 if (autoScrollLuckyListReq.getRet() == 0) &#123; AutoPollAdapter autoPollAdapter = new AutoPollAdapter(getApplicationContext(), autoScrollLuckyListReq.getDatas()); mRecyclerView.setAdapter(autoPollAdapter); // 启动滚动 mRecyclerView.start(); &#125; &#125;&#125; 5. 效果和Demo地址 Demo地址：Allen_Demo_AutoPollRecyclerView]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蘸水牛肉]]></title>
    <url>%2F2019%2F07%2F27%2F%E8%98%B8%E6%B0%B4%E7%89%9B%E8%82%89%2F</url>
    <content type="text"><![CDATA[【食材】：牛腱子两斤，老姜一大块，花椒四五十粒， 食盐适量，大蒜泥适量、调味盐、味精适量，红油辣子一大勺，花椒面适量，藤椒油适量，芝麻油适量，香葱花适量。 流程： 牛腱子用洗水浸泡两三个小时，尽量泡出肉的的血水，因为肉中血水多，肉的腥味就比较重，不好吃； 浸泡好的牛肉入冷水锅，中火煮开后，再煮两分钟； 经过稍稍煮过的牛肉会紧缩一团，我们从锅中取出肉，再用温水冲洗干净牛肉表面的血污，再控干水分，以上几个步骤的目的都是尽量去除肉中的血污，让肉的味道更鲜美，而没有腥味； 砂锅中放入前面处理好的牛肉，再加入纯净水或矿泉水，再加入一块用刀拍破的老姜和花椒粒，以及适量的食盐，开 大火烧开后，转小火盖上锅盖煮，大约一个小时左右； 煮一个小时左右，我们用一根筷子插肉，如果可以轻松插入牛肉肉中就差不多了； 我们再把牛肉从锅中取出，彻底晾凉后再切成薄片备用； 取一个碗，碗中加入大蒜泥，红油辣子（最好是近期制作的在，时间长了不香），适量的花面和藤椒油卡 ，还要加上适量的调味盐（虽然前面煮肉时加过盐，但比较淡，这里还是需要加少量的调味盐），最后我们还要加入，适量的味精、芝麻油、香葱花，再搅拌匀就可以蘸牛肉了。]]></content>
      <categories>
        <category>美食</category>
      </categories>
      <tags>
        <tag>美食</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[豆角焖面]]></title>
    <url>%2F2019%2F07%2F27%2F%E8%B1%86%E8%A7%92%E7%84%96%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[主料：圆滚豆角一小把切成丁，五花肉适量切成末，细刀切面适量 配料：泡发好的香菇4、5朵切丁，胡萝卜一小段切丁，葱末、姜米、蒜米，香菜碎，八角一朵，干红辣椒4、5只 酱汁：另准备4、5瓣大蒜切米放入碗中，加适量青葱碎，里面放入两匙酱油，一匙陈醋，1\3匙白糖 调成酱汁备用 流程： 热锅凉油，油温7、8层热时放入八角爆香，下肉末煸炒，肉末变色断生后放入干红辣椒翻炒几下，依次加入姜末、葱末、蒜末，翻炒出香味后加入适量酱油和少许盐，加稍多些水，烧开后慢火炖煮10分钟； 冲调酱汁：10分钟后将锅里面的汤一勺一勺舀出，冲倒在酱汁碗中； 锅内留少许汤汁，以不没过豆角为限，将刀切面疏散的铺在豆角上面，尽量不要贴在锅壁上，防粘和糊； 将冲调好的酱汁分三次均匀淋在面条上，每次间隔3分钟； 9分钟后关火，在面条上淋少许香油，撒上香菜碎，用筷子轻轻将面条拨散拌匀，装盘上桌。 搭配上橄榄油沙拉和花生米，营养很均衡。]]></content>
      <categories>
        <category>美食</category>
      </categories>
      <tags>
        <tag>美食</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二、Android XML数据解析]]></title>
    <url>%2F2019%2F07%2F26%2F%E4%BA%8C%E3%80%81Android-XML%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1. XML数据要点介绍XML，可扩展标记语言。可以用来存储数据，可以看做是一个小型的数据库，SharedPreference就是使用XML文件存储数据的，SQLite底层也是一个XML文件，而在网络应用方面，通常作为信息的载体，通常把数据包装成XML来传递。 123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt; -----文档开始&lt;persons&gt; -----开始元素(persons) &lt;person id = "11"&gt; -----文本节点（空白文本） 开始元素(person)属性 &lt;name&gt;Coder-pig&lt;/name&gt; -----文本节点（空白文本） 开始元素(name)属性 结束元素 &lt;age&gt;18&lt;/age&gt; -----文本节点（空白文本） 开始元素(age)属性 结束元素 &lt;/person&gt; -----文本节点（空白文本） 结束元素 &lt;person id = "13"&gt; &lt;name&gt;Jay&lt;/name&gt; &lt;age&gt;20&lt;/age&gt; &lt;/person&gt;&lt;/persons&gt; -----结束元素(persons) -----文档结束 上面就简单的定义了一个存储person对象的xml文件的编码，注意，外面的空白区域也是文本节点。 2. 三种解析XML方法的比较2.1 SAX解析XML对文档进行顺序扫描，当扫描到文档(doucument)开始与结束、元素(element)开始与结束等地方时，通知事件处理函数，由事件处理函数做相对应动作，然后继续进行同样的扫描，直至文档结束。解释速度快，占用内存小，，每需要解析一类XML，就需要编写新的适合该类的XML处理类，比较麻烦。采用的是流式解析，解析是同步的，读到哪就处理到哪。 2.2 Dom解析XML先把XML文档读取到内存中，然后再用DOM API来访问树形结构，并获取数据。这个写起来很简单，但是很消耗内存，假如读取的数据量大，手机内存不够的话，可能导致手机死机。不建议在Android设备中使用，解析简单的XML可以。常用的五个接口与类：Docculem、Element、Node、NodeList、DOMParser，Don是整个文件解析到内存中，供用户需要的节点信息，支持随机访问。 2.3 pull解析XMLXML pull提供了开始元素和结束元素。当某个元素开始时，可以调用parser、nextText从XML文档中提取所有字符数据。当解析到文档结束时，自动生成EndDocument。常用接口和类：XmlPullParser、XmlSerializer、XmlPullParserFactory。和SAX差不多，代码实现比较简单，非常适合移动设备，Android系统内置pull解析器，而且Android系统内部默认使用pull来解析XML文件。 3. SAX解析XMLSAX是一个解析速度快且占用内存少的XML解析器，非常适合用于Android等移动设备；SAX解析XML文件采用的是事件驱动，也就是说不需要解析整个文档，而是在解析过程中，判断读取的字符是否符合XML语法的某部分（文档开头，文档结束，或者标签开头和标签结束），符合的话就会触发事件（回调方法），而这些方法都定义在ContentHandler接口中，而ContentHandler是一个接口， 使用起来不方便，所以Android准备了一个帮助类DefaultHandler，只需要继承这个类，重写里面对应的方法即可。 可以重写的方法： startDocument()：当读取到文文档开始标志时触发，通常在这里完成一些初始化操作。 endDocument()：文档结束部分，在这里完成一些善后工作。 startElement(names, paceURI, localName, qName, atts)：参数依次问命名空间，不带命名空间的前缀标签名，带命名空间的前缀标签名，通过atts可以得到所有的属性名和相应的值；SAX中一个重要的特点就是它的流式处理，当遇到一个标签时，它并不会记录下以前遇到的标签，就是说，在startElement()中，所有知道的信息就是标签的名字和属性，至于标签的嵌套结构，上层标签的名字，是否有子元素等其他与结构相关的信息，都不知道，需要程序来完成，这使得SAX在编程处理上没有DOM方便。 endElement(uri, localName, name)：在遇到结束标签的时候，调用该方法。 characters(ch, start, length)：这个方法用来处理在XML文件中读到的内容，第一个参数用于存放文件的内容，后面两个参数是读到的字符串在这个数组中的起始位置和长度，使用new String(ch, start, length)就可以获取内容。 核心代码：SAX解析类——SaxHelper.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package com.ly.allendemowebservice;import android.util.Log;import org.xml.sax.Attributes;import org.xml.sax.SAXException;import org.xml.sax.helpers.DefaultHandler;import java.util.ArrayList;/** * SAX解析XML * * @author Liuyang * @date 2019/7/26 */public class SaxHelper extends DefaultHandler &#123; private static final String TAG = "SaxHelper"; private Person mPerson; private ArrayList&lt;Person&gt; mPersons; /** * 当前解析的元素标签 */ private String mTagName = null; /** * 当读取到文档开始标志时触发，通常在里面完成一些初始化操作 */ @Override public void startDocument() throws SAXException &#123; this.mPersons = new ArrayList&lt;&gt;(); Log.i(TAG, "读取到文档头,开始解析xml"); &#125; private static final String ELEMENT = "person"; /** * 读到一个开始标签时触发，第二个参数为标签名，最后一个参数为属性数组 */ @Override public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException &#123; if (ELEMENT.equals(localName)) &#123; mPerson = new Person(); mPerson.setId(Integer.parseInt(attributes.getValue("id"))); Log.i(TAG, "开始处理person元素~"); &#125; mTagName = localName; &#125; private static final String TAG_NAME1 = "name"; private static final String TAG_NAME2 = "age"; /** * 读取标签里面的内容，第一个参数为字符串内容，后面依次为起始位置和长度 */ @Override public void characters(char[] ch, int start, int length) throws SAXException &#123; // 判断当前标签是否有效 if (mTagName != null) &#123; String data = new String(ch, start, length); // 读取标签内容 if (TAG_NAME1.equals(mTagName)) &#123; mPerson.setName(data); Log.i(TAG, "处理name元素内容"); &#125; else if (TAG_NAME2.equals(mTagName)) &#123; mPerson.setAge(Integer.parseInt(data)); Log.i(TAG, "处理age元素内容"); &#125; &#125; &#125; /** * 读取到元素结束时触发，这里将对象添加到集合中 */ @Override public void endElement(String uri, String localName, String qName) throws SAXException &#123; if (ELEMENT.equals(localName)) &#123; mPersons.add(mPerson); mPerson = null; Log.i(TAG, "处理person元素结束~"); &#125; mTagName = null; &#125; /** * 读取到文档结束时触发， */ @Override public void endDocument() throws SAXException &#123; super.endDocument(); Log.i(TAG, "处理person元素结束~"); &#125; /** * 获取persons集合 */ public ArrayList&lt;Person&gt; getPersons() &#123; return mPersons; &#125;&#125; 1234567891011121314private ArrayList&lt;Person&gt; readXmlForSax() throws IOException, ParserConfigurationException, SAXException &#123; // 获取文件资源建立输入流对象，可能是从网络获取 InputStream inputStream = getAssets().open("person1.xml"); // 创建XML解析器 SaxHelper helper = new SaxHelper(); // 得到SAX解析工厂 SAXParserFactory factory = SAXParserFactory.newInstance(); // 创建SAX解析器 SAXParser parser = factory.newSAXParser(); // 将XML解析器分配给解析器，对文档进行解析，将事件发送给处理器 parser.parse(inputStream, helper); inputStream.close(); return helper.getPersons();&#125; 在项目assets目录下有一个文件person1.xml。 1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;persons&gt; &lt;person id = "11"&gt; &lt;name&gt;SAX解析&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;/person&gt; &lt;person id = "13"&gt; &lt;name&gt;XML1&lt;/name&gt; &lt;age&gt;43&lt;/age&gt; &lt;/person&gt;&lt;/persons&gt; Demo地址：Allen_Demo_WebService 4. DOM解析XML数据DOM解析XML文件时会将文件所有的内容以文档树的形式存放在内存中，可以使用DOM API遍历XML树，检索到需要的数据。使用DOM操作XML的代码比较直观，并且在编码方面比基于SAX的实现更加简单。但是DOM需要将XML文件的所有内容存放到内存中，所以内存消耗大，特别是对于Android设备而言，内存资源有限，因此建议使用前面的SAX解析。如果解析的内容比较小，也可以使用DOM来解析。 DOM API： DocumentBuilderFactory（解析器工厂类）：创建方法DoucmentBuilderFactory factory = DoucmentBuilderFactory.newInstance(); DocumentBuilder（解析器类）：创建方法：通过解析器工厂类来获得DocumentBuidler builder = factory.newDocumentBuilder(); Document（文档树模型）：将需要解析的XML文件读入DOM解析器：Document doc = builder.parse(context.getAssets().open(&quot;person2.xml&quot;)); Document对象代表了一个XML文档的模型，所有的其他Node都以一定的顺序包含在Document对象内，排列成树状，以后对XML文档的所有操作都与解析器无关。 NodeList（列表类）：代表一个包含一个或多个Node的列表，有以下两个方法： item(index)：返回集合的第index个Node项； getLength()：列表的节点数 Node（节点类）：DOM中最基本的对象，代表文档树中的抽象节点，很少会直接使用；通常调用其子对象的Element、Attr、Text等。 Element（元素类）：Node最主要的子对象，在元素中可以包含属性，因此有获取属性的方法： getAttrbute()：获取属性值 getTagName()：获取元素名称 Attr（属性类）：代表某个元素的属性，虽然Attr继承自Node接口，但因为Attr是包含在Element中的，但并不能将其看做是Element的子对象，因为Attr并不是DOM树的一部分。 核心代码：DOM解析类——DomHelper.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.ly.allendemowebservice;import android.content.Context;import android.util.Log;import org.w3c.dom.Document;import org.w3c.dom.Element;import org.w3c.dom.Node;import org.w3c.dom.NodeList;import org.xml.sax.SAXException;import java.io.IOException;import java.util.ArrayList;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.parsers.ParserConfigurationException;/** * DOM解析XML * * @author Liuyang * @date 2019/7/26 */public class DomHelper &#123; private static final String TAG = "DomHelper"; private static final String TAG_NAME = "name"; private static final String TAG_AGE = "age"; public static ArrayList&lt;Person&gt; queryXML(Context context) &#123; ArrayList&lt;Person&gt; persons = new ArrayList&lt;&gt;(); try &#123; // 1. 获取DOM解析器工厂 DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); // 2. 获取DOM解析器 DocumentBuilder builder = factory.newDocumentBuilder(); // 3. 将要解析的XML文件读入DOM解析器 Document document = builder.parse(context.getAssets().open("person2.xml")); Log.i(TAG, "处理该文档的DomImplementation对象 = " + document.getImplementation()); // 4. 得到文档中名称为person的元素的节点元素 NodeList nodeList = document.getElementsByTagName("person"); // 5. 遍历集合，显示集合中的元素以及子元素的名字 for (int i = 0; i &lt; nodeList.getLength(); i++) &#123; // 先从person元素开始解析 Element personElement = (Element) nodeList.item(i); Person person = new Person(); person.setId(Integer.valueOf(personElement.getAttribute("id"))); // 获取person下的name和age的Note集合 NodeList childNodeList = personElement.getChildNodes(); for (int j = 0; j &lt; childNodeList.getLength(); j++) &#123; Node childNode = childNodeList.item(j); // 判断子Node类型是否为元素的Node if (childNode.getNodeType() == Node.ELEMENT_NODE) &#123; Element childElement = (Element) childNode; if (TAG_NAME.equals(childElement.getNodeName())) &#123; person.setName(childElement.getFirstChild().getNodeValue()); &#125; else if (TAG_AGE.equals(childElement.getNodeName())) &#123; person.setAge(Integer.valueOf(childElement.getFirstChild().getNodeValue())); &#125; &#125; &#125; persons.add(person); &#125; &#125; catch (ParserConfigurationException e) &#123; e.printStackTrace(); &#125; catch (SAXException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return persons; &#125;&#125; 5. PULL解析XML数据除了SAX和DOM解析XML之外，Android系统内置了Pull解析器用来解析XML，比如SharedPreference就是使用内置的pull解析配置文件的。它的使用和SAX类似，都是采用事件驱动来完成XML的解析，而pull代码比较简单，只需处理开始和结束的事件，通常使用switch语句，根据事件不同的类型，匹配不同的处理方式，有五种事件：START_DOCUMENT、START_TAG、TEXT、END_TAG、END_DUCOMENT。 XML pull 提供了开始元素和结束元素。当某个元素开始的时候，可以调用paser.nextText从XML文档中提取所有字符数据。当解析到一个文档结束时，自动生成EndDocument事件。在PULL解析过程中返回的是数字，且需要自己获取产生事件然后做出相应的操作，而不像SAX那样由处理器触发一种事件的方法，执行我们的代码：读取到XML的声明返回START_DOCUMENT；结束返回END_DOCUMENT；开始标签返回START_TAG；结束标签返回END_TAG；文本返回TEXT。使用PULL解析XML的流程： 获取一个XmlPullPaser类的引用： 1234// 方式1：通过xml解析工厂获得实体类XmlPullPaserFactory factory = XmlPullPaserFactory.newInstance(); XmlPullPaser paser = factory.newPullPaser();// 方式2：直接获得实体类XmlPullPaser paser = Xml.newPullPaser(); 为paser解析器对象提供xml流与编码格式： 1paser.setInput(xml, "UTF-8"); 获得事件的类型： 1int eventType = paser.getEventType(); 用switch对不同的事件类型进行不同的处理： START_DUCUMENT：开始读文档时触发，在这里完成初始化操作； START_TAG:开始读标签，通过paser的getName()方法获得标签名信息比较，使用getAttributeValue(index)获取属性值； 对于文字节点TEXT可以使用paser.nextText()获得节点内容； END_TAG：标签结束； paser.next()：循环解析下一个元素。 核心代码：PULL解析XML——PullHelper.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.ly.allendemowebservice;import org.xmlpull.v1.XmlPullParser;import org.xmlpull.v1.XmlPullParserException;import org.xmlpull.v1.XmlPullParserFactory;import java.io.IOException;import java.io.InputStream;import java.util.ArrayList;/** * PULL解析XML * * @author Liuyang * @date 2019/7/27 */public class PullHelper &#123; public static ArrayList&lt;Person&gt; getPersons(InputStream xml) throws XmlPullParserException, IOException &#123; ArrayList&lt;Person&gt; persons = null; Person person = null; // 创建一个XML解析工厂 XmlPullParserFactory factory = XmlPullParserFactory.newInstance(); // 获得XML解析类的引用 XmlPullParser parser = factory.newPullParser(); parser.setInput(xml, "UTF_8"); // 获得事件类型 int eventType = parser.getEventType(); while (eventType != XmlPullParser.END_DOCUMENT) &#123; switch (eventType) &#123; case XmlPullParser.START_DOCUMENT: persons = new ArrayList&lt;&gt;(); break; case XmlPullParser.START_TAG: if ("person".equals(parser.getName())) &#123; person = new Person(); // 取出属性值 int id = Integer.parseInt(parser.getAttributeValue(0)); person.setId(id); &#125; else if ("name".equals(parser.getName())) &#123; // 获取该节点的内容 String name = parser.nextText(); assert person != null; person.setName(name); &#125; else if ("age".equals(parser.getName())) &#123; int age = Integer.parseInt(parser.nextText()); assert person != null; person.setAge(age); &#125; break; case XmlPullParser.END_TAG: if ("person".equals(parser.getName())) &#123; assert persons != null; persons.add(person); person = null; &#125; break; default: break; &#125; eventType = parser.next(); &#125; return persons; &#125;&#125; 使用： 1234567891011try &#123; InputStream inputStream = getAssets().open("person3.xml"); ArrayList&lt;Person&gt; persons = PullHelper.getPersons(inputStream); for (int i = 0; i &lt; persons.size(); i++) &#123; Log.i(TAG, i + " == " + persons.get(i).toString()); &#125;&#125; catch (IOException e) &#123; e.printStackTrace();&#125; catch (XmlPullParserException e) &#123; e.printStackTrace();&#125; 使用PULL生成XML数据的流程： 创建XMlSerializer（XML序列化类）的实例： 1XmlSerializer serializer = Xml.newSerializer(); 为XmlSerializer设置输出流与编码格式： 1serializersetOutput(out, "UTF-8"); 为XMlSerializer设置XML的编码格式： 1serializer.startDocument("UTF-8", true); 设置根元素： 1serializer.startTag(null, "person"); 使用foreach循环遍历persons集合中所有的元素，同时依次写入标签与属性： 1234567891011for(Person p: persons)&#123; serializer.startTag(null, "person"); serializer.attribute(null, "id", p.getId() + ""); serializer.startTag(null, "name"); serializer.text(p.getName()); serializer.endTag(null, "name"); serializer.startTag(null, "age"); serializer.text(p.getAge() + ""); serializer.endTag(null, "age"); serializer.endTag(null, "person");&#125; 设置跟踪完结元素： 1serializer.endTag(null, "persons"); 结束文档编写： 1serializer.endDocument(); 调用flush()，将内存中的数据写入文件中并关闭输出流 12out.flush();out.close(); 核心代码： 12345678910111213141516171819202122public static void save(List&lt;Person&gt; persons, OutputStream out) throws Exception &#123; XmlSerializer serializer = Xml.newSerializer(); serializer.setOutput(out, "UTF-8"); serializer.startDocument("UTF-8", true); serializer.startTag(null, "persons"); for (Person p : persons) &#123; serializer.startTag(null, "person"); serializer.attribute(null, "id", p.getId() + ""); serializer.startTag(null, "name"); serializer.text(p.getName()); serializer.endTag(null, "name"); serializer.startTag(null, "age"); serializer.text(p.getAge() + ""); serializer.endTag(null, "age"); serializer.endTag(null, "person"); &#125; serializer.endTag(null, "persons"); serializer.endDocument(); out.flush(); out.close();&#125; Demo地址：Allen_Demo_WebService]]></content>
      <categories>
        <category>Android</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>WebService</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一、Android调用WebService]]></title>
    <url>%2F2019%2F07%2F26%2F%E4%B8%80%E3%80%81Android%E8%B0%83%E7%94%A8WebService%2F</url>
    <content type="text"><![CDATA[Android调用WebService类似于一些给我们提供了原始数据API服务的数据平台，比如聚合数据。而WebService则用到了XML和SOAP，通过HTTP协议即可完成与远程机器的交互。 1. WebService简介1.1 WebService的引入手机硬件资源是有限的，对于一些复杂的数据处理和计算，通常都是部署在远程服务器上，然后安卓手机作为对应的客户端。为了让Android APP与远程服务器进行交互，肯定需要一些技术，这里使用WebService就可以了。 什么是WebService？ 简单来说，就是某些站点开放出来的服务，当然也可以自己开发一个service，也就是一些方法，通过URI，指定某一个方法名，发出请求，站点的这个服务（方法），接收请求后，根据传入的参数进行一些处理，然后将处理的结果以XML的形式返回。客户端收到这些XML并进行解析，然后显示或者进行其他操作。 例如，很多大的站点提供天气预报的WebSwevice、查询某网站的数据的WebService，只要发送请求，它就返回天气预报、某网站的数据，然后在客户端就能显示出来。 1.2 主要采用的四个技术1.2.1 XML可扩展的标记语言。同时采用XML Schema。正式因为WebWervice采用了XML，才使得它可以跨越各种编程语言。 1.2.2 SOAP简单对象访问协议。提供了标准的RPC（Remote Procedure Call，远程调用过程）方法来调用WebService。SOAP规范中定义了SOAP消息格式，以及怎样通过HTTP协议来使用SOAP。SOAP是基于XML语言和XSD标准的，其中XML是SOAP的数据编码方式。 1.2.3 WSDLWSDL是一种基于XML的用于描述WenService及其操作、参数和返回值的语言。因为是基于XML，一些IDE可以根据WenService来生成WSDL文档，又能通过导入WSDL文档 ，生成调用相应WebWervice的代码。 1.2.4 UDDI用于在网上自动查找WebService，一旦WebService注册到UDDI，客户就可以很方便的查找和定位所需要的WebService。 1.3 WebService模型 服务提供者：把自己的服务注册到“服务注册中心”。 服务请求者：到“服务注册中心”查找相应的服务，然后定位到“服务提供者”。 服务提供者：开始为“服务请求者”提供相应的服务。 2. 去哪里获取WebService网上有很多WebService的站点，这里选取了WebXmlu为例。 WebXml：http://www.webxml.com.cn/zh_cn/index.aspx 3. 第三方jar包准备首先如果想在Android平台上调用WebService，需要依赖第三方库ksoap2，而在Android平台上使用的是ksoap2-android-releases，一个高效、轻量级的SOAP开发包。 ksoap2-Android项目网站：https://simpligility.github.io/ksoap2-android/index.html ksoap2-android-assembly发布版本列表(包含所有可用版本jar包)：https://oss.sonatype.org/content/repositories/ksoap2-android-releases/com/google/code/ksoap2-android/ksoap2-android-assembly/ 4. 获取相关参数首先找到需要获取的服务，然后记录相关的参数：NameSpace（命名空间）、SoapAction以及URL。 比如这里查找天气的查询参数，点击去可以看到一个参数文档： 假设这里需要的是天气查询部分的功能： 这里可以拿到SoapAction和NameSpace。 这是一个测试页，可以不用填id信息，点击查询，可以看到这样一个页面： 这就是返回的XML文件，下面就需要去解析这个文件，这里的.gif表示天气的图标。 上面的查询号码归属地也是同理操作。 5. 注册 6. Demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234package com.ly.allendemowebservice;import android.annotation.SuppressLint;import android.os.Handler;import android.os.Message;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.TextView;import android.widget.Toast;import org.ksoap2.SoapEnvelope;import org.ksoap2.serialization.SoapObject;import org.ksoap2.serialization.SoapPrimitive;import org.ksoap2.serialization.SoapSerializationEnvelope;import org.ksoap2.transport.HttpTransportSE;import org.xmlpull.v1.XmlPullParserException;import java.io.IOException;import java.lang.reflect.Method;/** * WebService demo * * @author Liuyang * @date 2019/7/24 */public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private static final String TAG = "MainActivity"; private EditText mEtParam; private TextView mTvResult; private String mResult; private static final String USER_ID = "1e3c36a0f18b4da4affa98cdd26ab0b4"; /** * 定义获取手机信息的SoapAction与命名空间,作为常量 */ private static final String NAME_SPACE = "http://WebXml.com.cn/"; /** * 天气查询相关参数 */ private static final String WEATHER_URL = "http://ws.webxml.com.cn/WebServices/WeatherWS.asmx"; private static final String WEATHER_METHOD = "getWeather"; private static final String WEATHER_SOAP_ACTION = "http://WebXml.com.cn/getWeather"; /** * 号码归属地查询相关参数 */ private static final String ADDRESS_URL = "http://ws.webxml.com.cn/WebServices/MobileCodeWS.asmx"; private static final String ADDRESS_METHOD = "getMobileCodeInfo"; private static final String ADDRESS_SOAP_ACTION = "http://WebXml.com.cn/getMobileCodeInfo"; /** * 定义一个Handler用来更新页面 */ @SuppressLint("HandlerLeak") private Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case 0x001: mTvResult.setText(mResult); Toast.makeText(MainActivity.this, "获取天气信息成功", Toast.LENGTH_SHORT).show(); break; case 0x002: mTvResult.setText(mResult); Toast.makeText(MainActivity.this, "号码归属地查询成功", Toast.LENGTH_SHORT).show(); break; default: break; &#125; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); bindViews(); &#125; private void bindViews() &#123; mEtParam = findViewById(R.id.et_param); Button btnAttribution = findViewById(R.id.btn_attribution); Button btnWeather = findViewById(R.id.btn_weather); mTvResult = findViewById(R.id.tv_result); btnAttribution.setOnClickListener(this); btnWeather.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.btn_attribution: new Thread() &#123; @Override public void run() &#123; getLand(); &#125; &#125;.start(); break; case R.id.btn_weather: new Thread() &#123; @Override public void run() &#123; getWeather();// getWeather1(); &#125; &#125;.start(); break; default: break; &#125; &#125; /** * 获取某个号码的归属地信息 */ private void getLand() &#123; mResult = ""; // 根据命名空间和方法得到SoapObject对象 SoapObject soapObject = new SoapObject(NAME_SPACE, ADDRESS_METHOD); soapObject.addProperty("mobileCode", mEtParam.getText().toString()); soapObject.addProperty("userID", USER_ID); // 通过SOAP1.1协议得到envelop对象 SoapSerializationEnvelope envelope = new SoapSerializationEnvelope(SoapEnvelope.VER11); // 将soapObject对象设置为envelop对象，传出消息 envelope.bodyOut = soapObject; // 设置是否调用的是dotNet开发的WebService // 指定webservice的类型的（java，PHP，dotNet） envelope.dotNet = true; // 等价于envelop.bodyOut = soapObject; envelope.setOutputSoapObject(soapObject); HttpTransportSE httpTransportSe = new HttpTransportSE(ADDRESS_URL); Log.i(TAG, "号码服务设置完毕,准备开启服务"); // 开始调用远程方法 try &#123; // 得到远程方法返回的SOAP对象 httpTransportSe.call(ADDRESS_SOAP_ACTION, envelope); Log.i(TAG, "调用号码归属地查询WebService服务成功"); &#125; catch (IOException e) &#123; e.printStackTrace(); Log.i(TAG, "调用号码归属地查询WebService服务失败 = IOException"); &#125; catch (XmlPullParserException e) &#123; e.printStackTrace(); Log.i(TAG, "调用号码归属地查询WebService服务失败 = XmlPullParserException"); &#125; // 获取返回的数据，并开始解析 SoapObject object = (SoapObject) envelope.bodyIn; mResult = object.getProperty(0).toString(); int count = object.getPropertyCount(); Log.i(TAG, "count = " + count); for (int i = 0; i &lt; count; i++) &#123; Log.i(TAG, i + " === " + object.getProperty(i).toString()); &#125; mHandler.sendEmptyMessage(0x002); Log.i(TAG, "发送号码归属地数据完毕"); &#125; /** * 获取某个城市的天气信息，使用封装的工具类 */ private void getWeather1() &#123;// SoapNetUtils.getInstance().doSoapRequest(); &#125; /** * 获取某个城市的天气信息 */ private void getWeather() &#123; mResult = ""; // 根据命名空间和方法得到SoapObject对象 SoapObject soapObject = new SoapObject(NAME_SPACE, WEATHER_METHOD); soapObject.addProperty("theCityCode", mEtParam.getText().toString()); soapObject.addProperty("theUserID", USER_ID); // 通过SOAP1.1协议得到envelop对象 SoapSerializationEnvelope envelope = new SoapSerializationEnvelope(SoapEnvelope.VER11); // 将soapObject对象设置为envelop对象，传出消息 envelope.bodyOut = soapObject; // 设置是否调用的是dotNet开发的WebService // 指定webservice的类型的（java，PHP，dotNet） envelope.dotNet = true; // 等价于envelop.bodyOut = soapObject; envelope.setOutputSoapObject(soapObject); HttpTransportSE httpTransportSe = new HttpTransportSE(WEATHER_URL); Log.i(TAG, "天气服务设置完毕,准备开启服务"); // 开始调用远程方法 try &#123; // 得到远程方法返回的SOAP对象 httpTransportSe.call(WEATHER_SOAP_ACTION, envelope); Log.i(TAG, "调用天气查询WebService服务成功"); &#125; catch (IOException e) &#123; e.printStackTrace(); Log.i(TAG, "调用天气查询WebService服务失败 = IOException"); &#125; catch (XmlPullParserException e) &#123; e.printStackTrace(); Log.i(TAG, "调用天气查询WebService服务失败 = XmlPullParserException"); &#125; // 获取返回的数据，并开始解析，以下都通过getClass()直到数据的类型，才去进行强制类型转换的 SoapObject object = (SoapObject) envelope.bodyIn; SoapPrimitive primitive; int count = object.getPropertyCount(); for (int i = 0; i &lt; count; i++) &#123; SoapObject object1 = (SoapObject) object.getProperty(i); for (int j = 0; j &lt; object1.getPropertyCount(); j++) &#123; primitive = (SoapPrimitive) object1.getProperty(j); Log.i(TAG, "第" + j + "个数据为：" + primitive.getName() + " = " + primitive.getValue()); &#125; &#125; primitive = (SoapPrimitive) ((SoapObject) object.getProperty(0)).getProperty(37); mResult = (String) primitive.getValue(); mHandler.sendEmptyMessage(0x001); Log.i(TAG, "发送天气数据完毕"); &#125;&#125; Demo地址：Allen_Demo_WebService]]></content>
      <categories>
        <category>Android</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>WebService</tag>
      </tags>
  </entry>
</search>
