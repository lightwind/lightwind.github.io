<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tyler的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://tylerLiu.top/"/>
  <updated>2020-08-02T08:41:04.813Z</updated>
  <id>https://tylerLiu.top/</id>
  
  <author>
    <name>Tyler Liu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>（拉钩）Android工程师进阶34讲-14：Android Touch事件分发时序</title>
    <link href="https://tylerLiu.top/2020/08/01/%EF%BC%88%E6%8B%89%E9%92%A9%EF%BC%89Android%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BF%9B%E9%98%B634%E8%AE%B2-14%EF%BC%9AAndroid-Touch%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%97%B6%E5%BA%8F/"/>
    <id>https://tylerLiu.top/2020/08/01/（拉钩）Android工程师进阶34讲-14：Android-Touch事件分发时序/</id>
    <published>2020-08-01T07:22:04.000Z</published>
    <updated>2020-08-02T08:41:04.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h1><p>Android Touch事件的分发是Android工程师必备的技能之一。关于事件分发主要有几个方向可以展开分析：</p><ul><li>1、touch 事件是如何从驱动层传递给Framework层的<code>InputManagerService</code>。</li><li>2、WMS 是如何通过<code>ViewRootImpl</code>将事件传递到目标窗口。</li><li>3、touch 事件达到<code>DecorView</code>后，是如何一步步传递到内部的子View中。</li></ul><p>本文是基于Android-28的源码分析的。</p><h1 id="1-思路梳理"><a href="#1-思路梳理" class="headerlink" title="1. 思路梳理"></a>1. 思路梳理</h1><p>2个概念。</p><h2 id="1-1-ViewGroup"><a href="#1-1-ViewGroup" class="headerlink" title="1.1 ViewGroup"></a>1.1 ViewGroup</h2><p><code>ViewGroup</code>是一组<code>View</code>的组合，在其内部有可能包含多个子<code>View</code>，当手指触摸屏幕时，手指所在的区域既能在<code>ViewGroup</code>显示范围内，也可能在其内部<code>View</code>控件上。</p><p>因此它内部的事件分发的重心是处理当前<code>Group</code>和子<code>View</code>之间的逻辑关系：</p><ul><li>1、当前<code>Group</code>是否需要拦截touch事件。</li><li>2、是否需要将touch事件继续分发给子<code>View</code>。</li><li>3、如何将touch事件分发给子<code>View</code>。</li></ul><h1 id="1-2-View"><a href="#1-2-View" class="headerlink" title="1.2 View"></a>1.2 View</h1><p><code>View</code>是一个单纯的控件，不能再被细分，内部也并不会存在子<code>View</code>，所以它的事件分发的重点在于当前View如何处理touch事件，并根据相应的手势逻辑进行一系列的效果展示（比如滑动，放大，点击，长按等）。</p><ul><li>1、是否存在<code>TouchListener</code>；</li><li>2、是否自己接收处理touch事件（主要逻辑在<code>onTouchEvent</code>方法中）。</li></ul><h1 id="2-事件分发核心dispatchTouchEvent（ViewGroup）"><a href="#2-事件分发核心dispatchTouchEvent（ViewGroup）" class="headerlink" title="2. 事件分发核心dispatchTouchEvent（ViewGroup）"></a>2. 事件分发核心dispatchTouchEvent（ViewGroup）</h1><p>整个View之间的事件分发，实质上就是一个大的递归函数，而这个递归函数就是<code>dispatchTouchEvent</code>方法。在这个递归的过程中会适时调用<code>onInterceptTouchEvent</code>来拦截事件，或者调用<code>onTouchEvent</code>方法来处理事件。</p><p>先从宏观角度，纵览整个<code>dispatch</code>的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 步骤1：检查当前ViewGroup是否需要拦截事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 步骤2：将事件分发给子View</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 步骤3：根据mFirstTouchTarget，再次分发事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如代码中的注释，<code>dispatch</code>主要分为三个步骤：</p><ul><li>步骤1：判断当前<code>ViewGroup</code>是否需要拦截此touch事件，如果拦截则此次touch事件不再会传递给子View（或者以CENCEL的方式通知子View）。</li><li>步骤2：如果没有拦截，则将事件分发给子View继续处理，如果子View将此事件拦截，则将<code>mFirstTouchTarget</code>赋值给捕获touch事件的View。</li><li>步骤3：根据<code>mFirstTouchTarget</code>重新分发事件。</li></ul><p>下面分析每个步骤：</p><h2 id="2-1-步骤1具体代码如下"><a href="#2-1-步骤1具体代码如下" class="headerlink" title="2.1 步骤1具体代码如下"></a>2.1 步骤1具体代码如下</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、检查当前ViewGroup是否需要拦截事件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">        intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">        ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        intercepted = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// There are no touch targets and this action is not an initial down</span></span><br><span class="line">    <span class="comment">// so this view group continues to intercept touches.</span></span><br><span class="line">    intercepted = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null</code>判断了是否需要拦截的条件：</p><ul><li>如果事件为<code>DOWN</code>事件，则调用<code>onInterceptTouchEvent()</code>进行拦截判断。</li><li>或者<code>mFirstTouchTarget</code>不为<code>null</code>，代表已经有子View捕获了这个事件，子View的<code>dispatchTouchEvent</code>返回<code>true</code>表示捕获touch事件。</li></ul><p>如果在步骤1中，当前<code>ViewGroup</code>并没有对事件进行拦截，则进行步骤2。</p><h2 id="2-2-步骤2具体代码如下"><a href="#2-2-步骤2具体代码如下" class="headerlink" title="2.2 步骤2具体代码如下"></a>2.2 步骤2具体代码如下</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2、将事件分发给子View</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">    View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()</span><br><span class="line">            ? findChildWithAccessibilityFocus() : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN <span class="comment">// 1</span></span><br><span class="line">            || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</span><br><span class="line">            || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = ev.getActionIndex();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> idBitsToAssign = split ? <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex)</span><br><span class="line">                : TouchTarget.ALL_POINTER_IDS;</span><br><span class="line"></span><br><span class="line">        removePointersFromTouchTargets(idBitsToAssign);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</span><br><span class="line">        <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; childrenCount != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX(actionIndex);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY(actionIndex);</span><br><span class="line">            <span class="keyword">final</span> ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> customOrder = preorderedList == <span class="keyword">null</span></span><br><span class="line">                    &amp;&amp; isChildrenDrawingOrderEnabled();</span><br><span class="line">            <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 2</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> childIndex = getAndVerifyPreorderedIndex(</span><br><span class="line">                        childrenCount, i, customOrder);</span><br><span class="line">                <span class="keyword">final</span> View child = getAndVerifyPreorderedView(</span><br><span class="line">                        preorderedList, children, childIndex);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (childWithAccessibilityFocus != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (childWithAccessibilityFocus != child) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    childWithAccessibilityFocus = <span class="keyword">null</span>;</span><br><span class="line">                    i = childrenCount - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3</span></span><br><span class="line">                <span class="keyword">if</span> (!canViewReceivePointerEvents(child)</span><br><span class="line">                        || !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                newTouchTarget = getTouchTarget(child);</span><br><span class="line">                <span class="keyword">if</span> (newTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                resetCancelNextUpFlag(child);</span><br><span class="line">                <span class="comment">// 4</span></span><br><span class="line">                <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">                    ...</span><br><span class="line">                    newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                    alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) preorderedList.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>1、表明事件主动分发的前提是事件为<code>DOWN</code>事件；</li><li>2、遍历所有子View；</li><li>3、判断事件坐标是否在子View坐标范围内，并且子View并没有处在动画状态；</li><li>4、调用<code>dispatchTransformedTouchEvent</code>方法将事件分发给子View，如果子View捕获事件成功，则将<code>mFirstTouchTarget</code>赋值给子View。</li></ul><h2 id="2-3-步骤3具体代码如下"><a href="#2-3-步骤3具体代码如下" class="headerlink" title="2.3 步骤3具体代码如下"></a>2.3 步骤3具体代码如下</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 3、根据mFirstTouchTarget，再次分发事件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123; <span class="comment">// 1</span></span><br><span class="line">    <span class="comment">// No touch targets so treat this as an ordinary view.</span></span><br><span class="line">    handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>, <span class="comment">// 传入child为null</span></span><br><span class="line">            TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Dispatch to touch targets, excluding the new touch target if we already</span></span><br><span class="line">    <span class="comment">// dispatched to it.  Cancel touch targets if necessary.</span></span><br><span class="line">    TouchTarget predecessor = <span class="keyword">null</span>;</span><br><span class="line">    TouchTarget target = mFirstTouchTarget;</span><br><span class="line">    <span class="keyword">while</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> TouchTarget next = target.next;</span><br><span class="line">        <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class="line">            handled = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child)</span><br><span class="line">                    || intercepted;</span><br><span class="line">            <span class="comment">// 2</span></span><br><span class="line">            <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild,</span><br><span class="line">                    target.child, target.pointerIdBits)) &#123;</span><br><span class="line">                handled = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        predecessor = target;</span><br><span class="line">        target = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤3有两个分支判断：</p><ul><li>分支1：如果此时<code>mFirstTouchTarget</code>为<code>null</code>，说明在上述的事件分发中并没有子View对事件进行捕获操作。这种情况下，直接调用<code>dispatchTransformedTouchEvent</code>方法，并传入<code>child</code>为<code>null</code>，最终会调用<code>dispatchTransformedTouchEvent</code>方法，并传入<code>chiild</code>为<code>null</code>，最终会调用<code>super.dispatchTouchEvent</code>方法。实际上最终会调用自身的<code>onTouchEvent</code>方法，进行处理touch事件。也就是说：<strong>如果没有子View捕获处理touch事件，ViewGroup会通过自身的<code>onTouchEvent</code>方法进行处理。</strong></li><li>分支2：<code>mFirstTouchTarget</code>不为<code>null</code>，说明在上面步骤2中有子View对touch事件进行了捕获，则直接将当前以及后续的事件交给<code>mFirstTouchTarget</code>指向的View进行处理。</li></ul><h1 id="3-事件分发流程代码演示"><a href="#3-事件分发流程代码演示" class="headerlink" title="3. 事件分发流程代码演示"></a>3. 事件分发流程代码演示</h1><p>布局文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">com.ly.lgdemoandroid.DownInterceptedGroup</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">"@color/colorPrimary"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.ly.lgdemoandroid.CaptureTouchView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:background</span>=<span class="string">"@color/colorAccent"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">com.ly.lgdemoandroid.DownInterceptedGroup</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>DownInterceptedGroup</code>和<code>CaptureTouchView</code>是两个自定义View，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownInterceptedGroup</span> <span class="keyword">extends</span> <span class="title">FrameLayout</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = DownInterceptedGroup.class.getSimpleName();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DownInterceptedGroup</span><span class="params">(@NonNull Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DownInterceptedGroup</span><span class="params">(@NonNull Context context, @Nullable AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DownInterceptedGroup</span><span class="params">(@NonNull Context context, @Nullable AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"dispatchTouchEvent: "</span> + ev);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"onInterceptTouchEvent: "</span> + ev);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onInterceptTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CaptureTouchView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = CaptureTouchView.class.getSimpleName();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CaptureTouchView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CaptureTouchView</span><span class="params">(Context context, @Nullable AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CaptureTouchView</span><span class="params">(Context context, @Nullable AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"dispatchTouchEvent: "</span> + event);</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">        Log.i(TAG, <span class="string">"dispatchTouchEvent result is "</span> + result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"onTouchEvent: "</span> + event);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        setMeasuredDimension(<span class="number">500</span>, <span class="number">300</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用手触摸<code>CaptureTouchView</code>并滑动一段距离后抬起，打印日志如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">com.ly.lgdemoandroid I/DownInterceptedGroup: dispatchTouchEvent: MotionEvent &#123; action=ACTION_DOWN</span><br><span class="line">com.ly.lgdemoandroid I/DownInterceptedGroup: onInterceptTouchEvent: MotionEvent &#123; action=ACTION_DOWN</span><br><span class="line">com.ly.lgdemoandroid I/CaptureTouchView: dispatchTouchEvent: MotionEvent &#123; action=ACTION_DOWN</span><br><span class="line">com.ly.lgdemoandroid I/CaptureTouchView: onTouchEvent: MotionEvent &#123; action=ACTION_DOWN</span><br><span class="line">com.ly.lgdemoandroid I/CaptureTouchView: dispatchTouchEvent result is true</span><br><span class="line">com.ly.lgdemoandroid I/DownInterceptedGroup: dispatchTouchEvent: MotionEvent &#123; action=ACTION_MOVE</span><br><span class="line">com.ly.lgdemoandroid I/DownInterceptedGroup: onInterceptTouchEvent: MotionEvent &#123; action=ACTION_MOVE</span><br><span class="line">com.ly.lgdemoandroid I/CaptureTouchView: dispatchTouchEvent: MotionEvent &#123; action=ACTION_MOVE</span><br><span class="line">com.ly.lgdemoandroid I/CaptureTouchView: onTouchEvent: MotionEvent &#123; action=ACTION_MOVE</span><br><span class="line">com.ly.lgdemoandroid I/CaptureTouchView: dispatchTouchEvent result is true</span><br><span class="line">......</span><br><span class="line">com.ly.lgdemoandroid I/DownInterceptedGroup: dispatchTouchEvent: MotionEvent &#123; action=ACTION_UP</span><br><span class="line">com.ly.lgdemoandroid I/DownInterceptedGroup: onInterceptTouchEvent: MotionEvent &#123; action=ACTION_UP</span><br><span class="line">com.ly.lgdemoandroid I/CaptureTouchView: dispatchTouchEvent: MotionEvent &#123; action=ACTION_UP</span><br><span class="line">com.ly.lgdemoandroid I/CaptureTouchView: onTouchEvent: MotionEvent &#123; action=ACTION_UP</span><br><span class="line">com.ly.lgdemoandroid I/CaptureTouchView: dispatchTouchEvent result is true</span><br></pre></td></tr></table></figure><p>上图中在DOWN事件中，<code>DownInterceptGroup</code>的<code>onInterceptTouchEvent</code>被触发一次；然后在子View <code>CaptureTouchEvent</code>的<code>dispatchTouchEvent</code>中返回<code>true</code>，代表它捕获消费了这个DOWN事件。这种情况下<code>CaptureTouchEvent</code>会被添加到父视图（<code>DownInterceptGroup</code>）中的<code>mFirstTouchTarget</code>中。因此后续的MOVE和UP事件都会经过<code>DownInterceptGroup</code>的<code>onInterceptTouchEvent</code>进行拦截判断。</p><h2 id="3-1-为什么DOWN事件特殊"><a href="#3-1-为什么DOWN事件特殊" class="headerlink" title="3.1 为什么DOWN事件特殊"></a>3.1 为什么DOWN事件特殊</h2><p>所有touch事件都会从DOWN事件开始的，这是DOWN事件比较特殊的原因之一。另一个原因是DOWN事件的处理结果会直接影响后续MOVE、UP事件的逻辑。</p><p>在步骤2中，只有DOWN事件会传递给子View进行捕获判断，一旦子View捕获成功，后续的MOVE和UP事件是通过遍历<code>mFirstTouchTarget</code>链表，查找之前接受<code>ACTION_DOWN</code>的子View，并将触摸事件分配给这些子View。<strong>也就是说后续的MOVE、UP等事件的分发交给谁，取决于它们的起始事件DOWN是由谁捕获的。</strong></p><h2 id="3-2-mFirstTouchTarget有什么作用"><a href="#3-2-mFirstTouchTarget有什么作用" class="headerlink" title="3.2 mFirstTouchTarget有什么作用"></a>3.2 mFirstTouchTarget有什么作用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> TouchTarget mFirstTouchTarget;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TouchTarget</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ALL_POINTER_IDS = -<span class="number">1</span>; <span class="comment">// all ones</span></span><br><span class="line">    <span class="comment">// The touched child view.</span></span><br><span class="line">    <span class="keyword">public</span> View child;</span><br><span class="line">    <span class="comment">// The combined bit mask of pointer ids for all pointers captured by the target.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> pointerIdBits;</span><br><span class="line">    <span class="comment">// The next target in the target list.</span></span><br><span class="line">    <span class="keyword">public</span> TouchTarget next;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">TouchTarget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出<code>mFirstTouchTarget</code>是一个<code>TouchTarget</code>类型的链表结构。而这个<code>TouchTarget</code>的作用就是用来记录捕获了DOWN事件的View，具体保存在上图中的<code>child</code>变量。为什么要用链表类型的结构呢？因为Android设备是支持多指操作的，每一个手指的DOWN事件都可以当做一个<code>TouchTarget</code>保存起来。在步骤3中判断如果<code>mFirstTouchTarget</code>不为<code>null</code>，则再次将事件分发给相应的<code>TouchTarget</code>。</p><h2 id="3-3-容易被遗漏的CANCEL事件"><a href="#3-3-容易被遗漏的CANCEL事件" class="headerlink" title="3.3 容易被遗漏的CANCEL事件"></a>3.3 容易被遗漏的CANCEL事件</h2><p>在上面的步骤3中，继续向子View分发事件的代码中，有一段逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (target != <span class="keyword">null</span>) &#123; <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">final</span> TouchTarget next = target.next;</span><br><span class="line">    <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class="line">        handled = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child)</span><br><span class="line">                || intercepted; <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild,</span><br><span class="line">                target.child, target.pointerIdBits)) &#123;</span><br><span class="line">            handled = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cancelChild) &#123;</span><br><span class="line">            <span class="keyword">if</span> (predecessor == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mFirstTouchTarget = next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                predecessor.next = next;</span><br><span class="line">            &#125;</span><br><span class="line">            target.recycle();</span><br><span class="line">            target = next;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    predecessor = target;</span><br><span class="line">    target = next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1处的<code>target != null</code>表明已经有子View捕获了touch事件，但是2处的<code>intercepted boolean</code>变量又是<code>true</code>。这种情况下，事件主导权或重新回到父视图ViewGroup中，并传递给子View的分发事件中传入一个<code>cancelChild == true</code>。</p><p><code>dispatchTransformedTouchEvent</code>方法部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel, View child, <span class="keyword">int</span> desiredPointerIdBits)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldAction = event.getAction();</span><br><span class="line">    <span class="keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123; <span class="comment">// 1</span></span><br><span class="line">        event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">            handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            handled = child.dispatchTouchEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">        event.setAction(oldAction);</span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1处因为之前传入的<code>cancel</code>为<code>true</code>，并且<code>child</code>不为<code>null</code>，<strong>最终这个事件会被包装成一个<code>ACTIOON_CANCEL</code>事件传递给<code>child</code></strong>。</p><h3 id="3-3-1-什么情况下会触发这段代码？"><a href="#3-3-1-什么情况下会触发这段代码？" class="headerlink" title="3.3.1 什么情况下会触发这段代码？"></a>3.3.1 什么情况下会触发这段代码？</h3><p>当父视图的<code>onInterceptTouchEvent</code>先返回<code>false</code>，然后在子View的<code>dispatchTouchEvent</code>中返回<code>true</code>（表示子View捕获事件），关键步骤就是接下来的MOVE的过程，父视图的<code>onInterceptTouchEvent</code>又返回<code>true</code>，<code>intercepted</code>被重新置为<code>true</code>，此时上述逻辑就会被触发，子控件就会收到<code>ACTION_CANCEL</code>的touch事件。</p><h3 id="3-3-2-经典案例演示上述情况"><a href="#3-3-2-经典案例演示上述情况" class="headerlink" title="3.3.2 经典案例演示上述情况"></a>3.3.2 经典案例演示上述情况</h3><p>当在<code>ScrollView</code>中添加自定义View时，<code>ScrollView</code>默认在DOWN事件中并不会进行拦截，事件会被传递给<code>ScrollView</code>内的子控件。只有当手指进行滑动并到达一定距离之后，<code>onInterceptTouchEvent</code>方法返回<code>true</code>，并触发<code>ScrollView</code>的滚动效果。当<code>ScrollView</code>进行滚动的瞬间，内部的子View会接收到一个CANCEL事件，并丢失touch焦点。</p><p>如下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ScrollView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">"@color/colorPrimaryDark"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:context</span>=<span class="string">".MainActivity"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">com.ly.lgdemoandroid.CaptureTouchView</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">"300dp"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">"300dp"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_marginTop</span>=<span class="string">"10dp"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_marginBottom</span>=<span class="string">"10dp"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:background</span>=<span class="string">"@color/colorAccent"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--    重复上面的CaptureTouchView    --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">ScrollView</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>CaptureTouchView</code>中<code>onTouchEvent</code>返回<code>true</code>，表示它会将接收到的touch事件进行捕获消费。</p><p>上述代码执行后，当手指点击屏幕时DOWN事件会被传递给<code>CaptureTouchView</code>，手指滑动屏幕将<code>ScrollView</code>向下滚动，刚开始MOVE事件还是由<code>CaptureTouchView</code>来消费处理，但是当<code>ScrollView</code>开始滚动时，<code>CaptureTouchView</code>会接收一个CANCEL事件，并不在接收后续的touch事件。日志如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CaptureTouchView: dispatchTouchEvent: MotionEvent &#123; action=ACTION_DOWN</span><br><span class="line">CaptureTouchView: onTouchEvent: MotionEvent &#123; action=ACTION_DOWN</span><br><span class="line">CaptureTouchView: dispatchTouchEvent result is true</span><br><span class="line">CaptureTouchView: dispatchTouchEvent: MotionEvent &#123; action=ACTION_MOVE</span><br><span class="line">CaptureTouchView: onTouchEvent: MotionEvent &#123; action=ACTION_MOVE</span><br><span class="line">CaptureTouchView: dispatchTouchEvent result is true</span><br><span class="line">CaptureTouchView: dispatchTouchEvent: MotionEvent &#123; action=ACTION_CANCEL</span><br><span class="line">CaptureTouchView: onTouchEvent: MotionEvent &#123; action=ACTION_CANCEL</span><br><span class="line">CaptureTouchView: dispatchTouchEvent result is true</span><br></pre></td></tr></table></figure><p>因此，平时自定义View时，尤其是有可能被<code>ScrollView</code>或者<code>ViewPager</code>嵌套使用的控件，不要遗漏对CANCEL事件的处理，否则有可能引起UI显示异常。</p><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p><code>dispatchTouchEvent</code>事件的流程机制：</p><ul><li>判断是否需要拦截 -&gt; 主要是根据<code>onInterceptTouchEvent</code>方法的返回值来决定是否拦截。</li><li>在DOWN事件中将touch事件分发给子View -&gt; 这一过程如果有子View捕获消费了touch事件，会对<code>mFirstTouchTarget</code>进行赋值。</li><li>最后一步，DOWN、MOVE、UP事件会根据<code>mFirstTouchTarget</code>是否为<code>null</code>，决定是自己处理touch事件，还是再次分发给子View。</li></ul><p>事件分发的几个特殊点：</p><ul><li>DOWN事件的特殊之处：事件的起点；决定后续事件由谁来消费处理；</li><li><code>mFirstTouchTarget</code>的作用：记录捕获消费touch事件的View，是一个链表结构；</li><li>CANCEL事件的触发场景：当父视图先不拦截，然后在MOVE事件中重新拦截，此时子View会接收到一个CANCEL事件。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0. 前言&quot;&gt;&lt;/a&gt;0. 前言&lt;/h1&gt;&lt;p&gt;Android Touch事件的分发是Android工程师必备的技能之一。关于事件分发主要有几个方向可以展开分析：&lt;/p
      
    
    </summary>
    
      <category term="Android" scheme="https://tylerLiu.top/categories/Android/"/>
    
      <category term="进阶" scheme="https://tylerLiu.top/categories/Android/%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Android核心技术" scheme="https://tylerLiu.top/tags/Android%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>（拉钩）Android工程师进阶34讲-13：Android是如何通过Activity进行交互的？</title>
    <link href="https://tylerLiu.top/2020/07/31/%EF%BC%88%E6%8B%89%E9%92%A9%EF%BC%89Android%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BF%9B%E9%98%B634%E8%AE%B2-13%EF%BC%9AAndroid%E6%98%AF%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87Activity%E8%BF%9B%E8%A1%8C%E4%BA%A4%E4%BA%92%E7%9A%84%EF%BC%9F/"/>
    <id>https://tylerLiu.top/2020/07/31/（拉钩）Android工程师进阶34讲-13：Android是如何通过Activity进行交互的？/</id>
    <published>2020-07-31T01:30:30.000Z</published>
    <updated>2020-08-01T07:19:02.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-taskAffinity"><a href="#1-taskAffinity" class="headerlink" title="1. taskAffinity"></a>1. taskAffinity</h1><p>Actiivty的启动模式。通过配置不同的启动模式可以实现调配不同的<code>Task</code>。但是<code>taskAffinity</code>在一定程度上也会影响任务栈的调配流程。</p><p>每一个Activity都有一个<code>Affinity</code>属性，如果不在清单文件中指定，默认为当前应用的包名。<code>taskAffinity</code>主要有以下几点需要注意：</p><h2 id="1-1-taskAffinity会默认使Activity在新的栈中分配吗？"><a href="#1-1-taskAffinity会默认使Activity在新的栈中分配吗？" class="headerlink" title="1.1 taskAffinity会默认使Activity在新的栈中分配吗？"></a>1.1 taskAffinity会默认使Activity在新的栈中分配吗？</h2><p>可以通过一个例子验证一下，在一个Android项目<code>LagouTaskAffinity</code>中，创建两个Activity：<code>First</code>和<code>Second</code>，它们的具体配置如下：</p><img src="/2020/07/31/（拉钩）Android工程师进阶34讲-13：Android是如何通过Activity进行交互的？/LagouTaskAffinity1.png"><p>除了Activity类名之外，其他都是默认配置。这种情况下，点击<code>First</code>中的<code>Button</code>，从<code>First</code>跳转到<code>Second</code>。</p><p>然后再执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys activity activities</span><br></pre></td></tr></table></figure><p>上述命令会将系统中所有存活中的Activity信息打印到控制台，具体结果如下：</p><img src="/2020/07/31/（拉钩）Android工程师进阶34讲-13：Android是如何通过Activity进行交互的？/LagouTaskAffinity2.png"><p>上图中的<code>TaskRecord</code>代表一个任务栈，在这个栈中存在两个<code>Activity</code>实例：<code>First</code>和<code>Second</code>，并且<code>Second</code>处于栈顶。</p><p>接下来将<code>Second</code>的<code>taskAffinity</code>修改如下：</p><img src="/2020/07/31/（拉钩）Android工程师进阶34讲-13：Android是如何通过Activity进行交互的？/LagouTaskAffinity3.png"><p>将<code>Second</code>的<code>taskAffinity</code>修改成<code>lagou.affinity</code>，使它和<code>First</code>的<code>taskAffinity</code>不同。重新运行代码，并再次查看任务栈中的情况，如下：</p><img src="/2020/07/31/（拉钩）Android工程师进阶34讲-13：Android是如何通过Activity进行交互的？/LagouTaskAffinity4.png"><p>可以看到，虽然<code>First</code>和<code>Second</code>的<code>taskAffinity</code>不同，但是它们都被创建在一个任务栈中。</p><p>但如果再将<code>Second</code>的<code>launchMode</code>改为<code>singleTask</code>，再次重新运行，则会发现两个Activity会被分配到不同的任务栈中，如下图：</p><img src="/2020/07/31/（拉钩）Android工程师进阶34讲-13：Android是如何通过Activity进行交互的？/LagouTaskAffinity5.png"><p>结论：单独使用<code>taskAffinity</code>不能导致Activity被创建在新的任务栈中，需要配合<code>singleTask</code>或者<code>singleInstance</code>。</p><h2 id="1-2-taskAffinity-allowTaskReparenting"><a href="#1-2-taskAffinity-allowTaskReparenting" class="headerlink" title="1.2 taskAffinity + allowTaskReparenting"></a>1.2 taskAffinity + allowTaskReparenting</h2><p><code>allowTaskReparenting</code>赋予Activity在各个<code>task</code>中间转移的特性。一个后台任务栈中的Activity A，当有其他任务进入前台，并且<code>taskAffinity</code>和A相同，则会自动将A添加到当前启动的任务栈中。举例：</p><ul><li>1、在某外卖app中下好订单后，跳转到支付平台支付。当在支付平台支付成功之后，页面停留在支付平台支付成功页面。</li><li>2、按Home键，在主页面重新打开支付平台App，页面上显示的并不是支付平台主页面，而是之前支付成功页面。</li><li>3、再次进入外卖App，发现支付平台支付成功页面已经消失。</li></ul><p>造成上述现象的原因就是<code>allowTaskReparenting</code>属性，代码演示。</p><p>分别创建两个Android工程：<code>First</code>和<code>TaskAffinityReparent</code>：</p><ul><li>在<code>First</code>中有三个Activity：<code>FirstA</code>、<code>FirstB</code>、<code>FirstC</code>。打开顺序依次是<code>FirstA</code> -&gt; <code>FirstB</code> -&gt; ``FirstC<code>。其中</code>FirstC<code>的</code>taskAffinity<code>为</code>“lagou.affinity”<code>，且</code>allowTaskReparenting<code>属性设置为</code>true<code>。</code>FirstA<code>和</code>FirstB`为默认值；</li><li><code>TaskAffinityReparent</code>中只有一个Activity——<code>ReparentActivity</code>，并且其<code>TaskAffinity</code>也等于<code>&quot;lagou.affinity&quot;</code>。</li></ul><p>将这个两个项目分别安装到手机上后，打开First App，并从<code>FirstA</code>开始跳转到<code>FirstB</code>，再进入<code>FirstC</code>页面。然后按Home键，使其进入后天任务。此时系统中的Activity信息如下：</p><img src="/2020/07/31/（拉钩）Android工程师进阶34讲-13：Android是如何通过Activity进行交互的？/LagouTaskAffinity6.png"><p>接下来，打开TaskAffinityReparent项目，屏幕上本应显示显示<code>ReoarentActivity</code>的页面内容，但是实际上显示的却是<code>FirstC</code>中的页面内容，并且系统中Activity信息如下：</p><img src="/2020/07/31/（拉钩）Android工程师进阶34讲-13：Android是如何通过Activity进行交互的？/LagouTaskAffinity7.png"><p>可以看出，<code>FirstC</code>被移动到与<code>ReparentActivity</code>处在一个任务栈中。此时<code>FIrstC</code>位于栈顶位置，再次点击返回键，才会显示<code>ReparentActivity页面</code>。</p><h1 id="2-通过Binder传递数据的限制"><a href="#2-通过Binder传递数据的限制" class="headerlink" title="2. 通过Binder传递数据的限制"></a>2. 通过Binder传递数据的限制</h1><h2 id="2-1-Binder传递数据限制"><a href="#2-1-Binder传递数据限制" class="headerlink" title="2.1 Binder传递数据限制"></a>2.1 Binder传递数据限制</h2><p>Activity界面跳转时，使用<code>Intent</code>传递数据是最常用的操作。但是<code>Intent</code>传值偶尔也会导致程序崩溃，如下代码：</p><img src="/2020/07/31/（拉钩）Android工程师进阶34讲-13：Android是如何通过Activity进行交互的？/Binder传值限制1.png"><p>在<code>startFirstB()</code>方法中，跳转<code>FirstB</code>页面，并通过<code>Itent</code>传递Bean类中的数据。但是执行上述代码会报如下错误：</p><img src="/2020/07/31/（拉钩）Android工程师进阶34讲-13：Android是如何通过Activity进行交互的？/Binder传值限制2.png"><p>上面log日志的意思是<code>Intent</code>传递数据过大，最终原因是Andorid系统对使用<code>Binder</code>传数据进行了限制。通常情况为1M，但是根据不同版本、不同厂商，这个值会有区别。</p><h2 id="2-2-解决办法"><a href="#2-2-解决办法" class="headerlink" title="2.2 解决办法"></a>2.2 解决办法</h2><ul><li>1、减少通过<code>Binder</code>传递数据，将非必须字段使用<code>transient</code>关键字修饰。</li></ul><p>比如上述Bean类中，假如<code>byte[] data</code>并非必须使用的数据，则需要避免将其序列化，如下所示：</p><img src="/2020/07/31/（拉钩）Android工程师进阶34讲-13：Android是如何通过Activity进行交互的？/Binder传值限制3.png"><p>添加<code>transient</code>修饰之后，再次运行代码，就不会报错。</p><ul><li>2、将对象转化为JSON字符串，减少数据体积。</li></ul><p>因为JVM加载类通常会伴随额外空间来保存类相关信息，将类中数据转化为JSON字符串可以减少数据大小。</p><blockquote><p>有时将类转化为JSON字符串，还是会超出<code>Binder</code>的限制，说明实际需要传递的数据很大。这时，需要考虑使用本地持久化来实现数据共享，或者使用<code>EventBus</code>来实现数据传递。</p></blockquote><p>关于<code>Binder</code>机制的原理分析。可以参考以下文章：</p><ul><li><a href="https://blog.csdn.net/luoshengyang/article/details/6629298" target="_blank" rel="noopener">Android系统进程间通信（IPC）机制Binder中的Server启动过程源代码分析</a></li><li><a href="https://www.jianshu.com/p/adaa1a39a274" target="_blank" rel="noopener">听说你 Binder 机制学的不错，来面试下这几个问题</a></li></ul><h2 id="2-3-process造成多个Application"><a href="#2-3-process造成多个Application" class="headerlink" title="2.3 process造成多个Application"></a>2.3 process造成多个Application</h2><p>一直以来，都会在<code>Application</code>中做一些初始化操作。比如App分包、推送初始化、图片加载库的全局配置等，如下图：</p><img src="/2020/07/31/（拉钩）Android工程师进阶34讲-13：Android是如何通过Activity进行交互的？/process造成多个Application1.png"><p>但实际上，Activity可以在不同的进程中启动，而每一个不同的进程都会创建出一个Application，因此可能造成Application的<code>onCreate</code>方法被执行多次。比如以下代码：</p><img src="/2020/07/31/（拉钩）Android工程师进阶34讲-13：Android是如何通过Activity进行交互的？/process造成多个Application2.png"><p><code>RemoteActivity</code>的<code>process</code>为<code>&quot;lagou.process&quot;</code>，这将导致它会在新的进程中创建。当在<code>MainActivity</code>中跳转到<code>RemoteActivity</code>时，LagouApplication会被再次创建，代码如下：</p><img src="/2020/07/31/（拉钩）Android工程师进阶34讲-13：Android是如何通过Activity进行交互的？/process造成多个Application3.png"><p>最终打印日志如下：</p><img src="/2020/07/31/（拉钩）Android工程师进阶34讲-13：Android是如何通过Activity进行交互的？/process造成多个Application4.png"><p>可以看出LagouApplication的<code>onCreate</code>方法被创建了2次，因此各种初始化的操作也会被执行2遍。</p><p>针对这个问题，目前有两种比较好的处理方式：</p><ul><li><code>onCreate</code>方法中判断进程名称，只有在符合要求的进程里，才执行初始化操作；</li><li>抽象出一个与Application生命周期同步的类，并根据不同的进程创建相应的Application实例。</li></ul><p>可以参考：<a href="http://conorlee.top/2017/02/21/Multi-Process-Dispatch/" target="_blank" rel="noopener">解决Android多进程导致Application重复创建问题</a></p><h1 id="3-后台启动Activity失效"><a href="#3-后台启动Activity失效" class="headerlink" title="3. 后台启动Activity失效"></a>3. 后台启动Activity失效</h1><p>正在打开某个App，此时手机后台正在下载另一个App。当App下载完成后，突然弹出安装界面，中断了前一个App的界面交互，这种情况会影响用户体验，而最终用户会抱怨Android手机或者Android系统本身。</p><p>为了避免这种情况的发生，从Android 10（API 29）开始，Android系统对后台进程启动Activity做了一定的限制，官网介绍如下：</p><img src="/2020/07/31/（拉钩）Android工程师进阶34讲-13：Android是如何通过Activity进行交互的？/Android系统对后台启动Activity的限制1.png"><p>主要目的就是为了避免当前前台用户的交互被打断，保证当前屏幕上显示的内容不受影响。</p><blockquote><p>但是这也造成了很多实际问题，在项目中有Force Update功能，当用户选择升级之后后台进行新的安装包下载任务。正常情况下，下载成功需要弹出apk安装界面，但是在某一版升级时，突然有很多用户反馈无法弹出下载界面。经过查看抓取的Log信息，最终发现有个特点就是发生在Andorid 10 版本，因此怀疑是版本兼容性问题，最终也确定是此问题。</p></blockquote><p>解决办法：</p><p>Android官方建议使用通知来替代直接启动Activity操作：</p><img src="/2020/07/31/（拉钩）Android工程师进阶34讲-13：Android是如何通过Activity进行交互的？/Android系统对后台启动Activity的限制2.png"><p>也就是当后台任务执行完毕之后，并不会直接调用<code>startActivity</code>来启动新的界面，而是通过<code>NotificationManager</code>来发送<code>Notification</code>到状态栏。这样既不会影响的当前使用的交互操作，用户也能及时获取后台任务的进展情况，后续的操作由用户自己决定。</p><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p>使用<code>startActivity()</code>时可能遇到的问题：</p><ul><li><code>taskAffinity</code>实现任务栈的调配；</li><li>通过<code>Binder</code>传递数据的限制；</li><li>多进程可能造成的问题；</li><li>后台启动Activity的限制。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-taskAffinity&quot;&gt;&lt;a href=&quot;#1-taskAffinity&quot; class=&quot;headerlink&quot; title=&quot;1. taskAffinity&quot;&gt;&lt;/a&gt;1. taskAffinity&lt;/h1&gt;&lt;p&gt;Actiivty的启动模式。通过配置不同
      
    
    </summary>
    
      <category term="Android" scheme="https://tylerLiu.top/categories/Android/"/>
    
      <category term="进阶" scheme="https://tylerLiu.top/categories/Android/%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Android核心技术" scheme="https://tylerLiu.top/tags/Android%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>（拉钩）Android工程师进阶34讲-12：DVM以及ART是如何对JVM进行优化的？</title>
    <link href="https://tylerLiu.top/2020/07/30/%EF%BC%88%E6%8B%89%E9%92%A9%EF%BC%89Android%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BF%9B%E9%98%B634%E8%AE%B2-12%EF%BC%9ADVM%E4%BB%A5%E5%8F%8AART%E6%98%AF%E5%A6%82%E4%BD%95%E5%AF%B9JVM%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96%E7%9A%84%EF%BC%9F/"/>
    <id>https://tylerLiu.top/2020/07/30/（拉钩）Android工程师进阶34讲-12：DVM以及ART是如何对JVM进行优化的？/</id>
    <published>2020-07-30T02:39:50.000Z</published>
    <updated>2020-07-31T01:27:22.131Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-什么是Dalvik"><a href="#1-什么是Dalvik" class="headerlink" title="1. 什么是Dalvik"></a>1. 什么是Dalvik</h1><p>Dalvik是谷歌自己设计用于Android平台的Java虚拟机，Android工程师编写的Java或Kotlin代码最终都在这台虚拟机中执行。在Android 5.0之前叫DVM，5.0以后改叫ART(Android Runtime)。</p><p>在整个Android操作系统体系中，ART位于以下位置：</p><blockquote><p>其实成DMV/ART为Android版的Java虚拟机是不准确的。虚拟机必须符合Java虚拟机规范，即通过JCM(Java Compliance Kit)的测试并获得授权，但是DVM/ART并没有得到授权。</p></blockquote><p>DVM大多数实现与传统的JVM相同，但是因为Android最初是被设计用于手机端的，对内存空间要求比较高，并且起初Dalvik目标只是运行ARM架构的CPU上。针对这几种情况，Android DVM有了自己独有的优化措施。</p><h1 id="2-Dex文件"><a href="#2-Dex文件" class="headerlink" title="2. Dex文件"></a>2. Dex文件</h1><p>传统class文件是由一个Java文件编译成的.class文件，而Android是把所有class文件进行合并优化，然后生成一个最终的class.dex文件。dex文件中去除了class文件中的冗余信息（如重复字符常量），并且结构更加紧凑，因此在dex文件解析阶段，可以减少I/O操作，提高类的查找速度。</p><p>比如在course12目录下，分别创建Dex1.java和Dex2.java，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dex1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i + j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dex2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num + i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别对它们进行编译：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac Dex1.java  -&gt;  Dex1.class</span><br><span class="line">javac Dex2.java  -&gt;  Dex2.class</span><br></pre></td></tr></table></figure><p>然后使用<code>jar cvf AllDex.jar Dex1.class Dex2.class</code>将Dex1.class和Dex2.class打包到一个jar文件中。</p><p>这时会生成一个名为AllDex.jar的文件。</p><p>最后使用dx命令对AllDex.jar进行优化，生成AllDex.dex文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dx --dex --output AllDex.dex AllDex.jars</span><br></pre></td></tr></table></figure><p>正常情况下，无法通过反编译工具查看其源码，可以通过Android SDK中的工具dexdump查看其字节码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dexdump -d -l plain AllDex.dex</span><br></pre></td></tr></table></figure><p>上述命令将Dex1和Dex2优化后的字节码显示到控制台，内容较多，部分结果如下：</p><img src="/2020/07/30/（拉钩）Android工程师进阶34讲-12：DVM以及ART是如何对JVM进行优化的？/dex文件1.png"><p>可以看出Dex1和Dex2的信息都在此.dex文件中。</p><blockquote><p>实际上，dex文件在App安装过程中还会被进一步优化为odex(optimized dex)，此过程还会在后面介绍安装过程再次提到。</p></blockquote><p>注意：这里的优化也伴随着一些副作用，最经典的就是Android 65535问题。出现这个问题的根本原因是在DVM源码中的<code>MemberIdsSection.java</code>类中，有如下一段代码：</p><img src="/2020/07/30/（拉钩）Android工程师进阶34讲-12：DVM以及ART是如何对JVM进行优化的？/dex文件2.png"><p>如果<code>items</code>个数超过<code>DexFormat.MAX_MEMBER_IDX</code>，则会报错，<code>DexFormat.MAX_MEMBER_IDX</code>的值为65535，<code>items</code>代表dex文件中方法的个数、属性个数、以及类的个数。也就是说理论上不止方法数，在java文件中声明的变量，或者创建的类超过65535个，同样会编译失败，Android提供了<code>MultiDex</code>来解决这个问题。</p><h1 id="3-架构基于寄存器-amp-基于栈堆结构"><a href="#3-架构基于寄存器-amp-基于栈堆结构" class="headerlink" title="3. 架构基于寄存器&amp;基于栈堆结构"></a>3. 架构基于寄存器&amp;基于栈堆结构</h1><p>前面已经介绍过，JVM的指令集是基于栈结构来执行的；而Android字节码和Java字节码完全不同，Androdid的字节码(smali)更多的是二地址指令和三地址指令，具体Dalvik指令可以参考<a href="https://source.android.google.cn/devices/tech/dalvik/dalvik-bytecode?hl=zh-cn" target="_blank" rel="noopener">Dalvik 字节码</a>。</p><p>具体看一下Dalvik和JVM字节码的区别，在上文中提到的Dex1.java，在Dex1中有<code>add()</code>方法。</p><p>经过编译为Dex1.class之后，查看其字节码如下：</p><img src="/2020/07/30/（拉钩）Android工程师进阶34讲-12：DVM以及ART是如何对JVM进行优化的？/Dex1.class1.png"><p><code>add()</code>方法会使用4行指令来完成。而通过dx将其优化为.dex之后，再次查看它的Dalvik字节码如下：</p><img src="/2020/07/30/（拉钩）Android工程师进阶34讲-12：DVM以及ART是如何对JVM进行优化的？/dex文件3.png"><p>说明：</p><ul><li><code>add_int</code>指令需要三个寄存器参数：<code>v0</code>、<code>v2</code>、<code>v3</code>。这个指令会将<code>v2</code>和<code>v3</code>进行相加运算，然后将结果保存到寄存器<code>v0</code>中。</li><li><code>return</code>指令将结果返回。</li></ul><p>可以看出，Dalvik字节码只需要2行指令。基于寄存器的指令明显会比基于栈的指令少，虽然增加了指令长度但却缩减了指令的数量，执行也更迅速。</p><p>用一张表来对比基于栈和基于寄存器的实现方式：</p><table><thead><tr><th align="center">栈式VS寄存器式</th><th align="center">对比</th></tr></thead><tbody><tr><td align="center">指令条数</td><td align="center">栈式 &gt; 寄存器式</td></tr><tr><td align="center">指令长度</td><td align="center">栈式 &lt; 寄存器式</td></tr><tr><td align="center">移植性</td><td align="center">栈式由于寄存器式</td></tr><tr><td align="center">指令优化</td><td align="center">栈式更不易优化</td></tr><tr><td align="center">解释器执行速度</td><td align="center">栈式解释器速度稍慢</td></tr><tr><td align="center">代码生成难度</td><td align="center">栈式简单</td></tr></tbody></table><h1 id="4-内存管理与回收"><a href="#4-内存管理与回收" class="headerlink" title="4. 内存管理与回收"></a>4. 内存管理与回收</h1><p>DVM与JVM另一个比较显著的不同是内存结构的区别，主要体现在对“堆”内存的管理。Dalvik虚拟机中的堆被划分为两个部分：Active Heap和Zygote Heap。如下如：</p><img src="/2020/07/30/（拉钩）Android工程师进阶34讲-12：DVM以及ART是如何对JVM进行优化的？/Dalvik虚拟机中的堆.png"><p>图中的Card Table以及两个Heap Bitmap主要用来记录垃圾收集过程中对象的引用情况，以便实现Concurrent GC。</p><h1 id="5-为什么要分Zygote和Active两个部分？"><a href="#5-为什么要分Zygote和Active两个部分？" class="headerlink" title="5. 为什么要分Zygote和Active两个部分？"></a>5. 为什么要分Zygote和Active两个部分？</h1><p>Android系统中的第一个Dalvik虚拟机是由Zygote进程创建的，而应用程序进程是由Zygote进程fork出来的。</p><p>Zygote进程是系统启动时产生的，它会完成虚拟机的初始化，库的加载，预置类的加载以及初始化等操作，而在系统需要一个新的虚拟机实例时，Zygote通过复制自身，最快速的提供一个进程；另外，对于一些只读的系统库，所有虚拟机实例都和Zygote共享一块内存区域，大大节省内存开销。如下图：</p><img src="/2020/07/30/（拉钩）Android工程师进阶34讲-12：DVM以及ART是如何对JVM进行优化的？/Zygote进程.png"><p>说明：</p><p>当启动一个应用时，Android操作系统需要为应用程序创建新的进程，而这一步操作是通过一种写时拷贝技术(COW)直接复制Zygote进程而来。这意味着在开始的时候，应用程序进程和Zygote进程共享了同一个用来分配对象的堆。然而，当Zygote进程或者应用程序进程对该堆进行写操作时，内核就会执行真正额拷贝操作，使得Zygote进程和应用程序进程分别拥有自己的一份拷贝。拷贝是一件费时费力额的事情。<strong>因此，为了尽量避免拷贝，Dalvik虚拟机将自己的堆栈划分为两部分。</strong></p><blockquote><p>事实上，Dalvik虚拟机的堆最初只有一个，也就是Zygote进程在启动过程创建Dalvik虚拟机时，只有一个堆。但是当Zygote进程在fork第一个应用程序进程之前，会将已经使用的那部分堆内存划分为一部分，把还没有使用的堆内部内划分为另外一部分。前者称为Zygote堆，后者称为 Active堆。以后无论Zygote进程，还是应用程序进程，当它们需要分配对象时，都在Active上进行。<strong>这样就可以使得Zygote堆尽可能少地被执行写操作，因为就可以减少执行写时拷贝的操作时间。</strong></p></blockquote><h1 id="6-Dalvik虚拟机堆"><a href="#6-Dalvik虚拟机堆" class="headerlink" title="6. Dalvik虚拟机堆"></a>6. Dalvik虚拟机堆</h1><p>在Dalvik虚拟机中，堆实际上就是一块匿名共享内存。Dalvik虚拟机并不是直接管理这块匿名共享内存，而是将它封装成一个mspace，交给C库来管理，为什么呢？因为内存碎片问题实际是一个通用的问题，不只是Dalvik虚拟机在Java堆为对象分配内存时会遇到，C库的malloc函数在分配内存时也会遇到。</p><p>Android系统使用的C库bionic使用了Doug Lea写的dlmalloc内存分配器，也就是说，调用函数malloc时，使用的是dlmalloc内存分配器来分配的内存。这是一个成熟的内存分配器，可以很好的解决内存碎片问题。</p><p>关于dlmalloc内存分配器的设计，可以参考：<a href="http://gee.cs.oswego.edu/dl/html/malloc.html" target="_blank" rel="noopener">A Memory Allocator</a></p><h1 id="7-拓展阅读"><a href="#7-拓展阅读" class="headerlink" title="7. 拓展阅读"></a>7. 拓展阅读</h1><ul><li><a href="https://www.apiref.com/android-zh/dalvik/system/package-summary.html" target="_blank" rel="noopener">dalvik.system</a></li><li><a href="http://www.zhangchuany.com/dalvik/dalvik-bytecode-instructionset-comparedtab/" target="_blank" rel="noopener">Dalvik虚拟机字节码与指令集对照表</a></li><li><a href="https://blog.csdn.net/luoshengyang/article/details/41581063" target="_blank" rel="noopener">Dalvik虚拟机Java堆创建过程分析</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-什么是Dalvik&quot;&gt;&lt;a href=&quot;#1-什么是Dalvik&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是Dalvik&quot;&gt;&lt;/a&gt;1. 什么是Dalvik&lt;/h1&gt;&lt;p&gt;Dalvik是谷歌自己设计用于Android平台的Java虚拟机
      
    
    </summary>
    
      <category term="Android" scheme="https://tylerLiu.top/categories/Android/"/>
    
      <category term="进阶" scheme="https://tylerLiu.top/categories/Android/%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="JVM与DVM必知必会" scheme="https://tylerLiu.top/tags/JVM%E4%B8%8EDVM%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"/>
    
  </entry>
  
  <entry>
    <title>（拉钩）Android工程师进阶34讲-11：线程池之刨根问底</title>
    <link href="https://tylerLiu.top/2020/07/27/%EF%BC%88%E6%8B%89%E9%92%A9%EF%BC%89Android%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BF%9B%E9%98%B634%E8%AE%B2-11%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B9%8B%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95/"/>
    <id>https://tylerLiu.top/2020/07/27/（拉钩）Android工程师进阶34讲-11：线程池之刨根问底/</id>
    <published>2020-07-27T10:31:17.000Z</published>
    <updated>2020-07-30T02:29:05.013Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h1><p>在介绍<code>synchronized</code>原理时，已经了解了Java中线程的创建以及上下切换是比较消耗性能的，因此引入了偏向锁、轻量级锁等优化技术，目的就是减少用户态和核心态之间的切换频率。但是在这些优化基础之上，还有另外一个角度值得思考：创建和销毁线程非常损耗性能，那有没有可能复用一些已经被创建的好的线程呢？那就是线程池。</p><p>另外，线程的创建需要开辟虚拟机栈、本地方法栈、程序计数器等线程私有的空间，在线程销毁时需要回收这些系统资源，频繁的创建销毁线程会浪费大量资源，而通过复用已有线程可以更好地管理和协调线程的工作。</p><p>线程池主要解决两个问题：</p><ul><li>1、当执行大量异步任务时，线程池能提供更好的性能。</li><li>2、线程池提供了一种资源限制和管理的手段，比如可以限制线程的个数，动态新增线程等。</li></ul><h1 id="1-线程池体系"><a href="#1-线程池体系" class="headerlink" title="1. 线程池体系"></a>1. 线程池体系</h1><p>线程池体系如下图：</p><img src="/2020/07/27/（拉钩）Android工程师进阶34讲-11：线程池之刨根问底/线程池体系.png"><p>说明：</p><ul><li><code>Executor</code>：线程池最顶层的接口，在<code>Executor</code>中只有一个<code>execute()</code>方法，用于执行任务。至于线程创建、调度等细节由子类实现。</li><li><code>ExecutorService</code>：继承并扩展了<code>Executor</code>，在<code>ExecutorService</code>内部提供了更全面的任务提交机制以及线程池关闭的方法。</li><li><code>ThreadPoolExecutor</code>：是<code>ExecutorService</code>的默认实现，所谓的线程池机制也大多封装在此类当中，因此它是分析的重点。</li><li><code>ScheduledExecutorService</code>继承自<code>ExecutorService</code>，增加了定时任务相关方法。</li><li><code>ScheduledThreadPoolExecutor</code>继承自<code>ThreadPoolExecutor</code>，并实现了<code>ScheduledExecutorService</code>接口。</li><li><code>ForkJoinPool</code>是一种支持任务分解的线程池，一般要配合可分解任务接口<code>ForkJoinTask</code>来使用。</li></ul><h1 id="2-创建线程池"><a href="#2-创建线程池" class="headerlink" title="2. 创建线程池"></a>2. 创建线程池</h1><p>JDK提供了一个线程池的工厂类——<code>Executors</code>。在<code>Executors</code>中定义了多个静态方法，用来创建不同配置的线程池。常用有以下几种。</p><h2 id="2-1-newSingleThreadExecutor"><a href="#2-1-newSingleThreadExecutor" class="headerlink" title="2.1 newSingleThreadExecutor"></a>2.1 newSingleThreadExecutor</h2><p>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按先进先出的顺序执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateSingleThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建单线程池</span></span><br><span class="line">        ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> taskId = i;</span><br><span class="line">            <span class="comment">// 向线程池中提交任务</span></span><br><span class="line">            singleThreadExecutor.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"线程："</span> + Thread.currentThread().getName() + <span class="string">" 正在执行 task："</span> + taskId);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上述代码，结果如下，可以看出所有的<code>task</code>始终是在同一个线程中执行的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">线程：pool-1-thread-1 正在执行 task：0</span><br><span class="line">线程：pool-1-thread-1 正在执行 task：1</span><br><span class="line">线程：pool-1-thread-1 正在执行 task：2</span><br><span class="line">线程：pool-1-thread-1 正在执行 task：3</span><br><span class="line">线程：pool-1-thread-1 正在执行 task：4</span><br><span class="line">线程：pool-1-thread-1 正在执行 task：5</span><br></pre></td></tr></table></figure><h2 id="2-2-newCachedThreadPool"><a href="#2-2-newCachedThreadPool" class="headerlink" title="2.2 newCachedThreadPool"></a>2.2 newCachedThreadPool</h2><p>创建一个可缓存线程，如果线程池长度超过处理需要，可灵活回收空线程，若无可回收，则新建线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateCacheThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService cacheThreadPool = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> taskId = i;</span><br><span class="line"></span><br><span class="line">            cacheThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">"线程："</span> + Thread.currentThread().getName() + <span class="string">" 正在执行 task："</span> + taskId);</span><br><span class="line">                        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        cacheThreadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行效果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">线程：pool-1-thread-1 正在执行 task：0</span><br><span class="line">线程：pool-1-thread-2 正在执行 task：1</span><br><span class="line">线程：pool-1-thread-3 正在执行 task：2</span><br><span class="line">线程：pool-1-thread-4 正在执行 task：3</span><br><span class="line">线程：pool-1-thread-5 正在执行 task：4</span><br><span class="line">线程：pool-1-thread-6 正在执行 task：5</span><br></pre></td></tr></table></figure><p>从日志可以看出，缓存线程池会创建新的线程来执行任务。但是如果将代码修改一下，在提交任务之前休眠1秒，修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateCacheThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService cacheThreadPool = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> taskId = i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 每次执行任务前休眠1秒</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">            cacheThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">"线程："</span> + Thread.currentThread().getName() + <span class="string">" 正在执行 task："</span> + taskId);</span><br><span class="line">                        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        cacheThreadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">线程：pool-1-thread-1 正在执行 task：0</span><br><span class="line">线程：pool-1-thread-1 正在执行 task：1</span><br><span class="line">线程：pool-1-thread-1 正在执行 task：2</span><br><span class="line">线程：pool-1-thread-1 正在执行 task：3</span><br><span class="line">线程：pool-1-thread-1 正在执行 task：4</span><br><span class="line">线程：pool-1-thread-1 正在执行 task：5</span><br></pre></td></tr></table></figure><h2 id="2-3-newFixedThreadPool"><a href="#2-3-newFixedThreadPool" class="headerlink" title="2.3 newFixedThreadPool"></a>2.3 newFixedThreadPool</h2><p>创建一个固定数目的、可重用的线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateFixedThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建线程数量为3的线程池</span></span><br><span class="line">        ExecutorService singleThreadThreadExecutor = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 提交10个任务交给线程池执行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> taskId = i;</span><br><span class="line"></span><br><span class="line">            singleThreadThreadExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"线程："</span> + Thread.currentThread().getName() + <span class="string">" 正在执行 task："</span> + taskId);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">线程：pool-1-thread-2 正在执行 task：1</span><br><span class="line">线程：pool-1-thread-1 正在执行 task：0</span><br><span class="line">线程：pool-1-thread-3 正在执行 task：2</span><br><span class="line">线程：pool-1-thread-1 正在执行 task：4</span><br><span class="line">线程：pool-1-thread-2 正在执行 task：3</span><br><span class="line">线程：pool-1-thread-1 正在执行 task：6</span><br><span class="line">线程：pool-1-thread-3 正在执行 task：5</span><br><span class="line">线程：pool-1-thread-1 正在执行 task：8</span><br><span class="line">线程：pool-1-thread-2 正在执行 task：7</span><br><span class="line">线程：pool-1-thread-1 正在执行 task：10</span><br><span class="line">线程：pool-1-thread-3 正在执行 task：9</span><br></pre></td></tr></table></figure><h2 id="2-4-newScheduledThreadPool"><a href="#2-4-newScheduledThreadPool" class="headerlink" title="2.4 newScheduledThreadPool"></a>2.4 newScheduledThreadPool</h2><p>创建一个定时线程池，支持定时及周期性任务执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateScheduledThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 指定线程数量为2的定时任务线程池</span></span><br><span class="line">        ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">        scheduledThreadPool.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Date now = <span class="keyword">new</span> Date();</span><br><span class="line">                System.out.println(<span class="string">"线程："</span> + Thread.currentThread().getName() + <span class="string">" 报时："</span> + now);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">500</span>, <span class="number">500</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        <span class="comment">// 关闭定时任务</span></span><br><span class="line">        scheduledThreadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码创建了一个线程数量为2的定时任务线程池，通过<code>scheduleAtFixedRate()</code>方法，指定每隔500毫秒执行一次任务，并且在5秒之后通过<code>shutdown()</code>关闭定时任务。执行效果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">线程：pool-1-thread-1 报时：Tue Jul 28 14:25:04 CST 2020</span><br><span class="line">线程：pool-1-thread-1 报时：Tue Jul 28 14:25:04 CST 2020</span><br><span class="line">线程：pool-1-thread-2 报时：Tue Jul 28 14:25:05 CST 2020</span><br><span class="line">线程：pool-1-thread-1 报时：Tue Jul 28 14:25:05 CST 2020</span><br><span class="line">线程：pool-1-thread-2 报时：Tue Jul 28 14:25:06 CST 2020</span><br><span class="line">线程：pool-1-thread-1 报时：Tue Jul 28 14:25:06 CST 2020</span><br><span class="line">线程：pool-1-thread-2 报时：Tue Jul 28 14:25:07 CST 2020</span><br><span class="line">线程：pool-1-thread-2 报时：Tue Jul 28 14:25:07 CST 2020</span><br><span class="line">线程：pool-1-thread-1 报时：Tue Jul 28 14:25:08 CST 2020</span><br></pre></td></tr></table></figure><p>上面是常用的几种线程池的使用方式，但是《阿里Java开发手册》中已经严禁使用<code>Executors</code>来创建线程池了，为什么呢？下面先看看线程池的工作原理。</p><h1 id="3-线程池工作原理分析"><a href="#3-线程池工作原理分析" class="headerlink" title="3. 线程池工作原理分析"></a>3. 线程池工作原理分析</h1><h2 id="3-1-案例"><a href="#3-1-案例" class="headerlink" title="3.1 案例"></a>3.1 案例</h2><p>某工艺品加工厂有三台机器用来生产订单所需的产品，正常情况下，三天机器能保证所有订单按时按需生产完毕，如下图：</p><img src="/2020/07/27/（拉钩）Android工程师进阶34讲-11：线程池之刨根问底/案例1.gif"><p>如果订单突然大幅增加，三台机器已经处于满负荷状态，一时间无法完成新增的订单任务，怎么办呢？如果接下了新的订单，会将新来的订单暂时存放在仓库中，当有加工机器空闲时，再用来生产仓库中的订单，如下图：</p><img src="/2020/07/27/（拉钩）Android工程师进阶34讲-11：线程池之刨根问底/案例2.gif"><p>如果订单持续快速增长，导致仓库也存储满了？又该如何？正常情况下加工厂肯定会通过购买新的加工机器来满足订单需求，如下图：</p><img src="/2020/07/27/（拉钩）Android工程师进阶34讲-11：线程池之刨根问底/案例3.png"><p>有了仓库和新买的机器，加工厂业务还能正常流转。但是当某些极端情况发生时，比如节假日之后的爆单。这时新增的订单连仓库以及所有的加工机器都不能满足，说明工厂已经不能接新的订单了，只能拒绝新的订单。</p><img src="/2020/07/27/（拉钩）Android工程师进阶34讲-11：线程池之刨根问底/案例4.png"><p>线程池的工作流程和上面描述的加工厂完成订单任务类似，并且在线程池的构造器中，通过传入的参数可以设置默认有多少台加工机器、仓库的大小、可以购买新的加工机器的最大数量等等。</p><h2 id="3-2-线程池结构"><a href="#3-2-线程池结构" class="headerlink" title="3.2 线程池结构"></a>3.2 线程池结构</h2><img src="/2020/07/27/（拉钩）Android工程师进阶34讲-11：线程池之刨根问底/线程池结构.png"><p>从上图可以看出，线程池内部主要包含以下几个部分：</p><ul><li>work集合：保存所有的核心线程和非核心线程，其本质是一个<code>HashSet</code>。</li><li>等待任务队列：当核心线程的个数达到<code>corePiilSize</code>时，提交新的任务会被先保存在等待队列中，其本质是一个阻塞队列<code>BlockingQueue</code>。</li><li>ctl：是一个<code>AtomicInteger</code>类型，二进制高3位用来标识线程池的状态，低29位用来记录线程池中线程的数量。</li></ul><p>获取线程池状态、工作线程数量、修改ctl的方法分别如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算当前运行状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &amp; -CAPACITY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算当前线程数量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &amp; CAPACITY;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过状态和线程数量生成ctl</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rs | wc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程池主要有几下几种运行状态：</p><ul><li>RUNNING：默认状态，接收新任务并处理排队任务；</li><li>SHUTDOWN:不接受新任务，但处理排队任务，调用<code>shutDown()</code>会处于该状态；</li><li>STOP：不接受新任务，也不处理排队任务，并中断正在运行的任务，调用<code>shutDownNow()</code>会处于该状态；</li><li>TIDYING：所有任务都已终止，<code>workCount</code>为0时，线程会转换到TIDYING状态，并将运行<code>terminate()</code>方法。</li><li>TERMINATED：<code>terminate()</code>运行完成后，线程池转为此状态。</li></ul><h2 id="3-3-参数分析"><a href="#3-3-参数分析" class="headerlink" title="3.3 参数分析"></a>3.3 参数分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>corePoolSIze</code>：表示核心线程数量。</li><li><code>maximumPoolSize</code>：表示线程池最大能容纳同时执行的线程数，必须 &gt;= 1。如果和<code>corePoolSize</code>相等即是固定大小线程池。</li><li><code>keepAliveTime</code>：表示线程池中的空闲时间，当空闲时间达到此值时，线程会被销毁直到剩下<code>corePoolSize</code>个线程。</li><li><code>unit</code>：用来指定<code>KeepAliveTime</code>的时间单位，有<code>MILLISECONDS</code>、<code>SECONDS</code>、<code>MINUTES</code>、<code>HOURS</code>等。</li><li><code>workQueue</code>：等待队列，<code>BlockingQueue</code>类型。当请求任务数大于<code>corePoolSize</code>时，任务将被缓存到此<code>BlockingQueue</code>中。</li><li><code>threadFactory</code>：线程工厂，线程池中使用它来创建线程，如果传入的是null，则使用默认工厂类<code>DefaultThreadFactory</code>。</li><li><code>handler</code>：执行拒绝策略的对象。当<code>workQueue</code>满了之后并且活动线程数大于<code>maximumPoolSize</code>时，线程池通过该策略处理请求。</li></ul><blockquote><p>注意：当<code>ThreadPoolExecutor</code>的<code>allowCoreThreadTimeOut</code>设置为<code>true</code>时，核心线程超时后也会被销毁。</p></blockquote><h2 id="3-4-流程解析"><a href="#3-4-流程解析" class="headerlink" title="3.4 流程解析"></a>3.4 流程解析</h2><p>当调用<code>execute</code>或者<code>submit</code>，将一个任务交给线程池，线程池接收这个任务请求后，有以下几种处理情况：</p><ul><li>1、当前线程池中运行的线程数量还没有达到<code>corePoolSize</code>大小时，线程池会创建一个新线程执行提交的任务，无论之前创建的线程是否处于空闲状态。例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LessThanCoreCount</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> taskId = i;</span><br><span class="line"></span><br><span class="line">            fixedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">"线程："</span> + Thread.currentThread().getName() + <span class="string">" 正在执行 task："</span> + taskId);</span><br><span class="line">                        <span class="comment">// 任务耗时100毫秒</span></span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// 延时2s向线程池中提交任务</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        fixedThreadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>上面代码创建了3个固定数量的线程池，每次提交的任务耗时100毫秒。每次提交任务之前都会延迟2秒，保证线程池中的工作线程已经执行完毕的，但是执行效果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">线程：pool-1-thread-1 正在执行 task：1</span><br><span class="line">线程：pool-1-thread-2 正在执行 task：2</span><br><span class="line">线程：pool-1-thread-3 正在执行 task：3</span><br><span class="line">线程：pool-1-thread-1 正在执行 task：4</span><br><span class="line">线程：pool-1-thread-2 正在执行 task：5</span><br></pre></td></tr></table></figure><p>虽然线程1和线程2都已经执行完毕，并处于空闲状态，但是线程池还是会尝试创建新的线程去执行新提交的任务，知道线程数量达到<code>corePoolSize</code>。</p><ul><li>2、当前线程池中运行的线程数量已经达到<code>corePoolSize</code>时，线程池会把任务加到等待队列中，直到某一个线程空闲了，线程池会根据设置的等待队列规则，从队列中取出一个新的任务执行。例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoreThanCoreCount</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreadPoolExecutor fixedThreadPool = (ThreadPoolExecutor) Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> taskId = i;</span><br><span class="line"></span><br><span class="line">            fixedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">"线程："</span> + Thread.currentThread().getName() + <span class="string">" 正在执行 task："</span> + taskId);</span><br><span class="line">                        <span class="comment">// 任务耗时4秒</span></span><br><span class="line">                        Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            System.out.println(<span class="string">"此时等待队列中有 "</span> + fixedThreadPool.getQueue().size() + <span class="string">" 个元素。"</span>);</span><br><span class="line">            <span class="comment">// 延时500毫秒向线程池中提交任务</span></span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        fixedThreadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>代码中，任务耗时4秒。此时新的任务提交给线程时，任务会缓存到等待队列中，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">此时等待队列中有 0 个元素。</span><br><span class="line">线程：pool-1-thread-1 正在执行 task：1</span><br><span class="line">此时等待队列中有 0 个元素。</span><br><span class="line">线程：pool-1-thread-2 正在执行 task：2</span><br><span class="line"></span><br><span class="line">// 2</span><br><span class="line">此时等待队列中有 1 个元素。</span><br><span class="line">此时等待队列中有 2 个元素。</span><br><span class="line">此时等待队列中有 3 个元素。</span><br><span class="line">线程：pool-1-thread-1 正在执行 task：3</span><br><span class="line">线程：pool-1-thread-2 正在执行 task：4</span><br><span class="line">线程：pool-1-thread-1 正在执行 task：5</span><br></pre></td></tr></table></figure><p>1中通过两个核心线程直接执行提交的任务，因此等待队列中的数量为0；2中表明，此时核心线程都已经被占用，新提交的任务都被放入等待队列中。</p><ul><li>3、如果线程数大于<code>corePoolSize</code>，但是还没达到最大线程池数<code>maximumPoolSize</code>，并且等待队列已满，则线程池会创建新的线程来执行任务。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NonCoreThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 核心线程为2，最大线程数为10，等待队列长度为2</span></span><br><span class="line">        ThreadPoolExecutor threadPool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">10</span>, <span class="number">0L</span>,</span><br><span class="line">                TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> taskId = i;</span><br><span class="line"></span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">"线程："</span> + Thread.currentThread().getName() + <span class="string">" 正在执行 task："</span> + taskId);</span><br><span class="line">                        <span class="comment">// 任务耗时4秒</span></span><br><span class="line">                        Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            System.out.println(<span class="string">"此时等待队列中有 "</span> + threadPool.getQueue().size() + <span class="string">" 个元素。"</span>);</span><br><span class="line">            <span class="comment">// 延时500毫秒向线程池中提交任务</span></span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>执行效果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">此时等待队列中有 0 个元素。</span><br><span class="line">线程：pool-1-thread-1 正在执行 task：1</span><br><span class="line">此时等待队列中有 0 个元素。</span><br><span class="line">线程：pool-1-thread-2 正在执行 task：2</span><br><span class="line"></span><br><span class="line">// 2</span><br><span class="line">此时等待队列中有 1 个元素。</span><br><span class="line">此时等待队列中有 2 个元素。</span><br><span class="line">此时等待队列中有 2 个元素。</span><br><span class="line">线程：pool-1-thread-3 正在执行 task：5 // 3</span><br><span class="line"></span><br><span class="line">线程：pool-1-thread-1 正在执行 task：3</span><br><span class="line">线程：pool-1-thread-2 正在执行 task：4</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><p>1处表示线程数量已经达到<code>corePoolSize</code>。</p></li><li><p>2处表示等待队列已满。</p></li><li><p>3处创建新的线程执行任务。</p></li><li><p>4、最后如果提交的任务，无法被核心线程直接执行，又无法加入等待队列，又无法创建“非核心线程”直接执行，线程池将根据拒绝处理器定义的策略处理这个任务。比如在<code>ThreadPoolExecutor</code>中，如果没有为线程池设置<code>RejectedExecutionHandler</code>。这时线程池会抛出<code>RejectedExecutionException</code>，即线程池拒绝接受这个任务。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolRejectHandle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 核心线程为2，最大线程数为3，等待队列长度为2</span></span><br><span class="line">        ThreadPoolExecutor threadPool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">3</span>, <span class="number">0L</span>,</span><br><span class="line">                TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123; <span class="comment">// 提交6次任务</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> taskId = i;</span><br><span class="line"></span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">"线程："</span> + Thread.currentThread().getName() + <span class="string">" 正在执行 task："</span> + taskId);</span><br><span class="line">                        <span class="comment">// 任务耗时5秒</span></span><br><span class="line">                        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            System.out.println(<span class="string">"此时等待队列中有 "</span> + threadPool.getQueue().size() + <span class="string">" 个元素。"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>执行效果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">此时等待队列中有 0 个元素。</span><br><span class="line">此时等待队列中有 0 个元素。</span><br><span class="line">此时等待队列中有 1 个元素。</span><br><span class="line">此时等待队列中有 2 个元素。</span><br><span class="line">此时等待队列中有 2 个元素。</span><br><span class="line">线程：pool-1-thread-1 正在执行 task：1</span><br><span class="line">线程：pool-1-thread-2 正在执行 task：2</span><br><span class="line">线程：pool-1-thread-3 正在执行 task：5</span><br><span class="line">Exception in thread &quot;main&quot; java.util.concurrent.RejectedExecutionException: Task ThreadPoolRejectHandle$1@d716361 rejected from java.util.concurrent.ThreadPoolExecutor@6ff3c5b5[Running, pool size = 3, active threads = 3, queued tasks = 2, completed tasks = 0]</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2063)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:830)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1379)</span><br><span class="line">at ThreadPoolRejectHandle.main(ThreadPoolRejectHandle.java:14)</span><br><span class="line">线程：pool-1-thread-1 正在执行 task：3</span><br><span class="line">线程：pool-1-thread-2 正在执行 task：4</span><br></pre></td></tr></table></figure><p>程序报了<code>RejectedExecutionException</code>，拒绝策略是线程池的一种保护机制，目的就是当这种无节制的线程资源申请发生时，拒绝新的任务保护线程池。默认拒绝策略会直接报异常，但是JDK中一共提供了4中保护策略，如下：</p><table><thead><tr><th align="center">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">ThreadPoolExecutor.AbortPolicy</td><td align="left">丢弃任务并抛出<code>RejectedExecutionException</code>。这时线程池默认的拒绝策略，在任务不能再提交时，抛出异常，及时反馈程序运行状态。如果是比较关键的业务，推荐使用此策略，这样在系统不能承载更大的并发量的时候，能及时通过异常发现。</td></tr><tr><td align="center">ThreadPoolExecutor.DiscardPolicy</td><td align="left">丢弃任务，但是不抛出异常。使用此策略，可能会无法发现系统的异常状态。建议一些不重要的业务采用此策略。</td></tr><tr><td align="center">ThreadPoolExecutor.DiscardOldestPolicy</td><td align="left">丢弃队列最前面的任务，然后重新提交被拒绝的任务。是否要采用此种拒绝策略，要根据实际业务是否允许丢弃老任务来衡量。</td></tr><tr><td align="center">ThreadPoolExecutor.CallerRunsPolicy</td><td align="left">由调用线程（提交任务的线程）处理该任务。这种情况是需要让所有任务都执行完毕，那么就适合大量计算的任务类型去执行，多线程仅仅是增大吞吐量的手段，最终必须要让每个任务都执行完毕。</td></tr></tbody></table><blockquote><p>实际上拒绝策略都是实现接口<code>RejectedExecutionException</code>，也可以自定义类实现接口，定义自己的拒绝策略。</p></blockquote><p>整个流程的动画演示：<a href="https://mp.weixin.qq.com/s?__biz=MzU3Mjc5NjAzMw==&mid=2247484276&idx=1&sn=31c805234afd7284457f268a74db7ce3&chksm=fcca3e9acbbdb78c3d4c4a58aab058577377e87e612aea435fe08f4f3f90bbd8612abdc07237&token=263838289&lang=zh_CN#rd" target="_blank" rel="noopener">漫画Java线程池的工作机制</a></p><h1 id="4-为何禁止使用Executors"><a href="#4-为何禁止使用Executors" class="headerlink" title="4. 为何禁止使用Executors"></a>4. 为何禁止使用Executors</h1><p>再来看看对于禁止使用<code>Executors</code>，特别是<code>newFixedThreadPool</code>和<code>newCachedThreadPool</code>两个方法。</p><p>比如如下使用<code>newFixedThreadPool</code>方法创建线程池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FixedThreadPoolOOM</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPoolExecutor fixedThreadPool = (ThreadPoolExecutor) Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 提交10个任务交给线程池执行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> taskId = i;</span><br><span class="line">            System.out.println(<span class="string">"execute task:"</span> + taskId);</span><br><span class="line"></span><br><span class="line">            fixedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">"线程："</span> + Thread.currentThread().getName() + <span class="string">" 正在执行 task："</span> + taskId);</span><br><span class="line">                        <span class="comment">// 任务耗时10秒</span></span><br><span class="line">                        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        fixedThreadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码创建一个固定线程数量为2的线程池，并通过<code>for</code>循环向线程池中提交100W个任务。</p><p>通过<code>java -Xms4m -Xmx4m FixedThreadPoolOOM</code>执行上述代码：</p><img src="/2020/07/27/（拉钩）Android工程师进阶34讲-11：线程池之刨根问底/FixedThreadPoolOOM.png"><p>可以看到当任务执行到7W多个时候，程序发生OOM。为什么呢？看一下<code>newSingleThreadExecutor()</code>和<code>newFixedThreadPool()</code>的具体实现，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads, <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">        <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到传入的是一个无界的阻塞队列，理论上可以无限添加任务到线程池。当核心线程执行时间很长，则新提交的任务在不断插入到阻塞队列中，最终造成OOM。</p><p>再看一下<code>newCachedThreadPool()</code>有什么问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheThreadPoolOOM</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPoolExecutor fixedThreadPool = (ThreadPoolExecutor) Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">// 提交10个任务交给线程池执行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> taskId = i;</span><br><span class="line">            System.out.println(<span class="string">"execute task:"</span> + taskId);</span><br><span class="line"></span><br><span class="line">            fixedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">"线程："</span> + Thread.currentThread().getName() + <span class="string">" 正在执行 task："</span> + taskId);</span><br><span class="line">                        <span class="comment">// 任务耗时10秒</span></span><br><span class="line">                        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        fixedThreadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码同样会报OOM，只是错误的log信息有点区别：无法创建新的线程。</p><img src="/2020/07/27/（拉钩）Android工程师进阶34讲-11：线程池之刨根问底/CacheThreadPoolOOM.png"><p>看一下<code>newCachedThreadPool()</code>的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，缓存线程池的最大线程数为<code>Integer</code>最大值。当核心线程耗时很久，线程池会尝试创建新的线程来执行提交任务，当内部不足时就会报无法创建线程的错误。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0. 前言&quot;&gt;&lt;/a&gt;0. 前言&lt;/h1&gt;&lt;p&gt;在介绍&lt;code&gt;synchronized&lt;/code&gt;原理时，已经了解了Java中线程的创建以及上下切换是比较消耗性能
      
    
    </summary>
    
      <category term="Android" scheme="https://tylerLiu.top/categories/Android/"/>
    
      <category term="进阶" scheme="https://tylerLiu.top/categories/Android/%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="JVM与DVM必知必会" scheme="https://tylerLiu.top/tags/JVM%E4%B8%8EDVM%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"/>
    
  </entry>
  
  <entry>
    <title>（拉钩）Android工程师进阶34讲-10：深入理解AQS和CAS原理</title>
    <link href="https://tylerLiu.top/2020/07/24/%EF%BC%88%E6%8B%89%E9%92%A9%EF%BC%89Android%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BF%9B%E9%98%B634%E8%AE%B2-10%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3AQS%E5%92%8CCAS%E5%8E%9F%E7%90%86/"/>
    <id>https://tylerLiu.top/2020/07/24/（拉钩）Android工程师进阶34讲-10：深入理解AQS和CAS原理/</id>
    <published>2020-07-24T01:37:59.000Z</published>
    <updated>2020-07-27T10:27:53.726Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h1><p>AQS 全称 Abstract Queued Synchronized，一般翻译为同步器。它是一套实现多线程同步功能的框架，由 Doug Lea 操刀设计并开发实现的。AQS 在源码中被广泛使用，尤其是在JUC(Java Util Concurrent)中，比如<code>ReentrantLock</code>、<code>Semaphore</code>、<code>CountDownLatch</code>、<code>ThreadPoolExecutor</code>。理解 AQS 对理解 JUC 以及其他组件很有帮助，并且在实际开发中也可以通过自定义 AQS 来实现各种需求场景。</p><blockquote><p>注意：理解 AQS 需要一定额数据结构基础，尤其是双端队列，并对Unsafe有一定了解。</p></blockquote><h1 id="1-ReentrantLock-和-AQS-的关系"><a href="#1-ReentrantLock-和-AQS-的关系" class="headerlink" title="1. ReentrantLock 和 AQS 的关系"></a>1. ReentrantLock 和 AQS 的关系</h1><p>这里主要通过<code>ReentrantLock</code>来理解 AQS 内部的工作机制。首先从<code>ReentrantLock</code>的<code>lock()</code>方法开始：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires the lock.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Acquires the lock if it is not held by another thread and returns</span></span><br><span class="line"><span class="comment"> * immediately, setting the lock hold count to one.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If the current thread already holds the lock then the hold</span></span><br><span class="line"><span class="comment"> * count is incremented by one and the method returns immediately.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If the lock is held by another thread then the</span></span><br><span class="line"><span class="comment"> * current thread becomes disabled for thread scheduling</span></span><br><span class="line"><span class="comment"> * purposes and lies dormant until the lock has been acquired,</span></span><br><span class="line"><span class="comment"> * at which time the lock hold count is set to one.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在里面只调用了<code>Sync</code>的<code>lock()</code>方法，这个<code>Sync</code>是什么呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7373984872572414699L</span>;</span><br><span class="line">    <span class="comment">/** Synchronizer providing all implementation mechanics */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Sync</code>是<code>ReentrantLock</code>的一个内部类。<code>ReentrantLock</code>并没有直接继承 AQS，而是通过内部<code>Sync</code>来扩展AQS的功能，然后<code>ReentrantLock</code>中存有<code>Sync</code>的全局变量引用。</p><p><code>Sync</code>在<code>ReentrantLock</code>有两种实现：<code>NonfairSync</code>和<code>FairSync</code>，分别对应非公平锁和公平锁。以非公平锁为例，实现源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sync object for non-fair locks</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">     * acquire on failure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) <span class="comment">// 通过cas操作来修改state状态，表示争抢锁的操作</span></span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread()); <span class="comment">// 设置当前获得锁状态的线程</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>); <span class="comment">// 修改状态失败，尝试获取锁</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，在非公平锁的<code>lock()</code>方法中，主要做了如下操作：</p><ul><li>如果通过CAS设置变量<code>state</code>（同步状态）成功，表示当前线程获取锁成功，则将当前线程设置为独占线程。</li><li>如果通过CAS设置变量<code>state</code>（同步状态）失败，表示当前做正在被其他线程持有，则进入Acquire方法进行后续处理。</li></ul><p><code>acquire()</code>方法定义在AQS中，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires in exclusive mode, ignoring interrupts.  Implemented</span></span><br><span class="line"><span class="comment"> * by invoking at least once &#123;<span class="doctag">@link</span> #tryAcquire&#125;,</span></span><br><span class="line"><span class="comment"> * returning on success.  Otherwise the thread is queued, possibly</span></span><br><span class="line"><span class="comment"> * repeatedly blocking and unblocking, invoking &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * #tryAcquire&#125; until success.  This method can be used</span></span><br><span class="line"><span class="comment"> * to implement method &#123;<span class="doctag">@link</span> Lock#lock&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment"> *        &#123;<span class="doctag">@link</span> #tryAcquire&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment"> *        can represent anything you like.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>acquire()</code>主要做了三件事：</p><ul><li>1、<code>tryAcquire()</code>：尝试获取锁；</li><li>2、<code>addWaiter()</code>：如果<code>tryAcquire()</code>尝试获取锁失败，则调用<code>addWaiter()</code>将当前线程添加到一个等待队列中；</li><li>3、<code>acquireQueued()</code>：处理加入到队列中的节点，通过自旋去尝试获取锁，根据情况将线程挂起或取消。</li></ul><p>以上三个方法都被定义在AQS中，其中<code>tryAcquire()</code>有点特殊，其实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，直接抛出异常，因此它需要在子类中重写，<strong>真正的获取锁的逻辑由子类同步器自己实现。</strong></p><p><code>ReentrantLock</code>中<code>tryAcquire()</code>的实现（非公平锁）如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs non-fair tryLock.  tryAcquire is implemented in</span></span><br><span class="line"><span class="comment"> * subclasses, but both need nonfair try for trylock method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前执行的线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState(); <span class="comment">// 获取 state 值</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// c == 0，说明当前是无锁状态</span></span><br><span class="line">        <span class="comment">// 通过cas操作来替换state的值为1</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            <span class="comment">// 设置当前线程持有独占锁</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是同一个线程来获得锁，则直接增加重入次数</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires; <span class="comment">// 增加重入次数</span></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>获得当前线程，判断当前的锁的状态。</li><li>如果<code>state == 0</code>，表示当前是无锁状态，通过cas更新<code>state</code>状态的值，返回<code>true</code>。</li><li>如果当前线程属于重入，则增加重入次数，返回<code>true</code>。</li><li>上述情况都不满足，则获取锁失败，返回<code>false</code>。</li></ul><p>一张图表示<code>ReentrantLock.lock()</code>过程：</p><img src="/2020/07/24/（拉钩）Android工程师进阶34讲-10：深入理解AQS和CAS原理/ReentrantLock.lock()过程.png"><p>图中可以看出，在<code>ReentrantLock</code>执行<code>lock()</code>过程中，大部分同步机制的核心逻辑都已经在AQS中实现，<code>ReentrantLock</code>自身只要实现某些特定步骤下的方法即可，这种设计模式叫<strong>模板模式</strong>。比如Android中，Activity的生命周期的执行流程都已经在framework中定义好了，子类Activity只要在相应的<code>onCreate()</code>、<code>onPause()</code>等生命周期方法中提供相应的实现即可。</p><blockquote><p>注意：不止<code>ReentrantLock</code>，JUC包中的其他组件如<code>CountDownLatch</code>、<code>Semaphor</code>等都是通过一个内部类<code>Sync</code>来继承AQS，然后在内部中通过操作<code>Sync</code>来实现同步。这种做法的好处是将线程控制的逻辑控制在<code>Sync</code>内部，而对外面向用户提供的接口是自定义锁，这种聚合关系能够很好的解耦两者所关注的逻辑。</p></blockquote><h1 id="2-AQS核心功能原理分析"><a href="#2-AQS核心功能原理分析" class="headerlink" title="2. AQS核心功能原理分析"></a>2. AQS核心功能原理分析</h1><p>首先看看AQS中几个关键的属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure><p>代码中展示了AQS中两个比较重要的属性<code>Node</code>和<code>state</code>。</p><h2 id="2-1-state锁状态"><a href="#2-1-state锁状态" class="headerlink" title="2.1 state锁状态"></a>2.1 state锁状态</h2><p><code>state</code>表示当前锁状态。当<code>state = 0</code>时表示无锁状态；当<code>state &gt; 0</code>时，表示已经有线程获得锁，也就是<code>state = 1</code>，如果同一个线程多次获得同步锁时，<code>state</code>会递增，比如重入5次，那么<code>state = 5</code>。而在释放锁时，同样需要释放5次直到<code>state = 0</code>，其他线程才有资格获得锁。</p><p><code>state</code>还有一个功能是实现锁的独占模式或共享模式。</p><ul><li>独占模式：只有一个线程能够持有同步锁。</li></ul><blockquote><p>在独占模式下，可以把<code>state</code>的初始值设置成0，当某个线程申请锁对象时，需要判断<code>state</code>的值是不是0，如果不是0，表示其他线程已经持有该锁，则本线程需要阻塞等待。</p></blockquote><ul><li>共享模式：可以有多个线程持有同步锁。</li></ul><blockquote><p>共享模式下，比如某项操作允许10个线程同时进行，超过这个数量的线程就需要阻塞等待。那么只需要在线程申请对象时判断<code>state</code>的值是否小于10。如果小于10，就将<code>state</code>加1后继续同步语句的执行；如果等于10，说明已经有10个线程同时执行该操作，本线程需要阻塞等待。</p></blockquote><h2 id="2-2-Node双端队列节点"><a href="#2-2-Node双端队列节点" class="headerlink" title="2.2 Node双端队列节点"></a>2.2 Node双端队列节点</h2><p><code>Node</code>是一个先进先出的双端队列，并且是等待队列，当多线程争用资源被阻塞时会进入此队列。这个队列是AQS实现多线程同步的核心。</p><p>从之前<code>ReentrantLock</code>图中可以看出，在AQS中有两个<code>Node</code>的指针，分别指向队列的<code>head</code>和<code>tail</code>。</p><p><code>Node</code>的主要结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 该等待同步的节点处于共享模式</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="comment">// 该等待同步的节点处于独占模式</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Node中的线程状态，这个和state是不一样的：有1，0，-1，-2，-3五个值</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">    <span class="keyword">volatile</span> Node prev; <span class="comment">// 前驱节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next; <span class="comment">// 后继节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread; <span class="comment">// 等待锁的线程</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，AQS中的链表结构如下图所示：</p><img src="/2020/07/24/（拉钩）Android工程师进阶34讲-10：深入理解AQS和CAS原理/AQS的链表结构1.png"><h2 id="2-3-获取锁失败后续流程分析"><a href="#2-3-获取锁失败后续流程分析" class="headerlink" title="2.3 获取锁失败后续流程分析"></a>2.3 获取锁失败后续流程分析</h2><p>锁的意义就是使竞争到锁对象的线程执行同步代码，多个线程竞争锁时，竞争失败的线程需要被阻塞等待后续唤醒。那么<code>ReentrantLock</code>是如何实现让线程等待并唤醒的呢？</p><p>前面提到在<code>ReentrantLock.lock()</code>阶段，在<code>acquire()</code>方法中会先调用<code>tryAcquire</code>、<code>addWaiter</code>、<code>acquireQueued</code>这三个方法来处理。<code>tryAcquire</code>在<code>ReentrantLock</code>中被复写并实现，如果返回<code>true</code>，说明成功获取锁，就继续执行同步代码语句。可是如果<code>tryAcquire</code>返回<code>false</code>，也就是当前锁对象被其他线程所持有，那么当前线程会被AQS如何处理呢？</p><h3 id="2-3-1-addWaiter"><a href="#2-3-1-addWaiter" class="headerlink" title="2.3.1 addWaiter"></a>2.3.1 addWaiter</h3><p>首先当前获取锁失败的线程会被添加到一个等待队列的末端，具体源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将线程以Node的方式添加到队列中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 把当前线程封装到一个新的Node</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123; <span class="comment">// 将node插入到队列</span></span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123; <span class="comment">// CAS替换当前尾部，成功则返回</span></span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node); <span class="comment">// 插入队列失败，进入enq自旋重试入队</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入节点到队列中，如果队列未初始化则初始化，然后再插入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// 如果队列从未被初始化，需要初始化一个空的Node</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有两种情况会致使插入队列失败：</p><ul><li>1、<code>tail</code>为空：说明队列从未初始化，因此需要调用<code>enq()</code>方法在队列中插入一个<strong>空的<code>Node</code></strong>。</li><li>2、<code>compareAndSetTail()</code>失败：说明插入过程中有线程修改了此队列，因此需要说明<code>enq()</code>将当前<code>node</code>重新插入到队列末端。</li></ul><p>经过<code>addWaiter</code>方法之后，此时线程以<code>Node</code>的方式被加入到队列的末端，但是线程还没有被执行阻塞操作，真正的阻塞操作是在下面的<code>acquireQueued()</code>方法中判断执行。</p><h3 id="2-3-2-acquireQueued"><a href="#2-3-2-acquireQueued" class="headerlink" title="2.3.2 acquireQueued"></a>2.3.2 acquireQueued</h3><p>在<code>acquireQueued()</code>方法中不会立即挂起该节点中的线程，因此在插入节点的过程中，之前持有锁的线程可能已经执行完毕并释放锁，所以这里使用自旋再次去尝试获取锁（不放过任何优化细节）。如果自旋操作还没没有获取到锁，那么就将该线程挂起（阻塞），该方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在队列中的节点通过此方法获取锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 检测当前节点前驱是否head，这是试获取锁的资格。</span></span><br><span class="line">            <span class="comment">// 如果是，则调用tryAcquire尝试获取锁，</span></span><br><span class="line">            <span class="comment">// 成功，则将head置为当前节点。</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果未成功获取锁则根据前驱节点判断是否需要阻塞。</span></span><br><span class="line">            <span class="comment">// 如果阻塞过程中被中断，则置interrupted标志位为true。</span></span><br><span class="line">            <span class="comment">// shouldParkAfterFailedAcquire方法在前驱状态不为SINGAL的情况下都会循环重试获取锁。</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出在<code>shouldParkAfterFailedAcquire()</code>方法中会判断当前线程是否应该被挂起，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据前驱节点中的waitStatus来判断是否需要阻塞当前线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取前驱节点的状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL) <span class="comment">// 如果是SINGAL状态，返回true，将当前线程挂起</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 前驱节点状态为取消，向前遍历，更新当前节点的前驱为往前一个非取消节点。</span></span><br><span class="line"><span class="comment">         * 当前线程之后会再次回到循环并尝试获取锁。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 等待状态为0或PROPAGATE(-3)，设置前驱的等待状态为SINGAL，</span></span><br><span class="line"><span class="comment">         * 并且之后会回到循环再次重试获取锁。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取前驱节点的<code>waitStatus</code>值，<code>Node</code>中的<code>waitStatus</code>一共有5种取值，分别代表的意义如下：<br>|<code>waitStatus</code>值|意义|<br>|:-:|:–|<br>|CANCELLED(1)|当前线程因为超时或者中断被取消。这是一个终结状态，也就是状态到此为止|<br>|SIGNAL(-1)|当前线程的后继线程被阻塞或者即将被阻塞，当前线程释放锁或者取消后需要唤醒后继线程。这个状态一般都是后继线程来设置前驱节点的|<br>|CONDITION(-2)|当前线程在condition队列中|<br>|PROPAGATE(-3)|用于将唤醒后继线程继续传递下去，这个状态的引入是为了完善和增强共享锁的唤醒机制。在一个节点成为头节点之前，是不会跃迁为此状态的|<br>|0|表示无锁状态|</p><p>接下来根据<code>waitStatus</code>不同的值进行不同的操作，主要有以下几种情况：</p><ul><li>如果<code>waitStatus = SIGNAL</code>，返回<code>true</code>，将当前线程挂起，等待后续唤醒操作即可。</li><li>如果<code>waitStatus = CANCELLED</code>，会将此前驱节点从队列中删除，并在循环中逐步寻找下一个不是<code>CANCELLED</code>状态的节点作为当前节点的前驱节点。</li><li>如果<code>waitStatus</code>既不是<code>SIGNAL</code>，也不是<code>CANCELLED</code>，则将当前节点的前驱节点状态设置为<code>SIGNAL</code>，这样做的好处是下一次执行<code>shouldParkAfterFaildAcquire()</code>时可以直接返回<code>true</code>，挂起线程。</li></ul><p>代码再回到<code>acquireQueued()</code>中，如果<code>shouldParkAfterFaileAcquire()</code>返回<code>true</code>，表示线程需要被挂起，那么会继续调用<code>parkAndCheckInterrupt()</code>方法执行真正的阻塞线程代码，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Object blocker)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    setBlocker(t, blocker);</span><br><span class="line">    UNSAFE.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在里面调用了<code>LockSupport.park()</code>。在<code>LockSupport.park()</code>中，调用了Unsafe API来执行底层native方法将线程挂起，代码到这里已经到了操作系统的层面。</p><p>至此，获取锁的大体流程已经分析完毕，总结：</p><ul><li>AQS的模板方法<code>acquire()</code>通过调用子类自定义实现的<code>tryAcquire()</code>获取锁；</li><li>如果获取锁失败，通过<code>addWaiter()</code>方法将线程构造成<code>Node</code>节点插入到同步队列队尾；</li><li>在<code>acquireQueued()</code>方法中以自旋的方式尝试获取锁，如果失败则判断是否需要将当前线程阻塞，如果需要阻塞则最终执行<code>LockSupport(Unsafe)</code>中的native API来实现阻塞线程。</li></ul><h2 id="2-4-释放锁流程分析"><a href="#2-4-释放锁流程分析" class="headerlink" title="2.4 释放锁流程分析"></a>2.4 释放锁流程分析</h2><p>在上面加锁阶段被阻塞的线程需要被唤醒之后才能重新执行。那具体AQS是何时尝试唤醒等待队列中被阻塞的线程呢？</p><p>和加锁过程一样，释放锁需要从<code>ReentrantLock.unlock()</code>方法开始：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先调用<code>tryRelease()</code>来尝试释放锁，如果成功，最终会调用AQS中的<code>unparkSuccessor()</code>方法来实现释放锁的操作。具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取头节点waitStatus</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 获取当前节点（实际是head节点）的下一个节点</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">// 如果下一个节点是null或者下个节点是CANCEL状态，就找到队列最开始的非CALCEL的节点</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 从尾部节点开始找，到队首，找到队列第一个waitStatus &lt; 0的节点</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前节点的下个节点不为空，而且状态 &lt;= 0，那就把当前节点unpark</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释说明：</p><ul><li>首先获取当前节点（实际上传入的是head节点）的状态，如果head节点的下一个节点是null，或者下一个节点的状态为CANCEL，则从等待队列的尾部开始遍历，直到寻找到第一个<code>waitStatus &lt; 0</code>的节点。</li><li>如果最终遍历的节点不为空，再调用<code>LockSupport.unpark()</code>方法，调用底层方法唤醒线程。至此，线程被唤醒的时机分析完毕。</li></ul><h3 id="2-5-不得不说的CAS"><a href="#2-5-不得不说的CAS" class="headerlink" title="2.5 不得不说的CAS"></a>2.5 不得不说的CAS</h3><p>不管在加锁还是释放锁阶段，都提到了通用的操作：compareAndSetXXX。这种操作最终会调用Unsafe中的API进行CAS操作。</p><p>CAS全称Compare And Swap，译为比较和替换，是一种通过硬件实现并发安全的常用技术，底层通过利用CPU的CAS指令对缓存加锁或总线加锁的方式实现多处理器之间的原子操作。</p><p>它的实现过程主要有3个操作数：内存值V、旧的预期值E、要修改的新值U，当且仅当预期值E和内存值V相同时，才将内存值V修改为U，否则什么都不做。</p><h1 id="3-自定义AQS"><a href="#3-自定义AQS" class="headerlink" title="3. 自定义AQS"></a>3. 自定义AQS</h1><p>通过自定义AQS来实现同步机制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> compareAndSetState(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MyLock</code>就是一个最简单的独占锁，通过使用<code>MyLock</code>也能实现同<code>synchronized</code>和<code>ReentrantLock</code>相同的功能。比如下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> MyLock myLock = <span class="keyword">new</span> MyLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        testMyLock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testMyLock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Runnable runnable = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                myLock.lock();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                myLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终打印的<code>count</code>值为20000，说明两个线程之间是线程安全的同步操作。</p><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p>AQS是一套框架，在框架内部已经封装好了大部分同步需要的逻辑，在AQS内部维护了一个状态指示器<code>state</code>和一个等待队列<code>Node</code>，通过<code>state</code>的操作分为两种模式：独占模式和共享模式。导致AQS有两种不同的实现：独占锁(<code>ReentrantLock</code>等)和分享锁(<code>CountDownLatch</code>、读写锁等)。这里主要从独占锁的角度分析了AQS的加锁和释放锁的流程。</p><p>理解AQS的原理对理解JUC包中其他组件实现的基础有帮助，并且理解其原理才能更好的扩展其功能。上层开发人员可以基于此框架基础上进行扩展实现适合不同场景、不同功能的锁。其中几个有可能需要子类同步器实现的方法如下。</p><ul><li><code>lock()</code>。</li><li><code>tryAcquire()</code>：独占方式。尝试获取资源，成功则返回<code>true</code>，失败则返回<code>false</code>。</li><li><code>tryRelease()</code>：独占方式。尝试释放资源，成功则返回<code>true</code>，失败则返回<code>false</code>。</li><li><code>tryAcquireShared(int)</code>：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li><li><code>tryReleaseShared(int)</code>：共享方式。尝试释放资源，如果释放后允许唤醒后续等待节点返回<code>true</code>，否则返回<code>false</code>。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0. 前言&quot;&gt;&lt;/a&gt;0. 前言&lt;/h1&gt;&lt;p&gt;AQS 全称 Abstract Queued Synchronized，一般翻译为同步器。它是一套实现多线程同步功能的框
      
    
    </summary>
    
      <category term="Android" scheme="https://tylerLiu.top/categories/Android/"/>
    
      <category term="进阶" scheme="https://tylerLiu.top/categories/Android/%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="JVM与DVM必知必会" scheme="https://tylerLiu.top/tags/JVM%E4%B8%8EDVM%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"/>
    
  </entry>
  
  <entry>
    <title>（拉钩）Android工程师进阶34讲-09：Java线程优化之偏向锁，轻量级所锁、重量级锁</title>
    <link href="https://tylerLiu.top/2020/07/17/%EF%BC%88%E6%8B%89%E9%92%A9%EF%BC%89Android%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BF%9B%E9%98%B634%E8%AE%B2-09%EF%BC%9AJava%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96%E4%B9%8B%E5%81%8F%E5%90%91%E9%94%81%EF%BC%8C%E8%BD%BB%E9%87%8F%E7%BA%A7%E6%89%80%E9%94%81%E3%80%81%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81/"/>
    <id>https://tylerLiu.top/2020/07/17/（拉钩）Android工程师进阶34讲-09：Java线程优化之偏向锁，轻量级所锁、重量级锁/</id>
    <published>2020-07-17T02:51:48.000Z</published>
    <updated>2020-07-23T02:45:43.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h1><p>Java的线程是映射到操作系统原生线程之上的，如果要阻塞或唤醒一个线程就需要操作系统的帮忙，这就要从用户态转换到核心态，而状态转换需要花费很多处理器的时间。</p><p>比如下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">        value++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>value++</code>因为被关键字<code>synchronized</code>修饰，所以会在各个线程之间同步执行。但是<code>value++</code>消耗的时间很有可能比线程状态转换消耗的时间还要短，所以说<code>synchronized</code>是Java语言的重量级操作。</p><h1 id="1-Synchronized实现原理"><a href="#1-Synchronized实现原理" class="headerlink" title="1. Synchronized实现原理"></a>1. Synchronized实现原理</h1><p>先了解两个基础概念：对象头和Monitor。</p><h2 id="1-1-对象头"><a href="#1-1-对象头" class="headerlink" title="1.1 对象头"></a>1.1 对象头</h2><p>在<a href="https://mp.weixin.qq.com/s/fyvoraVu9yjgqX-xhn6EHQ" target="_blank" rel="noopener">《大话Java对象在虚拟机中是什么样子？》</a>中提到了Java对象在内存中的布局分为三部分：对象头、实例数据、对齐填充。当在Java代码中，使用<code>new</code>创建一个对象时，JVM会在堆中创建一个<code>instanceOopDesc</code>对象，这个对象中包含了对象头以及实例数据。</p><p><code>instanceOopDesc</code>的基类是<code>oopDesc</code>。结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class oopDesc&#123;</span><br><span class="line">    friend class VMStructs;</span><br><span class="line">    private:</span><br><span class="line">        volatile markOop _mark;</span><br><span class="line">        union _metadata&#123;</span><br><span class="line">            wideKlassOop _klass;</span><br><span class="line">            narrowOop _compressed_klass;</span><br><span class="line">        &#125; _metadata;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>_mark</code>和<code>_meatdata</code>一起组成对象头。<code>_metadata</code>主要保存了类元数据，不需要做过多介绍。这里重点看一下<code>_mark</code>属性，<code>_mark</code>是<code>markOop</code>类型数据，一般称它为标记字段(Mark Word)，其中主要存储了对象的hashCode、分代年龄、锁标志位、是否偏向锁等。</p><p>用一张图来表示32位Java虚拟机的Mark Word的默认存储结构如下：</p><img src="/2020/07/17/（拉钩）Android工程师进阶34讲-09：Java线程优化之偏向锁，轻量级所锁、重量级锁/MarkWord1.png"><p>默认情况下，没有线程进行加锁操作，所以锁对象中的Mark Word处于无锁状态。但是考虑到JVM的空间效率，Mark Word被设计成一个非固定的数据结构，以便存储更多的有效数据，它会根据对象本身的状态复用自己的存储空间，如32位JVM下，除了上述列出的Mark Word默认存储结构外，还有如下可能变化的结构：</p><img src="/2020/07/17/（拉钩）Android工程师进阶34讲-09：Java线程优化之偏向锁，轻量级所锁、重量级锁/MarkWord2.png"><p>从图中可以看出，根据“锁标志位”以及“是否为偏向锁”，Java中的锁可以分为以下几种状态：</p><table><thead><tr><th align="center">是否为偏向锁</th><th align="center">锁标志位</th><th align="center">锁状态</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">01</td><td align="center">无锁</td></tr><tr><td align="center">1</td><td align="center">01</td><td align="center">偏向锁</td></tr><tr><td align="center">0</td><td align="center">00</td><td align="center">轻量级锁</td></tr><tr><td align="center">0</td><td align="center">10</td><td align="center">重量级锁</td></tr><tr><td align="center">0</td><td align="center">11</td><td align="center">GC标记</td></tr></tbody></table><p>Java6之前，并没有轻量级锁和偏向锁，只有重量级锁，也就是通常所说的<code>synchronized</code>的对象锁，锁标记位为10。从图中的描述可以看出：当锁是重量级锁时，对象头中Mark Word会用30 bit来指向一个“互斥量”，而这个互斥量就是<code>Monitor</code>。</p><h2 id="1-2-Monitor"><a href="#1-2-Monitor" class="headerlink" title="1.2 Monitor"></a>1.2 Monitor</h2><p>可以把它理解成是一个同步工具，也可以描述为一种同步机制。实际上，它是一个保存在对象头中的一个对象。在<code>markOop</code>中有如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bool has_monitor() const&#123;</span><br><span class="line">    return ((value() &amp; monitor_value) != 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ObjectMonitor* monitor() const&#123;</span><br><span class="line">    assert(has_monitor(), &quot;check&quot;);</span><br><span class="line">    // Use xor instead of &amp;~ to provide one extra tag-bit check.</span><br><span class="line">    return (ObjectMonitor*) (value() ^ monitor_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>monitor()</code>创建一个<code>ObjectMonitor</code>对象，而<code>ObjectMonitor</code>就是Java虚拟机中的<code>Monitor</code>的具体实现。因此Java中每个对象都会有一个对应的<code>ObjectMonitor</code>对象，这也是Java中所有<code>Object</code>都可以作为锁对象的原因。</p><p><code>ObjectMonitor</code>是如何实现同步机制的？</p><p>首先看<code>ObjectMonitor</code>的结构：</p><img src="/2020/07/17/（拉钩）Android工程师进阶34讲-09：Java线程优化之偏向锁，轻量级所锁、重量级锁/ObjectMonitor1.png"><p>其中几个比较关键的属性：</p><ul><li><code>_owner</code>：指向持有<code>ObjectMonitor</code>对象的线程。</li><li><code>_WaitSet</code>：存放处于wait状态的线程队列。</li><li><code>_EntryList</code>：存放处于等待锁block状态的线程队列。</li><li><code>_recursions</code>：锁的重入次数。</li><li><code>_count</code>：用来记录该线程获取锁的次数。</li></ul><p>当多个线程访问同一段同步代码时，首先会进入<code>_EntryList</code>队列中，当某个线程通过竞争获取到对象的<code>monitor</code>后，<code>monitor</code>会把<code>_owner</code>变量设置为当前线程，同时<code>monitor</code>中的计数器<code>_count</code>加1，即获得对象锁。</p><p>若持有<code>monitor</code>的线程调用<code>wait()</code>方法，将释放当前持有的<code>monitor</code>，<code>_owner</code>变量恢复为null，<code>_count</code>减1，同时该线程进入<code>_WaitSet</code>集合中等待被唤醒。若当前线程执行完毕也将释放<code>monitor</code>（锁）并复位变量的值，以便其他线程进入获取<code>monitor</code>（锁）。</p><h2 id="1-3-实例演示"><a href="#1-3-实例演示" class="headerlink" title="1.3 实例演示"></a>1.3 实例演示</h2><p>比如以下代码通过三个线程分别执行以下同步代码块：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>锁对象是<code>lock</code>对象，在JVM中会有一个<code>ObjectMonitor</code>对象与之呼应。如下图：</p><img src="/2020/07/17/（拉钩）Android工程师进阶34讲-09：Java线程优化之偏向锁，轻量级所锁、重量级锁/实例演示1.png"><p>分别使用三个线程来执行以上同步代码块。默认情况下，三个线程都会进入<code>ObjectMonitor</code>中的<code>EntrySet</code>队列中，如下：</p><img src="/2020/07/17/（拉钩）Android工程师进阶34讲-09：Java线程优化之偏向锁，轻量级所锁、重量级锁/实例演示2.png"><p>假设线程2首先通过竞争获取到锁对象，则<code>ObjectMonitor</code>中的<code>Owner</code>指向线程2，并将<code>count</code>加1。结果如下：</p><img src="/2020/07/17/（拉钩）Android工程师进阶34讲-09：Java线程优化之偏向锁，轻量级所锁、重量级锁/实例演示3.png"><p>上图中<code>Owner</code>指向线程2表示它已经成功获取到锁(<code>Monitor</code>)对象，其他线程只能处于阻塞(blocking)状态。如果线程2在执行过程中调用<code>wait()</code>操作，则线程2会释放(<code>Monitor</code>)对象，以便其他线程进入获取锁(<code>Monitor</code>)对象，<code>Owner</code>变量恢复为null，<code>count</code>做减1操作，同时线程2会添加到<code>WaitSet</code>集合，进入等待(waiting)状态并等待被唤醒。结果如下：</p><img src="/2020/07/17/（拉钩）Android工程师进阶34讲-09：Java线程优化之偏向锁，轻量级所锁、重量级锁/实例演示4.png"><p>然后线程1和线程3再次通过竞争获取到锁(<code>Monitor</code>)对象，则重新将<code>Owner</code>指向成功获取到锁的线程。假设线程1获取到锁，如下：</p><img src="/2020/07/17/（拉钩）Android工程师进阶34讲-09：Java线程优化之偏向锁，轻量级所锁、重量级锁/实例演示5.png"><p>如果在线程1执行过程中调用<code>notify</code>操作将线程1唤醒，则当前处于<code>WaitSet</code>中的线程2会被重新添加到<code>EntrySet</code>集合中，并尝试重新回去竞争锁(<code>Monitor</code>)对象。但是<code>notify</code>操作并不会是线程1释放锁(<code>Monitor</code>)对象。结果如下：</p><img src="/2020/07/17/（拉钩）Android工程师进阶34讲-09：Java线程优化之偏向锁，轻量级所锁、重量级锁/实例演示6.png"><p>当线程1中的代码执行完毕以后，同样会自动释放锁，以便其他线程再次获取锁对象。</p><blockquote><p>实际上，<code>ObjectMonitor</code>的同步机制是JVM对操作系统级别的 Mutex Lock（互斥锁）的管理过程，其间都会转入操作系统内核态。也就是说<code>synchronized</code>实现锁，在“重量级锁”状态下，当多个线程之间切换上下文时，还是一个比较重量级的操作。</p></blockquote><h1 id="2-Java虚拟机对synchronized的优化"><a href="#2-Java虚拟机对synchronized的优化" class="headerlink" title="2. Java虚拟机对synchronized的优化"></a>2. Java虚拟机对synchronized的优化</h1><p>从Java 6开始，虚拟机对<code>synchronized</code>关键字做了多方面的优化，主要目的是，避免<code>ObjectMonitor</code>的访问，减少“重量级锁”的使用次数，并最终减少线程上下文切换的频率。其中主要做了以下几个优化：<strong>锁自旋、轻量级锁、偏向锁。</strong></p><h2 id="2-1-锁自旋"><a href="#2-1-锁自旋" class="headerlink" title="2.1 锁自旋"></a>2.1 锁自旋</h2><p>线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，会给系统的并发性能带来很大的压力，所以Java引入了自旋锁的操作。实际上自旋锁在Java 1.4就被引入了，默认关闭，但是可以使用参数<code>-XX:UseSpinning</code>将其开启。但是从Java 6以后，默认开启。</p><p>所谓自旋，就是让该线程等待一段时间，不会被立即乖挂起，看当前持有锁的线程是否很快释放锁。而所谓的等待就是执行一段无意义的循环即可（自旋）。</p><blockquote><p>自旋锁的缺陷：自旋锁要占用CPU，如果锁竞争的时间比较长，那么自旋通常不能获得锁，浪费自旋占用的CPU时间。这通常发生在锁持有时间长，且竞争激烈的场景，此时应主动禁用自旋锁。</p></blockquote><h2 id="2-2-轻量级锁"><a href="#2-2-轻量级锁" class="headerlink" title="2.2 轻量级锁"></a>2.2 轻量级锁</h2><p>有时Java虚拟机会出现这种情形：对于一块同步代码块，虽然有多个不同线程去执行，但是这些线程是在不同额时间段交替请求这把锁对象，也就是不存在竞争锁的现象。这时，锁会保持轻量级所得状态，避免重量级锁的阻塞和唤醒操作。</p><p>要了解轻量级锁的工作流程，需要再次看下对象头中的Mark Work。上文中已经提到，锁的标志位包含几种情况：00代表轻量级锁、01代表无锁（或偏向锁）、10代表重量锁、11是跟垃圾回收算法的标记有关。</p><p>当线程执行某段同步代码时，Java虚拟机会在当前线程的栈帧中开辟一块空间(Lock Record)作为该锁的记录，如下图所示：</p><img src="/2020/07/17/（拉钩）Android工程师进阶34讲-09：Java线程优化之偏向锁，轻量级所锁、重量级锁/轻量级锁1.png"><p>然后Java虚拟机会尝试使用CAS(Compare And Swap)操作，将锁对象的Mark Word拷贝到这块空间中，并且将锁记录中的<code>owner</code>指向Mark Word。结果如下：</p><img src="/2020/07/17/（拉钩）Android工程师进阶34讲-09：Java线程优化之偏向锁，轻量级所锁、重量级锁/轻量级锁2.png"><p>当线程再次执行此同步代码块时，判断当前对象的Mark Word是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象的锁，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占，这时轻量级锁需要膨胀为重量级锁。</p><blockquote><p>轻量级锁适应的场景是线程交替执行同步快的场合，如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁。</p></blockquote><h2 id="2-3-偏向锁"><a href="#2-3-偏向锁" class="headerlink" title="2.3 偏向锁"></a>2.3 偏向锁</h2><p>轻量级锁是在没有锁竞争情况的锁状态，但是有时锁不仅存在多线程的竞争，而且总有由同一个线程获得。因此为了让线程获得锁的代价更低，引入了偏向锁。偏向锁的意思是如果一个线程获得了一个偏向锁，如果在接下来的一段时间中没有其他线程来竞争锁，那么持有偏向锁的线程再次进入或退出同一个同步代码块，不需要再次进行抢占和释放锁的操作。偏向锁可以通过<code>-XX:UseBiasedLocking</code>开始或关闭。</p><p>偏向锁的具体实现就是在锁对象的对象头中有个<code>ThreadId</code>字段，默认情况下这个字段是空的，当第一次获取锁的时候，就将自身的<code>ThreadId</code>写入锁对象的Mark Word中的<code>ThreadId</code>字段内，将是否偏向锁的状态置位为01。这样下次获取锁的时候，直接检查<code>ThreadId</code>是否和自身线程Id一致，如果一致，则认为当前线程已经获取了锁，因此不需要再获取锁，略过轻量级锁和重量级锁的加锁阶段，提高效率。</p><blockquote><p>其实偏向锁并不适合所有应用场景，因为一旦锁竞争，偏向锁会被撤销，并膨胀为重量级锁，而撤销锁操作(revoke)是比较重的行为，只有当存在较多不会真正竞争的<code>synchronized</code>块时，才能体现出明显改善；因此实践中，还需要考虑具体业务场景，并测试后，在决定是否开启偏向锁。</p></blockquote><p>对于锁的几种状态转换的源码分析，可以参考：<a href="https://mp.weixin.qq.com/s/WWRbfmY2vVy-usVXgaIdAA" target="_blank" rel="noopener">源码分析Java虚拟机中锁膨胀的过程</a>。</p><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><p>本节主要介绍Java中锁的几种状态，其中偏向锁和轻量级锁都是通过自旋等技术避免真正的加锁，而重量级锁才是获取锁和释放锁，重量级锁通过对象内部的监听器(<code>ObjectMonitor</code>)实现，其本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，成本很高。实际上Java对锁的优化还是“锁消除”，但“锁消除”是基于Java对象逃逸分析的，可以查看<a href="https://mp.weixin.qq.com/s/Pub_K7PSCNE82F-96y2v6g" target="_blank" rel="noopener">Java逃逸分析</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0. 前言&quot;&gt;&lt;/a&gt;0. 前言&lt;/h1&gt;&lt;p&gt;Java的线程是映射到操作系统原生线程之上的，如果要阻塞或唤醒一个线程就需要操作系统的帮忙，这就要从用户态转换到核心态，
      
    
    </summary>
    
      <category term="Android" scheme="https://tylerLiu.top/categories/Android/"/>
    
      <category term="进阶" scheme="https://tylerLiu.top/categories/Android/%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="JVM与DVM必知必会" scheme="https://tylerLiu.top/tags/JVM%E4%B8%8EDVM%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"/>
    
  </entry>
  
  <entry>
    <title>（拉钩）Android工程师进阶34讲-08：Synchronized与ReentrantLock</title>
    <link href="https://tylerLiu.top/2020/07/14/%EF%BC%88%E6%8B%89%E9%92%A9%EF%BC%89Android%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BF%9B%E9%98%B634%E8%AE%B2-08%EF%BC%9ASynchronized%E4%B8%8EReentrantLock/"/>
    <id>https://tylerLiu.top/2020/07/14/（拉钩）Android工程师进阶34讲-08：Synchronized与ReentrantLock/</id>
    <published>2020-07-14T03:26:12.000Z</published>
    <updated>2020-07-17T02:48:32.400Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Synchronized"><a href="#1-Synchronized" class="headerlink" title="1. Synchronized"></a>1. Synchronized</h1><p><code>Synchronized</code>可以用来修饰以下三个层面：</p><ul><li>修饰实例方法；</li><li>修饰静态类方法；</li><li>修饰代码块。</li></ul><h2 id="1-1-Synchronized修饰实例方法"><a href="#1-1-Synchronized修饰实例方法" class="headerlink" title="1.1 Synchronized修饰实例方法"></a>1.1 Synchronized修饰实例方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LagouSynchronizedMethods</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">calculate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sum = sum + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下锁的对象是当前实例对象，因此只有同一个实例对象调用此方法才会产生效果，不同实例对象之间不会有互斥效果。如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LagouSynchronizedMethods</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LagouSynchronizedMethods l1 = <span class="keyword">new</span> LagouSynchronizedMethods();</span><br><span class="line">        LagouSynchronizedMethods l2 = <span class="keyword">new</span> LagouSynchronizedMethods();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(l1::printLog);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(l2::printLog);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">printLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" is printing "</span> + i);</span><br><span class="line">                Thread.sleep(<span class="number">300</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码，在不同线程中调用的是不同对象的<code>printLog</code>方法，因此彼此之间不会排斥。运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread-1 is printing 0</span><br><span class="line">Thread-0 is printing 0</span><br><span class="line">Thread-0 is printing 1</span><br><span class="line">Thread-1 is printing 1</span><br><span class="line">Thread-1 is printing 2</span><br><span class="line">Thread-0 is printing 2</span><br><span class="line">Thread-1 is printing 3</span><br><span class="line">Thread-0 is printing 3</span><br><span class="line">Thread-0 is printing 4</span><br><span class="line">Thread-1 is printing 4</span><br></pre></td></tr></table></figure><p>可以看到，两个线程是交互执行的。</p><p>如果将代码修改如下，两个线程调用一个对象的<code>printLog</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LagouSynchronizedMethods</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LagouSynchronizedMethods l1 = <span class="keyword">new</span> LagouSynchronizedMethods();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(l1::printLog);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(l1::printLog);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">printLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" is printing "</span> + i);</span><br><span class="line">                Thread.sleep(<span class="number">300</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread-0 is printing 0</span><br><span class="line">Thread-0 is printing 1</span><br><span class="line">Thread-0 is printing 2</span><br><span class="line">Thread-0 is printing 3</span><br><span class="line">Thread-0 is printing 4</span><br><span class="line">Thread-1 is printing 0</span><br><span class="line">Thread-1 is printing 1</span><br><span class="line">Thread-1 is printing 2</span><br><span class="line">Thread-1 is printing 3</span><br><span class="line">Thread-1 is printing 4</span><br></pre></td></tr></table></figure><p>可以看出，只有当一个线程中的代码执行完毕后，才会调用另一个线程中的代码。此时两个线程间是互斥的。</p><h2 id="1-2-Synchronized修饰静态类方法"><a href="#1-2-Synchronized修饰静态类方法" class="headerlink" title="1.2 Synchronized修饰静态类方法"></a>1.2 Synchronized修饰静态类方法</h2><p>如果<code>synchronized</code>修饰的是静态方法，则锁对象是当前类的Class对象，因此即使在不同线程间调用不同实例对象，也会有互斥效果。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LagouSynchronizedMethods</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LagouSynchronizedMethods l1 = <span class="keyword">new</span> LagouSynchronizedMethods();</span><br><span class="line">        LagouSynchronizedMethods l2 = <span class="keyword">new</span> LagouSynchronizedMethods();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; l1.printLog());</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; l2.printLog());</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">printLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" is printing "</span> + i);</span><br><span class="line">                Thread.sleep(<span class="number">300</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread-0 is printing 0</span><br><span class="line">Thread-0 is printing 1</span><br><span class="line">Thread-0 is printing 2</span><br><span class="line">Thread-0 is printing 3</span><br><span class="line">Thread-0 is printing 4</span><br><span class="line">Thread-1 is printing 0</span><br><span class="line">Thread-1 is printing 1</span><br><span class="line">Thread-1 is printing 2</span><br><span class="line">Thread-1 is printing 3</span><br><span class="line">Thread-1 is printing 4</span><br></pre></td></tr></table></figure><p>两个线程是依次执行的。</p><h2 id="1-3-Synchronized修饰代码块"><a href="#1-3-Synchronized修饰代码块" class="headerlink" title="1.3 Synchronized修饰代码块"></a>1.3 Synchronized修饰代码块</h2><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LagouSynchronizedMethods</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        LagouSynchronizedMethods l1 = <span class="keyword">new</span> LagouSynchronizedMethods();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(l1::printLog);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(l1::printLog);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" is printing "</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>synchronized</code>作用于代码块，锁对象就是紧跟在后面括号中的对象。上图可以看出任何<code>Object</code>对象都可以当做锁对象。</p><h2 id="1-4-实现细节"><a href="#1-4-实现细节" class="headerlink" title="1.4 实现细节"></a>1.4 实现细节</h2><p><code>synchronized</code>既可以作用于方法，也可以作用于某一代码块。但在实现上是有区别的。比如以下代码，使用<code>synchronized</code>作用于代码块：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            number = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用javap查看<code>test1</code>方法的字节码，可以看出，编译而成的字节码中会包含<code>monitorenter</code>和<code>monitorexit</code>这两个字节码指令。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public void test1();</span><br><span class="line">   descriptor: ()V</span><br><span class="line">   flags: ACC_PUBLIC</span><br><span class="line">   Code:</span><br><span class="line">     stack=3, locals=4, args_size=1</span><br><span class="line">        0: iconst_0</span><br><span class="line">        1: istore_1</span><br><span class="line">        2: aload_0</span><br><span class="line">        3: dup</span><br><span class="line">        4: astore_2</span><br><span class="line">        5: monitorenter</span><br><span class="line">        6: aload_0</span><br><span class="line">        7: iload_1</span><br><span class="line">        8: iconst_1</span><br><span class="line">        9: iadd</span><br><span class="line">       10: putfield      #2                  // Field number:I</span><br><span class="line">       13: aload_2</span><br><span class="line">       14: monitorexit</span><br><span class="line">       15: goto          23</span><br><span class="line">       18: astore_3</span><br><span class="line">       19: aload_2</span><br><span class="line">       20: monitorexit</span><br><span class="line">       21: aload_3</span><br><span class="line">       22: athrow</span><br><span class="line">       23: return</span><br></pre></td></tr></table></figure><p>上面字节码中有1个<code>monitorenter</code>和2个<code>monitorexit</code>。这是因为虚拟机需要保证当异常发生时也能释放锁。因此2个<code>monitorexit</code>，一个是代码正常执行结束后释放锁，一个是代码执行异常时释放锁。</p><p>再来看看<code>synchronized</code>修饰方法有哪些区别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        i = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码经过编译之后，字节码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void test1();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=2, args_size=1</span><br><span class="line">         0: iconst_0</span><br><span class="line">         1: istore_1</span><br><span class="line">         2: iload_1</span><br><span class="line">         3: iconst_1</span><br><span class="line">         4: iadd</span><br><span class="line">         5: istore_1</span><br><span class="line">         6: return</span><br></pre></td></tr></table></figure><p>可以看出，被<code>synchronized</code>修饰的方法在被编译成字节码后，在方法的<code>flags</code>属性中会被标记为<code>ACC_SYNCHRONIZED</code>。当虚拟机访问一个被标记为<code>ACC_SYNCHRONIZED</code>的方法时，会自动在方法的开始和结束（或异常）位置添加<code>monitorenter</code>和<code>monitorexit</code>指令。</p><p>关于<code>monitorenter</code>和<code>monitorexit</code>，可以理解为一把具体的锁。在这个锁中保存着两个比较重要的属性：计数器和指针。</p><ul><li>计数器：表示当前线程一共访问几次这把锁。</li><li>指针：指向持有这把锁的线程。</li></ul><img src="/2020/07/14/（拉钩）Android工程师进阶34讲-08：Synchronized与ReentrantLock/synchronized_1.png"><p>锁计数器默认为0，当执行<code>monitorenter</code>指令时，如锁计数器为0，说明这把锁没有被其他线程持有。那么线程会将计数器加1，并将锁中的指针指向自己。当执行<code>monitorexit</code>指令时，会将计数器减1。</p><h1 id="2-ReentrantLock"><a href="#2-ReentrantLock" class="headerlink" title="2. ReentrantLock"></a>2. ReentrantLock</h1><h2 id="2-1-ReentrantLock基本使用"><a href="#2-1-ReentrantLock基本使用" class="headerlink" title="2.1 ReentrantLock基本使用"></a>2.1 ReentrantLock基本使用</h2><p><code>ReentrantLock</code>的用法和<code>synchronized</code>有点不同，它的加锁和解锁操作都需要手动完成，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LagouReentrantLockTest</span> </span>&#123;</span><br><span class="line">    ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LagouReentrantLockTest l1 = <span class="keyword">new</span> LagouReentrantLockTest();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(l1::printLog);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(l1::printLog);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" is printing "</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread-0 is printing 0</span><br><span class="line">Thread-0 is printing 1</span><br><span class="line">Thread-0 is printing 2</span><br><span class="line">Thread-0 is printing 3</span><br><span class="line">Thread-0 is printing 4</span><br><span class="line">Thread-1 is printing 0</span><br><span class="line">Thread-1 is printing 1</span><br><span class="line">Thread-1 is printing 2</span><br><span class="line">Thread-1 is printing 3</span><br><span class="line">Thread-1 is printing 4</span><br></pre></td></tr></table></figure><h2 id="2-2-公平锁实现"><a href="#2-2-公平锁实现" class="headerlink" title="2.2 公平锁实现"></a>2.2 公平锁实现</h2><p><code>ReentrantLock</code>有一个带参的构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125; with the</span></span><br><span class="line"><span class="comment"> * given fairness policy.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fair &#123;<span class="doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，<code>synchronized</code>和<code>ReentrantLock</code>都是非公平锁。但是<code>ReentrantLock</code>可以通过传入<code>true</code>来创建一个公平锁。所谓公平锁就是通过同步队列来实现多个线程按照申请锁的顺序获取锁。</p><p>公平锁实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LagouFairLockTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> shareNumber = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建公平锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (shareNumber &lt; <span class="number">20</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                shareNumber++;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" 获得锁，shareNumber is "</span> + shareNumber);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LagouFairLockTest lft = <span class="keyword">new</span> LagouFairLockTest();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(lft);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(lft);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(lft);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Thread-0 获得锁，shareNumber is 1</span><br><span class="line">Thread-1 获得锁，shareNumber is 2</span><br><span class="line">Thread-0 获得锁，shareNumber is 3</span><br><span class="line">Thread-1 获得锁，shareNumber is 4</span><br><span class="line">Thread-0 获得锁，shareNumber is 5</span><br><span class="line">Thread-1 获得锁，shareNumber is 6</span><br><span class="line">Thread-2 获得锁，shareNumber is 7</span><br><span class="line">Thread-0 获得锁，shareNumber is 8</span><br><span class="line">Thread-1 获得锁，shareNumber is 9</span><br><span class="line">Thread-2 获得锁，shareNumber is 10</span><br><span class="line">Thread-0 获得锁，shareNumber is 11</span><br><span class="line">Thread-1 获得锁，shareNumber is 12</span><br><span class="line">Thread-2 获得锁，shareNumber is 13</span><br><span class="line">Thread-0 获得锁，shareNumber is 14</span><br><span class="line">Thread-1 获得锁，shareNumber is 15</span><br><span class="line">Thread-2 获得锁，shareNumber is 16</span><br><span class="line">Thread-0 获得锁，shareNumber is 17</span><br><span class="line">Thread-1 获得锁，shareNumber is 18</span><br><span class="line">Thread-2 获得锁，shareNumber is 19</span><br><span class="line">Thread-0 获得锁，shareNumber is 20</span><br><span class="line">Thread-1 获得锁，shareNumber is 21</span><br><span class="line">Thread-2 获得锁，shareNumber is 22</span><br></pre></td></tr></table></figure><p>可以看出，创建的3个线程按照顺序去修改<code>shareNumber</code>的值。</p><h2 id="2-2-读写锁-ReentrantReadWriteLock"><a href="#2-2-读写锁-ReentrantReadWriteLock" class="headerlink" title="2.2 读写锁(ReentrantReadWriteLock)"></a>2.2 读写锁(ReentrantReadWriteLock)</h2><p>开发中，经常定义一个线程间共享的用作缓存的数据结构，比如一个较大的<code>Map</code>。缓存中保存了全部的城市id和城市name对应关系。这个大<code>Map</code>绝大部分时间提供读服务（根据城市id查询城市名称等）。而写操作占有的时间很少，通常是在服务启动时初始化，然后可以每隔一段时间再刷新缓存的数据。但是写操作开始到结束之间，不能再有其他读操作进来，并且写操作完成之后的更新数据需要对后续的读操作可见。</p><p>在没有读写锁支持的时候，如果想要实现上面的功能，需要使用Java的等待通知机制，就是当写操作开始时，所有晚于写操作的读操作都会进入等待状态，只有写操作完成并进行通知之后，所有等待的读操作才能继续执行。这样做的目的是使读操作能读取到正确的数据。</p><p>但是如果使用<code>concurrent</code>包中的读写锁(<code>ReentrantReadWriteLock</code>)实现上面的功能，就只需要在读操作时获取读锁，写操作时获取写锁即可。当写锁被获取到时，后续的读写锁都会被阻塞，写锁释放之后，所有操作继续执行，这种编程方式相对于使用等待通知机制而言，更加简明。</p><p>下面，看看读写锁(<code>ReentrantReedWriteLock</code>)如何使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LagouReentrantReadWriteLockTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建读写锁对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String number = <span class="string">"0"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Reader(), <span class="string">"读线程 1"</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Reader(), <span class="string">"读线程 2"</span>);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Writer(), <span class="string">"写线程"</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Reader</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 使用读锁对读操作加锁</span></span><br><span class="line">                lock.readLock().lock();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" ---&gt; Number is "</span> + number);</span><br><span class="line">                lock.readLock().unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Writer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">7</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 使用写锁对写操作加锁</span></span><br><span class="line">                    lock.writeLock().lock();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" is writing "</span> + i);</span><br><span class="line">                    number = number.concat(<span class="string">""</span> + i);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.writeLock().unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">读线程 1 ---&gt; Number is 0</span><br><span class="line">读线程 2 ---&gt; Number is 0</span><br><span class="line">读线程 1 ---&gt; Number is 0</span><br><span class="line">写线程 is writing 1</span><br><span class="line">读线程 2 ---&gt; Number is 01</span><br><span class="line">读线程 1 ---&gt; Number is 01</span><br><span class="line">写线程 is writing 3</span><br><span class="line">读线程 2 ---&gt; Number is 013</span><br><span class="line">读线程 1 ---&gt; Number is 013</span><br><span class="line">写线程 is writing 5</span><br><span class="line">读线程 2 ---&gt; Number is 0135</span><br><span class="line">读线程 1 ---&gt; Number is 0135</span><br><span class="line">写线程 is writing 7</span><br><span class="line">读线程 2 ---&gt; Number is 01357</span><br><span class="line">读线程 1 ---&gt; Number is 01357</span><br><span class="line">读线程 1 ---&gt; Number is 01357</span><br><span class="line">读线程 2 ---&gt; Number is 01357</span><br><span class="line">读线程 1 ---&gt; Number is 01357</span><br><span class="line">读线程 1 ---&gt; Number is 01357</span><br><span class="line">读线程 1 ---&gt; Number is 01357</span><br><span class="line">读线程 2 ---&gt; Number is 01357</span><br><span class="line">读线程 2 ---&gt; Number is 01357</span><br><span class="line">读线程 2 ---&gt; Number is 01357</span><br><span class="line">读线程 2 ---&gt; Number is 01357</span><br></pre></td></tr></table></figure><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><p>Java同步实现的两个方式：</p><ul><li><code>synchronized</code>：使用简单，加锁和释放锁都是由虚拟机自动完成。</li><li><code>ReentrantLock</code>：需要开发者手动加锁和释放锁。但使用场景更多，公平锁还可以通过读写锁(<code>ReentrantReadWriteLock</code>)来实现。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Synchronized&quot;&gt;&lt;a href=&quot;#1-Synchronized&quot; class=&quot;headerlink&quot; title=&quot;1. Synchronized&quot;&gt;&lt;/a&gt;1. Synchronized&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Synchronized&lt;/
      
    
    </summary>
    
      <category term="Android" scheme="https://tylerLiu.top/categories/Android/"/>
    
      <category term="进阶" scheme="https://tylerLiu.top/categories/Android/%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="JVM与DVM必知必会" scheme="https://tylerLiu.top/tags/JVM%E4%B8%8EDVM%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"/>
    
  </entry>
  
  <entry>
    <title>（拉钩）Android工程师进阶34讲-07：Java内存模型与线程</title>
    <link href="https://tylerLiu.top/2020/07/09/%EF%BC%88%E6%8B%89%E9%92%A9%EF%BC%89Android%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BF%9B%E9%98%B634%E8%AE%B2-07%EF%BC%9AJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <id>https://tylerLiu.top/2020/07/09/（拉钩）Android工程师进阶34讲-07：Java内存模型与线程/</id>
    <published>2020-07-09T06:44:24.000Z</published>
    <updated>2020-07-14T03:22:59.814Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h1><p>Java内存模型翻译自Java Memory Model，简称JMM，它所描述的是多线程并发、CPU缓存等方面的内容。</p><h1 id="1-为什么有Java内存模型"><a href="#1-为什么有Java内存模型" class="headerlink" title="1. 为什么有Java内存模型"></a>1. 为什么有Java内存模型</h1><p>很多介绍JMM时，会借用《深入理解Java虚拟机》中的一张图。</p><img src="/2020/07/09/（拉钩）Android工程师进阶34讲-07：Java内存模型与线程/为什么会有Java内存模型.png"><p>上图描述的意思是，在每一个线程中，都会有一块内部的工作内存（working memory）。这块工作内存保存了主内存共享数据的拷贝副本。第一节中，了解到JVM内存结构中有一块线程独享的内存空间——虚拟机栈，这里自然而然就会将线程工作内存理解成虚拟机栈。</p><p>但是，这是不准确的！虚拟机栈和线程的工作内存并不是一个概念。在Java线程中并不存在所谓的工作内存，<strong>它只是对CPU寄存器和高速缓存的抽象描述</strong>。</p><h2 id="1-1-CPU普及"><a href="#1-1-CPU普及" class="headerlink" title="1.1 CPU普及"></a>1.1 CPU普及</h2><p>线程是CPU调度的最小单位，线程中的字节码指令最终都是在CPU中执行的。CPU在执行的时候，免不了要和各种数据打交道，而Java中所有数据都存放在主内存(RAM)中的，这一过程可以参考下图：</p><img src="/2020/07/09/（拉钩）Android工程师进阶34讲-07：Java内存模型与线程/CPU普及1.png"><p>随着CPU技术的发展，CPU的执行速度越来越快，但内存的技术并没有太大变化，所以在内存中读取和写入数据的过程和CPU的执行速度比起来差距会越来越大。CPU对主内存的访问需要等待较长时间，这样就体现不出CPU超强的运算能力的优势了。</p><p>为了“压榨”处理性能，达到“高并发”的效果，在CPU中添加高速缓存(cache)来作为缓冲。</p><img src="/2020/07/09/（拉钩）Android工程师进阶34讲-07：Java内存模型与线程/CPU普及2.png"><p>在执行任务时，CPU会先将运算所需要使用到的数据复制到高速缓存中，让运算能快速进行，当运算完成之后，再将缓存中的结果刷回(flush back)主内存，这样CPU就不用等待主内存的读写操作了。</p><p>但是这样也有问题。每个处理器都有自己的高速缓存，同时又共同操作同一块主内存，当多个处理器同时操作主内存时，可能导致数据不一致，这就是<strong>缓存一致性</strong>问题。</p><h2 id="1-2-缓存一致性问题"><a href="#1-2-缓存一致性问题" class="headerlink" title="1.2 缓存一致性问题"></a>1.2 缓存一致性问题</h2><p>现在市面上手机通常有两个或多个CPU，一些CPU还有多核。每个CPU在某一时刻都能运行一个线程，这意味着，如果Java程序是多线程的，那么就有可能存在多个线程在同一时刻被不同CPU执行的情况。</p><p>如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r1 = x;</span><br><span class="line">        y = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r2 = y;</span><br><span class="line">        x = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure><p>定义两个变量<code>x</code>和<code>y</code>，初始值都为0。</p><p>在线程<code>t1</code>中，将<code>x</code>赋值给<code>r1</code>，然后将<code>y</code>设置为1。</p><p>在线程<code>t2</code>中，将<code>y</code>赋值给<code>r2</code>，然后将<code>x</code>设置为2。</p><p>假设一台设备上有2个CPU，分别为C1和C2，将上面这段代码在这台设备上执行，最后打印<code>r1</code>和<code>r2</code>的值分别为多少？答案是不确定。</p><p><strong>情况1：</strong></p><p>假设<code>t1</code>现在C1中执行完毕，并成功刷回主内存中，此时<code>r1 = 0</code>，<code>x = 0</code>，<code>y = 1</code>。</p><p>然后<code>t2</code>在C2中执行，从主内存中加载<code>y = 1</code>并赋值给<code>r2</code>，此时<code>r2 = 1</code>，<code>x = 2</code>，<code>y = 1</code>。</p><p><strong>情况2：</strong></p><p>假设<code>t2</code>现在C1中执行完毕，并成功刷回主内存中，此时<code>r2 = 0</code>，<code>x = 2</code>，<code>y = 0</code>。</p><p>然后<code>t1</code>在C2中执行，从主内存中加载<code>y = 1</code>并赋值给<code>r2</code>，此时<code>r1 = 2</code>，<code>x = 2</code>，<code>y = 1</code>。</p><p><strong>情况3：</strong></p><p><code>x</code>和<code>y</code>的值分别缓存在C1和C2的缓存中。</p><p>首先<code>t1</code>在C1中执行完毕，但是没有将结果刷回主内存中，此时主内存中<code>x = 0</code>，<code>y = 0</code>。</p><p>然后<code>t2</code>在C2中执行，缓存中的<code>y = 0</code>，并将其赋值给<code>r2</code>，此时<code>r2 = 0</code>，<code>x = 2</code>，<code>y = 1</code>。</p><p>如下图：</p><img src="/2020/07/09/（拉钩）Android工程师进阶34讲-07：Java内存模型与线程/缓存一致性问题.png"><p>可以看出，虽然在C1和C2的缓存中，分别修改了<code>x</code>和<code>y</code>的值，但是并未将它刷回主内存中，这就是缓存一致性问题。</p><h2 id="1-3-指令重排"><a href="#1-3-指令重排" class="headerlink" title="1.3 指令重排"></a>1.3 指令重排</h2><p>除了缓存一致性问题，还有另外一个硬件问题：为了使CPU内部的运算单元能尽量被充分利用，处理器可能会对输入的字节码指令进行重排序处理，也就是处理器优化。除了CPU之外，很多编程语言的编译器也会有类似的优化，比如Java虚拟机的即使编译(JIT)也会做指令重排。</p><p>以下面代码为例：</p><img src="/2020/07/09/（拉钩）Android工程师进阶34讲-07：Java内存模型与线程/指令重排1.png"><p>编译之后的字节码指令如下：</p><img src="/2020/07/09/（拉钩）Android工程师进阶34讲-07：Java内存模型与线程/指令重排2.png"><p>可以看出，在上述指令中，有两处指令表达的是同样的语义，并且指令7并不依赖指令2和指令3。在这种情况下，CPU会对指令的顺序做优化，如下：</p><img src="/2020/07/09/（拉钩）Android工程师进阶34讲-07：Java内存模型与线程/指令重排3.png"><p>从Java是语言的角度看这层优化就是：</p><img src="/2020/07/09/（拉钩）Android工程师进阶34讲-07：Java内存模型与线程/指令重排4.png"><p>也就是说在CPU层面，有时代码并不会严格按照Java文件中的顺序执行。再看一下之前<code>r1</code>/<code>r2</code>的实例，刚才分析了会有三种情况发生，其实在极端情况下，还会出现第4种情况：</p><blockquote><p><code>r1 = 2</code>，<code>r2 = 1</code></p></blockquote><p>线程<code>t2</code>中的代码经过CPU优化之后，会被重排为：</p><img src="/2020/07/09/（拉钩）Android工程师进阶34讲-07：Java内存模型与线程/指令重排5.png"><p>经过优化之后，<code>t2</code>线程将<code>x</code>赋值为2，这时CPU将时间片段分配给线程<code>t1</code>，线程<code>t1</code>在执行过程中，将<code>r1</code>赋值为<code>x</code>，此时<code>x = 2</code>，所以<code>r1 = 2</code>。然后将<code>y</code>赋值为1，此时CPU再将时间片段重新分配给<code>t2</code>。</p><p>代码回到<code>t2</code>中，将<code>y</code>赋值给<code>r2</code>，此时<code>y = 1</code>，所以<code>r2 = 1</code>，整个过程如下图：</p><img src="/2020/07/09/（拉钩）Android工程师进阶34讲-07：Java内存模型与线程/指令重排6.png"><p>上面两小部分的内容表明，如果任由CPU优化或编译器指令重排，那编写的Java代码最终执行效果可能会出现偏差。为了解决这个问题，让Java在不同硬件、不同操作系统中，输出的结果达到一致，Java虚拟机规范了一套机制——Java内存模型。</p><h1 id="2-什么是内存模型"><a href="#2-什么是内存模型" class="headerlink" title="2. 什么是内存模型"></a>2. 什么是内存模型</h1><p>内存模型是一套共享内存中多线程读写操作行为的规范，这套规范屏蔽了底层各种硬件和操作系统的内存访问差异，解决了CPU多级缓存、CPU优化、指令重排等导致的内存访问问题，从而保证Java程序（尤其是多线程程序）在各种平台下对内存的访问效果一致。</p><p>在Java内存模型中，统一用工作内存(working memory)来当做CPU中寄存器或高速缓存的抽象。线程之间的共享变量存储在主内存(main memory)中，每个线程都有一个私有的工作内存（类比CPU中的寄存器或高速缓存），本地工作内存中存储了该线程读/写共享变量的副本。</p><p>这套规范中有一个非常重要的规则——happens-before。</p><h2 id="happens-before-先行发生原则"><a href="#happens-before-先行发生原则" class="headerlink" title="happens-before 先行发生原则"></a>happens-before 先行发生原则</h2><p>happens-before用于描述两个操作的内存可见性，通过保证可见性的机制可以让应用程序免于数据竞争干扰。它的定义如下：</p><blockquote><p>如果一个操作A happens-before 另一个操作B，那么操作A的执行结果将对操作B可见。</p></blockquote><p>上述定义也可以反过来理解：如果操作A的结果需要对另一个操作B可见，那么操作A必须happens-before 操作B。</p><p>用以下代码举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    value = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设<code>setValue</code>就是操作A，<code>getValue</code>就是操作B。如果先后在两个线程中调用A和B，那最后在B操作中返回的<code>value</code>值是多少呢？有以下两种情况：</p><p><strong>如果 A happens-before B不成立</strong></p><p>也就是说当线程调用操作B(<code>getValue</code>)时，即使操作A(<code>setValue</code>)已经在其他线程中被调用过，并且<code>value</code>也被成功设置为1，但这个修改对于操作B(<code>getValue</code>)仍然是不可见的。根据之前介绍的CPU缓存，<code>value</code>值有可能返回0，也可能返回1。</p><p><strong>如果 A happens-before 成立</strong></p><p>根据 happens-before 的定义，先行发生动作的结果，对后续发生动作是可见的。也就是说如果先在一个线程中调用操作A(<code>setValue</code>)，那个这个修改的结果对后续的操作B(<code>getValue</code>)始终可见。因此先调用<code>setValue</code>为<code>value</code>赋值1之后，后续在其他线程中调用<code>getValue</code>的值一定是1。</p><p>那么Java中两个操作如何就算符合 happens-before 规则呢？JMM中定义了以下几种情况实时自动符合 happens-before 规则的：</p><h3 id="程序次序规则"><a href="#程序次序规则" class="headerlink" title="程序次序规则"></a>程序次序规则</h3><p>在单线程内部，如果一段代码的字节码顺序也隐式符合 happens-before 原则，那么逻辑顺序靠前的字节码执行结果一定对后续逻辑字节码可见，只是后续逻辑中不一定用到而已。比如下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>; <span class="comment">// 1</span></span><br><span class="line">b = b + <span class="number">1</span>;  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>当代码执行到2时，<code>a = 10</code>这个结果已经可见，至于用没用到<code>a</code>这个结果，则不一定。比如上面的代码就没用到，说明<code>b</code>对<code>a</code>的结果没有依赖，这样就有可能发生指令重排。</p><p>但如果将代码修改如下，就不会发生指令重排优化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>; <span class="comment">// 1</span></span><br><span class="line">b = b + a;  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h3 id="锁定规则"><a href="#锁定规则" class="headerlink" title="锁定规则"></a>锁定规则</h3><p>无论在单线程环境还是多线程环境，一个锁如果处于被锁状态，那么必须先执行unlock操作后才能进行lock操作。</p><h3 id="变量规则"><a href="#变量规则" class="headerlink" title="变量规则"></a>变量规则</h3><p><code>volatile</code>保证了线程可见性。通俗讲就是如果一个线程先写了一个<code>volatile</code>变量，然后另外一个线程去读这个变量，那么这个写操作一定是 happens-before 读操作的。</p><h3 id="线程启动规则"><a href="#线程启动规则" class="headerlink" title="线程启动规则"></a>线程启动规则</h3><p><code>Thread</code>对象的<code>start()</code>方法先行发生于此线程的每个动作。假定线程A执行过程中，通过执行<code>ThreadB.start()</code>来启动线程B，那么线程A对共享变量的修改在线程B开始执行后确保对线程B可见。</p><h3 id="线程中断规则"><a href="#线程中断规则" class="headerlink" title="线程中断规则"></a>线程中断规则</h3><p>对线程<code>interrupt()</code>方法的调用先行发生于被中断线程的代码检测，直到中断事件的发生。</p><h3 id="线程终结规则"><a href="#线程终结规则" class="headerlink" title="线程终结规则"></a>线程终结规则</h3><p>线程中所有的操作都发生在线程的终止检测之前，可以通过<code>Thread.join()</code>方法结束、<code>Thread.isAlive()</code>的返回值等方法检测线程是否终止执行。假定线程A在执行过程中，通过调用<code>Thread.join()</code>等待线程B终止，那么线程B在终止之前对共享变量的修改在线程A等待返回后可见。</p><h3 id="对象终结规则"><a href="#对象终结规则" class="headerlink" title="对象终结规则"></a>对象终结规则</h3><p>一个对象的初始化完成发生在它的<code>finalize()</code>方法开始之前。</p><p>此外，happens-before 原则还具有传递性L如果操作 A happens-before 操作B，而操作 B happens-before 操作 C，则操作 A happens-before 操作 C。</p><h1 id="3-Java内存模型的应用"><a href="#3-Java内存模型的应用" class="headerlink" title="3. Java内存模型的应用"></a>3. Java内存模型的应用</h1><p>上面介绍的 happens-before 原则很重要，它是判断数据是否存在竞争、线程是否安全的主要依据，根据这个原则，可以解决在并发环境下操作之间是否可能存在冲突的问题。在此基础上，可以通过Java提供的一系列关键字，实现多线程操作 “happens-before化”。</p><h2 id="3-1-使用volatile修饰value"><a href="#3-1-使用volatile修饰value" class="headerlink" title="3.1 使用volatile修饰value"></a>3.1 使用volatile修饰value</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    value = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-使用synchronized关键字"><a href="#3-2-使用synchronized关键字" class="headerlink" title="3.2 使用synchronized关键字"></a>3.2 使用synchronized关键字</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        value = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上两种方式，都可以使<code>setValue</code>和<code>getValue</code>符合 happens-before 原则——当在某一线程中调用<code>setValue</code>后，再在其他线程中调用<code>getValue</code>获取的值一定是1。</p><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><ul><li>Java内存模型的来源：主要是因为CPU缓存和指令重排等优化导致多线程程序结果不可控。</li><li>Java内存模型是什么：本质上它是一套规范，在这套规范中有一条最重要的 happens-before 原则。</li><li>Java内存模型的使用，介绍了两种方式：<code>volatile</code>和<code>synchronized</code>。除了这两种方法，Java还提供了很多关键字来实现 happens-before 原则，会在后面介绍。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0. 前言&quot;&gt;&lt;/a&gt;0. 前言&lt;/h1&gt;&lt;p&gt;Java内存模型翻译自Java Memory Model，简称JMM，它所描述的是多线程并发、CPU缓存等方面的内容。&lt;
      
    
    </summary>
    
      <category term="Android" scheme="https://tylerLiu.top/categories/Android/"/>
    
      <category term="进阶" scheme="https://tylerLiu.top/categories/Android/%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="JVM与DVM必知必会" scheme="https://tylerLiu.top/tags/JVM%E4%B8%8EDVM%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"/>
    
  </entry>
  
  <entry>
    <title>（拉钩）Android工程师进阶34讲-06：Class对象在执行引擎中的初始化过程</title>
    <link href="https://tylerLiu.top/2020/07/07/%EF%BC%88%E6%8B%89%E9%92%A9%EF%BC%89Android%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BF%9B%E9%98%B634%E8%AE%B2-06%EF%BC%9AClass%E5%AF%B9%E8%B1%A1%E5%9C%A8%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B/"/>
    <id>https://tylerLiu.top/2020/07/07/（拉钩）Android工程师进阶34讲-06：Class对象在执行引擎中的初始化过程/</id>
    <published>2020-07-07T09:01:51.000Z</published>
    <updated>2020-07-09T06:41:10.715Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h1><p>前面介绍了<code>ClassLoader</code>的使用，包括它的主要作用就是用来将class字节码加载到内存中。那么，JVM加载class文件的具体过程是怎么样的呢？</p><p>一个class文件被加载到内存分为三步：装载、链接、初始化。其中链接可细分为：验证、准备、解析。</p><h1 id="1-装载"><a href="#1-装载" class="headerlink" title="1. 装载"></a>1. 装载</h1><h2 id="1-1-什么是装载"><a href="#1-1-什么是装载" class="headerlink" title="1.1 什么是装载"></a>1.1 什么是装载</h2><p>装载是指将Java虚拟机查找.class文件并生成字节流，然后根据字节流创建<code>java.lang.Class</code>对象的过程。</p><p>这一过程主要完成三件事：</p><ul><li>1、<code>ClassLoader</code>通过一个类的全限定名（包名 + 类名）来查找.class文件，并生成二进制字节流：其中class字节码文件的来源不一定是.class文件，也可以是jar包、zip包，甚至是网络的字节流。</li><li>2、把.class文件各个部分分别解析(parse)为JVM内部特定的数据结构，并存放在方法区。这点和JSON解析过程有点类似。</li><li>3、在内存中创建一个<code>java.lang.Class</code>类型的对象：后面程序在运行过程中所有对该类的访问都通过这个对象，即这个Class类型的对象是提供给外界访问该类的接口。</li></ul><h2 id="1-2-加载时机"><a href="#1-2-加载时机" class="headerlink" title="1.2 加载时机"></a>1.2 加载时机</h2><p>一个项目编译之后，往往会生成大量的.class文件。当程序运行时，JVM并不会一次性将这些.class文件全部加载到内存中。那JVM什么时候加载某个.class文件？对此，Java虚拟机规范中没有做严格的规定，不同的虚拟机会有不同实现。以下两种情况一般会对class进行装载操作。</p><ul><li>隐式装载：在程序运行时，当碰到通过<code>new</code>等方式生成的对象时，系统会隐式调用<code>ClassLoader</code>去装载对应的class到内存中。</li><li>显示装载：在编写源代码时，主动调用<code>Class.forName()</code>等方法也会进行class装载操作。</li></ul><h1 id="2-链接"><a href="#2-链接" class="headerlink" title="2. 链接"></a>2. 链接</h1><p>链接分为三步：验证、准备、解析。</p><h2 id="2-1-验证"><a href="#2-1-验证" class="headerlink" title="2.1 验证"></a>2.1 验证</h2><p>目的是为了确保.class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危及虚拟机本身的安全。主要包含以下几个方面的检验。</p><ul><li>1、文件格式检验：检验字节流是否符合class文件格式的规范，并且能被当前版本的虚拟机处理。</li><li>2、元数据检验：对字节码描述的信息进行语义分析，以保证其描述的内容符合Java语言规范的要求。</li><li>3、字节码检验：通过数据流和控制流分析，确定程序语义是合法、符合逻辑的。</li><li>4、符号引用检验：符号引用检验可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验。</li></ul><p>实例分析：</p><p>下面使用<code>Foo.java</code>来分析验证阶段的几个情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Foo().print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> superCode = <span class="keyword">super</span>.hashCode();</span><br><span class="line">        System.out.println(<span class="string">"superCode is "</span> + superCode);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> thisCode = hashCode();</span><br><span class="line">        System.out.println(<span class="string">"thisCode is "</span> + thisCode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">111</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用javac将<code>Foo.java</code>编译成<code>Foo.class</code>，然后使用16进制编辑器打开.class文件，部分如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CA FE BA BE 00 00 00 34 00 36 0A 00 10 00 1C 07</span><br><span class="line">00 1D 0A 00 02 00 1C 0A 00 02 00 1E 0A 00 10 00</span><br><span class="line">1F 09 00 20 00 21 07 00 22 0A 00 07 00 1C 08 00</span><br><span class="line">23 0A 00 07 00 24 0A 00 07 00 25 0A 00 07 00 26</span><br><span class="line">0A 00 27 00 28 0A 00 02 00 1F 08 00 29 07 00 2A</span><br><span class="line">01 00 06 3C 69 6E 69 74 3E 01 00 03 28 29 56 01</span><br></pre></td></tr></table></figure><p>正常执行<code>Foo.java</code>，打印如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">superCode is 460141958</span><br><span class="line">thisCode is 111</span><br></pre></td></tr></table></figure><p>使用16进制编辑器，修改class魔数，将<code>CAFE BABE</code>改成<code>CAFE BABB</code>，重新运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">E:\Project\MyStudyDemo\LGDemo\src&gt;java Foo</span><br><span class="line">Error: A JNI error has occurred, please check your installation and try again</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.ClassFormatError: Incompatible magic value 3405691579 in class file Foo</span><br><span class="line">        at java.lang.ClassLoader.defineClass1(Native Method)</span><br><span class="line">        at java.lang.ClassLoader.defineClass(Unknown Source)</span><br><span class="line">        at java.security.SecureClassLoader.defineClass(Unknown Source)</span><br><span class="line">        at java.net.URLClassLoader.defineClass(Unknown Source)</span><br><span class="line">        at java.net.URLClassLoader.access$100(Unknown Source)</span><br><span class="line">        at java.net.URLClassLoader$1.run(Unknown Source)</span><br><span class="line">        at java.net.URLClassLoader$1.run(Unknown Source)</span><br><span class="line">        at java.security.AccessController.doPrivileged(Native Method)</span><br><span class="line">        at java.net.URLClassLoader.findClass(Unknown Source)</span><br><span class="line">        at java.lang.ClassLoader.loadClass(Unknown Source)</span><br><span class="line">        at sun.misc.Launcher$AppClassLoader.loadClass(Unknown Source)</span><br><span class="line">        at java.lang.ClassLoader.loadClass(Unknown Source)</span><br><span class="line">        at sun.launcher.LauncherHelper.checkAndLoadMain(Unknown Source)</span><br></pre></td></tr></table></figure><p>魔数后面的<code>&quot;0034&quot;</code>为版本号，如果改成<code>&quot;0035&quot;</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CA FE BA BE 00 00 00 35 00 36 0A 00 10 00 1C 07</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">E:\Project\MyStudyDemo\LGDemo\src&gt;java Foo</span><br><span class="line">Error: A JNI error has occurred, please check your installation and try again</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.UnsupportedClassVersionError: Foo has been compiled by a more recent version of the Java Runtime (class file version 53.0), th</span><br><span class="line">is version of the Java Runtime only recognizes class file versions up to 52.0</span><br><span class="line">        at java.lang.ClassLoader.defineClass1(Native Method)</span><br><span class="line">        at java.lang.ClassLoader.defineClass(Unknown Source)</span><br><span class="line">        at java.security.SecureClassLoader.defineClass(Unknown Source)</span><br><span class="line">        at java.net.URLClassLoader.defineClass(Unknown Source)</span><br><span class="line">        at java.net.URLClassLoader.access$100(Unknown Source)</span><br><span class="line">        at java.net.URLClassLoader$1.run(Unknown Source)</span><br><span class="line">        at java.net.URLClassLoader$1.run(Unknown Source)</span><br><span class="line">        at java.security.AccessController.doPrivileged(Native Method)</span><br><span class="line">        at java.net.URLClassLoader.findClass(Unknown Source)</span><br><span class="line">        at java.lang.ClassLoader.loadClass(Unknown Source)</span><br><span class="line">        at sun.misc.Launcher$AppClassLoader.loadClass(Unknown Source)</span><br><span class="line">        at java.lang.ClassLoader.loadClass(Unknown Source)</span><br><span class="line">        at sun.launcher.LauncherHelper.checkAndLoadMain(Unknown Source)</span><br></pre></td></tr></table></figure><p>版本号<code>&quot;0034&quot;</code>之后的<code>&quot;0036&quot;</code>是常量计数器，表示常量池中有54个常量。这个修改成<code>&quot;0032&quot;</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CA FE BA BE 00 00 00 35 00 32 0A 00 10 00 1C 07</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">E:\Project\MyStudyDemo\LGDemo\src&gt;java Foo</span><br><span class="line">Error: A JNI error has occurred, please check your installation and try again</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.ClassFormatError: Invalid constant pool index 50 in class file Foo</span><br><span class="line">        at java.lang.ClassLoader.defineClass1(Native Method)</span><br><span class="line">        at java.lang.ClassLoader.defineClass(Unknown Source)</span><br><span class="line">        at java.security.SecureClassLoader.defineClass(Unknown Source)</span><br><span class="line">        at java.net.URLClassLoader.defineClass(Unknown Source)</span><br><span class="line">        at java.net.URLClassLoader.access$100(Unknown Source)</span><br><span class="line">        at java.net.URLClassLoader$1.run(Unknown Source)</span><br><span class="line">        at java.net.URLClassLoader$1.run(Unknown Source)</span><br><span class="line">        at java.security.AccessController.doPrivileged(Native Method)</span><br><span class="line">        at java.net.URLClassLoader.findClass(Unknown Source)</span><br><span class="line">        at java.lang.ClassLoader.loadClass(Unknown Source)</span><br><span class="line">        at sun.misc.Launcher$AppClassLoader.loadClass(Unknown Source)</span><br><span class="line">        at java.lang.ClassLoader.loadClass(Unknown Source)</span><br><span class="line">        at sun.launcher.LauncherHelper.checkAndLoadMain(Unknown Source)</span><br></pre></td></tr></table></figure><p>虽然JVM会检查各种对class字节码文件的篡改行为，但是依然无法保证class文件的安全性。比如在<code>Foo.java</code>中的<code>print()</code>方法中，分别打印出父类的自身类的<code>hashCode</code>值，分别是460141958和111。我们可以在class字节码的基础上篡改，将父类的<code>hashCode</code>返回111。</p><p>通过<code>javap -v Foo</code>查看<code>Foo.class</code>中常量池的具体信息（部分）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #16.#28        // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Class              #29            // Foo</span><br><span class="line">   #3 = Methodref          #2.#28         // Foo.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #4 = Methodref          #2.#30         // Foo.print:()V</span><br><span class="line">   #5 = Methodref          #16.#31        // java/lang/Object.hashCode:()I</span><br><span class="line">   #6 = Fieldref           #32.#33        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #7 = Class              #34            // java/lang/StringBuilder</span><br><span class="line">   #8 = Methodref          #7.#28         // java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #9 = String             #35            // superCode is</span><br><span class="line">  #10 = Methodref          #7.#36         // java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">  #11 = Methodref          #7.#37         // java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span><br><span class="line">  #12 = Methodref          #7.#38         // java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">  #13 = Methodref          #39.#40        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">  #14 = Methodref          #2.#31         // Foo.hashCode:()I</span><br><span class="line">  #15 = String             #41            // thisCode is</span><br><span class="line">  #16 = Class              #42            // java/lang/Object</span><br></pre></td></tr></table></figure><p><code>#5</code>处指向了父类<code>Object</code>的<code>hashCode</code>方法，<code>#14</code>处指向了<code>Foo</code>的<code>hashCode</code>方法。第03节中，已经了解到<code>CONSTANT_Methodref_info</code>结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Methodref_info&#123;</span><br><span class="line">    u1 tag = 10;</span><br><span class="line">    u2 class_index;     // 指向此方法的所属类</span><br><span class="line">    u2 name_type_index; // 指向此方法名称和类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>class_index</code>就是指向方法的所属类，示例中为16，转化为16进制为0X10，因此只需要使用16进制编辑器将指向<code>Object</code>的<code>class_index</code>改为执行<code>Foo</code>的<code>class_index</code>即可。具体修改如下：</p><img src="/2020/07/07/（拉钩）Android工程师进阶34讲-06：Class对象在执行引擎中的初始化过程/链接-验证1.png"><p>将<code>&quot;0X10&quot;</code>改成<code>&quot;0X02&quot;</code>，重新运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E:\Project\MyStudyDemo\LGDemo\src&gt;java Foo</span><br><span class="line">superCode is 111</span><br><span class="line">thisCode is 111</span><br></pre></td></tr></table></figure><p>可以看出，虽然在Java源文件中调用了<code>super.hashCode()</code>方法，但是经过篡改之后，<code>Foo.class</code>文件成功通过了JVM校验，并成功执行最终打印。</p><blockquote><p>注意，上面的实例说明，即使没有Java源文件，某种程度上，也可以对编译之后的class字节码进行篡改。这也是为什么在项目中使用混淆，甚至使用一些第三方加固软件，来保证编写的代码的安全性。</p></blockquote><h2 id="2-2-准备"><a href="#2-2-准备" class="headerlink" title="2.2 准备"></a>2.2 准备</h2><p>目的是为类中的静态变量分配内存，并为其设置“0值”。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>在准备阶段，JVM会为value分配内存，并将其设置为0。而真正的值100是在初始化阶段设置的。并且此阶段进行内存分配的仅包括类变量，而不包括实例变量（实例变量将会在对象初始化时随对象一起分配在Java堆中）。</p><p>有一种情况比较特殊——静态常量，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>以上代码会在准备阶段为<code>value</code>分配内存，并设置为100。</p><p>Java中基本类型的默认“0值”如下：</p><ul><li>基本类型的默认值为0；</li><li>引用类型的默认值为null。</li></ul><h2 id="2-3-解析"><a href="#2-3-解析" class="headerlink" title="2.3 解析"></a>2.3 解析</h2><p>这一阶段的任务是把常量池中的符号引用转换为直接引用，也就是具体的内存地址。在这一阶段，JVM会将常量池中的类、接口名、字段名、方法名等转换为具体的内存地址。</p><p>比如上面<code>Foo.java</code>中编译之后<code>main</code>方法的字节码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #16.#28        // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Class              #29            // Foo</span><br><span class="line">   #3 = Methodref          #2.#28         // Foo.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #4 = Methodref          #2.#30         // Foo.print:()V</span><br><span class="line">   #5 = Methodref          #2.#31         // Foo.hashCode:()I</span><br><span class="line">   #6 = Fieldref           #32.#33        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #7 = Class              #34            // java/lang/StringBuilder</span><br><span class="line">   #8 = Methodref          #7.#28         // java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #9 = String             #35            // superCode is</span><br><span class="line">  #10 = Methodref          #7.#36         // java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">  #11 = Methodref          #7.#37         // java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span><br><span class="line">  #12 = Methodref          #7.#38         // java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">  #13 = Methodref          #39.#40        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">  #14 = Methodref          #2.#31         // Foo.hashCode:()I</span><br><span class="line">  #15 = String             #41            // thisCode is</span><br><span class="line">  #16 = Class              #42            // java/lang/Object</span><br><span class="line">  #17 = Utf8               &lt;init&gt;</span><br><span class="line">  #18 = Utf8               ()V</span><br><span class="line">  #19 = Utf8               Code</span><br><span class="line">  #20 = Utf8               LineNumberTable</span><br><span class="line">  #21 = Utf8               main</span><br><span class="line">  #22 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #23 = Utf8               print</span><br><span class="line">  #24 = Utf8               hashCode</span><br><span class="line">  #25 = Utf8               ()I</span><br><span class="line">  #26 = Utf8               SourceFile</span><br><span class="line">  #27 = Utf8               Foo.java</span><br><span class="line">  #28 = NameAndType        #17:#18        // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #29 = Utf8               Foo</span><br><span class="line">  #30 = NameAndType        #23:#18        // print:()V</span><br><span class="line">  #31 = NameAndType        #24:#25        // hashCode:()I</span><br><span class="line">  #32 = Class              #43            // java/lang/System</span><br><span class="line">  #33 = NameAndType        #44:#45        // out:Ljava/io/PrintStream;</span><br><span class="line">  #34 = Utf8               java/lang/StringBuilder</span><br><span class="line">  #35 = Utf8               superCode is</span><br><span class="line">  #36 = NameAndType        #46:#47        // append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">  #37 = NameAndType        #46:#48        // append:(I)Ljava/lang/StringBuilder;</span><br><span class="line">  #38 = NameAndType        #49:#50        // toString:()Ljava/lang/String;</span><br><span class="line">  #39 = Class              #51            // java/io/PrintStream</span><br><span class="line">  #40 = NameAndType        #52:#53        // println:(Ljava/lang/String;)V</span><br><span class="line">  #41 = Utf8               thisCode is</span><br><span class="line">  #42 = Utf8               java/lang/Object</span><br><span class="line">  #43 = Utf8               java/lang/System</span><br><span class="line">  #44 = Utf8               out</span><br><span class="line">  #45 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #46 = Utf8               append</span><br><span class="line">  #47 = Utf8               (Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">  #48 = Utf8               (I)Ljava/lang/StringBuilder;</span><br><span class="line">  #49 = Utf8               toString</span><br><span class="line">  #50 = Utf8               ()Ljava/lang/String;</span><br><span class="line">  #51 = Utf8               java/io/PrintStream</span><br><span class="line">  #52 = Utf8               println</span><br><span class="line">  #53 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  public Foo();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 1: 0</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: new           #2                  // class Foo</span><br><span class="line">         3: dup</span><br><span class="line">         4: invokespecial #3                  // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         7: invokevirtual #4                  // Method print:()V</span><br><span class="line">        10: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 4: 0</span><br><span class="line">        line 5: 10</span><br></pre></td></tr></table></figure><p>在<code>main</code>方法中通过<code>invokespecial</code>指令调用<code>print</code>方法，<code>Foo.print:()V</code>就是一个<strong>符号引用</strong>，当<code>main</code>方法执行到此处时，会将<strong>符号引用</strong> <code>Foo.print:()V</code>解析成<strong>直接引用</strong>，可以将直接引用理解为方法真正的内存地址。</p><blockquote><p>对于符号引用和直接引用，可以与微信聊天类比，在微信好友列表中，保存的是好友的名称或别名（就是符号引用），当真正给某个好友发送消息时，计算机（JVM）会根据好友的名称找到对象计算机的IP地址（直接引用）并将消息发送给这一地址。</p></blockquote><h1 id="3-初始化"><a href="#3-初始化" class="headerlink" title="3. 初始化"></a>3. 初始化</h1><p>这一阶段执行类构造器<code>&lt;clinit&gt;</code>方法的过程，并真正初始化类变量。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>在准备阶段<code>value</code>被分配内存，并设置为0，在初始化阶段<code>value</code>就会被设置为100。</p><h2 id="3-1-初始化的时机"><a href="#3-1-初始化的时机" class="headerlink" title="3.1 初始化的时机"></a>3.1 初始化的时机</h2><p>对于装载阶段，JVM并没有规范何时具体执行。但是对于初始化，JVM规范中严格规定了class初始化的时机，主要有以下几种情况会触发class的初始化：</p><ul><li>1、虚拟机启动时，初始化包含<code>main</code>方法的主类；</li><li>2、遇到<code>new</code>指令创建对象实例时，如果目标对象类没有被初始化则进行初始化操作；</li><li>3、遇到访问静态方法或静态字段的指令时，如果目标对象类没有被初始化则进行初始化操作；</li><li>4、子类的初始化过程如果发现其父类没有进行初始化，则需要先触发其父类的初始化；</li><li>5、使用反射API进行反射调用时，如果类没有进行初始化则需要先触发其初始化；</li><li>6、第一次调用<code>java.lang.invoke.MethodHandle</code>实例时，需要初始化<code>MethodHandle</code>指向方法所在的类。</li></ul><h2 id="3-2-初始化类变量"><a href="#3-2-初始化类变量" class="headerlink" title="3.2 初始化类变量"></a>3.2 初始化类变量</h2><p>在初始化阶段，只会初始化与类相关的静态赋值语句和静态语句，也就是有<code>static</code>关键字修饰的信息，而没有<code>static</code>修饰的语句块在实例化对象的时候才进行初始化。</p><p>如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassInit</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态语句块在初始化阶段执行</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"ClassInit static block!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非静态语句块只在创建对象实例时被执行</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"ClassInit non-static block!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在<code>ClassInitTest.java</code>中访问<code>ClassInit</code>的<code>value</code>值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassInitTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassInit.value = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行代码，打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassInit static block!</span><br></pre></td></tr></table></figure><p>可以看出，非静态代码块没有被执行。如果将<code>ClassInitTest.java</code>修改成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassInitTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassInit.value = <span class="number">2</span>;</span><br><span class="line">        ClassInit ci = <span class="keyword">new</span> ClassInit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次执行，就会执行非静态代码块，打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassInit static block!</span><br><span class="line">ClassInit non-static block!</span><br></pre></td></tr></table></figure><h2 id="3-3-被动引用"><a href="#3-3-被动引用" class="headerlink" title="3.3 被动引用"></a>3.3 被动引用</h2><p>上述的6种情况在JVM中被称为主动引用，除此6种情况之外所有引用类的方式都被称为被动引用。被动引用并不会触发class的初始化。</p><p>最典型的就是子类调用父类的静态变量，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"this is Parent!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"this is Child!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Child</code>继承了<code>Parent</code>，如果直接使用<code>Child</code>来访问<code>Parent</code>的<code>value</code>值，则不会初始化<code>Child</code>类，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonInitTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Child.value = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this is Parent!</span><br></pre></td></tr></table></figure><p>可以看出，<code>Child</code>中的静态代码没有执行。也就是说JVM没有对<code>Child</code>进行初始化操作。</p><p>对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过子类<code>Child</code>来引用父类<code>Parent</code>中定义的静态字段，只会触发<code>Parent</code>额初始化。至于是否要触发子类的加载和验证，在虚拟机规范中没有明确规定，可以通过<code>XX:-TraceClassLoading</code>参数来查看，比如使用如下命令再次执行<code>NonInitTest</code>：（先<code>javac NonInitTest.java</code>编译）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java XX:-TraceClassLoading NonInitTest</span><br></pre></td></tr></table></figure><p>打印（部分）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Loaded Parent from file:/E:/Project/MyStudyDemo/LGDemo/src/]</span><br><span class="line">[Loaded Child from file:/E:/Project/MyStudyDemo/LGDemo/src/]</span><br><span class="line">this is Parent!</span><br></pre></td></tr></table></figure><p>可以看到，虽然只有<code>Parent</code>被初始化，但是<code>Parent</code>和<code>Child</code>都经过了装载和验证阶段，并被加载到了内存中。</p><h2 id="3-4-class初始化和对象的创建顺序"><a href="#3-4-class初始化和对象的创建顺序" class="headerlink" title="3.4 class初始化和对象的创建顺序"></a>3.4 class初始化和对象的创建顺序</h2><p>关于class的初始化还有一点经常被提及，就是对象的初始化顺序。当在代码中使用<code>new</code>创建一个类的实例对象时，类中的静态代码块、费静态代码块、构造函数之间的执行顺序是怎样的：</p><p>如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitOrder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parent p = <span class="keyword">new</span> Child();</span><br><span class="line">        System.out.println(<span class="string">"-----------------------"</span>);</span><br><span class="line">        p = <span class="keyword">new</span> Child();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Child static block!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"Child non-static block!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Child</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Child constructor!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Parent static block!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"Parent non-static block!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Parent constructor!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Parent static block!</span><br><span class="line">Child static block!</span><br><span class="line">Parent non-static block!</span><br><span class="line">Parent constructor!</span><br><span class="line">Child non-static block!</span><br><span class="line">Child constructor!</span><br><span class="line">-----------------------</span><br><span class="line">Parent non-static block!</span><br><span class="line">Parent constructor!</span><br><span class="line">Child non-static block!</span><br><span class="line">Child constructor!</span><br></pre></td></tr></table></figure><p>对象初始化顺序：<br>静态变量/静态代码块 -&gt; 普通代码块 -&gt; 构造函数</p><ul><li>1、父类静态变量和静态代码块；</li><li>2、子类静态变量和静态代码块；</li><li>3、父类普通成员变量和普通代码块；</li><li>4、父类构造函数；</li><li>5、子类普通成员变量和普通代码块；</li><li>6、子类构造函数；</li></ul><p><strong>更多参考链接</strong>：</p><ul><li><a href="https://www.zhihu.com/question/50258991" target="_blank" rel="noopener">JVM符号引用转换直接引用的过程?</a></li><li><a href="https://www.zhihu.com/question/30300585/answer/51335493" target="_blank" rel="noopener">JVM里的符号引用如何存储？</a></li><li><a href="https://mp.weixin.qq.com/s/fyvoraVu9yjgqX-xhn6EHQ" target="_blank" rel="noopener">大话Java对象在虚拟机中是什么样子？</a></li><li><a href="https://www.jianshu.com/p/252e27863822" target="_blank" rel="noopener">JVM源码分析之Java类的加载过程</a></li></ul><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><ul><li>1、装载：查找字节流，并根据此字节流创建类的过程。装载过程成功的标志就是在方法区中成功创建类所对应的Class对象。</li><li>2、链接：验证创建的类，并将其解析到JVM中使之能被JVM执行。</li><li>3、初始化：将标记为<code>static</code>的字段进行赋值，并且执行<code>static</code>标记的代码语句。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0. 前言&quot;&gt;&lt;/a&gt;0. 前言&lt;/h1&gt;&lt;p&gt;前面介绍了&lt;code&gt;ClassLoader&lt;/code&gt;的使用，包括它的主要作用就是用来将class字节码加载到内存中
      
    
    </summary>
    
      <category term="Android" scheme="https://tylerLiu.top/categories/Android/"/>
    
      <category term="进阶" scheme="https://tylerLiu.top/categories/Android/%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="JVM与DVM必知必会" scheme="https://tylerLiu.top/tags/JVM%E4%B8%8EDVM%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"/>
    
  </entry>
  
  <entry>
    <title>（拉钩）Android工程师进阶34讲-05：深入理解ClassLoader的加载机制</title>
    <link href="https://tylerLiu.top/2020/06/30/%EF%BC%88%E6%8B%89%E9%92%A9%EF%BC%89Android%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BF%9B%E9%98%B634%E8%AE%B2-05%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ClassLoader%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>https://tylerLiu.top/2020/06/30/（拉钩）Android工程师进阶34讲-05：深入理解ClassLoader的加载机制/</id>
    <published>2020-06-30T02:20:12.000Z</published>
    <updated>2020-07-07T08:56:31.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h1><p>第3节介绍了Java字节码文件(.class)的格式。一个完整的Java程序是由多个.class文件组成的，在程序运行过程中，需要将这些.class文件加载到JVM中才可以使用。而负责加载这些.class文件的就是类加载器(ClassLoader)。</p><h1 id="1-Java中的类何时被加载器加载"><a href="#1-Java中的类何时被加载器加载" class="headerlink" title="1. Java中的类何时被加载器加载"></a>1. Java中的类何时被加载器加载</h1><p>在Java程序启动的时候，并不会一次性加载程序中的所有.class文件，而是在程序的运行过程中，动态地加载相应的类到内存中。</p><p>通常情况下，Java程序中的.class文件会在以下2种情况下被ClassLoader主动加载到内存中：</p><ul><li>1、调用类构造器</li><li>2、调用类中的静态(static)变量或静态方法</li></ul><h1 id="2-Java中的ClassLoader"><a href="#2-Java中的ClassLoader" class="headerlink" title="2. Java中的ClassLoader"></a>2. Java中的ClassLoader</h1><p>JVM中自带3个类加载器：</p><ul><li>1、启动类加载器<code>BootstrapClassLoader</code></li><li>2、扩展类加载器<code>ExtClassLoader</code>（JDK 1.9之后，改名为<code>PlatformClassLoader</code>）</li><li>3、系统加载器<code>AppClassLoader</code></li></ul><p>以上三者在JVM中各有分工，但是又相互依赖。</p><h2 id="2-1-AppClassLoader系统类加载器"><a href="#2-1-AppClassLoader系统类加载器" class="headerlink" title="2.1 AppClassLoader系统类加载器"></a>2.1 AppClassLoader系统类加载器</h2><p>部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AppClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> URLClassPath ucp = SharedSecrets.getJavaNetAccess().getURLClassPath(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getAppClassLoader</span><span class="params">(<span class="keyword">final</span> ClassLoader var0)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String var1 = System.getProperty(<span class="string">"java.class.path"</span>);</span><br><span class="line">    <span class="keyword">final</span> File[] var2 = var1 == <span class="keyword">null</span> ? <span class="keyword">new</span> File[<span class="number">0</span>] : Launcher.getClassPath(var1);</span><br><span class="line">    <span class="keyword">return</span> (ClassLoader)AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Launcher.AppClassLoader&gt;() &#123;</span><br><span class="line">        <span class="keyword">public</span> Launcher.<span class="function">AppClassLoader <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            URL[] var1x = var1 == <span class="keyword">null</span> ? <span class="keyword">new</span> URL[<span class="number">0</span>] : Launcher.pathToURLs(var2);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Launcher.AppClassLoader(var1x, var0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，<code>AppClassLoader</code>主要加载系统属性<code>&quot;java.class.path&quot;</code>配置下的文件，也就是环境变量CLASS_PATH配置的路径。因此<code>AppClassLoader</code>是面向用户的类加载器，编写的代码以及使用的第三方jar包通常都是由它来加载的。</p><h2 id="2-2-ExtClassLoader扩展类加载器"><a href="#2-2-ExtClassLoader扩展类加载器" class="headerlink" title="2.2 ExtClassLoader扩展类加载器"></a>2.2 ExtClassLoader扩展类加载器</h2><p>部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Launcher.ExtClassLoader instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Launcher.<span class="function">ExtClassLoader <span class="title">getExtClassLoader</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Class var0 = Launcher.ExtClassLoader.class;</span><br><span class="line">            <span class="keyword">synchronized</span>(Launcher.ExtClassLoader.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = createExtClassLoader();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExtClassLoader</span><span class="params">(File[] var1)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(getExtURLs(var1), (ClassLoader)<span class="keyword">null</span>, Launcher.factory);</span><br><span class="line">        SharedSecrets.getJavaNetAccess().getURLClassPath(<span class="keyword">this</span>).initLookupCache(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> File[] getExtDirs() &#123;</span><br><span class="line">        String var0 = System.getProperty(<span class="string">"java.ext.dirs"</span>);</span><br><span class="line">        File[] var1;</span><br><span class="line">        <span class="keyword">if</span> (var0 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            StringTokenizer var2 = <span class="keyword">new</span> StringTokenizer(var0, File.pathSeparator);</span><br><span class="line">            <span class="keyword">int</span> var3 = var2.countTokens();</span><br><span class="line">            var1 = <span class="keyword">new</span> File[var3];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> var4 = <span class="number">0</span>; var4 &lt; var3; ++var4) &#123;</span><br><span class="line">                var1[var4] = <span class="keyword">new</span> File(var2.nextToken());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            var1 = <span class="keyword">new</span> File[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ExtClassLoader</code>加载系统属性<code>&quot;java.ext.dirs&quot;</code>配置下类文件，可以打印出这个属性查看具体有哪些文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(System.getPreperty(<span class="string">"java/ext.dirs"</span>));</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_1051.jdk/Contents/Home/jre/lib/ext</span><br></pre></td></tr></table></figure><h2 id="2-3-BootstrapClassLoader启动类加载器"><a href="#2-3-BootstrapClassLoader启动类加载器" class="headerlink" title="2.3 BootstrapClassLoader启动类加载器"></a>2.3 BootstrapClassLoader启动类加载器</h2><p><code>BootstrapClassLoader</code>和上面两种ClassLoader不一样。</p><p>首先，它并不是使用Java实现的， 而是由C/C++编写的，它本身属于虚拟机的一部分。因此无法在Java代码中直接获取它的引用。如果在Java层获取<code>BootstrapClassLoader</code>的引用，系统会返回<code>null</code>。</p><p><code>BootstrapClassLoader</code>加载系统属性<code>&quot;sun.boot.class.path&quot;</code>配置下的类文件，可以打印出这个属性来查看具体有哪些文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(System.getPreperty(<span class="string">"sun.boot.class.path"</span>));</span><br></pre></td></tr></table></figure><p>结果如下：</p><img src="/2020/06/30/（拉钩）Android工程师进阶34讲-05：深入理解ClassLoader的加载机制/BootstrapClassLoader启动类加载器.png"><p>可以看到，这些全是JRE目录下的jar包或.class文件。</p><h1 id="3-双亲委派模式-Parents-Delegation-Model"><a href="#3-双亲委派模式-Parents-Delegation-Model" class="headerlink" title="3. 双亲委派模式(Parents Delegation Model)"></a>3. 双亲委派模式(Parents Delegation Model)</h1><p>JVM中已经有了三种ClassLoader，那么JVM又是如何知道该使用哪一种类加载器去加载相应的类呢？是<strong>双亲委派模式</strong>。</p><h2 id="3-1-双亲委派模式"><a href="#3-1-双亲委派模式" class="headerlink" title="3.1 双亲委派模式"></a>3.1 双亲委派模式</h2><p>双亲委派模式就是当类加载器接收加载类或资源的请求时，通常都是先委托给父加载器加载，只有当父加载器找不到指定类或资源时，自身才会执行实际的类加载过程。</p><p>其具体实现代码就是在<code>ClassLoader.java</code>中的<code>loadClass()</code>方法中，如下：java/lang/ClassLoader.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name); <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>); <span class="comment">// 2</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name); <span class="comment">// 3</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                c = findClass(name); <span class="comment">// 4</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>1、判断该<code>Class</code>是否已加载，如果已经加载，则直接将该<code>Class</code>返回。</li><li>2、如果该<code>Class</code>没有被加载过，则判断<code>parent</code>是否为空，如果不为空，则将加载任务委托给<code>parent</code>。</li><li>3、如果<code>parent = null</code>，则直接调用<code>BootstrapClassLoader</code>加载该类。</li><li>4、如果<code>parent</code>和<code>BootstrapClassLoader</code>都没有加载成功，则调用当前<code>ClassLoader</code>的<code>findClass()</code>方法继续尝试加载。</li></ul><p>这个<code>parent</code>是什么呢？可以看<code>ClassLoader</code>的构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ClassLoader</span><span class="params">(ClassLoader parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(checkCreateClassLoader(), parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在每一个<code>ClassLoader</code>中都有一个<code>ClassLoader</code>类型的<code>parent</code>引用，并且在构造器中传入值。如果继续看源码，可以看到<code>AppClassLoader</code>传入的<code>parent</code>就是<code>ExtClassLoader</code>，而<code>ExtClassLoader</code>并没有传入任何<code>parent</code>，也就是<code>null</code>。</p><h2 id="3-2-举例"><a href="#3-2-举例" class="headerlink" title="3.2 举例"></a>3.2 举例</h2><p>比如执行下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Test test = <span class="keyword">new</span> Test();</span><br></pre></td></tr></table></figure><p>默认情况下，JVM首先使用<code>AppClassLoader</code>去加载<code>Test</code>类。</p><ul><li>1、<code>AppClassLoader</code>将加载的任务委派给它的父类加载器——<code>ExtClassLoader</code>。</li><li>2、<code>ExtClassLoader</code>的<code>parent</code>为<code>null</code>，所以直接将加载任务委派给<code>BootstrapClassLoader</code>。</li><li>3、<code>BootstrapClassLoader</code>在jdk/lib目录下无法找到<code>Test</code>类，因此返回的<code>Class</code>为<code>null</code>。</li><li>4、因为<code>parent</code>和<code>BootstrapClassLoader</code>都没有成功加载<code>Test</code>类，所以<code>AppClassLoader</code>会调用<code>findClass()</code>来加载<code>Test</code>。</li></ul><p>最终<code>Test</code>就是被<code>AppClassLoader</code>加载到内存中，可以通过如下代码验证此结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassLoader cl = Test.class.getClassLoader();</span><br><span class="line">        System.out.println(<span class="string">"cl is "</span> + cl);</span><br><span class="line"></span><br><span class="line">        ClassLoader parent = cl.getParent();</span><br><span class="line">        System.out.println(<span class="string">"parent is "</span> + parent);</span><br><span class="line"></span><br><span class="line">        ClassLoader boot_strap = parent.getParent();</span><br><span class="line">        System.out.println(<span class="string">"boot_strap is "</span> + boot_strap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cl is sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">parent is sun.misc.Launcher$ExtClassLoader@1b6d3586</span><br><span class="line">boot_strap is null</span><br></pre></td></tr></table></figure><blockquote><p>注意：“双亲委派模式”只是Java推荐的模式，并不是强制的。我们可以继承<code>ClassLoader</code>，实现自己的类加载器。如果想保持双亲委派模式，应该重写<code>findClass(name)</code>方法；如果想破坏双亲委派模式，可以重写<code>loadClass(name)</code>方法。</p></blockquote><h1 id="4-自定义ClassLoader"><a href="#4-自定义ClassLoader" class="headerlink" title="4. 自定义ClassLoader"></a>4. 自定义ClassLoader</h1><p>JVM中预置了三种<code>ClassLoader</code>，只能加载特定目录下的.class文件，如果想加载其他特殊位置下的jar包或类时（比如，要加载网络或磁盘上的一个.class文件），默认的<code>ClassLoader</code>就不能满足需求，所以需要自定义<code>ClassLoader</code>来加载特定目录下的.class文件。</p><h2 id="4-1-自定义ClassLoader步骤"><a href="#4-1-自定义ClassLoader步骤" class="headerlink" title="4.1 自定义ClassLoader步骤"></a>4.1 自定义ClassLoader步骤</h2><ul><li>1、自定义一个类继承抽象类<code>ClassLoader</code>。</li><li>2、重写<code>findClass()</code>方法。</li><li>3、在<code>findClass()</code>中，调用<code>defineClass()</code>方法将字节码转换成<code>Class</code>对象，并返回。</li></ul><p>伪代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 自定义<span class="title">ClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 寻找字节码</span></span><br><span class="line">        <span class="keyword">byte</span>[] code = findCodeFromSomeWhere(name);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.defineClass(name, code);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-自定义ClassLoader示例"><a href="#4-2-自定义ClassLoader示例" class="headerlink" title="4.2 自定义ClassLoader示例"></a>4.2 自定义ClassLoader示例</h2><p>首先创建测试类<code>Secret.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Secret</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printSecret</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打印了 printSecret"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类所在的磁盘路径如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Project/MyStudyDemo/LGDemo/src/Secret.java</span><br></pre></td></tr></table></figure><p>下面创建<code>DiskClassLoader</code>继承<code>ClassLoader</code>，重写<code>findClass()</code>方法，并在其中调用<code>defineClass()</code>创建<code>Class</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiskClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String filePath;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiskClassLoader</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.filePath = path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写findClass</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        String newPath = filePath + name + <span class="string">".class"</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] classBytes = <span class="keyword">null</span>;</span><br><span class="line">        Path path = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            path = Paths.get(<span class="keyword">new</span> URI(newPath));</span><br><span class="line">            classBytes = Files.readAllBytes(path);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (URISyntaxException | IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用defineClass，创建Class并返回</span></span><br><span class="line">        <span class="keyword">return</span> defineClass(name, classBytes, <span class="number">0</span>, classBytes.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，写一个测试自定义<code>DiskClassLoader</code>的测试类，验证自定义的<code>DiskClassLoader</code>是否正常工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiskClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        testClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建自定义ClassLoader对象</span></span><br><span class="line">        DiskClassLoader diskClassLoader = <span class="keyword">new</span> DiskClassLoader(<span class="string">"file:///Project/MyStudyDemo/LGDemo/src/"</span>); <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class c = diskClassLoader.loadClass(<span class="string">"Secret"</span>); <span class="comment">// 2</span></span><br><span class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Object obj = c.newInstance();</span><br><span class="line">                <span class="comment">// 通过反射调用Secret的printSecret方法</span></span><br><span class="line">                Method method = c.getDeclaredMethod(<span class="string">"printSecret"</span>, <span class="keyword">null</span>); <span class="comment">// 3</span></span><br><span class="line">                method.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>1、代表需要动态加载的class路径。</li><li>2、代表需要动态加载的类名。</li><li>3、代表需要动态调用的方法名称。</li></ul><p>最后执行，并打印如下结果，表示自定义的<code>ClassLoader</code>可以正常工作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D:\Java\jdk1.8.0_212\bin\java.exe &quot;-javaagent:D:\Program Files\JetBrains\IntelliJ IDEA 2020.1.2\lib\idea_rt.jar=55145:D:\Program Files\JetBrains\IntelliJ IDEA 2020.1.2\bin&quot; -Dfile.encoding=UTF-8 -classpath D:\Java\jdk1.8.0_212\jre\lib\charsets.jar;D:\Java\jdk1.8.0_212\jre\lib\deploy.jar;D:\Java\jdk1.8.0_212\jre\lib\ext\access-bridge-64.jar;D:\Java\jdk1.8.0_212\jre\lib\ext\cldrdata.jar;D:\Java\jdk1.8.0_212\jre\lib\ext\dnsns.jar;D:\Java\jdk1.8.0_212\jre\lib\ext\jaccess.jar;D:\Java\jdk1.8.0_212\jre\lib\ext\jfxrt.jar;D:\Java\jdk1.8.0_212\jre\lib\ext\localedata.jar;D:\Java\jdk1.8.0_212\jre\lib\ext\nashorn.jar;D:\Java\jdk1.8.0_212\jre\lib\ext\sunec.jar;D:\Java\jdk1.8.0_212\jre\lib\ext\sunjce_provider.jar;D:\Java\jdk1.8.0_212\jre\lib\ext\sunmscapi.jar;D:\Java\jdk1.8.0_212\jre\lib\ext\sunpkcs11.jar;D:\Java\jdk1.8.0_212\jre\lib\ext\zipfs.jar;D:\Java\jdk1.8.0_212\jre\lib\javaws.jar;D:\Java\jdk1.8.0_212\jre\lib\jce.jar;D:\Java\jdk1.8.0_212\jre\lib\jfr.jar;D:\Java\jdk1.8.0_212\jre\lib\jfxswt.jar;D:\Java\jdk1.8.0_212\jre\lib\jsse.jar;D:\Java\jdk1.8.0_212\jre\lib\management-agent.jar;D:\Java\jdk1.8.0_212\jre\lib\plugin.jar;D:\Java\jdk1.8.0_212\jre\lib\resources.jar;D:\Java\jdk1.8.0_212\jre\lib\rt.jar;E:\Project\MyStudyDemo\LGDemo\out\production\LGDemo DiskClassLoaderTest</span><br><span class="line">打印了 printSecret</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><blockquote><p>注意：上述动态加载.class文件的思路，经常被用作热修复和插件化开发的框架中，包括QQ空间热修复方案、微信Tink等原理都是由此而来。客户端只要从服务端下载一个加密的.class文件，然后在本地通过事先定义好的加密方式进行解密，最后再使用自定义<code>ClassLoader</code>动态加载解密后的.class文件，并动态调用相应的方法。</p></blockquote><h1 id="5-Android中的ClassLoader"><a href="#5-Android中的ClassLoader" class="headerlink" title="5. Android中的ClassLoader"></a>5. Android中的ClassLoader</h1><p>本质上，Andorid系统和JVM是一样的，也需要通过<code>ClassLoader</code>将目标类加载到内存，类加载器之间也符合双亲委派模式。但是在Android中，<code>ClassLoader</code>的加载细节有略微的差别。</p><p>在Android虚拟机中是无法直接运行.class文件的，Android会将所有的.class文件转换成一个.dex文件，并且Android将加载.dex文件的实现封装在<code>BaseDexClassLoader</code>中，一般只是用它的两个子类：<code>PathClassLoader</code>和<code>DexClassLoader</code>。</p><h2 id="5-1-PathClassLoader"><a href="#5-1-PathClassLoader" class="headerlink" title="5.1 PathClassLoader"></a>5.1 PathClassLoader</h2><p><code>PathClassLoader</code>用来加载系统apk和被安装到手机中的apk内的dex文件。它的2个构造函数如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>((String)<span class="keyword">null</span>, (File)<span class="keyword">null</span>, (String)<span class="keyword">null</span>, (ClassLoader)<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, String librarySearchPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>((String)<span class="keyword">null</span>, (File)<span class="keyword">null</span>, (String)<span class="keyword">null</span>, (ClassLoader)<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>dexPath</code>：dex文件路径，或者包含dex文件的jar包路径；</li><li><code>librarySearchPath</code>：C/C++ native库的路径。</li></ul><p><code>PathClassLoader</code>里面除了这2个构造方法以外就没有其他方法了，具体的实现都是在<code>BaseDexClassLoader</code>里面，其<code>dexPath</code>比较受限制，一般是已经安装应用的apk文件路径。</p><p>当一个App被安装手机后，apk里面的class.dex中的class均通过<code>PathClassLoader</code>来加载的，可以通过如下代码验证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        ClassLoader loader = MainActivity.class.getClassLoader();</span><br><span class="line">        Log.i(<span class="string">"TAG"</span>, loader.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out: dalvik.system.PathClassLoader</span><br><span class="line">[DexPathList[[zip file &quot;/data/app/com.ly.lgdemoandroid-1/base.apk&quot;],nativeLibraryDirectories=[/data/app/com.ly.lgdemoandroid-1/lib/x86, /system/lib, /vendor/lib]]]</span><br></pre></td></tr></table></figure><h2 id="5-2-DexClassLoader"><a href="#5-2-DexClassLoader" class="headerlink" title="5.2 DexClassLoader"></a>5.2 DexClassLoader</h2><p>官方描述：</p><blockquote><p>A class loader that loads classes from .jar and .apk filescontaining a classes.dex entry. </p><p>This can be used to execute code notinstalled as part of an application.</p></blockquote><p>对比<code>PathClassLoader</code>只能加载已经安装应用的dex或apk文件，<code>DexClassLoader</code>则没有此限制，可以从SD卡上加载包含class.dex的.jar和.apk文件，这也是插件化和热修复的基础，在不需要安装应用的情况下，完成需要使用的dex的加载。</p><p><code>DexClassLoader</code>的源码只有一个构造方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DexClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DexClassLoader</span><span class="params">(String dexPath, String optimizedDirectory, String librarySearchPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>((String)<span class="keyword">null</span>, (File)<span class="keyword">null</span>, (String)<span class="keyword">null</span>, (ClassLoader)<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><strong><code>dexPath</code></strong>：包含class.dex的apk、jar文件路径，多个路径用文件分隔符（默认是“:”）分隔。</li><li><strong><code>optimizedDirectory</code></strong>：用来缓存优化的dex文件的路径，即从apk或jar文件中提取出来的dex文件。该路径不可为空，且应该是应用私有的，有读写权限的路径。</li></ul><h3 id="5-2-1-使用DexClassLoader实现热修复"><a href="#5-2-1-使用DexClassLoader实现热修复" class="headerlink" title="5.2.1 使用DexClassLoader实现热修复"></a>5.2.1 使用DexClassLoader实现热修复</h3><h4 id="创建Android项目DexClassLoaderHotFix"><a href="#创建Android项目DexClassLoaderHotFix" class="headerlink" title="创建Android项目DexClassLoaderHotFix"></a>创建Android项目DexClassLoaderHotFix</h4><p>项目结构：</p><img src="/2020/06/30/（拉钩）Android工程师进阶34讲-05：深入理解ClassLoader的加载机制/DexClassLoader热修复示例1.png"><p><code>ISay</code>是一个接口，内部定义了一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ISay</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">saySomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SayException</code>实现了<code>ISay</code>接口，但是在<code>saySomething()</code>方法中，打印<code>&quot;something wrong here&quot;</code>来模拟线上的bug。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SayException</span> <span class="keyword">implements</span> <span class="title">ISay</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">saySomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"something wrong here"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在<code>MainActivity</code>中，当点击按钮时，将<code>saySomething</code>返回的内容通过<code>Toast</code>显示出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ISay say;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        say = <span class="keyword">new</span> SayException();</span><br><span class="line">        Button btnSay = findViewById(R.id.btn_say);</span><br><span class="line">        btnSay.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                Log.e(<span class="string">"TAG"</span>, <span class="string">"say_hotfix.jar not exists"</span>);</span><br><span class="line">                Toast.makeText(MainActivity.<span class="keyword">this</span>, say.saySomething(), Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击按钮：</p><img src="/2020/06/30/（拉钩）Android工程师进阶34讲-05：深入理解ClassLoader的加载机制/DexClassLoader热修复示例2.png"><h4 id="创建HotFix-patch包"><a href="#创建HotFix-patch包" class="headerlink" title="创建HotFix patch包"></a>创建HotFix patch包</h4><p>新建Java项目，并分别创建两个文件<code>ISay.java</code>和<code>SayHotFix.java</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ly.dexclassloaderhotfix;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ISay</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">saySomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ly.dexclassloaderhotfix;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SayHotFix</span> <span class="keyword">implements</span> <span class="title">ISay</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">saySomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Everything is right!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ISay</code>接口的包名和类名必须和Android项目中的一样。<code>SayHotFix</code>实现<code>ISay</code>接口，并在<code>saySomething()</code>中返回新的结果，用来模拟修复bug。</p><p>将<code>ISay</code>和<code>SayHotFix</code>打包成<strong>say_something.jar</strong>，然后通过dx工具将生成的<strong>say_something.jar</strong>包中的class文件优化为dex文件。</p><blockquote><p>dx –dex –output=say_something_hotfix.jar say_something.jar</p></blockquote><p>上述<strong>say_something.jar</strong>就是最终需要用作hotfix的jar包。</p><p><strong>将HotFix patch 包拷贝到SD卡主目录中，并使用<code>DexClassLoader</code>加载SD卡中的<code>ISay</code>接口</strong>。</p><p>首先将HotFix patch保存到本地目录下。一般在真实项目中，可以通过向后端发送请求的方式，将最新的HoFix patch下载到本地中。这里为了演示，直接使用adb命令将<strong>say_something.jar</strong>包push到SD卡目录下：</p><blockquote><p>adb push say_something_hotfix.jar /storage/self/primary/ </p></blockquote><p>下面，修改<code>MainActivity</code>中的逻辑，使用<code>DexClassLoader</code>加载HotFix patch中的<code>SayHotFix</code>类，如下：</p><img src="/2020/06/30/（拉钩）Android工程师进阶34讲-05：深入理解ClassLoader的加载机制/DexClassLoader热修复示例3.png"><h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h1><ul><li><code>ClassLoader</code>就是用来加载class文件的，不管是jar中还是dex中的class。</li><li>Java中的<code>ClassLoader</code>通过双亲委托模式来加载各自指定路径下的class文件。</li><li>可以自定义<code>ClassLoader</code>，一般覆盖<code>findClass()</code>方法，不建议重写<code>loadClass()</code>方法。</li><li>Andorid中常用的两种<code>ClassLoader</code>分别为：<code>PathClassLoader</code>和<code>DexClassLoader</code>。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0. 前言&quot;&gt;&lt;/a&gt;0. 前言&lt;/h1&gt;&lt;p&gt;第3节介绍了Java字节码文件(.class)的格式。一个完整的Java程序是由多个.class文件组成的，在程序运行过
      
    
    </summary>
    
      <category term="Android" scheme="https://tylerLiu.top/categories/Android/"/>
    
      <category term="进阶" scheme="https://tylerLiu.top/categories/Android/%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="JVM与DVM必知必会" scheme="https://tylerLiu.top/tags/JVM%E4%B8%8EDVM%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"/>
    
  </entry>
  
  <entry>
    <title>（拉钩）Android工程师进阶34讲-04：编译插桩操纵字节码，实现不可能完成的任务</title>
    <link href="https://tylerLiu.top/2020/06/25/%EF%BC%88%E6%8B%89%E9%92%A9%EF%BC%89Android%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BF%9B%E9%98%B634%E8%AE%B2-04%EF%BC%9A%E7%BC%96%E8%AF%91%E6%8F%92%E6%A1%A9%E6%93%8D%E7%BA%B5%E5%AD%97%E8%8A%82%E7%A0%81%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%B8%8D%E5%8F%AF%E8%83%BD%E5%AE%8C%E6%88%90%E7%9A%84%E4%BB%BB%E5%8A%A1/"/>
    <id>https://tylerLiu.top/2020/06/25/（拉钩）Android工程师进阶34讲-04：编译插桩操纵字节码，实现不可能完成的任务/</id>
    <published>2020-06-25T06:39:50.000Z</published>
    <updated>2020-06-30T02:15:37.123Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h1><p>前面介绍了Java字节码文件的格式，并通过一个Demo手动模拟了JVM解析class文件的过程。</p><p>本节看看，对于class文件还有其他什么玩法。</p><p>需求：</p><blockquote><p>记录每个页面的打开和关闭事件，并通过各种Data Tracking的框架上传到服务器，用来日后做数据分析。</p></blockquote><p>面对这样的需求，一般人会想到在每个Activity的<code>onCreate</code>和<code>onDestory</code>方法中，分别添加页面打开和关闭的逻辑。常见的做法有以下两种：</p><ul><li>1、修改项目中现有的每一个Activity，这样做，如果项目以后需要添加新的页面，这套逻辑需要多次拷贝，容易遗漏。</li><li>2、将项目中所有的Activity继承BaseActivity，将页面打开和关闭的逻辑添加在BaseActivity，这样做比1要好一些。但是这种方法对于第三方依赖库中的界面就无法添加。</li></ul><p>这时有一种更加优雅的处理方式：<strong>编译插桩</strong>。</p><h1 id="1-编译插桩是什么"><a href="#1-编译插桩是什么" class="headerlink" title="1. 编译插桩是什么"></a>1. 编译插桩是什么</h1><p>编译插桩就是在代码编译期间修改已有的代码或者生成新的代码。实际上，项目中用到的Dagger、ButterKnife甚至是Kotlin语言，都用到了编译插桩技术。</p><p>Android项目中.java文件的编译过程：</p><img src="/2020/06/25/（拉钩）Android工程师进阶34讲-04：编译插桩操纵字节码，实现不可能完成的任务/Android中.java文件编译过程.png"><p>从上图可以看出，在1、2两处对代码进行改造。</p><ul><li>1、在.java文件编译成.class文件时，ART、AndroidAnnotation等就是在此处触发代码生成。</li><li>2、在.class文件进一步优化成.dex文件时，也就是直接操作字节码文件，也是本节的内容。这种方式功能更加强大，应用场景也更多。但是门槛比较高，需要对字节码有一定理解。</li></ul><p>本节主要介绍第2种实现方式，用一张图描述如下过程，其中红色虚框包含了本节的所有内容。</p><img src="/2020/06/25/（拉钩）Android工程师进阶34讲-04：编译插桩操纵字节码，实现不可能完成的任务/修改.class文件.png"><p>一般情况下，经常会使用编译插桩实现如下几种功能：</p><ul><li>日志埋点；</li><li>性能监控；</li><li>动态权限控制；</li><li>业务逻辑跳转时，校验是否已经登录；</li><li>甚至是代码调试等。</li></ul><h1 id="2-插桩工具介绍"><a href="#2-插桩工具介绍" class="headerlink" title="2. 插桩工具介绍"></a>2. 插桩工具介绍</h1><p>目前主要流行两种实现编译插桩的方式：</p><ul><li><strong>AspectJ</strong>：AspectJ是老牌的AOP(Aspect-Oriented Programming)框架，如果做过J2EE可能会对这个框架更熟悉，经常拿这个框架和Spring AOP进行比较。其主要优势是成熟稳定，使用者也不需要对字节码有深入的理解。</li><li><strong>ASM</strong>：通过ASM可以修改现有的字节码文件，也可以动态生成字节码文件，并且它是一款完全以字节码层面来操纵字节码并分析字节码的框架。</li></ul><p>举例，在Java中实现两个数相加操作，可以如下实现：</p><img src="/2020/06/25/（拉钩）Android工程师进阶34讲-04：编译插桩操纵字节码，实现不可能完成的任务/相加.png"><p>如果直接使用ASM直接编写字节码指令，则有可能是如下几个字节码指令：</p><img src="/2020/06/25/（拉钩）Android工程师进阶34讲-04：编译插桩操纵字节码，实现不可能完成的任务/ASM编写字节码指令.png"><p>有工具可以帮助实现这些字节码指令。</p><p>本节就是使用ASM来实现简单的编译插桩效果，通过插桩实现最开始提出的需求，在每个Activity打开时输出相应的log日志。</p><h1 id="3-实现思路"><a href="#3-实现思路" class="headerlink" title="3. 实现思路"></a>3. 实现思路</h1><p>主要包含两步：</p><ul><li>1、<strong>遍历项目中所有的.class文件</strong>：如何找到项目中编译生成的所有.class文件，是需要解决的第一个问题。众所周知，Android Studio使用Gradle编译项目中的.java文件，并且从Gradle 1.5.0之后，可以自定义<code>Transform</code>，来获取所有.class文件引用。但是<code>Transform</code>的使用需要依赖Gradle Plugin。<strong>因此第一步需要创建一个单独的Gradle Plugin，并在Gradle Plugin中使用自定义<code>Transform</code>找出所有的.class文件</strong>。</li><li>2、<strong>遍历到目标.class文件(Activity)之后，通过ASM动态注入需要被插桩的字节码</strong>：第一步找到所有的.class文件，<strong>接下来就是过滤出目标Activity文件，并在目标Activity文件的<code>onCreate</code>方法中，通过ASM插入相应的log日志字节码</strong>。</li></ul><h1 id="4-具体实现"><a href="#4-具体实现" class="headerlink" title="4. 具体实现"></a>4. 具体实现</h1><h2 id="4-1-创建ASMLifeCycleDemo项目"><a href="#4-1-创建ASMLifeCycleDemo项目" class="headerlink" title="4.1 创建ASMLifeCycleDemo项目"></a>4.1 创建ASMLifeCycleDemo项目</h2><p>创建ASMLifeCycleDemo项目：</p><img src="/2020/06/25/（拉钩）Android工程师进阶34讲-04：编译插桩操纵字节码，实现不可能完成的任务/创建ASMLifeCycleDemo项目.png"><h2 id="4-2-创建自定义Gradle插件"><a href="#4-2-创建自定义Gradle插件" class="headerlink" title="4.2 创建自定义Gradle插件"></a>4.2 创建自定义Gradle插件</h2><p>首先在ASMLifeCycleDemo项目中创建一个新的module，并选择Android Library类型，命名为asm_lifecyle_plugin。</p><p>并将asm_lifecyle_plugin中除了build.gradle和main文件夹之外的所有内容都删除。然后在main目录下分别创建groovy和java目录。</p><img src="/2020/06/25/（拉钩）Android工程师进阶34讲-04：编译插桩操纵字节码，实现不可能完成的任务/创建groovy和java目录.png"><p>因为Gradle插件是使用Groovy编写的，所以需要创建一个groovy目录，用来存放插件相关的.groovy类。但是ASM是java层面的框架，所以在java目录里存放ASM相关的类。</p><p>然后，在groovy中创建目录tyler.liu.plugin，并在此目录中创建类<code>LifeCyclePlugin.groovy</code>文件。在<code>LifeCyclePlugin</code>中重写<code>apply</code>方法，实现插件逻辑，这里只是简单打印。</p><img src="/2020/06/25/（拉钩）Android工程师进阶34讲-04：编译插桩操纵字节码，实现不可能完成的任务/LifeCyclePlugin.png"><p>可以看出<code>LifeCyclePlugin</code>实现了gradle api中的<code>Plugin</code>接口。当在build.gradle文件中使用此插件时，其<code>LifeCyclePlugin</code>的<code>apply</code>方法将会被自动调用。</p><p>下面将asm_lifecycle_plugin中的build.gradle的内容全部删掉，换成如下内容：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">'groovy'</span></span><br><span class="line">apply plugin: <span class="string">'maven'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    implementation <span class="keyword">fileTree</span>(dir: <span class="string">'libs'</span>, <span class="keyword">includes</span>: [<span class="string">'*.jar'</span>])</span><br><span class="line"></span><br><span class="line">    implementation gradleApi()</span><br><span class="line">    implementation localGroovy()</span><br><span class="line"></span><br><span class="line">    implementation <span class="string">'com.android.tools.build:gradle:3.4.2'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">group</span> = <span class="string">'tyler.lifecycle.plugin'</span></span><br><span class="line">version = <span class="string">'1.0.0'</span></span><br><span class="line"></span><br><span class="line">uploadArchives &#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        mavenDeployer &#123;</span><br><span class="line">            <span class="comment">// 本地的Maven地址配置</span></span><br><span class="line">            repository(url: uri(<span class="string">'../asm_lifecycle_repo'</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>group</code>和<code>version</code>都需要在app mudule引用此插件时使用。</p><p>所有的插件都需要被部署到maven库中，可以选择部署到远程或本地。这里只是演示，所以只是将插件部署到本地目录中。具体地址通过<code>repository</code>属性设置，这里将其配置在项目根目录下的<code>asm_lifecycle_repo</code>目录下。</p><p>最后一步，创建properties文件。</p><p>在plugin/src/main目录下新建目录resources/META-INF/gradle-plugins，然后在此目录下新建文件：tyler.asm.lifecycle.properties，其中文件名tyler.asm.lifecycle就是自定义插件的名称，后面在app module中会使用到。</p><p>在.properties文件中，需要指定自定义的插件类名LifeCyclePlugin，如下：</p><img src="/2020/06/25/（拉钩）Android工程师进阶34讲-04：编译插桩操纵字节码，实现不可能完成的任务/properties文件.png"><p>至此，自定义Gradle插件就已经写完，现在在Android Studio右栏找到Gradle中点击uploadArchives，执行plugin的部署任务。</p><img src="/2020/06/25/（拉钩）Android工程师进阶34讲-04：编译插桩操纵字节码，实现不可能完成的任务/部署plugin.png"><p>构建成功后，在Project的根目录下将会出现一个repo目录，里面存放的就是插件目标文件。</p><h2 id="4-3-测试asm-lifecycle-plugin"><a href="#4-3-测试asm-lifecycle-plugin" class="headerlink" title="4.3 测试asm_lifecycle_plugin"></a>4.3 测试asm_lifecycle_plugin</h2><p>在app module的build.gradle引用此插件。</p><img src="/2020/06/25/（拉钩）Android工程师进阶34讲-04：编译插桩操纵字节码，实现不可能完成的任务/添加插件.png"><ul><li>1、在自定义Gradle插件中properties的文件名(tyler.asm.lifecycle)。</li><li>2、<code>dependencies</code>中的<code>classpath</code>是<code>group</code>值 + module名 + version。</li></ul><p>然后在执行命令行中使用gradlew执行构建命令，如果打印出插件里的log，说明自定义插件可以使用：</p><img src="/2020/06/25/（拉钩）Android工程师进阶34讲-04：编译插桩操纵字节码，实现不可能完成的任务/命令测试插件.png"><blockquote><p>也有比较成熟的第三方Gradle插件，如hiBever。</p></blockquote><h2 id="4-4-自定义Transform，实现遍历-class文件"><a href="#4-4-自定义Transform，实现遍历-class文件" class="headerlink" title="4.4 自定义Transform，实现遍历.class文件"></a>4.4 自定义Transform，实现遍历.class文件</h2><p>自定义Gradle插件已经写好，接下来就需要实现遍历所有.class的逻辑。这部分主要依赖Transform API。</p><h3 id="4-4-1-什么是Transform？"><a href="#4-4-1-什么是Transform？" class="headerlink" title="4.4.1 什么是Transform？"></a>4.4.1 什么是Transform？</h3><p>Transform可以被看做是Gradle在编译项目时的一个task，在.class文件转换成.dex的流程中会执行这些Task，对所有.class文件（可包含第三方库的.class）进行转换，转换的逻辑定义在Transform的<code>transform</code>方法中。实际上平时在build.gradle中常用的功能都是通过Transform实现的，比如混淆(proguard)、分包(multi-dex)、jar包合并(jarMerge)。</p><h4 id="4-4-2-自定义Transform"><a href="#4-4-2-自定义Transform" class="headerlink" title="4.4.2 自定义Transform"></a>4.4.2 自定义Transform</h4><p>在tyler.liu.plugin目录中，新建<code>LifeCycleTransform.groovy</code>，继承<code>Transform</code>类，并需要实现里面的方法。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tyler.liu.plugin</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.android.build.api.transform.QualifiedContent</span><br><span class="line"><span class="keyword">import</span> com.android.build.api.transform.Transform</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifeCycleTransform</span> <span class="keyword">extends</span> <span class="title">Transform</span> &#123;</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    String getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Set&lt;QualifiedContent.ContentType&gt; getInputTypes() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Set&lt;? super QualifiedContent.Scope&gt; getScopes() &#123;</span><br><span class="line">        return null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    boolean isIncremental() &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void transform(TransformInvocation transformInvocation) throws TransformException, InterruptedException, IOException &#123;</span><br><span class="line">        super.transform(transformInvocation)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Transform</code>的主要作用是检索项目编译过程中的所有文件。通过这几个方法，可以对自定义Transform设置一些遍历规则，具体如下：</p><ul><li><p><strong><code>getName()</code></strong>：设置自定义的<code>Transform</code>对应的Task名称。Gradle在编译的时候，会将这个名称显示在控制台上。比如：<code>app:transformClassesWithXXXForDebug</code>。</p></li><li><p><strong><code>getInputTypes()</code></strong>：在项目中会有各种各样格式的文件，通过<code>getInputType()</code>可以设置<code>LifeCycleTransform</code>接收的文件类型，此方法的返回值类型是<code>Set&lt;QualifiedContent.ContentType&gt;</code>。</p><p>  <code>ContentType</code>有以下两种取值：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The type of of the content.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> DefaultContentType implements ContentType &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The content is compiled Java code. This can be in a Jar file or in a folder. If</span></span><br><span class="line"><span class="comment">     * in a folder, it is expected to in sub-folders matching package names.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CLASSES(<span class="number">0x01</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The content is standard Java resources. */</span></span><br><span class="line">    RESOURCES(<span class="number">0x02</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    DefaultContentType(<span class="keyword">int</span> value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>CLASSES</code>：表示只检索.class文件。</li><li><code>RESOURCES</code>：表示检索java标准资源文件。</li></ul></li><li><p><strong><code>getScopes()</code></strong>：这个方法规定自定义<code>Transform</code>检索的范围。<br>  有以下取值：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PROJECT                 // 只有项目内容</span><br><span class="line">SUB_PROJECTS            // 只有子项目</span><br><span class="line">EXTERNAL_LIBRARIES      // 只有外部库</span><br><span class="line">TESTED_CODE             // 由当前变量（包括依赖项）测试的代码</span><br><span class="line">PROVIDED_ONLY           // 只提供本地或远程依赖项</span><br><span class="line">PROJECT_LOCAL_DEPS      // 只有项目的本地依赖（本地jar）</span><br><span class="line">SUB_PROJECTS_LOCAL_DEPS // 只有子项目的本地依赖项（本地jar）</span><br></pre></td></tr></table></figure></li><li><p><strong><code>isIncremental</code></strong>：表示当前<code>Transform</code>是否支持增量编译，不需要增量编译，就直接返回<code>false</code>。</p></li><li><p><strong><code>transform()</code></strong>：在自定义<code>Transform</code>中最重要的方法。在这个方法中可以获取两个数据的流向。</p><ul><li><code>inputs</code>：<code>inputs</code>中传过来的输入流，其中有两种格式，一种是jar包格式，一种是directory（目录格式）。</li><li><code>outputProvider</code>：<code>outputProvider</code>获取到输出目录，最后将修改的文件复制到输出目录，这一步必须做，否则编译报错。</li></ul></li></ul><p>下面实现了一个简单的<code>LifeCycleTransform</code>，功能是打印出所有.class文件。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tyler.liu.plugin</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.android.build.api.transform.DirectoryInput</span><br><span class="line"><span class="keyword">import</span> com.android.build.api.transform.QualifiedContent</span><br><span class="line"><span class="keyword">import</span> com.android.build.api.transform.Transform</span><br><span class="line"><span class="keyword">import</span> com.android.build.api.transform.TransformException</span><br><span class="line"><span class="keyword">import</span> com.android.build.api.transform.TransformInput</span><br><span class="line"><span class="keyword">import</span> com.android.build.api.transform.TransformInvocation</span><br><span class="line"><span class="keyword">import</span> com.android.build.gradle.internal.pipeline.TransformManager</span><br><span class="line"><span class="keyword">import</span> groovy.io.FileType</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifeCycleTransform</span> <span class="keyword">extends</span> <span class="title">Transform</span> &#123;</span></span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    String getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"LifeCycleTransform"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Set&lt;QualifiedContent.ContentType&gt; getInputTypes() &#123;</span><br><span class="line">        <span class="keyword">return</span> TransformManager.CONTENT_CLASS</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Set&lt;? super QualifiedContent.Scope&gt; getScopes() &#123;</span><br><span class="line">        return TransformManager.PROJECT_ONLY</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    boolean isIncremental() &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 4</span><br><span class="line">    @Override</span><br><span class="line">    void transform(TransformInvocation transformInvocation) throws TransformException, InterruptedException, IOException &#123;</span><br><span class="line">        // 拿到所有的class文件</span><br><span class="line">        Collection&lt;TransformInput&gt; transformInputs = transformInvocation.inputs</span><br><span class="line">        transformInputs.each &#123; TransformInput transformInput -&gt;</span><br><span class="line">            // directoryInputs代表以源码方式参与项目编译的所有目录结构及其目录下的源码文件</span><br><span class="line">            // 比如手写的类以及R.class、BuildConfig.class以及MainActivity.class等</span><br><span class="line">            transformInput.directoryInputs.each &#123; DirectoryInput directoryInput -&gt;</span><br><span class="line">                File dir = directoryInput.file</span><br><span class="line">                if (dir) &#123;</span><br><span class="line">                    dir.traverse(type: FileType.FILES, <span class="string">nameFilter:</span> <span class="regexp">~/.*\.class/</span>) &#123; File file -&gt;</span><br><span class="line">                        System.out.println(<span class="string">"find class: "</span> + file.name)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1、自定义的<code>Transform</code>的名称为<code>LifeCycleTransform</code>。</li><li>2、检索项目中的.class类型的目录或者文件。</li><li>3、设置当前<code>Transform</code>检索范围为当前项目。</li><li>4、设置过滤文件为.class文件（去除文件夹类型），并打印文件名称。</li></ul><h3 id="4-4-2-将自定义的LifeCycleTransform注册到Gradle插件中"><a href="#4-4-2-将自定义的LifeCycleTransform注册到Gradle插件中" class="headerlink" title="4.4.2  将自定义的LifeCycleTransform注册到Gradle插件中"></a>4.4.2  将自定义的LifeCycleTransform注册到Gradle插件中</h3><p>在<code>LifeCyclePlugin</code>中添加如下代码：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifeCyclePlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; &#123;</span></span><br><span class="line">    <span class="keyword">void</span> apply(Project project) &#123;</span><br><span class="line">        System.out.println(<span class="string">"==LifeCyclePlugin gradle plugin=="</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> android = project.extensions.getByType(AppExtension)</span><br><span class="line">        println <span class="string">'------------- registering AutoTrackTransform -------------'</span></span><br><span class="line">        LifeCycleTransform transform = <span class="keyword">new</span> LifeCycleTransform()</span><br><span class="line">        android.registerTransform(transform)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次执行build，可以看到<code>LifeCycleTransform</code>检索出的所有.class文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">Executing tasks: [clean, :app:assembleDebug] in project E:\Project\MyStudyDemo\ASMLifeCycleDemo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; Configure project :app</span><br><span class="line">==LifeCyclePlugin gradle plugin==</span><br><span class="line">------------- registering AutoTrackTransform -------------</span><br><span class="line"></span><br><span class="line">&gt; Task :clean</span><br><span class="line">&gt; Task :app:clean UP-TO-DATE</span><br><span class="line">&gt; Task :asm_lifecycle_plugin:clean UP-TO-DATE</span><br><span class="line">&gt; Task :app:preBuild UP-TO-DATE</span><br><span class="line">&gt; Task :app:preDebugBuild UP-TO-DATE</span><br><span class="line">&gt; Task :app:generateDebugBuildConfig</span><br><span class="line">&gt; Task :app:compileDebugAidl NO-SOURCE</span><br><span class="line">&gt; Task :app:compileDebugRenderscript NO-SOURCE</span><br><span class="line">&gt; Task :app:javaPreCompileDebug</span><br><span class="line">&gt; Task :app:generateDebugResValues</span><br><span class="line">&gt; Task :app:generateDebugResources</span><br><span class="line">&gt; Task :app:createDebugCompatibleScreenManifests</span><br><span class="line">&gt; Task :app:extractDeepLinksDebug</span><br><span class="line">&gt; Task :app:processDebugManifest</span><br><span class="line">&gt; Task :app:mergeDebugResources</span><br><span class="line">&gt; Task :app:processDebugResources</span><br><span class="line">&gt; Task :app:compileDebugJavaWithJavac</span><br><span class="line">&gt; Task :app:compileDebugSources</span><br><span class="line">&gt; Task :app:mergeDebugShaders</span><br><span class="line">&gt; Task :app:compileDebugShaders NO-SOURCE</span><br><span class="line">&gt; Task :app:generateDebugAssets UP-TO-DATE</span><br><span class="line">&gt; Task :app:mergeDebugAssets</span><br><span class="line">&gt; Task :app:processDebugJavaRes NO-SOURCE</span><br><span class="line"></span><br><span class="line">&gt; Task :app:transformClassesWithLifeCycleTransformForDebug</span><br><span class="line">find class: BuildConfig.class</span><br><span class="line">find class: MainActivity.class</span><br><span class="line"></span><br><span class="line">&gt; Task :app:checkDebugDuplicateClasses</span><br><span class="line">&gt; Task :app:dexBuilderDebug</span><br><span class="line">&gt; Task :app:mergeDebugJavaResource</span><br><span class="line">&gt; Task :app:mergeDebugJniLibFolders</span><br><span class="line">&gt; Task :app:validateSigningDebug</span><br><span class="line">&gt; Task :app:mergeExtDexDebug</span><br><span class="line">&gt; Task :app:mergeDebugNativeLibs</span><br><span class="line">&gt; Task :app:stripDebugDebugSymbols NO-SOURCE</span><br><span class="line">&gt; Task :app:mergeDexDebug</span><br><span class="line">&gt; Task :app:packageDebug</span><br><span class="line">&gt; Task :app:assembleDebug</span><br><span class="line"></span><br><span class="line">Deprecated Gradle features were used in this build, making it incompatible with Gradle 7.0.</span><br><span class="line">Use &apos;--warning-mode all&apos; to show the individual deprecation warnings.</span><br><span class="line">See https://docs.gradle.org/6.1.1/userguide/command_line_interface.html#sec:command_line_warnings</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL in 5s</span><br><span class="line">24 actionable tasks: 22 executed, 2 up-to-date</span><br><span class="line"></span><br><span class="line">Build Analyzer results available</span><br></pre></td></tr></table></figure><p>可以看到，Gradle编译时，多了一个自定义的<code>LifeCycleTransform</code>类型的任务，并且将所有.class文件打印出来，其中包含目标文件MainActivity.class。</p><h2 id="4-5-使用ASM，插入字节码到Activity中"><a href="#4-5-使用ASM，插入字节码到Activity中" class="headerlink" title="4.5 使用ASM，插入字节码到Activity中"></a>4.5 使用ASM，插入字节码到Activity中</h2><p>ASM是一套开源框架，其中几个常见的API如下：</p><ul><li><code>ClassReader</code>：负责解析.class文件中的字节码，并将所有字节码传递给<code>ClassWriter</code>。</li><li><code>ClassVisitor</code>：负责访问.class文件中的各个元素，<code>ClassVisitor</code>就是用来解析上节说到的.class文件结构，当解析到某些特定结构时（比如类变量、方法），它会自动调用内部相应的<code>FieldVisitor</code>和<code>MethodVisitor</code>的方法，进一步解析或修改.class文件内容。</li><li><code>ClassWriter</code>：继承自<code>ClassVisitor</code>，它是生成字节码的工具类，负责将修改后的字节码输出为byte数组。</li></ul><h3 id="4-5-1-添加ASM依赖"><a href="#4-5-1-添加ASM依赖" class="headerlink" title="4.5.1 添加ASM依赖"></a>4.5.1 添加ASM依赖</h3><p>在<code>asm_lifecycle_pligun</code>的build.gradle中，添加ASM的依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">    // ASM依赖</span><br><span class="line">    implementation &quot;org.ow2.asm:asm:7.1&quot;</span><br><span class="line">    implementation &quot;org.ow2.asm:asm-commons:7.1&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-2-创建自定义ASM-Visitor类"><a href="#4-5-2-创建自定义ASM-Visitor类" class="headerlink" title="4.5.2 创建自定义ASM Visitor类"></a>4.5.2 创建自定义ASM Visitor类</h3><p>在<code>asm_lifecycle_plugin</code>中的src/main/java目录下创建包tyler.liu.asm，并分别创建<code>LifeCycleClassVisitor.java</code>和<code>LifeCycleMethodVisitor.java</code>。</p><p><strong><code>LifeCycleClassVisitor.java</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tyler.liu.asm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.ClassVisitor;</span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.MethodVisitor;</span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.Opcodes;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Liuyang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/6/29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifecycleClassVisitor</span> <span class="keyword">extends</span> <span class="title">ClassVisitor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line">    <span class="keyword">private</span> String superName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LifecycleClassVisitor</span><span class="params">(ClassVisitor classVisitor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(Opcodes.ASM5, classVisitor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">int</span> version, <span class="keyword">int</span> access, String name, String signature, String superName, String[] interfaces)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.visit(version, access, name, signature, superName, interfaces);</span><br><span class="line">        <span class="keyword">this</span>.className = className;</span><br><span class="line">        <span class="keyword">this</span>.superName = superName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MethodVisitor <span class="title">visitMethod</span><span class="params">(<span class="keyword">int</span> access, String name, String descriptor, String signature, String[] exceptions)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ClassVisitor visitMethod name -----"</span> + name + <span class="string">", superName is"</span> + superName);</span><br><span class="line">        MethodVisitor mv = cv.visitMethod(access, name, descriptor, signature, exceptions);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"android/support/v7/app/AppCompatActivity"</span>.equals(superName)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (name.startsWith(<span class="string">"onCreate"</span>)) &#123;</span><br><span class="line">                <span class="comment">// 处理onCreate方法</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> LifeCycleMethodVisitor(mv, className, name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.visitEnd();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>&quot;android/support/v7/app/AppCompatActivity&quot;.equals(superName)</code>，用来过滤出继承<code>AppCompatActivity</code>的文件，并在<code>LifeCycleMethodVisitor.java</code>中对<code>onCreate</code>进行改造。</p><p><strong><code>LifeCycleMethodVisitor.java</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tyler.liu.asm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.MethodVisitor;</span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.Opcodes;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Liuyang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/6/29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifeCycleMethodVisitor</span> <span class="keyword">extends</span> <span class="title">MethodVisitor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LifeCycleMethodVisitor</span><span class="params">(MethodVisitor methodVisitor, String className, String methodName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(Opcodes.ASM5, methodVisitor);</span><br><span class="line">        <span class="keyword">this</span>.className = className;</span><br><span class="line">        <span class="keyword">this</span>.methodName = methodName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法执行前插入</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.visitCode();</span><br><span class="line">        System.out.println(<span class="string">"MethodVisitor visitCode ----------------"</span>);</span><br><span class="line"></span><br><span class="line">        mv.visitLdcInsn(<span class="string">"TAG"</span>);</span><br><span class="line">        mv.visitLdcInsn(className + <span class="string">"-----&gt;"</span> + methodName);</span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKESTATIC, <span class="string">"android/util/Log"</span>, <span class="string">"i"</span>, <span class="string">"(Ljava/lang/String;Ljava/lang/String;)I"</span>, <span class="keyword">false</span>);</span><br><span class="line">        mv.visitInsn(Opcodes.POP);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>visitCode()</code>中，是真正执行插入字节码的逻辑。可以看出ASM都是直接以字节码指令的方式进行操作的，所以如果想使用ASM，需要对字节码由一定了解。如果对字节码不是很了解，也可以使用第三方工具ASM ByteCode Outline来生成想要的字节码。</p><h2 id="4-5-3-修改LifeCycleTransform的tranform方法，使用ASM"><a href="#4-5-3-修改LifeCycleTransform的tranform方法，使用ASM" class="headerlink" title="4.5.3 修改LifeCycleTransform的tranform方法，使用ASM"></a>4.5.3 修改LifeCycleTransform的tranform方法，使用ASM</h2><p>各种Visitor定义好之后，就可以修改<code>LifeCycleTransform</code>的<code>transform</code>方法，并将需要插桩的字节码插入到<code>MainActivity.class</code>文件中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tyler.liu.plugin</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.android.build.api.transform.*</span><br><span class="line"><span class="keyword">import</span> com.android.build.gradle.internal.pipeline.TransformManager</span><br><span class="line"><span class="keyword">import</span> com.android.utils.FileUtils</span><br><span class="line"><span class="keyword">import</span> groovy.io.FileType</span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.ClassReader</span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.ClassVisitor</span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.ClassWriter</span><br><span class="line"><span class="keyword">import</span> tyler.liu.asm.LifecycleClassVisitor</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifeCycleTransform</span> <span class="keyword">extends</span> <span class="title">Transform</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"LifeCycleTransform"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Set&lt;QualifiedContent.ContentType&gt; getInputTypes() &#123;</span><br><span class="line">        <span class="keyword">return</span> TransformManager.CONTENT_CLASS</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Set&lt;? <span class="keyword">super</span> QualifiedContent.Scope&gt; getScopes() &#123;</span><br><span class="line">        <span class="keyword">return</span> TransformManager.PROJECT_ONLY</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isIncremental</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transform</span><span class="params">(TransformInvocation transformInvocation)</span> <span class="keyword">throws</span> TransformException, InterruptedException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 拿到所有的class文件</span></span><br><span class="line">        Collection&lt;TransformInput&gt; transformInputs = transformInvocation.inputs</span><br><span class="line">        TransformOutputProvider outputProvider = transformInvocation.outputProvider</span><br><span class="line"></span><br><span class="line">        transformInputs.each &#123; TransformInput transformInput -&gt;</span><br><span class="line">            <span class="comment">// directoryInputs代表以源码方式参与项目编译的所有目录结构及其目录下的源码文件</span></span><br><span class="line">            <span class="comment">// 比如手写的类以及R.class、BuildConfig.class以及MainActivity.class等</span></span><br><span class="line">            transformInput.directoryInputs.each &#123; DirectoryInput directoryInput -&gt;</span><br><span class="line">                File dir = directoryInput.file</span><br><span class="line">                <span class="keyword">if</span> (dir) &#123;</span><br><span class="line">                    dir.traverse(type: FileType.FILES, nameFilter: ~/.*\.class/) &#123; File file -&gt;</span><br><span class="line">                        System.out.println(<span class="string">"find class: "</span> + file.name)</span><br><span class="line">                        <span class="comment">// 对class文件进行读取和解析</span></span><br><span class="line">                        ClassReader classReader = <span class="keyword">new</span> ClassReader(file.bytes)</span><br><span class="line">                        <span class="comment">// 对class文件的写入</span></span><br><span class="line">                        ClassWriter classWriter = <span class="keyword">new</span> ClassWriter(classReader, ClassWriter.COMPUTE_MAXS)</span><br><span class="line">                        <span class="comment">// 访问class文件相应的内容，解析到某一个结构就会通知到ClassVisitor的相应方法</span></span><br><span class="line">                        ClassVisitor classVisitor = <span class="keyword">new</span> LifecycleClassVisitor(classWriter)</span><br><span class="line">                        <span class="comment">// 依次调用ClassVisitor接口的各个方法</span></span><br><span class="line">                        classReader.accept(classVisitor, ClassReader.EXPAND_FRAMES)</span><br><span class="line">                        <span class="comment">// toByteArray方法会将最终修改的字节码以byte数组形式返回</span></span><br><span class="line">                        <span class="keyword">byte</span>[] bytes = classWriter.toByteArray()</span><br><span class="line">                        <span class="comment">// 通过文件流写入方式覆盖掉原先的内容，实现class文件的改写</span></span><br><span class="line">                        FileOutputStream outputStream = <span class="keyword">new</span> FileOutputStream(file.path)</span><br><span class="line">                        outputStream.write(<span class="keyword">byte</span>)</span><br><span class="line">                        outputStream.close()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 处理完传输文件后，把输出传给下一个文件</span></span><br><span class="line">                def dest = outputProvider.getContentLocation(directoryInput.name, directoryInput.contentTypes,</span><br><span class="line">                        directoryInput.scopes, Format.DIRECTORY)</span><br><span class="line">                FileUtils.copyDirectory(directoryInput.file, dest)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-4-重新部署自定义Gradle插件，并运行主项目"><a href="#4-5-4-重新部署自定义Gradle插件，并运行主项目" class="headerlink" title="4.5.4 重新部署自定义Gradle插件，并运行主项目"></a>4.5.4 重新部署自定义Gradle插件，并运行主项目</h3><p>重新点击uploadAtchives重新部署LifeCyclePlugin。</p><p>部署成功后，重新运行APP主项目，当MainActivity被打开时，会在logcat看到如下日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2020-06-30 10:00:10.333 5421-5421/com.ly.asmlifecycledemo I/TAG: com/ly/asmlifecycledemo/MainActivity----&gt;onCreate</span><br></pre></td></tr></table></figure><p>如果后续有新的Activity，如<code>BActivity.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ly.asmlifecycledemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Liuyang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/6/30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并在<code>MainActivity</code>中实现点击按钮跳转到<code>BActivity</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        Button btn = findViewById(R.id.btn);</span><br><span class="line">        btn.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                startActivity(<span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, BActivity.class));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印日志如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2020-06-30 10:13:21.105 5647-5647/com.ly.asmlifecycledemo I/TAG: com/ly/asmlifecycledemo/MainActivity----&gt;onCreate</span><br><span class="line">2020-06-30 10:13:31.546 5647-5647/com.ly.asmlifecycledemo I/TAG: com/ly/asmlifecycledemo/BActivity----&gt;onCreate</span><br></pre></td></tr></table></figure><blockquote><p><strong>如果在项目中打开混淆，注入的字节码还能正常工作吗？混淆其实也是一个<code>Transform</code>，叫做<code>ProguardTransform</code>，它是在自定义的<code>Transform</code>之后执行。</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0. 前言&quot;&gt;&lt;/a&gt;0. 前言&lt;/h1&gt;&lt;p&gt;前面介绍了Java字节码文件的格式，并通过一个Demo手动模拟了JVM解析class文件的过程。&lt;/p&gt;
&lt;p&gt;本节看看
      
    
    </summary>
    
      <category term="Android" scheme="https://tylerLiu.top/categories/Android/"/>
    
      <category term="进阶" scheme="https://tylerLiu.top/categories/Android/%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="JVM与DVM必知必会" scheme="https://tylerLiu.top/tags/JVM%E4%B8%8EDVM%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"/>
    
  </entry>
  
  <entry>
    <title>（拉钩）Android工程师进阶34讲-03：字节码层面分析class类文件结构</title>
    <link href="https://tylerLiu.top/2020/06/21/%EF%BC%88%E6%8B%89%E9%92%A9%EF%BC%89Android%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BF%9B%E9%98%B634%E8%AE%B2-03%EF%BC%9A%E5%AD%97%E8%8A%82%E7%A0%81%E5%B1%82%E9%9D%A2%E5%88%86%E6%9E%90class%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <id>https://tylerLiu.top/2020/06/21/（拉钩）Android工程师进阶34讲-03：字节码层面分析class类文件结构/</id>
    <published>2020-06-21T01:47:24.000Z</published>
    <updated>2020-06-25T06:35:14.989Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h1><blockquote><p>面试题：Java中String字符串的长度有限制吗？</p></blockquote><p>平时开发中，经常会用到<code>String</code>来声明字符串，比如<code>String str = &quot;abc&quot;;</code>，但是有没有想过等于号后面的字符串常量有没有长度限制。要想知道这个，就需要先学习class文件。</p><h1 id="1-class的来龙去脉"><a href="#1-class的来龙去脉" class="headerlink" title="1. class的来龙去脉"></a>1. class的来龙去脉</h1><p>Java能实现“一次编译，到处运行”，这其中class文件占大部分功劳。为了让Java语言有良好的跨平台能力，Java提供了一种可以在所有平台上都能使用的一种中间代码——<strong>字节码类文件（.class文件）</strong>。有了字节码，无论哪种平台（如：Mac、Windows、Linux等），只要安装了虚拟机都可以直接运行代码。</p><p>并且，<strong>有了字节码，也解除了Java虚拟机和Java语言之间的耦合</strong>。</p><p>Java虚拟机当初被设计出来目的不单单只是运行Java一种语言。目前Java虚拟机可以支持很多除Java语言之外的其他语言了，如Groovy、JRuby、Jython、Scala等。之所以可以支持其他语言，是因为这些语言经过编译之后能够被JVM解析并执行的字节码文件。而虚拟机并不关心字节码是由哪种语言编译而来的。如下图：</p><img src="/2020/06/21/（拉钩）Android工程师进阶34讲-03：字节码层面分析class类文件结构/class来龙去脉.png"><h1 id="2-上帝视角看class文件"><a href="#2-上帝视角看class文件" class="headerlink" title="2. 上帝视角看class文件"></a>2. 上帝视角看class文件</h1><p>如果从纵观的角度来看class文件，class文件里只有两种数据结构：<strong>无符号数</strong>和<strong>表</strong>。</p><ul><li><strong>无符号数</strong>：属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用，、数量值或者字符串（UTF-8编码）。</li><li><strong>表</strong>：表是由多个无符号数或者其他表作为数据项构成的复合数据类型，<strong>class文件中所有的表都以“_info”结尾</strong>。其实，整个class文件本质上就是一张表。</li></ul><p>这二者之间的关系可以用下面这张图表示：</p><img src="/2020/06/21/（拉钩）Android工程师进阶34讲-03：字节码层面分析class类文件结构/表和符号之间的关系.png"><p>可以看出，在一张表中可以包含其他无符号数和其他表格。伪代码可以如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 无符号数</span><br><span class="line">u1 = byte[1];</span><br><span class="line">u2 = byte[2];</span><br><span class="line">u4 = byte[4];</span><br><span class="line">u8 = byte[8];</span><br><span class="line"></span><br><span class="line">// 表</span><br><span class="line">class_table &#123;</span><br><span class="line">    // 表中可以引用各种无符号数，</span><br><span class="line">    u1 tag;</span><br><span class="line">    u2 index2;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // 表中也可以引用其它表</span><br><span class="line">    method_table mt;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-class文件结构"><a href="#3-class文件结构" class="headerlink" title="3. class文件结构"></a>3. class文件结构</h1><p>刚才说了class文件只存在无符号数和表这两种数据结构。而这些无符号数和表就组成了class中的各个结构。这些结构按照<strong>预先规定好的顺序</strong>紧密的从前向后排列，相邻的项之间没有任何缝隙。如下图：</p><img src="/2020/06/21/（拉钩）Android工程师进阶34讲-03：字节码层面分析class类文件结构/class文件结构1.png"><p>当JVM加载某个class文件时，JVM就是根据上图中的结构去解析class文件的，加载class文件到内存中，并在内存中分配相应的空间。具体某一种结构需要占用多大空间，如下图：</p><img src="/2020/06/21/（拉钩）Android工程师进阶34讲-03：字节码层面分析class类文件结构/class文件结构2.png"><blockquote><p>到这里可能有点概念混淆，分不清无符号数、表格以及上面的结构是什么关系。举个例子：人体由H、O、C、N等元素组成的。但这些元素又是按照一定的规律组成人体的各个器官。class文件中的无符号数和表格就相当于人体的H、O、C、N等元素，而class结构图中的各项结构就相当于人体的各个器官，并且这些器官的组织顺序是有严格顺序要求的。</p></blockquote><h1 id="4-实例分析"><a href="#4-实例分析" class="headerlink" title="4. 实例分析"></a>4. 实例分析</h1><p>理清这些概念之后，下面通过一个Java代码实例，来看一下上面这几个结构的详细情况。首先编写一个Java代码Text.java，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">10</span>;</span><br><span class="line">        num = num + i;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过javac将其编译，生成Test.class字节码文件。使用16进制编辑器打开class文件，显示内容如下：</p><img src="/2020/06/21/（拉钩）Android工程师进阶34讲-03：字节码层面分析class类文件结构/实例分析1.png"><p>上图中都是一些16进制数字，每两个字符表示一个字节。乍一看各个字符之间毫无规律，但是在JVM的视角里，这些16进制字符是按照严格的规律排列的。接下来就一步一步看看JVN是如何解析它们的。</p><h2 id="4-1-魔数-magic-number"><a href="#4-1-魔数-magic-number" class="headerlink" title="4.1 魔数(magic number)"></a>4.1 魔数(magic number)</h2><img src="/2020/06/21/（拉钩）Android工程师进阶34讲-03：字节码层面分析class类文件结构/实例分析2.png"><p>如上图所示，在class文件开头的四个字节是class文件的魔数，它是一个固定的值–0XCAFEBABE。魔数是class文件的标志，也就是说它是判断一个文件是不是class格式文件的标准。如果开头的四个字节不是0XCAFEBABE，那么说明它不是class文件，不能被JVM识别或加载。</p><h2 id="4-2-版本号"><a href="#4-2-版本号" class="headerlink" title="4.2 版本号"></a>4.2 版本号</h2><img src="/2020/06/21/（拉钩）Android工程师进阶34讲-03：字节码层面分析class类文件结构/实例分析3.png"><p>紧跟在魔数后面的四个字节代表当前class文件的版本号。前两个字节 <strong>0000</strong> 代表次版本号(minor_version)，后两个字节 <strong>0034</strong> 是主版本号(major_version)，对应的十进制值为52，也就是说当前class文件的主版本号为52，次版本号为0。所以综合版本号为52.0，也就是 <strong>jdk1.8.0</strong>。</p><h2 id="4-3-常量池（重点）"><a href="#4-3-常量池（重点）" class="headerlink" title="4.3 常量池（重点）"></a>4.3 常量池（重点）</h2><p>紧跟在版本号之后的是一个叫做常量池的表(cp_info)。在常量池中保存了类的各种相关信息，比如类的名称、父类的名称、类中的方法名、参数名称、参数类型等，这些信息都是以各种表的形式保存在常量池中。</p><p><strong>常量池中的每一项都是一个表，其项目类型共有14种，如下表所示：</strong></p><img src="/2020/06/21/（拉钩）Android工程师进阶34讲-03：字节码层面分析class类文件结构/常量池1.png"><p>可以看出，常量池中的每一项都会有一个<code>u1</code>大小的<code>tag</code>值。<code>tag</code>值是表的标识，JVM解析class文件时，通过这个值来判断当前数据结构是哪一种表。以上14种表都有自己的结构，这里不再一一介绍，就以<code>CONSTANT_Class_info</code>和<code>CONSTANT_utf8_info</code>这两张表举例说明，因为其他表也基本类似。</p><p>首先，<code>CONSTANT_Class_info</code>表的具体结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">table CONSTANT_Class_info &#123;</span><br><span class="line">    u1  tag = 7;</span><br><span class="line">    u2  name_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><code>tag</code>：占用一个字节大小。比如值为7，说明是<code>CONSTANT_Class_info</code>类型表。</li><li><code>name_index</code>：是一个索引值，可以将它理解为一个指针，指向常量池中索引为<code>name_index</code>的常量表。比如<code>name_index=2</code>，则它指向常量池中第二个常量。</li></ul><p>再来看看<code>CONSTANT_utf8_info</code>表具体结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">table CONSTANT_utf8_info &#123;</span><br><span class="line">    u1  tag;</span><br><span class="line">    u2  length;</span><br><span class="line">    u1[] bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><code>tag</code>：值为1，表示是<code>CONSTANT_utf8_info</code>类型表。</li><li><code>length</code>：表示<code>u1[]</code>的长度，比如<code>length=5</code>，表示接下来的数据是5个连续的<code>u1</code>类型数据。</li><li><code>bytes</code>：<code>u1</code>类型数组，长度为上面第二个参数<code>length</code>的值。</li></ul><p>而在Java代码中声明的<code>String</code>字符串最终在class文件的存储格式就是<code>CONSTANT_utf8_info</code>。因此字符串最大长度也就是<code>u2</code>所能代表的最大值65536个，但是需要使用2个字节来保存<code>null</code>值，因此字符串的最大长度为65536 - 2 = 65534。</p><p>不难看出，在常量池内部的表也有相互之间的引用。用一张图来理解<code>CONSTANT_Class_info</code>和<code>CONSTANT_utf8_info</code>表格之间的关系，如下图：</p><img src="/2020/06/21/（拉钩）Android工程师进阶34讲-03：字节码层面分析class类文件结构/常量池2.png"><p>理解了常量池内部的数据结构之后，接下来就看一下实例代码的解析过程。因为开发者平时定义的Java类各式各样，类中的方法与参数也不尽相同。所以常量池的元素数量也就无法固定，因此class文件在常量池的前面使用2个字节的容量计数器，来表示当前类中常量池的大小。如下图：</p><img src="/2020/06/21/（拉钩）Android工程师进阶34讲-03：字节码层面分析class类文件结构/常量池3.png"><p><strong>001d</strong> 转化成十进制就是29，也就是说常量池计数器的值为29.其中下标为0的常量被JVM留作特殊用途。因此Test.class中实际的常量池大小28个。</p><p>第一个常量，如下：</p><img src="/2020/06/21/（拉钩）Android工程师进阶34讲-03：字节码层面分析class类文件结构/常量池4.png"><p><strong>0a</strong> 转化成十进制为10，通常查看常量池14种表格图中，可以查到<code>tag=10</code>的表类型为<code>CONSTANT_Methodref_info</code>，因此常量池中的第一个常量类型为方法引用表。其结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Methodref_info &#123;</span><br><span class="line">    u1 tag = 10;</span><br><span class="line">    u2 class_index;     // 指向此方法的所属类</span><br><span class="line">    u2 name_type_index; // 指向此方法的名称和类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说在 <strong>0a</strong> 之后的两个字节指向这个方法是属于哪个类，紧接的两个字节指向这个方法的名称和类型。它们的值分别为：</p><ul><li><strong>0006</strong>：十进制为6，表示指向常量池中的第6个常量。</li><li><strong>0015</strong>：十进制为21，表示指向常量池中的第21个常量。</li></ul><p>至此，第一个常量解读完毕。紧接着就是第二个常量，如图：</p><img src="/2020/06/21/（拉钩）Android工程师进阶34讲-03：字节码层面分析class类文件结构/常量池5.png"><p><code>tag = 9</code>表示字段引用表<code>CONSTANT_Fieldref_info</code>，其结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Fieldref_info&#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u2 class_index;     // 指向此字段的所属类</span><br><span class="line">    u2 name_type_index; // 指向此字段的名称和类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>0005</strong>：指向常量池中第5个常量。</li><li><strong>0016</strong>：指向常量池中第22个常量。</li></ul><p>这里已经解析了两个常量，剩下的21个常量的解析过程也是大同小异。</p><p>实际上可以借助javap命令帮助查看class常量池中的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -v Test.class</span><br></pre></td></tr></table></figure><p>执行上述命令之后，显示结果如下：</p><img src="/2020/06/21/（拉钩）Android工程师进阶34讲-03：字节码层面分析class类文件结构/常量池6.png"><p>和刚才的分析一样，常量池中的第一个常量是<code>Methodref</code>类型，指向下标6和下标21的常量。其中下标21的常量类型为<code>NameAndType</code>，它对应的数据结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_NameAndType_info&#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u2 name_index; // 指向某字段或方法的名称字符串</span><br><span class="line">    u2 type_index; // 指向某字段或方法的类型字符串</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而下标在21的<code>NameAndType</code>的<code>name_index</code>和<code>type_index</code>分别指向了13和14，也就是<code>&lt;int&gt;</code>和<code>()V</code>。因此最终解析下来常量池的第一个常量的解析过程以及最终值如下图：</p><img src="/2020/06/21/（拉钩）Android工程师进阶34讲-03：字节码层面分析class类文件结构/常量池7.png"><p>仔细解析层层引用，最后可以看出，Test.clsss文件中常量池的第一个常量保存的是<code>Object</code>中的默认构造方法。</p><h2 id="4-4-访问标志-access-flags"><a href="#4-4-访问标志-access-flags" class="headerlink" title="4.4 访问标志(access_flags)"></a>4.4 访问标志(access_flags)</h2><p>紧跟在常量池后面的常量是访问标志，占用两个字节。</p><img src="/2020/06/21/（拉钩）Android工程师进阶34讲-03：字节码层面分析class类文件结构/访问标志1.png"><p>访问标志代表类或者接口的访问信息，比如：该class文件是类还是接口，是否被定义成<code>public</code>，是否是<code>abstract</code>，如果是类，是否被声明成<code>final</code>等。各种访问标志如下：</p><img src="/2020/06/21/（拉钩）Android工程师进阶34讲-03：字节码层面分析class类文件结构/访问标志2.png"><p>前面定义的Test.java是一个普通类，不是接口、枚举或者注解。并且被<code>public</code>修饰但是没有被声明为<code>final</code>和<code>abstract</code>，因此它所对应的<code>access_falgs</code>为 <strong>0021</strong> （0X0001 和 0X0020 相结合）。</p><h2 id="4-5-类索引、父类索引和接口索引计数器"><a href="#4-5-类索引、父类索引和接口索引计数器" class="headerlink" title="4.5 类索引、父类索引和接口索引计数器"></a>4.5 类索引、父类索引和接口索引计数器</h2><p>在访问标志后的2个字节就是<strong>类索引</strong>，类索引后的2个字节就是<strong>父类索引</strong>，父类索引后的2个字节是<strong>接口索引计数器</strong>。如下如：</p><img src="/2020/06/21/（拉钩）Android工程师进阶34讲-03：字节码层面分析class类文件结构/类索引、父类索引和接口索引计数器.png"><p>可以看出类索引指向常量池的第5个常量，父类索引指向常量池中的第6个常量，并且实现的接口个数为2个。再回顾一下常量池中的数据：</p><img src="/2020/06/21/（拉钩）Android工程师进阶34讲-03：字节码层面分析class类文件结构/类索引、父类索引和接口索引计数器2.png"><p>从图中可以看出，第5个常量和第6个常量均为“CONSTANT_Class_info”表类型，并且代表的类分别是”Test”和”Object”。再看接口计数器，因为接口计数器的值为2，代表这个类实现了2个接口。查看接口索引计数器之后的4个字节分别是：</p><ul><li><strong>0007</strong>：指向常量池的第7个常量，从图中可以看出第7个常量值为”Serializable”。</li><li><strong>0008</strong>：指向常量池的第8个常量，从图中可以看出第8个常量值为”Cloneable”。</li></ul><p>综上所述，可以得出如下结论：<strong>当前类为Test继承自Object类，并实现了<code>Serializable</code>和<code>Cloneable</code>两个接口</strong>。</p><h2 id="4-6-字段表"><a href="#4-6-字段表" class="headerlink" title="4.6 字段表"></a>4.6 字段表</h2><p>紧跟在接口索引集合后面的就是字段表，字段表的主要功能是用来描述类或者接口中声明的变量。这里的字段包含了类级别变量以及实例变量，但是不包括方法内部声明的局部变量。</p><p>同样，一个类中的变量个数是不固定的，因此在字段表集合之前还是使用一个计数器来表示变量的个数，如下入：</p><img src="/2020/06/21/（拉钩）Android工程师进阶34讲-03：字节码层面分析class类文件结构/字段表1.png"><ul><li><strong>0002</strong>：表示类中声明了两个变量，字段计数器之后紧跟着2个字段表的数据结构。</li></ul><p>字段表的数据结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Fieldref_info&#123;</span><br><span class="line">    u2  access_flags     // 字段的访问标志</span><br><span class="line">    u2  name_index       // 字段的名称索引(也就是变量名)</span><br><span class="line">    u2  descriptor_index // 字段的描述索引(也就是变量的类型)</span><br><span class="line">    u2  attributes_count // 属性计数器</span><br><span class="line">    attribute_info</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续解析Test.class中的字段表，其结构如下：</p><img src="/2020/06/21/（拉钩）Android工程师进阶34讲-03：字节码层面分析class类文件结构/字段表2.png"><h2 id="4-7-字段访问标志"><a href="#4-7-字段访问标志" class="headerlink" title="4.7 字段访问标志"></a>4.7 字段访问标志</h2><p>对于Java类中的变量，也可以使用<code>public</code>、<code>private</code>、<code>final</code>、<code>static</code>等标识符进行标识。因此解析字段时，需要先判断它的访问标志，字段的访问标志如下所示：</p><img src="/2020/06/21/（拉钩）Android工程师进阶34讲-03：字节码层面分析class类文件结构/字段访问标志1.png"><p>字段表结构图中的访问标志的值为<strong>0002</strong>，代表它是<code>private</code>类型。变量名索引指向常量池中的第9个常量，变量名类型索引指向常量池中的第10个常量。第9和10个常量分别是<code>num</code>和<code>I</code>，如下所示：</p><img src="/2020/06/21/（拉钩）Android工程师进阶34讲-03：字节码层面分析class类文件结构/字段访问标志2.png"><p>因此可以得知类中有一个名为<code>num</code>，类型为<code>int</code>类型的变量。对于第二个变量的解析过程也是一样。</p><p>注意事项 ：</p><ul><li>1、字段表集合中不会列出从父类或者父接口中继承而来的字段。</li><li>2、内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。</li></ul><h2 id="4-8-方法表"><a href="#4-8-方法表" class="headerlink" title="4.8 方法表"></a>4.8 方法表</h2><p>字段表之后紧跟着的就是方法表常量。方法表常量也是以一个计数器开始的，因为一个类中的方法数是不固定的，如图：</p><img src="/2020/06/21/（拉钩）Android工程师进阶34讲-03：字节码层面分析class类文件结构/方法表1.png"><p>上图表示Test.class中有了两个方法，但是只在Test.java中声明了一个<code>add()</code>方法，这是为什么呢？这是因为<strong>默认构造器方法</strong>也被包含在方法表常量中。</p><p>方法表的结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Methodref_info&#123;</span><br><span class="line">    u2  access_flags;         // 方法的访问标志</span><br><span class="line">    u2  name_index;           // 指向方法名的索引</span><br><span class="line">    u2  descriptor_index;     // 指向方法类型的索引</span><br><span class="line">    u2  attributes_count;     // 方法属性计数器</span><br><span class="line">    attribute_info attributes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法也有自己的访问标志，具体如下：</p><img src="/2020/06/21/（拉钩）Android工程师进阶34讲-03：字节码层面分析class类文件结构/方法表2.png"><p>主要看<code>add()</code>方法，具体如下：</p><img src="/2020/06/21/（拉钩）Android工程师进阶34讲-03：字节码层面分析class类文件结构/方法表3.png"><ul><li>1、<strong>access_flags = 0001</strong>：访问权限为<code>public</code>。</li><li>2、<strong>bame_index = 0011</strong>：指向常量池中的第17个常量，也就是<code>add</code>。</li><li>3、<strong>type_index = 0012</strong>：指向常量池中的第18个常量，也就是<code>(I)</code>。这个方法接收<code>int</code>类型参数，并返回<code>int</code>类型参数。</li></ul><h2 id="4-9-属性表"><a href="#4-9-属性表" class="headerlink" title="4.9 属性表"></a>4.9 属性表</h2><p>在之前解析字段和方法时，在它们的具体结构中可以看到一个叫做<code>attributes_info</code>的表，这就是属性表。</p><p>属性表没有固定的结构，各个不同的属性满足以下结构即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Attribute_info&#123;</span><br><span class="line">    u2 name_index;</span><br><span class="line">    u2 attribute_length length;</span><br><span class="line">    u1[] info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JVM中预定义了很多属性表，这里重点看一下Code属性表。</p><p>接着上面解析方法表，向下分析：</p><img src="/2020/06/21/（拉钩）Android工程师进阶34讲-03：字节码层面分析class类文件结构/属性表1.png"><p>可以看到，在方法类型索引之后跟着的就是<code>add</code>方法的属性。</p><ul><li><strong>0001</strong>：是属性计数器，代表只有一个属性。</li><li><strong>000f</strong>：属性表类型索引，通过查看常量池可以看出，它是一个Code属性，如下所示：</li></ul><img src="/2020/06/21/（拉钩）Android工程师进阶34讲-03：字节码层面分析class类文件结构/属性表2.png"><p>Code属性表中，最重要的就是一系列的字节码。通过<code>javap -v Test.class</code>之后，可以看到方法的字节码，如下显示了<code>add</code>方法的字节码指令：</p><img src="/2020/06/21/（拉钩）Android工程师进阶34讲-03：字节码层面分析class类文件结构/属性表3.png"><p>JVM 执行<code>add</code>方法时，就是通过这一系列的指令来完成相应的操作的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0. 前言&quot;&gt;&lt;/a&gt;0. 前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;面试题：Java中String字符串的长度有限制吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p
      
    
    </summary>
    
      <category term="Android" scheme="https://tylerLiu.top/categories/Android/"/>
    
      <category term="进阶" scheme="https://tylerLiu.top/categories/Android/%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="JVM与DVM必知必会" scheme="https://tylerLiu.top/tags/JVM%E4%B8%8EDVM%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"/>
    
  </entry>
  
  <entry>
    <title>（拉钩）Android工程师进阶34讲-02：GC回收机制与分代回收策略</title>
    <link href="https://tylerLiu.top/2020/06/18/%EF%BC%88%E6%8B%89%E9%92%A9%EF%BC%89Android%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BF%9B%E9%98%B634%E8%AE%B2-02%EF%BC%9AGC%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/"/>
    <id>https://tylerLiu.top/2020/06/18/（拉钩）Android工程师进阶34讲-02：GC回收机制与分代回收策略/</id>
    <published>2020-06-18T00:43:12.000Z</published>
    <updated>2020-06-20T09:30:36.010Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h1><p>垃圾回收(Garbage Collection)，简称GC。Java语言比C语言好的地方在于，不需要手动释放对象的内存，JVM中的垃圾回收器(Garbage Collector)会自动回收。但是：一旦这种自动化机制出错，就需要去深入理解GC回收机制，甚至需要对这些“自动化”的技术实施必要的监控和调节。</p><p>上一节介绍了Java内存运行时区域的各个部分，其中程序计数器、虚拟机栈、本地方法栈三个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊的执行入栈和出栈操作，这几个区域内不需要过多考虑回收问题。</p><p>而堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的就是这部分内存。</p><h1 id="1-什么是垃圾"><a href="#1-什么是垃圾" class="headerlink" title="1. 什么是垃圾"></a>1. 什么是垃圾</h1><p>所谓垃圾就是内存中已经没有用的对象。既然是“垃圾回收”，就必须知道哪些对象是垃圾。Java虚拟机中使用一种叫做 <strong>“可达性分析”</strong> 的算法来决定对象是否可被回收。</p><h1 id="1-1-可达性分析"><a href="#1-1-可达性分析" class="headerlink" title="1.1 可达性分析"></a>1.1 可达性分析</h1><p>可达性分析算法是从离散数学中的图论引入的，JVM把内存中所有的对象之间的引用关系看作一张图，通过一组名为“GC Root”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，最后通过判断对象的引用链是否可达来决定对象是否可以被回收。如下图：</p><img src="/2020/06/18/（拉钩）Android工程师进阶34讲-02：GC回收机制与分代回收策略/可达性分析.png"><p>上图，对象A/B/C/D/E与GC Root之间都存在一条直接或间接的引用链，这也代表它们与GC Root之间是可达的，因此它们是不能被GC回收掉的。而对象M和K虽然被对象J引用到，但是并不存在一条引用链连接它们与GC Root，所以当GC进行垃圾回收时，只要遍历到J/K/M这三个对象，就会将它们回收。</p><blockquote><p>注意：上图中圆形图标虽然标记的是对象，但实际上代表的是此对象在内存中的引用。包括GC Root也是一组引用而非对象。</p></blockquote><h2 id="1-2-GC-Root对象"><a href="#1-2-GC-Root对象" class="headerlink" title="1.2 GC Root对象"></a>1.2 GC Root对象</h2><p>在Java中，有以下几种对象可以作为GC Root：</p><ul><li>1、Java虚拟机栈（局部变量表）中的引用的对象。</li><li>2、方法区静态引用指向的对象。</li><li>3、仍处于活跃状态中的线程对象。</li><li>4、Native方法中JVM引用的对象。</li></ul><h1 id="2-什么时候回收"><a href="#2-什么时候回收" class="headerlink" title="2. 什么时候回收"></a>2. 什么时候回收</h1><p>不同的虚拟机实现有着不同的GC实现机制，一般情况下每种GC实现都会在以下两种情况下触发垃圾回收。</p><ul><li>1、Allocation Failure：在堆内存中分配时，如果因为可用剩余空间不足导致对象内存分配失败，这时系统触发一次GC。</li><li>2、System.gc()：在应用层，可以主动调用API来进行一次GC。</li></ul><h1 id="3-代码验证GC-Root的几种情况"><a href="#3-代码验证GC-Root的几种情况" class="headerlink" title="3. 代码验证GC Root的几种情况"></a>3. 代码验证GC Root的几种情况</h1><p>现在了解了Java中的GC Root，以及何时触发GC，下面通过几个案例来验证GC Root的情况。在看具体代码前，先了解一个执行Java命令时的参数。</p><blockquote><p>-Xms 初始分配Java运行时的内存大小，如果不指定，默认为物理内存的 1/64。</p></blockquote><p>比如运行如下命令执行HelloWorld程序，从物理内存中分配出200M空间给JVM内存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xms200m HelloWorld</span><br></pre></td></tr></table></figure><h2 id="3-1-验证虚拟机栈（栈帧中的局部变量）中引用的对象作为GC-Root"><a href="#3-1-验证虚拟机栈（栈帧中的局部变量）中引用的对象作为GC-Root" class="headerlink" title="3.1 验证虚拟机栈（栈帧中的局部变量）中引用的对象作为GC Root"></a>3.1 验证虚拟机栈（栈帧中的局部变量）中引用的对象作为GC Root</h2><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCRootLocalVariable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> _10MB = <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] memory = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span> * _10MB];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"开始时："</span>);</span><br><span class="line">printMemory();</span><br><span class="line">method();</span><br><span class="line">System.gc();</span><br><span class="line">System.out.println(<span class="string">"第二次GC完成："</span>);</span><br><span class="line">printMemory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">GCRootLocalVariable g = <span class="keyword">new</span> GCRootLocalVariable();</span><br><span class="line">System.gc();</span><br><span class="line">System.out.println(<span class="string">"第一次GC完成："</span>);</span><br><span class="line">printMemory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.print(<span class="string">"free is "</span> + Runtime.getRuntime().freeMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">" M, "</span>);</span><br><span class="line">System.out.println(<span class="string">"total is "</span> + Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">" M."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">开始时：</span><br><span class="line">free is 242 M, total is 243 M.</span><br><span class="line">第一次GC完成：</span><br><span class="line">free is 161 M, total is 243 M.</span><br><span class="line">第二次GC完成：</span><br><span class="line">free is 241 M, total is 243 M.</span><br></pre></td></tr></table></figure><p>可以看出：</p><ul><li>当第一次GC时，<code>g</code>作为局部变量，引用了<code>new</code>出的对象（80M），并且它作为了GC Root，在GC后不会被GC回收。</li><li>第二次GC时，<code>method()</code>方法执行完毕后，局部变量<code>g</code>跟随方法消失，不再有引用类型指向该80M对象，所以第二次GC此后80M也会被回收。</li></ul><h2 id="3-2-验证方法区中的静态变量引用的对象作为GC-Root"><a href="#3-2-验证方法区中的静态变量引用的对象作为GC-Root" class="headerlink" title="3.2 验证方法区中的静态变量引用的对象作为GC Root"></a>3.2 验证方法区中的静态变量引用的对象作为GC Root</h2><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCRootStaticVariable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> _10MB = <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] memory;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> GCRootStaticVariable staticVariable;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">GCRootStaticVariable</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">memory = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"程序开始："</span>);</span><br><span class="line">printMemory();</span><br><span class="line">GCRootStaticVariable g = <span class="keyword">new</span> GCRootStaticVariable(<span class="number">4</span> * _10MB);</span><br><span class="line">g.staticVariable = <span class="keyword">new</span> GCRootStaticVariable(<span class="number">8</span> * _10MB);</span><br><span class="line"><span class="comment">// 将g设置为 null，调用GC时可以回收此对象内存</span></span><br><span class="line">g = <span class="keyword">null</span>;</span><br><span class="line">System.gc();</span><br><span class="line">System.out.println(<span class="string">"GC完成："</span>);</span><br><span class="line">printMemory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.print(<span class="string">"free is "</span> + Runtime.getRuntime().freeMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">" M, "</span>);</span><br><span class="line">System.out.println(<span class="string">"total is "</span> + Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">" M."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">程序开始：</span><br><span class="line">free is 242 M, total is 243 M.</span><br><span class="line">GC完成：</span><br><span class="line">free is 161 M, total is 243 M.</span><br></pre></td></tr></table></figure><p>可以看到：</p><p>程序刚开始运行时，内存为242M，并分别创建了<code>g</code>对象（40M），同时也初始化<code>g</code>对象内部的静态变量<code>staticVariable</code>对象（80M）。当调用GC时，只有<code>g</code>对象的40M被GC回收掉，而静态变量<code>staticVariable</code>作为GC Root，它引用的80M不会被回收。</p><h2 id="3-3-验证活跃线程作为GC-Root"><a href="#3-3-验证活跃线程作为GC-Root" class="headerlink" title="3.3 验证活跃线程作为GC Root"></a>3.3 验证活跃线程作为GC Root</h2><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCRootThread</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> _10MB = <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] memory = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span> * _10MB];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"开始前内存情况："</span>);</span><br><span class="line">printMemory();</span><br><span class="line">AsyncTask at = <span class="keyword">new</span> AsyncTask(<span class="keyword">new</span> GCRootThread());</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(at);</span><br><span class="line">thread.start();</span><br><span class="line">System.gc();</span><br><span class="line">System.out.println(<span class="string">"main方法执行完毕，完成GC："</span>);</span><br><span class="line">printMemory();</span><br><span class="line"></span><br><span class="line">thread.join();</span><br><span class="line">at = <span class="keyword">null</span>;</span><br><span class="line">System.gc();</span><br><span class="line">System.out.println(<span class="string">"线程代码执行完毕，完成GC："</span>);</span><br><span class="line">printMemory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.print(<span class="string">"free is "</span> + Runtime.getRuntime().freeMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">" M, "</span>);</span><br><span class="line">System.out.println(<span class="string">"total is "</span> + Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">" M."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> GCRootThread gcRootThread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">(GCRootThread gcRootThread)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.gcRootThread = gcRootThread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">500</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">开始前内存情况：</span><br><span class="line">free is 242 M, total is 243 M.</span><br><span class="line">main方法执行完毕，完成GC：</span><br><span class="line">free is 161 M, total is 243 M.</span><br><span class="line">线程代码执行完毕，完成GC：</span><br><span class="line">free is 241 M, total is 243 M.</span><br></pre></td></tr></table></figure><p>可以看到：</p><p>程序刚开始是242M内存，当调用第一次GC时线程没有执行结束，并且它作为GC Root，所以它所引用的80M内存不会被GC回收掉。<code>thread.join()</code>保证线程结束再调用后续代码，所以当调用第二次GC时，线程已经执行完毕并被设置为null，此时线程已经被销毁，所以之前它所引用的80M此时会被GC回收掉。</p><h2 id="3-4-测试成员变量是否可作为GC-Root"><a href="#3-4-测试成员变量是否可作为GC-Root" class="headerlink" title="3.4 测试成员变量是否可作为GC Root"></a>3.4 测试成员变量是否可作为GC Root</h2><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCRootClassVariable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> _10MB = <span class="number">10</span> * <span class="number">1024</span> * <span class="number">102</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] memory;</span><br><span class="line">    <span class="keyword">private</span>  GCRootClassVariable classVariable;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GCRootClassVariable</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        memory = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"程序开始："</span>);</span><br><span class="line">        printMemory();</span><br><span class="line">        GCRootClassVariable g = <span class="keyword">new</span> GCRootClassVariable(<span class="number">4</span> * _10MB);</span><br><span class="line">        g.classVariable = <span class="keyword">new</span> GCRootClassVariable(<span class="number">8</span> * _10MB);</span><br><span class="line">        g = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"GC完成："</span>);</span><br><span class="line">        printMemory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"free is "</span> + Runtime.getRuntime().freeMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">" M,"</span>);</span><br><span class="line">        System.out.println(<span class="string">"total is "</span> + Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">" M."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">程序开始：</span><br><span class="line">free is 238 M,total is 243 M.</span><br><span class="line">GC完成：</span><br><span class="line">free is 241 M,total is 243 M.</span><br></pre></td></tr></table></figure><p>从日志可以看出，当调用GC时，因为<code>g</code>已经设置为<code>null</code>，因此<code>g</code>中的全局变量<code>classVariable</code>此时也不会被GC Root所引用。所以最后<code>g</code>(40M)和<code>classVariable</code>(80M)都会被回收掉。<strong>这也表明全局变量和静态变量不同，它不会被作为GC Root</strong>。</p><blockquote><p>上面演示的几种情况往往也是内存泄露发生的场景，设想一下将各个Test类换成Android中的Activity的话将导致Activity无法被系统回收，而一个Activity中的数据往往比较大，因此内存泄露导致Activity无法回收还是比较致命的。</p></blockquote><h1 id="4-如何回收垃圾"><a href="#4-如何回收垃圾" class="headerlink" title="4. 如何回收垃圾"></a>4. 如何回收垃圾</h1><p>由于垃圾收集算法的实现涉及大量的程序细节，各家虚拟机厂商对其实现细节也各不相同，因此这里不过多讨论算法的实现，只是介绍几种算法的思想及优缺点。</p><h2 id="4-1-标记清除算法-Mark-and-Sweep-GC"><a href="#4-1-标记清除算法-Mark-and-Sweep-GC" class="headerlink" title="4.1 标记清除算法(Mark and Sweep GC)"></a>4.1 标记清除算法(Mark and Sweep GC)</h2><p>从“GC Root”集合开始，将内存整个遍历一次，保留所有可以被GC Root直接或间接引用到的对象，而剩下的对象都当做垃圾回收，过程分为两步。</p><ul><li>1、<strong>Mark 标记阶段</strong>：找到内存中的所有GC Root对象，只要是和GC Root对象直接或间接相连则标记为灰色（即存活对象），否则标记为黑色（即垃圾对象）。</li><li>2、<strong>Sweep 清除阶段</strong>：当遍历完所有的GC Root之后，则将标记为垃圾的对象直接清除。</li></ul><p>如下图：</p><img src="/2020/06/18/（拉钩）Android工程师进阶34讲-02：GC回收机制与分代回收策略/标记清除算法.png"><ul><li>优点：实现简单，不需要将对象进行移动。</li><li>缺点：这个算法需要中断进程内其他组件的执行(stop the world)，并且可能产生内存碎片，提高了垃圾回收的频率。</li></ul><h2 id="4-2-复制算法-Copying"><a href="#4-2-复制算法-Copying" class="headerlink" title="4.2 复制算法(Copying)"></a>4.2 复制算法(Copying)</h2><p>将现有的内存空间分为两块，每次只是用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中。之后，清除正在使用的内存块中所有的对象，交换两个内存的角色，完成垃圾回收。</p><ul><li><p>1、复制算法之前，内存分为A/B两块，并且当前只使用内存A，内存状况如下图：</p>  <img src="/2020/06/18/（拉钩）Android工程师进阶34讲-02：GC回收机制与分代回收策略/复制算法——复制之前.png"></li><li><p>2、标记完成之后，所有可达对象都被按次序复制到内存B中，并设置B为当前使用中的内存。内存状况如下图：</p>  <img src="/2020/06/18/（拉钩）Android工程师进阶34讲-02：GC回收机制与分代回收策略/复制算法——复制之后.png"></li></ul><h2 id="4-3-标记-压缩算法-Mark-Compact"><a href="#4-3-标记-压缩算法-Mark-Compact" class="headerlink" title="4.3 标记-压缩算法(Mark-Compact)"></a>4.3 标记-压缩算法(Mark-Compact)</h2><p>需要先从根节点开始对所有可达对象做一次标记，之后，它并不是简单的清理未标记的对象，而是将所有的存活对象压缩到内存的一端。最后，清理边界外所有的空间。因此标记-压缩算法也分为两步：</p><ul><li>1、<strong>Mark 标记阶段</strong>：找到内存中的所有GC Root对象，只要是和GC Root对象直接或间接相连则标记为灰色（即存活对象），否则标记为黑色（即垃圾对象）。</li><li>2、<strong>Compact 压缩阶段</strong>：将剩余存活对象按顺序压缩到内存的某一端。</li></ul><img src="/2020/06/18/（拉钩）Android工程师进阶34讲-02：GC回收机制与分代回收策略/标记-压缩算法.png"><ul><li>优点：这种方法避免了碎片的产生，又不需要两块相同的内存空间，因此，性价比高。</li><li>缺点：所谓压缩操作，仍需要进行局部对象移动，所以一定程度上降低了效率。</li></ul><h1 id="5-JVM分代回收策略"><a href="#5-JVM分代回收策略" class="headerlink" title="5. JVM分代回收策略"></a>5. JVM分代回收策略</h1><p>Java虚拟机根据对象存活的周期不同，把堆内存划分为几块，一般分为<strong>新生代、老年代</strong>，这就是JVM的内存分代策略。</p><blockquote><p>注意，在HotSpot中除了新生代和老年代，还有永久代。</p></blockquote><p>分代回收的中心思想就是：对于新创建的对象会在新生代中分配内存，此区域的对象生命周期一般较短。如果经历几次回收仍然存活下来，则将它们转移到老年代中。</p><h2 id="5-1-新生代-Young-Generation"><a href="#5-1-新生代-Young-Generation" class="headerlink" title="5.1 新生代(Young Generation)"></a>5.1 新生代(Young Generation)</h2><p>新生代的对象存放在新生代中，新生代对象朝生夕死，存活率很低。在新生代中，常规应用进行一次垃圾收集，一般可以回收70%~95%的空间，回收效率很高。</p><p>新生代又可以细分为三个部分：Eden、Survivor0（简称S0）、Survivor1（简称S1）。这三个部分按照8：1：1的比例来划分新生代。这三个区域的分配过程如下：</p><p>绝大多数刚刚被创建的对象会存放在<strong>Eden</strong>区。如图：</p><img src="/2020/06/18/（拉钩）Android工程师进阶34讲-02：GC回收机制与分代回收策略/新生代1.png"><p>当<strong>Eden</strong>区第一次存满时，会进行垃圾回收。首先将<strong>Eden</strong>区的垃圾对象回收清除，并将存活对象复制到<strong>S0</strong>，此时<strong>S1</strong>是空的。如图：</p><img src="/2020/06/18/（拉钩）Android工程师进阶34讲-02：GC回收机制与分代回收策略/新生代2.png"><p>下一次<strong>Eden</strong>区满时，在执行一次垃圾回收。此次会将<strong>Eden</strong>和<strong>S0</strong>区所有的垃圾对象清除，并将存活的对象复制到<strong>S1</strong>，此时<strong>S0</strong>变为空。如图：</p><img src="/2020/06/18/（拉钩）Android工程师进阶34讲-02：GC回收机制与分代回收策略/新生代3.png"><p>如此反复在<strong>S0</strong>和<strong>S1</strong>之间切换几次（默认是15次）之后，如果还有存活对象。说明这些对象的生命周期较长，则将它们转入到老年代。如图：</p><img src="/2020/06/18/（拉钩）Android工程师进阶34讲-02：GC回收机制与分代回收策略/新生代4.png"><h2 id="5-2-老年代-Old-Generation"><a href="#5-2-老年代-Old-Generation" class="headerlink" title="5.2 老年代(Old Generation)"></a>5.2 老年代(Old Generation)</h2><p>一个对象如果在新生代存活了足够长时间而没有被清理掉，则会被复制到老年代。老年代的内存大小一般比新生代大，能存放更多的对象。如果对象比较大（比如长字符串或大数组），并且新生代的剩余空间不足，则这个大对象会直接被分配到老年代上。</p><p>可以使用<code>-XX:PretenureSizeThreshold</code>来控制直接升入老年代的对象的大小，大小这个值的对象会直接分配在老年代上。老年代因为对象的生命周期较长，不需要过多的复制操作，所以一般采用标记-压缩到的回收算法。</p><blockquote><p>注意：对于老年代可能存在这么一种情况，老年代中的对象有时候会引用到新生代对象。这时如果要执行新生代GC，则可能需要查询整个老年代上可能引用新生代的情况，这显然是低效的。所以，老年代中维护了一个512 byte 的card table，所有老年代对象引用新生代对象的信息都记录在这里。每当新生代发生GC时，只需要检查这个 card table即可，大大提高性能。</p></blockquote><h1 id="6-GC-Log分析"><a href="#6-GC-Log分析" class="headerlink" title="6. GC Log分析"></a>6. GC Log分析</h1><p>为了让上层开发人员更加方便的调试Java程序，JVM提供了相应的GC日志。在GC执行垃圾回收事件过程中，会有各种相应的log被打印出来。其中新生代和老年代所打印的日志是有区别的：</p><ul><li>新生代GC：这一区域的GC叫做Minor GC。因为Java对象大多数都具备朝生夕死的特性，所以Minor GC非常频繁，一般回收速度也比较快。</li><li>老年代GC：这一区域的GC叫做Major GC或Full GC。当出现Major GC，经常会伴随至少一次Minor GC。</li></ul><blockquote><p>注意，在有些虚拟机实现中，Major GC和Full GC还有一些区别。Major GC只是代表回收老年代中的内存，而Full GC则代表回收整个堆中的内存，也就是新生代 + 老年代。</p></blockquote><p>接下来通过几个案例分析如何查看GC Log，分析这些GC Log的过程加深对JVM分代策略的理解。</p><p>Java命令参数：</p><table><thead><tr><th align="center">命令参数</th><th align="center">功能描述</th></tr></thead><tbody><tr><td align="center">-verbose:gc</td><td align="center">显示GC的操作内容</td></tr><tr><td align="center">-Xms20M</td><td align="center">初始化堆大小为20M</td></tr><tr><td align="center">-Xmx20M</td><td align="center">设置堆最大分配内存为20M</td></tr><tr><td align="center">-Xmn10M</td><td align="center">设置新生代的内存大小为10M</td></tr><tr><td align="center">-XX:+printGCDetails</td><td align="center">打印GC的详细log日志</td></tr><tr><td align="center">-XX:SurvivorRatio=8</td><td align="center">新生代中Eden区域与Survivor区域的大小比值为8:1:1</td></tr></tbody></table><p>使用如下代码，在内存中创建4个byte类型数组来演示内存分配和GC的详细过程。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM agrs: -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> * -XX:SurvivorRatio=8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinorGCTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAllocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] a1, a2, a3, z4;</span><br><span class="line">        a1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        a2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        a3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        a4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1</span> * _1MB];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] agrs)</span> </span>&#123;</span><br><span class="line">        testAllocation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的参数，可以看出堆内存总大小为20M，其中新生代占10M，剩下的10M会自动分配给老年代。执行上述代码日志如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Heap</span><br><span class="line">PSYoungGen      total 9216K, used 8003K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line">  eden space 8192K, 97% used [0x00000007bf600000,0x00000007bfdd0ed8,0x00000007bfe00000)</span><br><span class="line">  from space 1024K, 0% used [0x00000007bff00000,0x00000007bff00000,0x00000007c0000000)</span><br><span class="line">  to   space 1024K, 0% used [0x00000007bfe00000,0x00000007bfe00000,0x00000007bff00000)</span><br><span class="line">ParOldGen       total 10240K, used 0K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000)</span><br><span class="line">  object space 10240K, 0% used [0x00000007bec00000,0x00000007bec00000,0x00000007bf600000)</span><br><span class="line">Metaspace       used 2631K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 286K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure><p>日志中的各字段代表意义如下：</p><table><thead><tr><th align="center">字段</th><th align="center">代表含义</th></tr></thead><tbody><tr><td align="center">PSYoungGen</td><td align="center">新生代</td></tr><tr><td align="center">eden</td><td align="center">新生代中的Eden1区</td></tr><tr><td align="center">from</td><td align="center">新生代中的S0区</td></tr><tr><td align="center">to</td><td align="center">新生代中的S1区</td></tr><tr><td align="center">ParOldGen</td><td align="center">老年代</td></tr></tbody></table><p>从日志可以看出：程序执行完之后，<code>a1</code>、<code>a2</code>、<code>a3</code>、<code>a4</code>四个对象都被分配在新生代的Eden区。</p><p>如果将测试代码中的<code>a4</code>初始化改为<code>a4 = new byte[2 * _1MB];</code>，则打印日志如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 6815K-&gt;480K(9216K)] 6815K-&gt;6632K(19456K), 0.0067344 secs] [Times: user=0.04 sys=0.00, real=0.01 secs]</span><br><span class="line">Heap</span><br><span class="line">PSYoungGen      total 9216K, used 2130K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line">  eden space 8192K, 26% used [0x00000007bf600000,0x00000007bf814930,0x00000007bfe00000)</span><br><span class="line">  from space 1024K, 0% used [0x00000007bfe00000,0x00000007bfe00000,0x00000007bff00000)</span><br><span class="line">  to   space 1024K, 0% used [0x00000007bff00000,0x00000007bff00000,0x00000007c0000000)</span><br><span class="line">ParOldGen       total 10240K, used 6420K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000)</span><br><span class="line">  object space 10240K, 62% used [0x00000007bec00000,0x00000007bf2450d0,0x00000007bf600000)</span><br><span class="line">Metaspace       used 2632K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 286K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure><p>这时因为在给<code>a4</code>分配内存之前，Eden区已经被占用了6M，已经无法再分配出2M来存储<code>a4</code>对象。因此会执行一次Minor GC。并尝试将存活的<code>a1</code>、<code>a2</code>、<code>a3</code>复制到S1区。但是S1区只有1M空间，所以无法存储<code>a1</code>、<code>a2</code>、<code>a3</code>中的任意一个对象。这时，<code>a1</code>、<code>a2</code>、<code>a3</code>就会被转移到老年代，最后将<code>a4</code>保存在Eden区。<strong>所以最终结果是：Eden区占用2M(<code>a4</code>)，老年代占用6M(<code>a1</code>、<code>a2</code>、<code>a3</code>)</strong>。</p><blockquote><p>通过这个测试案例，也间接验证了JVM的内存分配和分代回收策略。</p></blockquote><h2 id="6-1-再谈引用"><a href="#6-1-再谈引用" class="headerlink" title="6.1 再谈引用"></a>6.1 再谈引用</h2><p>上文介绍了，判断对象是否存活是用过GC Root的引用可达性来判断的。但是JVM中的引用关系不止一种。根据引用强度可分为：<strong>强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)、虚引用(Phantom Reference)</strong>。</p><table><thead><tr><th align="center">引用</th><th align="center">GC回收时机</th><th align="center">使用示例</th></tr></thead><tbody><tr><td align="center">强引用</td><td align="center">如果一个对象具有强引用，那垃圾回收器绝对不会回收</td><td align="center"><code>Object obj = new Object();</code></td></tr><tr><td align="center">软引用</td><td align="center">在内存实在不足时，会对软引用进行回收</td><td align="center"><code>SoftReference&lt;Object&gt; softObj = new SoftReference();</code></td></tr><tr><td align="center">弱引用</td><td align="center">第一次GC回收时，如果垃圾回收器遍历到了此弱引用，就将其回收</td><td align="center"><code>WeakReference&lt;Object&gt; weakObj = new WeakReference();</code></td></tr><tr><td align="center">虚引用</td><td align="center">一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获取一个对象的实例</td><td align="center">不会使用</td></tr></tbody></table><p>平时项目中，特别是Android项目，因为有大量的图像(<code>Bitmap</code>)对象，使用软引用的场景比较多。所以重点看一下软引用的使用，不当的使用软引用会导致系统异常。</p><h2 id="6-2-软引用常规使用"><a href="#6-2-软引用常规使用" class="headerlink" title="6.2 软引用常规使用"></a>6.2 软引用常规使用</h2><p>常规使用代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SoftReferenceNormal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SoftObject</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 120M</span></span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">120</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将缓存数据用软引用持有</span></span><br><span class="line">        SoftReference&lt;SoftObject&gt; cacheRef = <span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> SoftObject());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"第一次GC前 软引用："</span> + cacheRef.get());</span><br><span class="line">        <span class="comment">// 进行一次GC回收后，查看对象的回收情况</span></span><br><span class="line">        System.out.println(<span class="string">"第一次GC后 软引用："</span> + cacheRef.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再分配一个120M的对象，看看缓存对象的回收情况</span></span><br><span class="line">        SoftObject newSo = <span class="keyword">new</span> SoftObject();</span><br><span class="line">        System.out.println(<span class="string">"再次分配120M强引用对象之后 软引用："</span> + cacheRef.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上述代码，打印日志如下：</p><img src="/2020/06/18/（拉钩）Android工程师进阶34讲-02：GC回收机制与分代回收策略/软引用常规使用.png"><p>首先通过<code>-Xmx200M</code>将堆最大内存设置为200M。从日志可以看出，当第一次GC时，内存中还有剩余可用内存，所以软引用不会被GC回收。但是再次创建一个120M的强引用时，JVM可用内存已经不够，所以会尝试将软引用回收。</p><h2 id="6-3-软引用隐藏问题"><a href="#6-3-软引用隐藏问题" class="headerlink" title="6.3 软引用隐藏问题"></a>6.3 软引用隐藏问题</h2><p>需要注意，被软引用对象关联的对象会自动被垃圾回收器回收，但是软引用对象本身也是一个对象，这些创建的软引用并不会自动被垃圾回收器回收掉。如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SoftReferenceTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SoftObject</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1KB</span></span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 100M</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> CACHE_INITIAL_CAPACITY = <span class="number">100</span> * <span class="number">1024</span>;</span><br><span class="line">        <span class="comment">// 静态集合保存软引用，会导致这些软引用对象本身无法被垃圾回收器回收</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Set&lt;SoftReference&lt;SoftObject&gt;&gt; cache = <span class="keyword">new</span> HashSet&lt;&gt;(CACHE_INITIAL_CAPACITY);</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> ReferenceQueue&lt;SoftObject&gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CACHE_INITIAL_CAPACITY; i++) &#123;</span><br><span class="line">                SoftObject obj = <span class="keyword">new</span> SoftObject();</span><br><span class="line">                cache.add(<span class="keyword">new</span> SoftReference&lt;&gt;(obj, referenceQueue));</span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">10000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"size of cache:"</span> + cache.size());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"End!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码，虽然每个<code>SoftObject</code>都被一个软引用所引用，在内存紧张时，GC会将<code>SoftObject</code>所占用的1KB回收。但是每个<code>SoftReference</code>又被<code>Set</code>所引用（强引用）。执行上述代码结果如下：</p><img src="/2020/06/18/（拉钩）Android工程师进阶34讲-02：GC回收机制与分代回收策略/软引用隐藏问题2.png"><p>限制堆内存大小为4M，最终程序崩溃，但是异常的原因并不是普通的堆内存溢出，而是“GC overhead”。之所以抛出这个错误，是由于虚拟机一会不断回收软引用，回收进行的速度过快，占用的CPU    过大（超过98%），并且每次回收掉的内存过小（小于2%），导致最终抛出这个错误。</p><p>这里需要做优化，合理的处理方式是注册一个引用队列，每次循环之后将引用队列中出现的软引用对象从<code>cache</code>中移除。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SoftReferenceTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SoftObject</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1KB</span></span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> removeSoftRefs = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 100M</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> CACHE_INITIAL_CAPACITY = <span class="number">100</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="comment">// 静态集合保存软引用，会导致这些软引用对象本身无法被垃圾回收器回收</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Set&lt;SoftReference&lt;SoftObject&gt;&gt; cache = <span class="keyword">new</span> HashSet&lt;&gt;(CACHE_INITIAL_CAPACITY);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReferenceQueue&lt;SoftObject&gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CACHE_INITIAL_CAPACITY; i++) &#123;</span><br><span class="line">            SoftObject obj = <span class="keyword">new</span> SoftObject();</span><br><span class="line">            cache.add(<span class="keyword">new</span> SoftReference&lt;&gt;(obj, referenceQueue));</span><br><span class="line">            clearUselessReference();</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">10000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"size of cache:"</span> + cache.size());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"End, removed soft reference = "</span> + removeSoftRefs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clearUselessReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Reference&lt;? extends SoftObject&gt; ref = referenceQueue.poll();</span><br><span class="line">        <span class="keyword">while</span> (ref != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cache.remove(ref)) &#123;</span><br><span class="line">                removeSoftRefs++;</span><br><span class="line">            &#125;</span><br><span class="line">            ref = referenceQueue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行，结果如下：</p><img src="/2020/06/18/（拉钩）Android工程师进阶34讲-02：GC回收机制与分代回收策略/软引用隐藏问题1.png"><p>可以看出优化后，程序可以正常执行完。并且在执行过程中会动态的将集合中的软引用删除。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0. 前言&quot;&gt;&lt;/a&gt;0. 前言&lt;/h1&gt;&lt;p&gt;垃圾回收(Garbage Collection)，简称GC。Java语言比C语言好的地方在于，不需要手动释放对象的内存，
      
    
    </summary>
    
      <category term="Android" scheme="https://tylerLiu.top/categories/Android/"/>
    
      <category term="进阶" scheme="https://tylerLiu.top/categories/Android/%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="JVM与DVM必知必会" scheme="https://tylerLiu.top/tags/JVM%E4%B8%8EDVM%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"/>
    
  </entry>
  
  <entry>
    <title>大话设计模式-02：商场促销——策略模式</title>
    <link href="https://tylerLiu.top/2020/06/14/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-02%EF%BC%9A%E5%95%86%E5%9C%BA%E4%BF%83%E9%94%80%E2%80%94%E2%80%94%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>https://tylerLiu.top/2020/06/14/大话设计模式-02：商场促销——策略模式/</id>
    <published>2020-06-14T06:05:18.000Z</published>
    <updated>2020-06-14T06:07:45.986Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="设计模式" scheme="https://tylerLiu.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="大话设计模式" scheme="https://tylerLiu.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://tylerLiu.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>大话设计模式-01：代码无错就是优？——简单工厂模式</title>
    <link href="https://tylerLiu.top/2020/06/13/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-01%EF%BC%9A%E4%BB%A3%E7%A0%81%E6%97%A0%E9%94%99%E5%B0%B1%E6%98%AF%E4%BC%98%EF%BC%9F%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://tylerLiu.top/2020/06/13/大话设计模式-01：代码无错就是优？——简单工厂模式/</id>
    <published>2020-06-13T08:14:19.000Z</published>
    <updated>2020-06-14T06:00:27.420Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h1><p>要求实现一个计算器的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Program</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"请输入数字A："</span>);</span><br><span class="line">String A = scanner.nextLine();</span><br><span class="line">System.out.println(<span class="string">"请选择运算符号（+、-、*、/）："</span>);</span><br><span class="line">String B = scanner.nextLine();</span><br><span class="line">System.out.println(<span class="string">"请输入数字C："</span>);</span><br><span class="line">String C = scanner.nextLine();</span><br><span class="line">String D = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (B.equals(<span class="string">"+"</span>))</span><br><span class="line">D = String.valueOf(Double.valueOf(A) + Double.valueOf(C));</span><br><span class="line"><span class="keyword">if</span> (B.equals(<span class="string">"-"</span>))</span><br><span class="line">D = String.valueOf(Double.valueOf(A) - Double.valueOf(C));</span><br><span class="line"><span class="keyword">if</span> (B.equals(<span class="string">"*"</span>))</span><br><span class="line">D = String.valueOf(Double.valueOf(A) * Double.valueOf(C));</span><br><span class="line"><span class="keyword">if</span> (B.equals(<span class="string">"/"</span>))</span><br><span class="line">D = String.valueOf(Double.valueOf(A) / Double.valueOf(C));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"结果为："</span> + D);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="1-代码规范"><a href="#1-代码规范" class="headerlink" title="1. 代码规范"></a>1. 代码规范</h1><p>问题：</p><ul><li>1、命名不规范；</li><li>2、判断分支，用<code>if</code>写，意味着每个条件都要判断，每次都要做三次无用功</li><li>3、如果除数为0或者不是数字，而是其他的字符，如何处理？</li></ul><p>修改之后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Program</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"请输入数字A："</span>);</span><br><span class="line">String strNumberA = scanner.nextLine();</span><br><span class="line">System.out.println(<span class="string">"请选择运算符号（+、-、*、/）："</span>);</span><br><span class="line">String strOperate = scanner.nextLine();</span><br><span class="line">System.out.println(<span class="string">"请输入数字B："</span>);</span><br><span class="line">String strNumberB = scanner.nextLine();</span><br><span class="line">String strResult = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (strOperate) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">strResult = String.valueOf(Double.valueOf(strNumberA) + Double.valueOf(strNumberB));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">strResult = String.valueOf(Double.valueOf(strNumberA) - Double.valueOf(strNumberB));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">strResult = String.valueOf(Double.valueOf(strNumberA) * Double.valueOf(strNumberB));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line">strResult = String.valueOf(Double.valueOf(strNumberA) / Double.valueOf(strNumberB));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"结果为："</span> + strResult);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">System.out.println(<span class="string">"输入有误："</span> + e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-业务封装"><a href="#2-业务封装" class="headerlink" title="2. 业务封装"></a>2. 业务封装</h1><p>程序不单要实现需求，还需要易维护，易扩展，易复用。</p><p>面向对象的分析设计编程思想，考虑<strong>通过封装、继承、多态把程序的耦合度降低</strong>，使用设计模式使程序更加灵活，容易修改，并且易于复用。</p><p>让业务逻辑和界面逻辑分开，降低耦合，只有分离开，才能容易维护或扩展。</p><p><strong><code>Operation</code>运算类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">getResult</span><span class="params">(<span class="keyword">double</span> numberA, <span class="keyword">double</span> numberB, String operation)</span> </span>&#123;</span><br><span class="line"><span class="keyword">double</span> result = <span class="number">0</span>D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (operation) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">result = numberA + numberB;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">result = numberA - numberB;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">result = numberA * numberB;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line">result = numberA / numberB;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Program</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"请输入数字A："</span>);</span><br><span class="line">String strNumberA = scanner.nextLine();</span><br><span class="line">System.out.println(<span class="string">"请选择运算符号（+、-、*、/）："</span>);</span><br><span class="line">String strOperate = scanner.nextLine();</span><br><span class="line">System.out.println(<span class="string">"请输入数字B："</span>);</span><br><span class="line">String strNumberB = scanner.nextLine();</span><br><span class="line">String strResult = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">strResult = String</span><br><span class="line">.valueOf(Operation.getResult(Double.valueOf(strNumberA), Double.valueOf(strNumberB), strOperate));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"结果为："</span> + strResult);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">System.out.println(<span class="string">"输入有误："</span> + e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-紧耦合-amp-松耦合"><a href="#3-紧耦合-amp-松耦合" class="headerlink" title="3. 紧耦合 &amp; 松耦合"></a>3. 紧耦合 &amp; 松耦合</h1><p>上面只用到了封装，继承和多态如何使用？</p><p>思考：如上，如果需要增加一个新的运算，按照一般方法，就是在<code>switch</code>中新增加一个<code>case</code>，但是这样，为了增加一个新的运算，却要所有的运算都参与编译，另外，如果不小心修改了其他<code>case</code>里面的内容，就会造成程序错误。</p><p>所以应该把运算分离，修改其中一个，不会影响到另外几个，增加新的运算，也不会影响其他代码。</p><p><strong>修改<code>Operation</code>运算类，接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IOperation</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getResult</span><span class="params">(<span class="keyword">double</span> numberA, <span class="keyword">double</span> numberB)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>加减乘除类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationAdd</span> <span class="keyword">implements</span> <span class="title">IOperation</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getResult</span><span class="params">(<span class="keyword">double</span> numberA, <span class="keyword">double</span> numberB)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> numberA + numberB;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationSub</span> <span class="keyword">implements</span> <span class="title">IOperation</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getResult</span><span class="params">(<span class="keyword">double</span> numberA, <span class="keyword">double</span> numberB)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> numberA - numberB;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationMul</span> <span class="keyword">implements</span> <span class="title">IOperation</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getResult</span><span class="params">(<span class="keyword">double</span> numberA, <span class="keyword">double</span> numberB)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> numberA * numberB;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationDiv</span> <span class="keyword">implements</span> <span class="title">IOperation</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getResult</span><span class="params">(<span class="keyword">double</span> numberA, <span class="keyword">double</span> numberB)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (numberB == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"除数不能为0"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> numberA / numberB;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-简单工厂模式"><a href="#4-简单工厂模式" class="headerlink" title="4. 简单工厂模式"></a>4. 简单工厂模式</h1><p>现在的问题就是如何去实例化对象的问题，可以使用<strong>简单工厂模式</strong>，即，到底要实例化谁，将来会不会增加实例化的对象，可以考虑使用一个单独的类来做这个创建实例的过程，这就是工厂。</p><p><strong>简单运算工厂类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationFactory</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Operation <span class="title">createOperation</span><span class="params">(String operation)</span> </span>&#123;</span><br><span class="line">Operation oper = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">switch</span> (operation) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">oper = <span class="keyword">new</span> OperationAdd();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">oper = <span class="keyword">new</span> OperationSub();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">oper = <span class="keyword">new</span> OperationMul();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line">oper = <span class="keyword">new</span> OperationDiv();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> oper;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样只需要输入运算符工厂类就会实例化对应的对象，通过多态，返回父类的方法实现计算的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IOperation operation = OperationFactory.createOperation(<span class="string">"-"</span>);</span><br><span class="line">operation.getResult(<span class="number">2</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0. 前言&quot;&gt;&lt;/a&gt;0. 前言&lt;/h1&gt;&lt;p&gt;要求实现一个计算器的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;
      
    
    </summary>
    
      <category term="设计模式" scheme="https://tylerLiu.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="大话设计模式" scheme="https://tylerLiu.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://tylerLiu.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>（拉钩）Android工程师进阶34讲-01：程序运行时，内存到底是如何进行分配的？</title>
    <link href="https://tylerLiu.top/2020/06/10/%EF%BC%88%E6%8B%89%E9%92%A9%EF%BC%89Android%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BF%9B%E9%98%B634%E8%AE%B2-01%EF%BC%9A%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%EF%BC%8C%E5%86%85%E5%AD%98%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%88%86%E9%85%8D%E7%9A%84%EF%BC%9F/"/>
    <id>https://tylerLiu.top/2020/06/10/（拉钩）Android工程师进阶34讲-01：程序运行时，内存到底是如何进行分配的？/</id>
    <published>2020-06-10T07:47:49.000Z</published>
    <updated>2020-06-17T09:00:27.522Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h1><p>将Java的内存分为堆内存(Heap)和栈内存(Stack)，这样划分体现了这两块区域时Java工程师最关注的内存区域。但是这样划分并不完全正确。</p><p>Java虚拟机在执行Java程序过程中，会把它所管理的内存划分成不同的数据区域。下面的图描述了<strong>一个HelloWorld.java文件被JVM加载到内存中</strong>的过程：</p><ul><li>1、HelloWorld.java文件首先需要经过编译器编译，生成HelloWorld.class字节码文件。</li><li>2、Java程序访问HelloWorld这个类时，需要通过ClassLoader（类加载器）将HelloWorld.class加载到JVM的内存中。</li><li>3、JVM的内存可以划分为若干个不同的数据区域，主要分为：<strong>程序计数器、虚拟机栈、本地方法栈、堆、方法区</strong>。</li></ul><img src="/2020/06/10/（拉钩）Android工程师进阶34讲-01：程序运行时，内存到底是如何进行分配的？/JVM运行时内存分布.png"><h1 id="1-程序计数器-Program-Counter-Register"><a href="#1-程序计数器-Program-Counter-Register" class="headerlink" title="1. 程序计数器(Program Counter Register)"></a>1. 程序计数器(Program Counter Register)</h1><p>Java程序是多线程的，CPU可以在多个线程中分配执行时间片段。当某一个线程被CPU挂起时，需要记录代码已经执行到的位置，方便CPU重新执行此线程时，知道从哪行命名开始执行。这就是<strong>程序计数器</strong>的作用。</p><blockquote><p>程序计数器是虚拟机中的一块较小的内存空间，主要用户记录当前线程执行的位置。</p></blockquote><p>如下图所示：每个线程都会记录当前方法执行到的位置，当CPU切换到某一个线程时，则根据程序计数器记录的数字，继续向下执行指令。</p><img src="/2020/06/10/（拉钩）Android工程师进阶34讲-01：程序运行时，内存到底是如何进行分配的？/程序计数器.png"><p><strong>实际上除了上图演示的恢复线程操作之外，其他一些我们熟悉的分支操作、循环操作、跳转、异常处理等也都需要依赖这个计数器来完成</strong>。</p><p>关于计数器还有几点需要格外注意：</p><ul><li>1、在Java虚拟机规范中，对程序计数器这一区域没有规定任何OutOfMemoryError情况。</li><li>2、线程私有的，每条线程内部都有一个私有程序计数器。它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</li><li>3、当一个线程正在执行一个Java方法的时候，这个计数器记录的是正在执行的虚拟字节码指令的地址。如果正在执行的是Native方法，这个计数器值为空(Undefined)。</li></ul><h1 id="2-虚拟机栈"><a href="#2-虚拟机栈" class="headerlink" title="2. 虚拟机栈"></a>2. 虚拟机栈</h1><p>虚拟机栈也是线程私有的，与线程的生命周期同步。在Java虚拟机规范中，对这个区域规定了两种异常情况：</p><ul><li>1、StackOverflowError：当线程请求栈深度超过虚拟机栈所允许的深度时抛出。</li><li>2、OutOfMemoryError：当Java虚拟机动态扩展到无法申请足够的内存时抛出。</li></ul><p>在学习Java虚拟机过程中，常会看到一句话：</p><blockquote><p>JVM是基于栈的解释器执行的， DVM是基于寄存器解释器执行的。</p></blockquote><p>上面的“基于栈”指的就是<strong>虚拟机栈</strong>。虚拟机栈的初衷是用来描述Java方法执行的内存模型，每个方法被执行的时候，JVM都会在虚拟机中创建一个<strong>栈帧</strong>。</p><h2 id="2-1-栈帧"><a href="#2-1-栈帧" class="headerlink" title="2.1 栈帧"></a>2.1 栈帧</h2><p>栈帧(Stack Frame)，是用于支持虚拟机进行方法调用和方法执行的数据结构，每一个线程在执行某个方法时，都会为这个方法创建一个栈帧。</p><p>可以这样理解：一个线程包含多个栈帧，而每个栈帧内部包含<strong>局部变量、操作数栈、动态链接、返回地址</strong>等。如下图：</p><img src="/2020/06/10/（拉钩）Android工程师进阶34讲-01：程序运行时，内存到底是如何进行分配的？/栈帧.png"><h2 id="2-2-局部变量表"><a href="#2-2-局部变量表" class="headerlink" title="2.2 局部变量表"></a>2.2 局部变量表</h2><p>局部变量是变量值的存储空间，调用方法时传递的参数，以及在方法内部创建的局部变量都保存在<strong>局部变量表</strong>中。在Java编译成Class文件时，就会在方法的Code属性表中的max_locals数据项中，确定该方法需要分配的最大局部变量表的容量。如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> i + j + k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用javap-v反编译之后，得到如下字节码指令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">  descriptor: (I)I</span><br><span class="line">  flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">      <span class="number">0</span>: iconst_1</span><br><span class="line">      <span class="number">1</span>: istore_1</span><br><span class="line">      <span class="number">2</span>: iconst_2</span><br><span class="line">      <span class="number">3</span>: istore_2</span><br><span class="line">      <span class="number">4</span>: iload_1</span><br><span class="line">      <span class="number">5</span>: iload_2</span><br><span class="line">      <span class="number">6</span>: iadd</span><br><span class="line">      <span class="number">7</span>: iload_0</span><br><span class="line">      <span class="number">8</span>: iadd</span><br><span class="line">      <span class="number">9</span>: ireturn</span><br></pre></td></tr></table></figure><p>上面的<code>locals=3</code>就是代表局部变量表的长度，也就是说经过编译之后，局部变量表的长度已经确定是3，分别保存参数<code>k</code>和局部变量<code>i</code>、<code>j</code>。</p><blockquote><p>注意：系统不会为局部变量赋予初始值（实例变量和类变量都会被赋予初始值），也就是说不存在类变量那样的准备阶段。这一点会在后续的Class初始化中详细介绍。</p></blockquote><h2 id="2-3-操作数栈"><a href="#2-3-操作数栈" class="headerlink" title="2.3 操作数栈"></a>2.3 操作数栈</h2><p>操作数栈（Operand Stack），也称操作栈，它是一个后入先出栈。</p><p>和局部变量表一样，操作数栈的最大深度也在编译的时候写入方法的Code属性表中的max_stacks数据项中。栈中的元素可以是任意Java数据类型，包括<code>long</code>和<code>double</code>。</p><p>当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的。在方法执行的过程中，会有各种字节码指令被压入和弹出操作数栈（比如：iadd指令就是将操作数栈中栈顶的两个元素弹出，执行加法运算，并将结果重新压回到操作数栈中）。</p><h2 id="2-4-动态链接"><a href="#2-4-动态链接" class="headerlink" title="2.4 动态链接"></a>2.4 动态链接</h2><p>动态链接的主要目的是为了支持方法调用过程中的动态链接(Dynamic Linking)。</p><p>在一个class文件中，一个方法要调用其他方法，需要将这些方法的符号引用转化为其所在内存地址中的直接引用，而符号引用存在于<strong>方法区</strong>中。</p><p>在Java虚拟机栈中，每个栈帧都包含一个指向运行时常量池中该栈所属方法的符号引用，持有这个引用的目的就是为了支持调用过程中的动态链接。具体过程会在后面字节码中讲解。</p><h2 id="2-5-返回地址"><a href="#2-5-返回地址" class="headerlink" title="2.5 返回地址"></a>2.5 返回地址</h2><p>当一个方法执行后，只有两种方法可以退出这个方法：</p><ul><li><strong>正常退出</strong>：指方法中的代码正常完成，或者遇到任意一个方法返回的字节码指令(如return)并退出，没有抛出任何异常。</li><li><strong>异常退出</strong>：指方法执行过程中遇到异常，并且这个异常在方法体内部没有得到处理，导致方法退出。</li></ul><p>无论当前方法采用何种退出方式，在方法退出后都需要返回到方法被调用的位置，程序才能继续执行。而虚拟机栈中的“返回地址”就是用来帮助当前方法恢复到它的上层方法执行状态。</p><p>一般来说，方法正常退出时，调用者的PC计数值可以作为返回地址，栈帧中可能保存此计数值。而方法异常退出时，返回地址是通过异常处理器表确定的，栈帧中一一般不会保存此部分的信息。</p><h2 id="2-6-实例讲解"><a href="#2-6-实例讲解" class="headerlink" title="2.6 实例讲解"></a>2.6 实例讲解</h2><p>下面用一个<code>add()</code>方法来演示，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">int</span> result = i + j;</span><br><span class="line">  <span class="keyword">return</span> result + <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用javap命令来查看某个类的字节码指令，比如<code>add()</code>方法的代码，经过javap之后的字节码指令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0: iconst_1    （把常量 1 压入操作数栈栈顶）</span><br><span class="line">1: istore_1    （把操作数栈栈顶的出栈放入局部变量表索引为 1 的位置）</span><br><span class="line">2: iconst_2    （把常量 2 压入操作数栈栈顶）</span><br><span class="line">3: istore_2    （把操作数栈栈顶的出栈放入局部变量表索引为 2 的位置）</span><br><span class="line">4: iload_1     （把局部变量表索引为 1 的值放入操作数栈栈顶）</span><br><span class="line">5: iload_2     （把局部变量表索引为 2 的值放入操作数栈栈顶）</span><br><span class="line">6: iadd        （将操作数栈栈顶的和栈顶下面的一个进行加法运算后放入栈顶）</span><br><span class="line">7: istore_3    （把操作数栈栈顶的出栈放入局部变量表索引为 3 的位置）</span><br><span class="line">8: iload_3     （把局部变量表索引为 3 的值放入操作数栈栈顶）</span><br><span class="line">9: bipush 10   （把常量 10 压入操作数栈栈顶）</span><br><span class="line">11: iadd       （将操作数栈栈顶的和栈顶下面的一个进行加法运算后放入栈顶）</span><br><span class="line">12: ireturn    （结束）</span><br></pre></td></tr></table></figure><p>从上面的字节码指令可以看到，其实局部变量表和操作数栈在代码执行期间是协同合作来达到某一运算效果的。接下来通过图示来看以上代码在执行期间，虚拟机栈的实际情况。</p><p>各指令代表的意思：</p><ul><li><strong>iconst和binpush</strong>：这两个指令都是将常量压入操作数栈顶，区别就是：当int取值-1<del>5采用iconst指令，取值-128</del>127采用binpush指令。</li><li><strong>istore</strong>：将操作数栈顶的元素放入局部变量表的某索引位置，比如istore_5表示将操作数栈顶的元素放到局部变量表下标为5的位置。</li><li><strong>iload</strong>：将局部变量表中某下标上的值加载到操作数栈顶中，比如iload_2表示将局部变量表下标为2上的值压入到操作数栈顶。</li><li><strong>iadd</strong>：表示加法运算，具体是将操作数栈顶最上方的两个元素进行相加操作，然后将结果重新压入栈顶。</li></ul><p>首先在<code>Add.java</code>被编译成<code>Add.class</code>时，<strong>栈帧中需要多大的局部变量表，多深的操作数栈已经完全确定了，并且写入到了方法表的Code属性中</strong>。因此这会局部变量表的大小是确定的，<code>add()</code>方法中有三个局部变量，因此局部变量表的大小为3，但是操作数栈此时为空。</p><p>所以代码刚执行到<code>add()</code>方法时，局部变量表和操作数栈的情况如下：</p><img src="/2020/06/10/（拉钩）Android工程师进阶34讲-01：程序运行时，内存到底是如何进行分配的？/实例1.png"><p>iconst_1 把常量1压入操作数栈顶，如下：</p><img src="/2020/06/10/（拉钩）Android工程师进阶34讲-01：程序运行时，内存到底是如何进行分配的？/实例2.png"><p>istore_1 把操作数栈顶的元素出栈并放入局部变量表下标为1的位置，如下：</p><img src="/2020/06/10/（拉钩）Android工程师进阶34讲-01：程序运行时，内存到底是如何进行分配的？/实例3.png"><p><strong>可以看到此时操作数栈重新变为空，并将出栈元素1保存到局部变量表中。</strong></p><p>iconst_2 把常量2压入到操作数栈顶，如下：</p><img src="/2020/06/10/（拉钩）Android工程师进阶34讲-01：程序运行时，内存到底是如何进行分配的？/实例4.png"><p>istore_2 把操作数栈顶的元素出栈并放入到局部变量表下标为2的位置，如下：</p><img src="/2020/06/10/（拉钩）Android工程师进阶34讲-01：程序运行时，内存到底是如何进行分配的？/实例5.png"><p>接下来是iload_1和iload_2。分别表示将局部变量表下标为1和2的元素重新压入操作数栈中，如下：</p><img src="/2020/06/10/（拉钩）Android工程师进阶34讲-01：程序运行时，内存到底是如何进行分配的？/实例6.png"><p>然后进行iadd操作，将栈顶最上方的两个元素进行加法操作，然后将结果重新压入到操作数栈顶，如下：</p><img src="/2020/06/10/（拉钩）Android工程师进阶34讲-01：程序运行时，内存到底是如何进行分配的？/实例7.png"><p>istore_3 将操作数栈顶的元素出栈，保存到局部变量表下标为3的位置，如下：</p><img src="/2020/06/10/（拉钩）Android工程师进阶34讲-01：程序运行时，内存到底是如何进行分配的？/实例8.png"><p>iload_3 将局部变量表下标为3的元素重新压入到操作数栈顶，如下：</p><img src="/2020/06/10/（拉钩）Android工程师进阶34讲-01：程序运行时，内存到底是如何进行分配的？/实例9.png"><p>bipush 10 将常量10压入到操作数栈顶，如下：</p><img src="/2020/06/10/（拉钩）Android工程师进阶34讲-01：程序运行时，内存到底是如何进行分配的？/实例10.png"><p>再次执行iadd操作， 如下：</p><img src="/2020/06/10/（拉钩）Android工程师进阶34讲-01：程序运行时，内存到底是如何进行分配的？/实例11.png"><p>最后执行ireturn指令，将操作数栈顶的元素13返回给上层方法。至此<code>add()</code>方法执行完毕。局部变量表和操作数栈也会被销毁。</p><h1 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3. 本地方法栈"></a>3. 本地方法栈</h1><p>本地方法栈和虚拟机栈基本相同，只不过是针对本地(native)方法。开发中，如果涉及JNI接触本地方法栈会多一些，在有些虚拟机的实现中已经将二者合二为一（比如HotSpot）。</p><h1 id="4-堆"><a href="#4-堆" class="headerlink" title="4. 堆"></a>4. 堆</h1><p>堆(Heap)，是JVM所管理的内存最大的一块，该区域的唯一目的就是存放对象实例，几乎所有的对象的实例都在堆里面分配，因此它也是Java垃圾收集器(GC)管理的主要区域，有时也叫做“GC堆”。同时它也是所有线程共享的内存区域，因此被分配在此区域的对象如果被多个线程访问的话，需要考虑线程安全问题。</p><p>按照对象存储时间的不同，堆中的内存可以划分为<strong>新生代</strong>(Young)和<strong>老年代</strong>(Old)，其中新生代又被划分为Eden和Survivor区。如图：</p><img src="/2020/06/10/（拉钩）Android工程师进阶34讲-01：程序运行时，内存到底是如何进行分配的？/堆.png"><p>图中不同区域存放具有不同生命周期的对象，这样可以根据不同的区域使用不同的垃圾回收算法，从而更具有针对性，进而提高垃圾回收效率。</p><h1 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5. 方法区"></a>5. 方法区</h1><p>方法区(Method Area)，也是JVM规范中规定的一块运行时数据区。方法区主要是存储已经被JVM加载的类信息（版本、字段、方法、接口）、常量、静态变量、即时编译器编译之后的代码和数据。该区域和堆一样，也是被各个线程共享的内存区域。</p><p><strong>注意：关于方法区，会跟“永久区”混淆</strong>。所以在这里对二者进行一下对比：</p><ul><li>方法区是JVM规范中规定的一块区域，但是并不是实际实现，切忌将规范跟实际实现混淆，不同的JVM厂商可以有不同版本的“方法区”的实现。</li><li>HotSpot在JDK 1.7以前使用“永久区”（或者叫Perm区）来实现方法区，在JDK 1.8以后“永久区”就已经被移除了，取而代之的是“元空间(metaspace)”的实现方式。</li></ul><p>总结一下：</p><ul><li>方法区是规范层面的东西，规定了这一区域要存放哪些数据。</li><li>永久区或者是metaspace是对方法区的不同实现，是实现层面的东西。</li></ul><h1 id="6-异常再现"><a href="#6-异常再现" class="headerlink" title="6. 异常再现"></a>6. 异常再现</h1><h2 id="6-1-StackOverflowError-栈溢出异常"><a href="#6-1-StackOverflowError-栈溢出异常" class="headerlink" title="6.1 StackOverflowError 栈溢出异常"></a>6.1 StackOverflowError 栈溢出异常</h2><p>递归调用是造成StackOverflowError的一个常见场景，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackOver</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">StackOver so = <span class="keyword">new</span> StackOver();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">so.method();</span><br><span class="line">&#125; <span class="keyword">catch</span> (StackOverflowError e) &#123;</span><br><span class="line">System.out.println(<span class="string">"栈容量已经溢出！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">number++;</span><br><span class="line">method();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>method()</code>方法中，递归调用了自身，并且没有设置结束条件。运行上述代码时，则会产生StackOverflowError。</p><p>原因就是每调用一次<code>method()</code>方法时，都会在虚拟机栈中创建一个栈帧。因为是递归调用，<code>method()</code>方法并不会退出，也就不会销毁栈帧；所以必然会导致StackOverflowError。因此当使用递归时，要格外注意。</p><h2 id="6-2-OutOfMemoryError-内存溢出异常"><a href="#6-2-OutOfMemoryError-内存溢出异常" class="headerlink" title="6.2 OutOfMemoryError 内存溢出异常"></a>6.2 OutOfMemoryError 内存溢出异常</h2><p>理论上，虚拟机栈、堆、方法区都有可能发生OutOfMemoryError。但实际项目中，大多数发生在堆中。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapError</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">list.add(<span class="keyword">new</span> HeapError());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一个无限循环中，动态向<code>ArrayList</code>中添加新的<code>HeapError</code>对象。这样不断的占用堆的内存，当堆内存不够时，必然产生OutOfMemoryError。</p><h1 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h1><p>对于JVM运行时内存布局，需要记住：上面介绍的5块内容都是在Java虚拟机规范中定义的规则，这些规则只是描述各个区域是负责做什么事情、存储什么样的数据、如何处理异常、是否允许线程间共享等。并不是虚拟机的<strong>“具体实现”</strong>，虚拟机的具体实现很多，比如Sun公司的HotSpot、JRocket、IBM J9，以及Android Dalvik和ART等。这些具体实现符合上面5中运行时数据区的前提下，各自会有不同的实现方式。</p><img src="/2020/06/10/（拉钩）Android工程师进阶34讲-01：程序运行时，内存到底是如何进行分配的？/总结.png"><p>总的来说，JVM的运行时内存结构中一共有两个“栈”和一个“堆”，分别是：Java虚拟机栈和本地方法栈，以及“GC堆”和方法区。除此之外还有一个程序计数器。JVM内存中只有堆和方法区是线程共享的数据区域，其他区域都是线程私有的。并且程序计数器是唯一一个在Java虚拟机规范中没有任何OutOfMemoryError情况的区域。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0. 前言&quot;&gt;&lt;/a&gt;0. 前言&lt;/h1&gt;&lt;p&gt;将Java的内存分为堆内存(Heap)和栈内存(Stack)，这样划分体现了这两块区域时Java工程师最关注的内存区域。
      
    
    </summary>
    
      <category term="Android" scheme="https://tylerLiu.top/categories/Android/"/>
    
      <category term="进阶" scheme="https://tylerLiu.top/categories/Android/%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="JVM与DVM必知必会" scheme="https://tylerLiu.top/tags/JVM%E4%B8%8EDVM%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin系列-01：DSL</title>
    <link href="https://tylerLiu.top/2020/06/04/Kotlin%E7%B3%BB%E5%88%97-01%EF%BC%9ADSL/"/>
    <id>https://tylerLiu.top/2020/06/04/Kotlin系列-01：DSL/</id>
    <published>2020-06-04T05:20:54.000Z</published>
    <updated>2020-06-09T07:11:04.088Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址：<a href="https://www.jianshu.com/p/0766ede7e917" target="_blank" rel="noopener">https://www.jianshu.com/p/0766ede7e917</a></p><h1 id="1-什么是DSL？"><a href="#1-什么是DSL？" class="headerlink" title="1. 什么是DSL？"></a>1. 什么是DSL？</h1><p>DSL是Domin Specific Language，领域特定语言。指的是专注于某个应用程序领域的计算机语言，比如显示网页的HTML、用于数据库处理的SQL、用于检索或替换文本的正则表达式。与DSL相对的是GPL(General Purpose Language)，通用编程语言，如C、Java、Objective-C等。</p><p>DSL分为外部DSL和内部DSL。外部DSL是一种可以独立解析的语言，就像SQL，它专注于数据库的操作；内部DSL是通用语言暴露的用来执行特定任务的API，它利用语言本身的特性，将API以特殊的形式暴露出去，例如Android的Gradel和iOS的依赖管理组件CocosPods，Geadle是基于Groovy的，Groovy是一种通用语言，但是Gradle基于Groovy的语言，构建了自己的一套DSL，所以在配置Gradle时，必须遵循Groovy的语法，还要遵循Gradle的DSL标准。</p><p><strong>Android的Gradle</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'com.android.application'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'kotlin-android'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'kotlin-android-extensions'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'kotlin-kapt'</span></span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion <span class="number">28</span></span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId <span class="string">"com.tanjiajun.androidgenericframework"</span></span><br><span class="line">        minSdkVersion rootProject.minSdkVersion</span><br><span class="line">        targetSdkVersion rootProject.targetSdkVersion</span><br><span class="line">        versionCode <span class="number">1</span></span><br><span class="line">        versionName <span class="string">"1.0"</span></span><br><span class="line">        testInstrumentationRunner <span class="string">"androidx.test.runner.AndroidJUnitRunner"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="literal">false</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android-optimize.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    androidExtensions &#123;</span><br><span class="line">        experimental = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dataBinding &#123;</span><br><span class="line">        enabled = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    packagingOptions &#123;</span><br><span class="line">        pickFirst <span class="string">'META-INF/kotlinx-io.kotlin_module'</span></span><br><span class="line">        pickFirst <span class="string">'META-INF/atomicfu.kotlin_module'</span></span><br><span class="line">        pickFirst <span class="string">'META-INF/kotlinx-coroutines-io.kotlin_module'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>iOS的Podfile文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">source &apos;https://github.com/CocoaPods/Specs.git&apos;</span><br><span class="line"></span><br><span class="line">platform :ios, &apos;10.0&apos;</span><br><span class="line"></span><br><span class="line">use_frameworks!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">target &apos;GenericFrameworkForiOS&apos; **do**</span><br><span class="line"></span><br><span class="line">​    pod &apos;SnapKit&apos;, &apos;~&gt; 4.0&apos;</span><br><span class="line"></span><br><span class="line">**end**</span><br></pre></td></tr></table></figure><h1 id="2-实现原理"><a href="#2-实现原理" class="headerlink" title="2. 实现原理"></a>2. 实现原理</h1><p>本文主要讲Kotlin的DSL，先来了解一个概念和语法。</p><h2 id="2-1-扩展函数"><a href="#2-1-扩展函数" class="headerlink" title="2.1 扩展函数"></a>2.1 扩展函数</h2><p>声明一个扩展函数，需要用到一个接受者类型(receiver type)，也就是被扩展的类型作为前缀，如下：</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Activity.<span class="title">getViewModelFactory</span><span class="params">()</span></span>: ViewModelFactory = ViewModelFactory((applicationContext <span class="keyword">as</span> AndroidGenericFrameworkApplication).userRepository)</span><br></pre></td></tr></table></figure><p>声明一个<code>getViewModelFactory()</code>函数，它是<code>Activity</code>的扩展函数。</p><h2 id="2-2-Lambda表达式"><a href="#2-2-Lambda表达式" class="headerlink" title="2.2 Lambda表达式"></a>2.2 Lambda表达式</h2><p>Java 8以下不支持Lambda表达式，Kotlin解决了与Java的互操作性，Kotlin的Lambda表达式以更加简洁的语法实现功能，使开发者从冗余的语法中解放出来。</p><h2 id="2-3-Lambda表达式分类"><a href="#2-3-Lambda表达式分类" class="headerlink" title="2.3 Lambda表达式分类"></a>2.3 Lambda表达式分类</h2><h3 id="2-3-1-普通Lambda表达式"><a href="#2-3-1-普通Lambda表达式" class="headerlink" title="2.3.1 普通Lambda表达式"></a>2.3.1 普通Lambda表达式</h3><p>不接受任何参数返回Uint的Lambda表达式</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() -&gt; <span class="built_in">Unit</span></span><br></pre></td></tr></table></figure><p>接受一个可空的<code>TabLayout.Tab</code>参数，返回Unit的Lambda表达式</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(tab: TabLayout.Tab?) -&gt; <span class="built_in">Unit</span></span><br></pre></td></tr></table></figure><h3 id="2-3-2-带接收者的Lambda表达式"><a href="#2-3-2-带接收者的Lambda表达式" class="headerlink" title="2.3.2 带接收者的Lambda表达式"></a>2.3.2 带接收者的Lambda表达式</h3><p>带有<code>OnTabSlectedListenerBuilder</code>接收者对象，不接受任何参数返回的Unit的Lambda表达式。这种带接收者的在Kotlin的标准库函数中很常见，如下的作用域函数(Scope Functions)：</p><p><strong>appyl函数</strong></p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Calls the specified function [block] with `this` value as its receiver and returns `this` value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#apply).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">apply</span><span class="params">(block: <span class="type">T</span>.()</span></span> -&gt; <span class="built_in">Unit</span>): T &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    block()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>let函数</strong></p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Calls the specified function [block] with `this` value as its argument and returns its result.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#let).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">let</span><span class="params">(block: (<span class="type">T</span>)</span></span> -&gt; R): R &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> block(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以给这些Lambda表达式起别称，叫做类别名(Type aliases)。</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">typealias</span> OnTabCallback = (tab: TabLayout.Tab?) -&gt; <span class="built_in">Unit</span></span><br></pre></td></tr></table></figure><p>这里给Lambda表达式起了别称，叫<code>OnTabCallback</code>。</p><p>Lambda表达式在Kotlin里的这些特性是实现DSL的必备语法糖。</p><h2 id="2-4-函数类型实例调用"><a href="#2-4-函数类型实例调用" class="headerlink" title="2.4 函数类型实例调用"></a>2.4 函数类型实例调用</h2><p>Kotlin提供invoke函数，可以这样写：<code>f.invoke(x)</code>，相当于<code>f(x)</code>，例如：</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onTabReselectedCallback?.invoke(tab) ?: <span class="built_in">Unit</span></span><br></pre></td></tr></table></figure><p>也可以写成这样：</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onTabReselectedCallback?.let&#123; it(tab) &#125; ?: <span class="built_in">Unit</span></span><br></pre></td></tr></table></figure><h2 id="2-5-中缀表示法"><a href="#2-5-中缀表示法" class="headerlink" title="2.5 中缀表示法"></a>2.5 中缀表示法</h2><p>标有<code>infix</code>关键字的函数可以使用中缀表示法（忽略该调用的点和圆括号）调用，中缀函数必须满足以下条件：</p><ul><li>1、它们必须是成员函数和扩展函数。</li><li>2、它们必须只有一个参数。</li><li>3、其参数不得接受可变数量的参数，而且不能有默认值。</li></ul><p>例子：</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="title">plus</span><span class="params">(x: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = <span class="keyword">this</span>.plus(x)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以中缀表示法调用函数</span></span><br><span class="line"><span class="number">1</span> plus <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="number">1</span>.plus(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>常用的函数：</p><p><strong>until函数用法</strong></p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(int <span class="number">0</span> until <span class="number">4</span>)&#123;</span><br><span class="line">    tlOrder.addTab(tlOrder.newTab().setText(<span class="string">"订单<span class="variable">$i</span>"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>until函数源码</strong></p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a range from this value up to but excluding the specified [to] value.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * If the [to] value is less than or equal to `this` value, then the returned range is empty.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">infix</span>  <span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="title">until</span><span class="params">(to: <span class="type">Int</span>)</span></span>: IntRange&#123;</span><br><span class="line">    <span class="keyword">if</span>(to &lt;= <span class="built_in">Int</span>.MIN_VALUE) <span class="keyword">return</span> IntRange.EMPTY</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span> .. (to -<span class="number">1</span>).toInt()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>to函数的用法</strong></p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapOf&lt;String, Any&gt;(<span class="string">"name"</span> to <span class="string">"Tyler"</span>, <span class="string">"age"</span> to <span class="number">30</span>)</span><br></pre></td></tr></table></figure><p><strong>to函数的源码</strong></p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a tuple of type [Pair] from this and [that].</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This can be useful for creating [Map] literals with less noise, for example:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@sample</span> samples.collections.Maps.Instantiation.mapFromPairs</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;A, B&gt;</span> A.<span class="title">to</span><span class="params">(that: <span class="type">B</span>)</span></span>: Pair&lt;A, B&gt; = Pair(<span class="keyword">this</span>, that)</span><br></pre></td></tr></table></figure><h1 id="3-实践"><a href="#3-实践" class="headerlink" title="3. 实践"></a>3. 实践</h1><p>Kotlin DSL使代码更加简洁，更加优雅，而且还很有想象力。</p><h2 id="3-1-回调处理"><a href="#3-1-回调处理" class="headerlink" title="3.1 回调处理"></a>3.1 回调处理</h2><h3 id="3-1-1-Java中的回调实现"><a href="#3-1-1-Java中的回调实现" class="headerlink" title="3.1.1 Java中的回调实现"></a>3.1.1 Java中的回调实现</h3><p>实现步骤：</p><ul><li>1、定义一个接口</li><li>2、在接口定义一些回调方法</li><li>3、定义一个设置回调接口的方法，这个方法的参数是回调接口的实例，一般以匿名对象的形式存在。</li></ul><p><strong>实现TextWatcher接口</strong></p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">EditText etCommonCallbackContent = findViewById(R.id.et_common_callback_content);</span><br><span class="line">etCommonCallbackContent.addTextChangedListener(new TextWatcher() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> void beforeTextChanged(CharSequence s, int start, int count, int after) &#123;</span><br><span class="line">        <span class="comment">// no implementation</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> void onTextChanged(CharSequence s, int start, int before, int count) &#123;</span><br><span class="line">        <span class="comment">// no implementation</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> void afterTextChanged(Editable s) &#123;</span><br><span class="line">        <span class="comment">// no implementation</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>实现TabLayout.OnTabSelectedListener接口</strong></p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">TabLayout tlOrder = findViewById(R.id.tl_order);</span><br><span class="line">tlOrder.addOnTabSelectedListener(new TabLayout.OnTabSelectedListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> void onTabSelected(TabLayout.Tab tab) &#123;</span><br><span class="line">        <span class="comment">// no implementation</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> void onTabUnselected(TabLayout.Tab tab) &#123;</span><br><span class="line">        <span class="comment">// no implementation</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> void onTabReselected(TabLayout.Tab tab) &#123;</span><br><span class="line">        <span class="comment">// no implementation</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="3-1-2-Kotlin中的回调实现"><a href="#3-1-2-Kotlin中的回调实现" class="headerlink" title="3.1.2 Kotlin中的回调实现"></a>3.1.2 Kotlin中的回调实现</h3><p><strong>实现TextWatcher接口</strong></p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">findViewById&lt;EditText&gt;(R.id.et_common_callback_content).addTextChangedListener(<span class="keyword">object</span> :</span><br><span class="line">    TextWatcher &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">beforeTextChanged</span><span class="params">(s: <span class="type">CharSequence</span>?, start: <span class="type">Int</span>, count: <span class="type">Int</span>, after: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// no implementation</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTextChanged</span><span class="params">(s: <span class="type">CharSequence</span>?, start: <span class="type">Int</span>, before: <span class="type">Int</span>, count: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// no implementation</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">afterTextChanged</span><span class="params">(s: <span class="type">Editable</span>?)</span></span> &#123;</span><br><span class="line">        tvCommonCallbackContent.text = s</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>实现TabLayout.OnTabSelectedListener接口</strong></p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">tlOrder.addOnTabSelectedListener(<span class="keyword">object</span> : TabLayout.OnTabSelectedListener&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTabReselected</span><span class="params">(tab: <span class="type">TabLayout</span>.<span class="type">Tab</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">// no implementation</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTabUnselected</span><span class="params">(tab: <span class="type">TabLayout</span>.<span class="type">Tab</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">// no implementation</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTabSelected</span><span class="params">(tab: <span class="type">TabLayout</span>.<span class="type">Tab</span>?)</span></span> &#123;</span><br><span class="line">        vpOrder.currentItem = tab?.position ?: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="3-1-2-Kotlin-DSL"><a href="#3-1-2-Kotlin-DSL" class="headerlink" title="3.1.2 Kotlin DSL"></a>3.1.2 Kotlin DSL</h3><p><strong>TextWatcherBuilder</strong></p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tanjiajun.kotlindsldemo</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.text.Editable</span><br><span class="line"><span class="keyword">import</span> android.text.TextWatcher</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">typealias</span> BeforeTextChangedCallback =</span><br><span class="line">            (s: CharSequence?, start: <span class="built_in">Int</span>, count: <span class="built_in">Int</span>, after: <span class="built_in">Int</span>) -&gt; <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">typealias</span> OnTextChangedCallback =</span><br><span class="line">            (s: CharSequence?, start: <span class="built_in">Int</span>, before: <span class="built_in">Int</span>, count: <span class="built_in">Int</span>) -&gt; <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">typealias</span> AfterTextChangedCallback = (s: Editable?) -&gt; <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextWatcherBuilder</span> : <span class="type">TextWatcher &#123;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> beforeTextChangedCallback: BeforeTextChangedCallback? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> onTextChangedCallback: OnTextChangedCallback? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> afterTextChangedCallback: AfterTextChangedCallback? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">beforeTextChanged</span><span class="params">(s: <span class="type">CharSequence</span>?, start: <span class="type">Int</span>, count: <span class="type">Int</span>, after: <span class="type">Int</span>)</span></span> =</span><br><span class="line">        beforeTextChangedCallback?.invoke(s, start, count, after) ?: <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTextChanged</span><span class="params">(s: <span class="type">CharSequence</span>?, start: <span class="type">Int</span>, before: <span class="type">Int</span>, count: <span class="type">Int</span>)</span></span> =</span><br><span class="line">        onTextChangedCallback?.invoke(s, start, before, count) ?: <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">afterTextChanged</span><span class="params">(s: <span class="type">Editable</span>?)</span></span> =</span><br><span class="line">        afterTextChangedCallback?.invoke(s) ?: <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">beforeTextChanged</span><span class="params">(callback: <span class="type">BeforeTextChangedCallback</span>)</span></span> &#123;</span><br><span class="line">        beforeTextChangedCallback = callback</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onTextChanged</span><span class="params">(callback: <span class="type">OnTextChangedCallback</span>)</span></span> &#123;</span><br><span class="line">        onTextChangedCallback = callback</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">afterTextChanged</span><span class="params">(callback: <span class="type">AfterTextChangedCallback</span>)</span></span> &#123;</span><br><span class="line">        afterTextChangedCallback = callback</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">registerTextWatcher</span><span class="params">(function: <span class="type">TextWatcherBuilder</span>.()</span></span> -&gt; <span class="built_in">Unit</span>) =</span><br><span class="line">    TextWatcherBuilder().also(function)</span><br></pre></td></tr></table></figure><p><strong>onTabSelectedListenerBuilder</strong></p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tanjiajun.androidgenericframework.utils</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.android.material.tabs.TabLayout</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">typealias</span> OnTabCallback = (tab: TabLayout.Tab?) -&gt; <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OnTabSelectedListenerBuilder</span> : <span class="type">TabLayout.OnTabSelectedListener &#123;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> onTabReselectedCallback: OnTabCallback? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> onTabUnselectedCallback: OnTabCallback? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> onTabSelectedCallback: OnTabCallback? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTabReselected</span><span class="params">(tab: <span class="type">TabLayout</span>.<span class="type">Tab</span>?)</span></span> =</span><br><span class="line">            onTabReselectedCallback?.invoke(tab) ?: <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTabUnselected</span><span class="params">(tab: <span class="type">TabLayout</span>.<span class="type">Tab</span>?)</span></span> =</span><br><span class="line">            onTabUnselectedCallback?.invoke(tab) ?: <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTabSelected</span><span class="params">(tab: <span class="type">TabLayout</span>.<span class="type">Tab</span>?)</span></span> =</span><br><span class="line">            onTabSelectedCallback?.invoke(tab) ?: <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onTabReselected</span><span class="params">(callback: <span class="type">OnTabCallback</span>)</span></span> &#123;</span><br><span class="line">        onTabReselectedCallback = callback</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onTabUnselected</span><span class="params">(callback: <span class="type">OnTabCallback</span>)</span></span> &#123;</span><br><span class="line">        onTabUnselectedCallback = callback</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onTabSelected</span><span class="params">(callback: <span class="type">OnTabCallback</span>)</span></span> &#123;</span><br><span class="line">        onTabSelectedCallback = callback</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">registerOnTabSelectedListener</span><span class="params">(function: <span class="type">OnTabSelectedListenerBuilder</span>.()</span></span> -&gt; <span class="built_in">Unit</span>) =</span><br><span class="line">        OnTabSelectedListenerBuilder().also(function)</span><br></pre></td></tr></table></figure><p>一般步骤：</p><ul><li>1、先定义一个类去实现回调接口，并实现它的回调方法</li><li>2、观察回调方法的参数，提取成一个函数模型（function type），并且按照需要使用类型别名给函数类型起一个别称，并且用私有修饰。</li><li>3、在类里面声明一些可空的函数类型的可变(<code>var</code>)私有成员变量，并且在回调函数中拿到对应的变量实现它的<code>invoke()</code>函数，传入对应的参数。</li><li>4、在类中定义定义一些和回调接口一样的名字，但是参数是对应的函数类型的函数，并且将函数类型赋值给当前类的对应的成员变量。</li><li>5、定义一个成员函数，参数是一个带有定义好的那个类的接受者对象并返回<code>Unit</code>的Lambda表达式，在函数里创建相应的对象，并且使用<code>also</code>函数把Lambda表达式传出去。</li></ul><p>如何使用？如下：<br><strong>TextWatcher</strong></p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">findViewById&lt;EditText&gt;(R.id.et_dsl_callback_content).addTextChangedListener(</span><br><span class="line">    registerTextWatcher &#123;</span><br><span class="line">        afterTextChanged &#123; tvDSLCallbackContent.text = it &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p><strong>Tablayout.OnTabSelectedListener</strong></p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tlOrder.addOnTabSelectedListener(registerOnTabSelectedListener &#123;</span><br><span class="line">    onTabSelected &#123; vpOrder.currentItem = it?.position ?: <span class="number">0</span> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>简化之前代码如下：</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">findViewById&lt;EditText&gt;(R.id.et_dsl_callback_content).addTextChangedListener(registerTextWatcher(&#123;</span><br><span class="line">    <span class="keyword">this</span>.afterTextChanged(&#123; s: Editable? -&gt;</span><br><span class="line">        tvDSLCallbackContent.text = s</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><p>Kotlin语法规定，如果函数最后一个参数是Lambda表达式的话，可以提到小括号外面，同时小括号也可以省略，然后Kotlin可以自己推导出参数的类型，并且使用默认参数<code>it</code>代替命名参数，然后因为这是个带接收者的Lambda表达式，所以可以用<code>this</code>拿到对象，并且调用它的<code>afterTextChanged()</code>函数，最后就得到简化后的代码。</p><h3 id="3-1-3-object对象表达式回调和DSL回调对比"><a href="#3-1-3-object对象表达式回调和DSL回调对比" class="headerlink" title="3.1.3 object对象表达式回调和DSL回调对比"></a>3.1.3 object对象表达式回调和DSL回调对比</h3><ul><li>1、DSL写法比object写法会更加符合Kotlin风格。</li><li>2、object写法要实现所有方法，DSL写法可以按照需要实现想要的方法。</li><li>3、从性能上对比，DSL写法对每个回调函数都会创建Lambda表达式的实例对象，而object写法不管有多少个回调方法，都只生成一个匿名对象实例，所以object写法比DSL写法性能好。</li></ul><p>这里拿<code>TextWatcher</code>举例，将它们反编译成Java代码，代码如下：</p><p><strong>object对象表达式回调</strong></p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">((EditText)<span class="keyword">this</span>.findViewById(-<span class="number">1000084</span>)).addTextChangedListener((TextWatcher)(new TextWatcher() &#123;</span><br><span class="line">   <span class="keyword">public</span> void beforeTextChanged(<span class="meta">@Nullable</span> CharSequence s, int start, int count, int after) &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> void onTextChanged(<span class="meta">@Nullable</span> CharSequence s, int start, int before, int count) &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> void afterTextChanged(<span class="meta">@Nullable</span> Editable s) &#123;</span><br><span class="line">      TextView var10000 = tvCommonCallbackContent;</span><br><span class="line">      Intrinsics.checkExpressionValueIsNotNull(var10000, <span class="string">"tvCommonCallbackContent"</span>);</span><br><span class="line">      var10000.setText((CharSequence)s);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p><strong>DSL回调</strong></p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">((EditText)<span class="keyword">this</span>.findViewById(-<span class="number">1000121</span>)).addTextChangedListener((TextWatcher)TextWatcherBuilderKt.registerTextWatcher((Function1)(new Function1() &#123;</span><br><span class="line">   <span class="comment">// $FF: synthetic method</span></span><br><span class="line">   <span class="comment">// $FF: bridge method</span></span><br><span class="line">   <span class="keyword">public</span> Object invoke(Object var1) &#123;</span><br><span class="line">      <span class="keyword">this</span>.invoke((TextWatcherBuilder)var1);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Unit</span>.INSTANCE;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> void invoke(<span class="meta">@NotNull</span> TextWatcherBuilder $<span class="keyword">this</span>$registerTextWatcher) &#123;</span><br><span class="line">      Intrinsics.checkParameterIsNotNull($<span class="keyword">this</span>$registerTextWatcher, <span class="string">"<span class="variable">$receiver</span>"</span>);</span><br><span class="line">      $<span class="keyword">this</span>$registerTextWatcher.beforeTextChanged((Function4)(new Function4() &#123;</span><br><span class="line">         <span class="comment">// $FF: synthetic method</span></span><br><span class="line">         <span class="comment">// $FF: bridge method</span></span><br><span class="line">         <span class="keyword">public</span> Object invoke(Object var1, Object var2, Object var3, Object var4) &#123;</span><br><span class="line">            <span class="keyword">this</span>.invoke((CharSequence)var1, ((Number)var2).intValue(), ((Number)var3).intValue(), ((Number)var4).intValue());</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Unit</span>.INSTANCE;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">final</span> void invoke(<span class="meta">@Nullable</span> CharSequence s, int start, int count, int after) &#123;</span><br><span class="line">            TextView var10000 = tvDSLCallbackContent;</span><br><span class="line">            Intrinsics.checkExpressionValueIsNotNull(var10000, <span class="string">"tvDSLCallbackContent"</span>);</span><br><span class="line">            var10000.setText(s);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;));</span><br><span class="line">      $<span class="keyword">this</span>$registerTextWatcher.onTextChanged((Function4)(new Function4() &#123;</span><br><span class="line">         <span class="comment">// $FF: synthetic method</span></span><br><span class="line">         <span class="comment">// $FF: bridge method</span></span><br><span class="line">         <span class="keyword">public</span> Object invoke(Object var1, Object var2, Object var3, Object var4) &#123;</span><br><span class="line">            <span class="keyword">this</span>.invoke((CharSequence)var1, ((Number)var2).intValue(), ((Number)var3).intValue(), ((Number)var4).intValue());</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Unit</span>.INSTANCE;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">final</span> void invoke(<span class="meta">@Nullable</span> CharSequence s, int start, int before, int count) &#123;</span><br><span class="line">            TextView var10000 = tvDSLCallbackContent;</span><br><span class="line">            Intrinsics.checkExpressionValueIsNotNull(var10000, <span class="string">"tvDSLCallbackContent"</span>);</span><br><span class="line">            var10000.setText(s);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;));</span><br><span class="line">      $<span class="keyword">this</span>$registerTextWatcher.afterTextChanged((Function1)(new Function1() &#123;</span><br><span class="line">         <span class="comment">// $FF: synthetic method</span></span><br><span class="line">         <span class="comment">// $FF: bridge method</span></span><br><span class="line">         <span class="keyword">public</span> Object invoke(Object var1) &#123;</span><br><span class="line">            <span class="keyword">this</span>.invoke((Editable)var1);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Unit</span>.INSTANCE;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">final</span> void invoke(<span class="meta">@Nullable</span> Editable it) &#123;</span><br><span class="line">            TextView var10000 = tvDSLCallbackContent;</span><br><span class="line">            Intrinsics.checkExpressionValueIsNotNull(var10000, <span class="string">"tvDSLCallbackContent"</span>);</span><br><span class="line">            var10000.setText((CharSequence)it);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)));</span><br></pre></td></tr></table></figure><p>可以看到<strong>object写法</strong>只生成一个匿名的<code>TextWathcer</code>对象实例，而<strong>DSL写法</strong>对每个回调函数都会创建Lambda表达式的实例对象(<code>Function1</code>、<code>Founction4</code>)，符合上述预期。</p><h2 id="3-2-题外话"><a href="#3-2-题外话" class="headerlink" title="3.2 题外话"></a>3.2 题外话</h2><p>Java8引入了<code>default</code>关键字，在接口中可以包含一些默认的方法实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Handlers</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onLoginClick</span><span class="params">(View view)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">onLogoutClick</span><span class="params">(View view)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用Kotlin实现的话，可以加上<code>@JvmDefault</code>注解，如下：</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Handlers</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onLoginClick</span><span class="params">(view: <span class="type">View</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@JvmDefault</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onLogoutClick</span><span class="params">(view: <span class="type">View</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以反编译成Java代码，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Metadata</span>(</span><br><span class="line">   mv = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">15</span>&#125;,</span><br><span class="line">   bv = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>&#125;,</span><br><span class="line">   k = <span class="number">1</span>,</span><br><span class="line">   d1 = &#123;<span class="string">"\u0000\u0018\n\u0002\u0018\u0002\n\u0002\u0010\u0000\n\u0000\n\u0002\u0010\u0002\n\u0000\n\u0002\u0018\u0002\n\u0002\b\u0002\bf\u0018\u00002\u00020\u0001J\u0010\u0010\u0002\u001a\u00020\u00032\u0006\u0010\u0004\u001a\u00020\u0005H&amp;J\u0010\u0010\u0006\u001a\u00020\u00032\u0006\u0010\u0004\u001a\u00020\u0005H\u0017ø\u0001\u0000\u0082\u0002\u0007\n\u0005\b\u0091(0\u0001¨\u0006\u0007"</span>&#125;,</span><br><span class="line">   d2 = &#123;<span class="string">"Lcom/tanjiajun/kotlindsldemo/MainActivity$Handlers;"</span>, <span class="string">""</span>, <span class="string">"onLoginClick"</span>, <span class="string">""</span>, <span class="string">"view"</span>, <span class="string">"Landroid/view/View;"</span>, <span class="string">"onLogoutClick"</span>, <span class="string">"app_debug"</span>&#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Handlers</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">onLoginClick</span><span class="params">(@NotNull View var1)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@JvmDefault</span></span><br><span class="line">   <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">onLogoutClick</span><span class="params">(@NotNull View view)</span> </span>&#123;</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(view, <span class="string">"view"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用<code>@JvmDefault</code>时，需要注意：</p><p>因为<code>default</code>关键字是Java8才引入的，所以需要做一些特殊处理，从Kotlin官方文档可以看到：<br><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-jvm-default/" target="_blank" rel="noopener">https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-jvm-default/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Specifies that a JVM default method should be generated for non-abstract Kotlin interface member.</span><br><span class="line"></span><br><span class="line">Usages of this annotation require an explicit compilation argument to be specified: either -Xjvm-default=enable or -Xjvm-default=compatibility.</span><br><span class="line"></span><br><span class="line">· with -Xjvm-default=enable, only default method in interface is generated for each @JvmDefault method. In this mode, annotating an existing method with @JvmDefault can break binary compatibility, because it will effectively remove the method from the DefaultImpls class.</span><br><span class="line">· with -Xjvm-default=compatibility, in addition to the default interface method, a compatibility accessor is generated in the DefaultImpls class, that calls the default interface method via a synthetic accessor. In this mode, annotating an existing method with @JvmDefault is binary compatible, but results in more methods in bytecode.</span><br><span class="line">Removing this annotation from an interface member is a binary incompatible change in both modes.</span><br><span class="line"></span><br><span class="line">Generation of default methods is only possible with JVM target bytecode version 1.8 (-jvm-target 1.8) or higher.</span><br><span class="line"></span><br><span class="line">@JvmDefault methods are excluded from interface delegation.</span><br></pre></td></tr></table></figure><p>翻译：</p><ul><li>1、只有使用JVM目标字节码1.8版本或者更高，才可以生成<code>default</code>方法。</li><li>2、使用这个注解还要指定一个显示的编译参数：<code>-Xjvm-default=enable</code>或<code>-Xjvm-default=compatibility</code>（兼容性），使用<code>-Xjvm-default=enable</code>的话对于每个<code>@JvmDefault</code>方法，仅仅是生成<code>default</code>方法，同时这样做可能会破坏二进制兼容性，因为它从<code>DefaultImpls</code>类中删除该方法；使用<code>-Xjvm-default=compatibility</code>的话，除了生成<code>default</code>方法之外，还将<code>defaultImpls</code>类中生成兼容性访问器，该访问器通过综合访问器调用<code>default</code>方法，在这种模式下，它是二进制兼容的，但是会导致字节码中有更多的方法。</li></ul><p>在<code>build.gradle</code>文件中加入如下代码：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">allprojects</span> &#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).all &#123;</span><br><span class="line">        kotlinOptions &#123;</span><br><span class="line">            jvmTarget = <span class="string">'1.8'</span></span><br><span class="line">            freeCompilerArgs += <span class="string">'-Xjvm-default=compatibility'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面尝试上面的两种方法，看看是否符合预期，代码如下：</p><p><strong>加上<code>-Xjvm-default=enable</code>后反编译的代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Metadata</span>(</span><br><span class="line">    mv = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">15</span>&#125;,</span><br><span class="line">    bv = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    k = <span class="number">1</span>,</span><br><span class="line">    d1 = &#123;<span class="string">"\u0000\u0018\n\u0002\u0018\u0002\n\u0002\u0010\u0000\n\u0000\n\u0002\u0010\u0002\n\u0000\n\u0002\u0018\u0002\n\u0002\b\u0002\bf\u0018\u00002\u00020\u0001J\u0010\u0010\u0002\u001a\u00020\u00032\u0006\u0010\u0004\u001a\u00020\u0005H&amp;J\u0010\u0010\u0006\u001a\u00020\u00032\u0006\u0010\u0004\u001a\u00020\u0005H\u0017ø\u0001\u0000\u0082\u0002\u0007\n\u0005\b\u0091(0\u0001¨\u0006\u0007"</span>&#125;,</span><br><span class="line">    d2 = &#123;<span class="string">"Lcom/tanjiajun/kotlindsldemo/MainActivity$Handlers;"</span>, <span class="string">""</span>, <span class="string">"onLoginClick"</span>, <span class="string">""</span>, <span class="string">"view"</span>, <span class="string">"Landroid/view/View;"</span>, <span class="string">"onLogoutClick"</span>, <span class="string">"app_debug"</span>&#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Handlers</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onLoginClick</span><span class="params">(@NotNull View var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JvmDefault</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">onLogoutClick</span><span class="params">(@NotNull View view)</span> </span>&#123;</span><br><span class="line">       Intrinsics.checkParameterIsNotNull(view, <span class="string">"view"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>加上<code>-Xjvm-default=compatibility</code>后反编译的代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Metadata</span>(</span><br><span class="line">    mv = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">15</span>&#125;,</span><br><span class="line">    bv = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    k = <span class="number">1</span>,</span><br><span class="line">    d1 = &#123;<span class="string">"\u0000\u0018\n\u0002\u0018\u0002\n\u0002\u0010\u0000\n\u0000\n\u0002\u0010\u0002\n\u0000\n\u0002\u0018\u0002\n\u0002\b\u0002\bf\u0018\u00002\u00020\u0001J\u0010\u0010\u0002\u001a\u00020\u00032\u0006\u0010\u0004\u001a\u00020\u0005H&amp;J\u0010\u0010\u0006\u001a\u00020\u00032\u0006\u0010\u0004\u001a\u00020\u0005H\u0017ø\u0001\u0000\u0082\u0002\u0007\n\u0005\b\u0091(0\u0001¨\u0006\u0007"</span>&#125;,</span><br><span class="line">    d2 = &#123;<span class="string">"Lcom/tanjiajun/kotlindsldemo/MainActivity$Handlers;"</span>, <span class="string">""</span>, <span class="string">"onLoginClick"</span>, <span class="string">""</span>, <span class="string">"view"</span>, <span class="string">"Landroid/view/View;"</span>, <span class="string">"onLogoutClick"</span>, <span class="string">"app_debug"</span>&#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Handlers</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onLoginClick</span><span class="params">(@NotNull View var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JvmDefault</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">onLogoutClick</span><span class="params">(@NotNull View view)</span> </span>&#123;</span><br><span class="line">       Intrinsics.checkParameterIsNotNull(view, <span class="string">"view"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Metadata</span>(</span><br><span class="line">       mv = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">15</span>&#125;,</span><br><span class="line">       bv = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>&#125;,</span><br><span class="line">       k = <span class="number">3</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultImpls</span> </span>&#123;</span><br><span class="line">       <span class="meta">@JvmDefault</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onLogoutClick</span><span class="params">(MainActivity.Handlers $<span class="keyword">this</span>, @NotNull View view)</span> </span>&#123;</span><br><span class="line">          $<span class="keyword">this</span>.onLogoutClick(view);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到加上了<code>-Xjvm-default=compatibility</code>要比<code>-Xjvm-default=enable</code>多了一个<code>DefaultImpls</code>的静态<code>final</code>类，而且类中也有一个静态方法，其实<code>-Xjvm-default=compatibility</code>是为了兼容Java8之前的版本在接口中也可以实现方法。</p><p><strong>Spek</strong></p><p>spek是一个为Kotlin打造的测试框架。</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Verify Check Email Valid"</span>) &#123;</span><br><span class="line">    it(<span class="string">"Email Is Null"</span>) &#123;</span><br><span class="line">        presenter.checkEmailValid(<span class="string">""</span>)</span><br><span class="line">        verify &#123; viewRenderer.showEmailEmptyError() &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    it(<span class="string">"Email Is Not Null and Is Not Valid"</span>) &#123;</span><br><span class="line">        presenter.checkEmailValid(<span class="string">"ktan"</span>)</span><br><span class="line">        verify &#123; viewRenderer.showEmailInvalidError() &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    it(<span class="string">"Email Is Not Null and Is Valid"</span>) &#123;</span><br><span class="line">        presenter.checkEmailValid(<span class="string">"ktan@xogrp.com"</span>)</span><br><span class="line">        verify &#123; viewRenderer.hideEmailError() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Github：<a href="https://github.com/spekframework/spek" target="_blank" rel="noopener">Spek</a></p><p><strong>KxDate</strong></p><p>一个日期处理库，可以写出类似于英语句子的代码：</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> twoMonthsLater = <span class="number">2</span> months fromNow</span><br><span class="line"><span class="keyword">val</span> yesterday = <span class="number">1</span> days ago</span><br></pre></td></tr></table></figure><p>Github：<a href="https://github.com/yole/kxdate" target="_blank" rel="noopener">KxDate</a></p><p><strong>Anko</strong></p><p>一个专门针对Android开发的Kotlin库，可以这样写：</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">verticalLayout &#123;</span><br><span class="line">    <span class="keyword">val</span> name = editText()</span><br><span class="line">    button(<span class="string">"Say Hello"</span>) &#123;</span><br><span class="line">        onClick &#123; toast(<span class="string">"Hello, <span class="subst">$&#123;name.text&#125;</span>!"</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Github：<a href="https://github.com/Kotlin/anko" target="_blank" rel="noopener">Anko</a></p><p><a href="https://gitee.com/QingFengBaiYu/KotlinDSLDemo" target="_blank" rel="noopener">Demo地址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文地址：&lt;a href=&quot;https://www.jianshu.com/p/0766ede7e917&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/0766ede7e917&lt;/a&gt;&lt;/p&gt;
&lt;h1 i
      
    
    </summary>
    
      <category term="Android" scheme="https://tylerLiu.top/categories/Android/"/>
    
      <category term="Kotlin" scheme="https://tylerLiu.top/categories/Android/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="https://tylerLiu.top/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Android网络优化-02：网络基础（下）</title>
    <link href="https://tylerLiu.top/2020/06/02/Android%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96-02%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>https://tylerLiu.top/2020/06/02/Android网络优化-02：网络基础（下）/</id>
    <published>2020-06-02T01:26:23.000Z</published>
    <updated>2020-06-03T09:31:01.776Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址：<a href="https://juejin.im/post/5ebb3db16fb9a0438e2396af" target="_blank" rel="noopener">https://juejin.im/post/5ebb3db16fb9a0438e2396af</a></p><h1 id="8-网络层"><a href="#8-网络层" class="headerlink" title="8. 网络层"></a>8. 网络层</h1><h2 id="8-1-网络层主要功能"><a href="#8-1-网络层主要功能" class="headerlink" title="8.1 网络层主要功能"></a>8.1 网络层主要功能</h2><p>数据路由。</p><h2 id="8-2-IP协议"><a href="#8-2-IP协议" class="headerlink" title="8.2 IP协议"></a>8.2 IP协议</h2><h3 id="8-2-1-IP协议拆解"><a href="#8-2-1-IP协议拆解" class="headerlink" title="8.2.1 IP协议拆解"></a>8.2.1 IP协议拆解</h3><p><strong>虚拟互联网络</strong></p><ul><li>1、实际的计算机网络是错综复杂的。</li><li>2、物理设备通过使用IP协议，屏蔽了物理网络之间的差异。</li><li>3、当网络中的主机IP协议连接时，则无需关心网络细节，</li></ul><p>计算机A与B之间的数据通信可以认为是通过一个虚拟的互联网络进行传输的。</p><p><strong>IP协议的作用</strong></p><ul><li>1、IP协议使得复杂的实际网络变成一个虚拟的互联网络。</li><li>2、IP协议使得网络层可以屏蔽底层细节而专注网络层的数据转发。</li><li>3、IP协议解决了在虚拟网络中数据报传输路径的问题。</li></ul><p><strong>IP地址</strong></p><p>每一个唯一的网络设备都有一个唯一的IP地址。不同于MAC地址是不可改变的，IP地址会根据当前设备所连接的网络环境的变化而变化。</p><p><strong>特点</strong></p><ul><li>IP地址长度为32位，常分为4个8位。</li><li>IP地址常使用点分十进制来表示，即0<del>255.0</del>255.0~255。</li><li>IP地址最多有2 ^ 32 = 4294961296 =&gt; 42 亿</li></ul><p>IP数据报 = IP首部 + IP数据报的数据，IP数据报的报文格式如下：</p><img src="/2020/06/02/Android网络优化-02：网络基础（下）/171e4f9a359e3d1e"><p><strong>版本</strong></p><p>占4位，指的是IP协议的版本，通信双方的版本必须一致，当前主流版本是4和6，即IPv4，也有IPv6。</p><p><strong>首部位长度</strong></p><p>占4位，最大数值为15，表示的是IP首部的长度，单位是32位字（4个字节）。所以IP首部的<strong>最大长度为 15 * 4 = 60 字节</strong>。</p><p><strong>服务类型（TOS）</strong></p><p>表示当前的数据包是高优先级的，还是低优先级的。数据包是按照TOS被分配到三个波段（band0、band1、band2）里面的。</p><p><strong>总长度</strong></p><p>占16位，最大数值为65535，表示的是IP数据报的总长度（IP首部 + IP数据）。</p><p>注意，<strong>数据在数据链路层中的传输受最大传输单元MTU的限制，而MTU一般为1500个字节，如果IP数据报的长度高于MTU，数据链路层会把IP数据报进行分片，即拆分成多个数据帧进行传输</strong>。</p><p><strong>标识</strong></p><p>协议内部自身使用，不需关注。</p><p><strong>标志</strong></p><p>占3位，目前只有两位有意思，<strong>标识是否进行分片</strong>。</p><p><strong>片偏移</strong></p><p>占13位，<strong>如果发生了分片，这里将会记录当前的数据帧保存的是第几个偏移的IP数据</strong>。</p><p><strong>TTL</strong></p><ul><li>占8位，表名IP数据报文在网络中的寿命，每经过一个设备，TTL减1，当TTL = 0时，网络设备必须丢弃该报文。</li><li>当IP报文在网络中找不到终点的时候，避免IP数据在网络中无限进行传输，消耗带宽。</li></ul><p><strong>协议</strong></p><p>占8位，<strong>表明IP数据所携带的具体数据是什么协议的。</strong>。如：TCP、UDP等。</p><table><thead><tr><th align="center">协议</th><th align="center">值</th></tr></thead><tbody><tr><td align="center">ICMP(Internet Control Message Protocol)Internet控制报文协议</td><td align="center">1</td></tr><tr><td align="center">IGMP(Internet Group Management Protocol)Internet组管理协议</td><td align="center">2</td></tr><tr><td align="center">IP(Internet Protocol)网络互连协议</td><td align="center">4</td></tr><tr><td align="center">TCP(Transmission Control Protocol)传输控制协议</td><td align="center">6</td></tr><tr><td align="center">UDP(User Datagram Protocol)用户数据报协议</td><td align="center">17</td></tr><tr><td align="center">OSPF(Open Shortest Path First)开放式最短路径优先，是一个内部网关协议(Interior Gateway Protocol)</td><td align="center">89</td></tr></tbody></table><p><strong>首部校验和</strong></p><p>占16位，校验IP首部是否有错，接收方在接收了IP数据报文之后会进行头部的校验，如果出错会进行丢弃。</p><p><strong>源IP地址</strong></p><p>发送IP数据报文的IP地址。</p><p><strong>目的IP地址</strong></p><p>数据报到达的IP的地址。</p><h3 id="8-2-2-IP协议的转发流程"><a href="#8-2-2-IP协议的转发流程" class="headerlink" title="8.2.2 IP协议的转发流程"></a>8.2.2 IP协议的转发流程</h3><p><strong>逐跳(hop-by-hop)</strong></p><p>数据是从目的设备传输到下一个网络1， 又从下一个网络1传输到路由器的，又从路由器跳到下一个网络2，所以是一跳一跳的，即hop-by-hop。</p><p><strong>路由表</strong></p><ul><li>1、不同于MAC地址表是由一组一组的MAC地址与硬件接口组成的，路由表是由一组一组的目的IP地址与吓一跳的IP地址组成。</li><li>2、计算机或者路由器都拥有路由表。</li></ul><p><strong>转发流程</strong></p><img src="/2020/06/02/Android网络优化-02：网络基础（下）/171e4f9d7cbc0feb"><ul><li>1、A发出的目的为C的IP数据报，查询路由表发现吓一跳为E。</li><li>2、A将IP数据报交给数据链路层，并告知目的MAC地址为E。</li><li>3、数据链路层填充源MAC地址A和目的MAC地址E。</li><li>4、数据链路层通过物理层将数据发送给E。</li><li>5、E的数据链路层接收到数据帧，把数据帧交给网络层。</li><li>6、E查询路由表，发现吓一跳为F。</li><li>7、E把数据报交给数据链路层，并告知目的MAC地址为F。</li><li>8、E的数据链路层封装数据帧并发送。</li><li>9、F的数据链路层收到数据帧，把数据帧交给网络层。</li><li>10、F查询路由表，发现吓一跳为C。</li><li>11、F把数据报交给路由链路层，并告知目的MAC地址为C。</li><li>12、F的数据链路层封装数据帧并发送。</li></ul><p><strong>MAC地址与IP地址的最大区别</strong></p><ul><li>1、数据帧每一跳的MAC地址都在变化，而IP数据报的每一跳的IP地址始终不变。</li><li>2、IP地址具有远程定位功能，而MAC地址更像是身份证号，它的唯一性是为了组网时可以不用担心不同的网卡在一个网络里会产生冲突，从硬件角度保证不同的网卡有不同的标识。</li><li>3、相比于IP地址，MAC地址的通信范围比较小，局限在一个子网内。如：从192.168.0.1/24访问192.168.0.9/24是可以用MAC地址的。</li></ul><h3 id="8-2-3-IP地址的子网划分"><a href="#8-2-3-IP地址的子网划分" class="headerlink" title="8.2.3 IP地址的子网划分"></a>8.2.3 IP地址的子网划分</h3><p><strong>为什么要对IP地址进行划分？</strong></p><p>因为规划和分配IP地址非常麻烦。</p><p><strong>分类的IP地址</strong></p><p>组成形式：网络号 + 主机号</p><p>通常有如下三种类型的IP地址：</p><ul><li>A类：首位为0，网络号为8位，主机号为24位。</li><li>B类：首位为10，网络号为16位，主机号为16位。</li><li>C类：首位为110，网络号为24位，主机号为8位。</li></ul><img src="/2020/06/02/Android网络优化-02：网络基础（下）/171e4fa0328300b2"><p><strong>特殊的网络号</strong></p><ul><li>A类地址网络段全0（00000000），表示特殊网络</li><li>A类地址网络后7位全1（01111111:127），表示回环地址</li><li>B类地址网络段（10000000.00000000:128.0），是不可使用的</li><li>C类地址网络段（192.0.0），是不可用的</li></ul><p><strong>特殊的主机号</strong></p><ul><li>主机号全0，表示当前网络段不可分配特定的主机。例如：1.0.0.0。</li><li>主机号全1，表示广播地址向当前网络段所有主机发消息。例如：0.1.11.111。</li></ul><img src="/2020/06/02/Android网络优化-02：网络基础（下）/171e4fa357b9529e"><p>本地回环地址（Loopback Address）：127.0.0.1，不属于任何一个有类别地址类。它代表设备的本地虚拟接口，所有默认被看作是永久不会废弃的接口。在Windows操作系统中也有相似的定义，所有一般在安装网卡前就可以ping通这个本地回环地址。一般都会用来检查本地网络协议、基本数据接口等是否正常。</p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\AHXIUWU_RJ_LY&gt;ping 127.0.0.1</span><br><span class="line"></span><br><span class="line">正在 Ping 127.0.0.1 具有 32 字节的数据:</span><br><span class="line">来自 127.0.0.1 的回复: 字节=32 时间&lt;1ms TTL=128</span><br><span class="line">来自 127.0.0.1 的回复: 字节=32 时间&lt;1ms TTL=128</span><br><span class="line">来自 127.0.0.1 的回复: 字节=32 时间&lt;1ms TTL=128</span><br><span class="line">来自 127.0.0.1 的回复: 字节=32 时间&lt;1ms TTL=128</span><br><span class="line"></span><br><span class="line">127.0.0.1 的 Ping 统计信息:</span><br><span class="line">    数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，</span><br><span class="line">往返行程的估计时间(以毫秒为单位):</span><br><span class="line">    最短 = 0ms，最长 = 0ms，平均 = 0ms</span><br></pre></td></tr></table></figure><p><strong>分类地址的补充</strong></p><ul><li>D类地址：1110……</li><li>E类地址：1111……</li></ul><p>他们仅做特殊用途。</p><p><strong>划分子网</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">某公司有256台计算机，该申请哪种网路段？</span><br></pre></td></tr></table></figure><p>分配B类地址，但是一个B类地址所能容纳的主机数量为2^16-2，这会造成极大的浪费。为了解决这个问题，需要划分子网。</p><p>例如：将193.10.10.0这个IP划分为193.10.10.0<del>193.10.10.127与193.10.10.128</del>193.10.10.255。</p><p><strong>子网掩码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">子网这么多，如何判断某个IP的网络号？</span><br></pre></td></tr></table></figure><p>快速的判断某个IP属于哪一个子网号，通过IP &amp; 子网掩码 = 该IP对应的子网号。子网掩码的组成特点如下：</p><ul><li>与IP地址一样，都是32位。</li><li>由连续的1和连续的0组成。</li><li>某一个子网掩码具备网络号位数个连续的1。</li></ul><p>例如，A、B、C类的子网掩码：</p><ul><li>A类：255.0.0.0</li><li>B类：255.255.0.0</li><li>B类：255.255.255.0</li></ul><p><strong>无分类编址CIDR（Classless Inter-Domain Routing，无类别域间路由）</strong></p><ul><li>1、CIDR中没有A、B、C类网络号和子网划分的概念</li><li>2、CIDR将网络前缀相同的IP地址称为一个CIDR地址块</li><li>3、网络前缀是任意位数的</li><li>4、相比原来子网划分更加灵活</li></ul><p>CIDR使用了斜线记法，例如：193.10.10.129/25 表示网络号为25位，主机号为7位。一般家里都是使用 /24 的CIDR，此时整个网络里面的一个地址为192.168.0.1，往往就是私网的出口地址。例如：家里面的电脑连接WIFI，WIFI路由器的地址就是192.168.0.1，而192.168.0.255就是广播的地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loopback是什么？</span><br></pre></td></tr></table></figure><p>回环接口，通常会被分配到127.0.0.1这个地址，它用于本机内部通信，经过内核处理后直接返回，不会再任何网络中出现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">某公司有200台电脑，需要拆分成两个部分，每个部分使用一个小型网络，如何进行CIDR进行划分？</span><br></pre></td></tr></table></figure><p>可以使用一个 /24 作为一个中型网络（在CIDR中被称为超网），旗下有两个 /25 作为一个小型网络（在CIDR中被称为子网）。</p><h2 id="8-3-ARP协议与RARP协议"><a href="#8-3-ARP协议与RARP协议" class="headerlink" title="8.3 ARP协议与RARP协议"></a>8.3 ARP协议与RARP协议</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在IP数据的转发过程中，A将IP数据报交给了数据链路层，并告知其目的MAC地址是E。这里A是如何知道目的MAC地址是E呢？</span><br></pre></td></tr></table></figure><h3 id="8-3-1-ARP-Address-Resolution-Protocol-地址解析协议"><a href="#8-3-1-ARP-Address-Resolution-Protocol-地址解析协议" class="headerlink" title="8.3.1 ARP(Address Resolution Protocol)地址解析协议"></a>8.3.1 ARP(Address Resolution Protocol)地址解析协议</h3><p>ARP协议将网络层IP 32位地址转换为数据链路层MAC 48位地址。</p><p><strong>ARP缓存池</strong></p><p>缓存了IP地址到硬件地址之间的映射关系。有缓存时直接从缓存中取出即可，没有缓存时则会和MAC地址表获取地址时使用的广播形式类似，即</p><ul><li>1、E检查MAC地址表，发现没有C的信息。</li><li>2、E将广播A的数据包到除A以外的端口。</li><li>3、E将收到来自B、C的回应，并将地址记录。</li></ul><p>ARP缓存时ARP协议和RARP协议运行的关键。此外，ARP缓存表中的记录并不是永久有效的，有一定的期限。</p><p><strong>查看ARP缓存表</strong></p><p>使用<code>arp -a</code>命令，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\AHXIUWU_RJ_LY&gt;arp -a</span><br><span class="line"></span><br><span class="line">接口: 192.168.137.1 --- 0xa</span><br><span class="line">  Internet 地址         物理地址              类型</span><br><span class="line">  192.168.137.255       ff-ff-ff-ff-ff-ff     静态</span><br><span class="line">  224.0.0.2             01-00-5e-00-00-02     静态</span><br><span class="line">  224.0.0.22            01-00-5e-00-00-16     静态</span><br><span class="line">  224.0.0.251           01-00-5e-00-00-fb     静态</span><br><span class="line">  224.0.0.252           01-00-5e-00-00-fc     静态</span><br><span class="line">  239.11.20.1           01-00-5e-0b-14-01     静态</span><br><span class="line">  239.255.255.250       01-00-5e-7f-ff-fa     静态</span><br><span class="line">  255.255.255.255       ff-ff-ff-ff-ff-ff     静态</span><br><span class="line"></span><br><span class="line">接口: 192.168.1.200 --- 0x12</span><br><span class="line">  Internet 地址         物理地址              类型</span><br><span class="line">  192.168.1.1           30-b4-9e-57-63-45     动态</span><br><span class="line">  192.168.1.202         48-3f-e9-66-03-09     动态</span><br><span class="line">  192.168.1.205         b4-c4-fc-43-b0-4f     动态</span><br><span class="line">  192.168.1.211         7c-67-a2-94-4d-82     动态</span><br><span class="line">  192.168.1.239         7c-67-a2-bd-96-e7     动态</span><br><span class="line">  192.168.1.255         ff-ff-ff-ff-ff-ff     静态</span><br><span class="line">  224.0.0.2             01-00-5e-00-00-02     静态</span><br><span class="line">  224.0.0.22            01-00-5e-00-00-16     静态</span><br><span class="line">  224.0.0.251           01-00-5e-00-00-fb     静态</span><br><span class="line">  224.0.0.252           01-00-5e-00-00-fc     静态</span><br><span class="line">  239.11.20.1           01-00-5e-0b-14-01     静态</span><br><span class="line">  239.255.255.250       01-00-5e-7f-ff-fa     静态</span><br><span class="line">  255.255.255.255       ff-ff-ff-ff-ff-ff     静态</span><br></pre></td></tr></table></figure><p><strong>ARP协议</strong></p><p>ARP协议是被直接封装在了数据链路层中的数据帧里面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">既然ARP协议是直接被封装在数据链路层中的数据帧里面，那么为什么它属于网络层的内容？</span><br></pre></td></tr></table></figure><p>主要是因为ARP协议使用到了网络层的IP地址。</p><p><strong>ARP协议内容</strong></p><img src="/2020/06/02/Android网络优化-02：网络基础（下）/171e4fa97c6c5d8a"><h3 id="8-3-2-RARP-Reverse-Address-Resolution-Protocol-逆地址解析协议"><a href="#8-3-2-RARP-Reverse-Address-Resolution-Protocol-逆地址解析协议" class="headerlink" title="8.3.2 RARP(Reverse Address Resolution Protocol)逆地址解析协议"></a>8.3.2 RARP(Reverse Address Resolution Protocol)逆地址解析协议</h3><ul><li>将数据链路层MAC 48位地址转换为网络层IP 32位地址。</li><li>除了类型8035标识为RARP协议，其他内容与ARP协议类似。</li></ul><h3 id="8-3-3-小结"><a href="#8-3-3-小结" class="headerlink" title="8.3.3 小结"></a>8.3.3 小结</h3><ul><li>RARP协议与ARP协议是TCP/IP协议栈里面的基础协议，它们的操作对程序员是透明的。</li><li>理解它们有助于里面网络分层的细节。</li><li>它们是协调数据链路层和网络层配合工作的重要协议。</li></ul><h2 id="8-4-网络地址转换NAT-Network-Address-Translation-技术"><a href="#8-4-网络地址转换NAT-Network-Address-Translation-技术" class="headerlink" title="8.4 网络地址转换NAT(Network Address Translation)技术"></a>8.4 网络地址转换NAT(Network Address Translation)技术</h2><p><strong>不改变IP地址的网关，称为转发网关；改变IP地址的网关，称为NAT网关</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为什么要使用NAT？</span><br></pre></td></tr></table></figure><ul><li>1、IPv4最多只有40+亿个IP地址。</li><li>2、早期IP地址的不合理规划导致IP号浪费。</li></ul><h3 id="8-4-1-内网地址"><a href="#8-4-1-内网地址" class="headerlink" title="8.4.1 内网地址"></a>8.4.1 内网地址</h3><p><strong>特点</strong></p><ul><li>内部机构使用</li><li>避免与外网地址重复</li></ul><p><strong>三类内网地址</strong></p><ul><li>A类：10.0.0.0 ~ 10.255.255.255，支持千万数据量级设备</li><li>B类：172.16.0.0 ~ 172.31.255.255，支持百万数据量级设备</li><li>C类：192.168.0.0 ~ 193.168.255.255，支持万数据量级设备</li></ul><p>对于公司，它可以在外部使用全球唯一的外网IP地址，通常在内部使用一个B类内网地址即可。</p><p>对于家庭，可以在外部使用全球唯一的外网IP地址，在内部使用一个C类内网地址即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">问题：内网的多个设备使用同一外网IP地址请求外网服务，外部是怎么知道时候哪一个内网设备请求的呢？</span><br></pre></td></tr></table></figure><p>使用NAT，它用于多个主机通过一个公有IP访问互联网的私有网络，并减缓了IP地址的消耗，但是增加了网络通信的复杂度。</p><h3 id="8-4-2-外网地址"><a href="#8-4-2-外网地址" class="headerlink" title="8.4.2 外网地址"></a>8.4.2 外网地址</h3><ul><li>全球范围使用</li><li>全球公网唯一</li></ul><h3 id="8-4-3-端口映射"><a href="#8-4-3-端口映射" class="headerlink" title="8.4.3 端口映射"></a>8.4.3 端口映射</h3><p>如下两个NAT转换过程：发送数据时，A设备内网地址和端口号 =&gt; 外网地址与端口号：192.168.2.11:6666 =&gt; 173.21.59.10:16666，B设备内网地址和端口号 =&gt; 外网地址和端口号：192.168.2.10:7777 =&gt; 173.21.59.10:17777。</p><p>由于同时转换了Port，即进行了端口映射，NAT也可称为NA(P)T。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文地址：&lt;a href=&quot;https://juejin.im/post/5ebb3db16fb9a0438e2396af&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://juejin.im/post/5ebb3db16fb9a0438e23
      
    
    </summary>
    
      <category term="Android" scheme="https://tylerLiu.top/categories/Android/"/>
    
      <category term="网络" scheme="https://tylerLiu.top/categories/Android/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="https://tylerLiu.top/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Android网络优化-01：网络基础（上）</title>
    <link href="https://tylerLiu.top/2020/05/29/Android%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96-01%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>https://tylerLiu.top/2020/05/29/Android网络优化-01：网络基础（上）/</id>
    <published>2020-05-29T02:01:12.000Z</published>
    <updated>2020-06-02T01:23:53.254Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址：<a href="https://juejin.im/post/5eba5a39e51d454de64e49b1" target="_blank" rel="noopener">https://juejin.im/post/5eba5a39e51d454de64e49b1</a></p><h1 id="0-大纲"><a href="#0-大纲" class="headerlink" title="0. 大纲"></a>0. 大纲</h1><img src="/2020/05/29/Android网络优化-01：网络基础（上）/计算机基础思维导图.png"><h1 id="1-重识计算机网络"><a href="#1-重识计算机网络" class="headerlink" title="1. 重识计算机网络"></a>1. 重识计算机网络</h1><h2 id="1-1-计算机网络是什么？"><a href="#1-1-计算机网络是什么？" class="headerlink" title="1.1 计算机网络是什么？"></a>1.1 计算机网络是什么？</h2><ul><li>1、主要由<strong>通用、可编程的硬件互连</strong>而成。</li><li>2、通过这些硬件，可以<strong>传送不同类型的数据</strong>。</li><li>3、计算机网络不仅包含<strong>软件概念</strong>，还包含<strong>硬件设备</strong>。</li><li>4、计算机网络不仅包含<strong>信息通信</strong>，还可以<strong>支持广泛和日益增长的应用</strong>。</li></ul><h2 id="1-2-计算机网络的分类"><a href="#1-2-计算机网络的分类" class="headerlink" title="1.2 计算机网络的分类"></a>1.2 计算机网络的分类</h2><h3 id="1-2-1-按作用范围"><a href="#1-2-1-按作用范围" class="headerlink" title="1.2.1 按作用范围"></a>1.2.1 按作用范围</h3><ul><li>广域网（WAM）：几十KM ~ 几千 KM，跨省、跨国。</li><li>城域网（MAN）：5KM ~ 50KM，城市间、城市内。</li><li>局域网（LAN）：1KM内，地区内、家庭间、公司内。</li></ul><h3 id="1-2-2-按网络使用者"><a href="#1-2-2-按网络使用者" class="headerlink" title="1.2.2 按网络使用者"></a>1.2.2 按网络使用者</h3><ul><li>公用网络：所有可以通过付费方式就可以加入的网络。</li><li>专用网络：某些部队、组织或者某些人<strong>为了满足特殊业务需求而建立起来的特殊网络</strong>。如军队、铁路、银行都有自己的专用网络。</li></ul><h1 id="2-网络历史演进"><a href="#2-网络历史演进" class="headerlink" title="2. 网络历史演进"></a>2. 网络历史演进</h1><h2 id="2-1-世界历史互联网发展历史演进"><a href="#2-1-世界历史互联网发展历史演进" class="headerlink" title="2.1 世界历史互联网发展历史演进"></a>2.1 世界历史互联网发展历史演进</h2><h3 id="2-1-1-单个网络"><a href="#2-1-1-单个网络" class="headerlink" title="2.1.1 单个网络"></a>2.1.1 单个网络</h3><p><strong>ARPANET</strong>，1969年美国国防部创建的一个网络，可以连接周围的计算机。计算机直接通过交换机就可以进行信息交换。</p><img src="/2020/05/29/Android网络优化-01：网络基础（上）/171e4ef50b60e990"><h3 id="2-1-2-三级结构"><a href="#2-1-2-三级结构" class="headerlink" title="2.1.2 三级结构"></a>2.1.2 三级结构</h3><p>现代互联网的雏形，也称<strong>互联网络</strong>，可以把大学、实验室、研究所都连接起来。</p><p>从上至下，由<strong>主干网、地区网、校园网</strong>组成。</p><img src="/2020/05/29/Android网络优化-01：网络基础（上）/171e4f06d452539c"><h3 id="2-1-3-多层次ISP"><a href="#2-1-3-多层次ISP" class="headerlink" title="2.1.3 多层次ISP"></a>2.1.3 多层次ISP</h3><p>ISP，Internet Service Provider：网路服务提供商，如中国电信、中国移动、中国联通等。从上之下，由主干ISP、地区ISP组成。</p><ul><li>主干ISP：中国的主干ISP，包括中国电信、中国移动、中国联通，它们可以直接连接其他国家的在主干ISP。</li><li>地区ISP：例如移动网络，在北京叫“北京移动”，在上海叫“上海移动”。这些就属于地区ISP。地区ISP可以连接公司、学校、家庭的网络。</li></ul><img src="/2020/05/29/Android网络优化-01：网络基础（上）/171e4f0c33f8a4ba"><h3 id="2-1-4-了解现代国际互联网的主要线路"><a href="#2-1-4-了解现代国际互联网的主要线路" class="headerlink" title="2.1.4 了解现代国际互联网的主要线路"></a>2.1.4 了解现代国际互联网的主要线路</h3><p>可以通过<a href="https://live.infrapedia.com/" target="_blank" rel="noopener">infrapedia</a>查看。</p><img src="/2020/05/29/Android网络优化-01：网络基础（上）/171e4f1c0019a551"><h2 id="2-2-中国互联网发展历史"><a href="#2-2-中国互联网发展历史" class="headerlink" title="2.2 中国互联网发展历史"></a>2.2 中国互联网发展历史</h2><ul><li>1980年，中国铁道部开始互联网实验。</li><li>1989年，建立并运行第一个公共网络。</li><li>1994年，接入国际互联网。</li><li>至今，当今中国最大的五个公用计算机网络：<ul><li>中国电信互联网(CHINANET)</li><li>中国联通互联网(UNINET)</li><li>中国移动互联网(CMNET)</li><li>中国教育与科研计算机网(CERNET)</li><li>中国科学技术网(CSTNET)</li></ul></li></ul><h2 id="2-3-中国的互联网企业"><a href="#2-3-中国的互联网企业" class="headerlink" title="2.3 中国的互联网企业"></a>2.3 中国的互联网企业</h2><ul><li>1996年，张朝阳创建搜狐。</li><li>1997年，丁磊创建网易。</li><li>1998年，王志东创建新浪，马化腾、张志东创建腾讯。</li><li>1999年，马云创建阿里巴巴。</li><li>2000年，李彦宏创建百度。</li></ul><h1 id="3-重识网络层次结构"><a href="#3-重识网络层次结构" class="headerlink" title="3. 重识网络层次结构"></a>3. 重识网络层次结构</h1><h3 id="网络为什么要分层"><a href="#网络为什么要分层" class="headerlink" title="网络为什么要分层"></a>网络为什么要分层</h3><p>因为复杂的程序都要分层。这时一个架构设计的通用问题，不仅仅是网络协议的问题，<strong>只要涉及复杂的逻辑或软件需求需要经常变动的情况通常都会通过分层来解决</strong>。</p><h3 id="思考：设计一个计算机网络需要解决哪些问题？"><a href="#思考：设计一个计算机网络需要解决哪些问题？" class="headerlink" title="思考：设计一个计算机网络需要解决哪些问题？"></a>思考：设计一个计算机网络需要解决哪些问题？</h3><ul><li>1、传输数据时需要保证数据通路顺畅。</li><li>2、需要识别目的计算机。</li><li>3、需要了解目的计算机的状态。</li><li>4、数据是否错误。</li></ul><p>因为计算机网络需要解决的问题繁多复杂，所以需要<strong>采用分层的设计分别去解决不同的问题，实现不同的功能</strong>。</p><h2 id="3-1-层级结构设计的基本原则"><a href="#3-1-层级结构设计的基本原则" class="headerlink" title="3.1 层级结构设计的基本原则"></a>3.1 层级结构设计的基本原则</h2><ul><li>相互独立：每一层仅仅实现一个相对独立的功能，并且需要确保层与层之间的耦合度非常低。</li><li>灵活性：每一层的设计需要具备很好的灵活性、扩展性，以适应未来的网络变化。</li><li>耦合度：各层之间是完全耦合的，层与层之间的变化互不影响。</li></ul><h2 id="3-2-OSI七层模型"><a href="#3-2-OSI七层模型" class="headerlink" title="3.2 OSI七层模型"></a>3.2 OSI七层模型</h2><table><thead><tr><th align="center">OSI</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">应用层</td><td align="center">为计算机用户提供接口和服务</td></tr><tr><td align="center">表示层</td><td align="center">数据处理：编解码、加解密等等</td></tr><tr><td align="center">会话层</td><td align="center">管理（建立、维护、重连）通信会话</td></tr><tr><td align="center">传输层</td><td align="center">管理端到端的通信连接</td></tr><tr><td align="center">网络层</td><td align="center">数据路由：决定数据在网络中的路径</td></tr><tr><td align="center">数据链路层</td><td align="center">管理相邻节点之间的数据通信</td></tr><tr><td align="center">物理层</td><td align="center">数据通信的光电物理特性</td></tr></tbody></table><h3 id="3-2-1-OSI的故事"><a href="#3-2-1-OSI的故事" class="headerlink" title="3.2.1 OSI的故事"></a>3.2.1 OSI的故事</h3><ul><li>开始，OSI想要成为全球计算机都遵循的标准。</li><li>但是，OSI在市场化的过程中困难重重，因为TCP/IP已经在全球范围成功运行。</li><li>最终，OSI没有成为广为使用的标准模型。</li></ul><h3 id="3-2-2-OSI七层模型失败的原因"><a href="#3-2-2-OSI七层模型失败的原因" class="headerlink" title="3.2.2 OSI七层模型失败的原因"></a>3.2.2 OSI七层模型失败的原因</h3><ul><li>1、OSI没有充分将理论和实际结合。</li><li>2、OSI标准的制定周期长，按OSI标准生产的设备无法及时投入市场。</li><li>3、OSI模型设计不合理，某些功能在多层重复出现。</li></ul><h2 id="3-3-TCP-IP四层模型"><a href="#3-3-TCP-IP四层模型" class="headerlink" title="3.3 TCP/IP四层模型"></a>3.3 TCP/IP四层模型</h2><img src="/2020/05/29/Android网络优化-01：网络基础（上）/微信图片_20200529145238.png"><p>需要理解数据通信过程中不同设备之间协议的转换。从下图可以看到<strong>路由器仅包括网络层和网络接口层</strong>。</p><img src="/2020/05/29/Android网络优化-01：网络基础（上）/微信图片_20200529145947.png"><p>从协议的数量来看，TCP/IP四层模型构成了中间窄，两端大的沙漏模型，下图：</p><img src="/2020/05/29/Android网络优化-01：网络基础（上）/微信图片_20200529150949.png"><h1 id="4-初始现代网络拓扑"><a href="#4-初始现代网络拓扑" class="headerlink" title="4. 初始现代网络拓扑"></a>4. 初始现代网络拓扑</h1><h2 id="4-1-为什么要了解网络拓扑？"><a href="#4-1-为什么要了解网络拓扑？" class="headerlink" title="4.1 为什么要了解网络拓扑？"></a>4.1 为什么要了解网络拓扑？</h2><p>有助于形成一个形象的计算机网络。</p><h2 id="4-2-网络拓扑分类"><a href="#4-2-网络拓扑分类" class="headerlink" title="4.2 网络拓扑分类"></a>4.2 网络拓扑分类</h2><h3 id="4-2-1-边缘部分"><a href="#4-2-1-边缘部分" class="headerlink" title="4.2.1 边缘部分"></a>4.2.1 边缘部分</h3><ul><li><p>家庭：由<strong>终端机器、路由器、网关、地区ISP</strong>组成。</p>  <img src="/2020/05/29/Android网络优化-01：网络基础（上）/171e4f3a5a49bcfe"></li><li><p>企业：不同于家庭的网络拓扑，其<strong>网关细分为内部网关和统一网关</strong>。</p>  <img src="/2020/05/29/Android网络优化-01：网络基础（上）/171e4f3e31828128"></li></ul><h3 id="4-2-2-核心部分"><a href="#4-2-2-核心部分" class="headerlink" title="4.2.2 核心部分"></a>4.2.2 核心部分</h3><p>由<strong>地区ISP、主干ISP、路由器、海底电缆或跨地区电缆</strong>组成。其中<strong>通信设备（一般是华为）主要由移动、联通锁铺设的</strong>。</p><img src="/2020/05/29/Android网络优化-01：网络基础（上）/171e4f40bf34946a"><p>现代互联网的网络拓扑形成了一个树形结构。</p><img src="/2020/05/29/Android网络优化-01：网络基础（上）/171e4f42fa879e70"><h3 id="4-2-3-C-S模式"><a href="#4-2-3-C-S模式" class="headerlink" title="4.2.3 C/S模式"></a>4.2.3 C/S模式</h3><p>由客户端/服务端模式组成，并可以相互进行通信。</p><img src="/2020/05/29/Android网络优化-01：网络基础（上）/171e4f476817dd10"><h3 id="4-2-4-P2P模式"><a href="#4-2-4-P2P模式" class="headerlink" title="4.2.4 P2P模式"></a>4.2.4 P2P模式</h3><p>不分客户端和服务端，它们之间<strong>对等地进行连接</strong>，优势在于可以使<strong>下载速度更快</strong>，如迅雷下载器中就是采用这种模式。</p><img src="/2020/05/29/Android网络优化-01：网络基础（上）/171e4f4b5c0fcffb"><h1 id="5-网络性能指标"><a href="#5-网络性能指标" class="headerlink" title="5. 网络性能指标"></a>5. 网络性能指标</h1><h2 id="5-1-速率"><a href="#5-1-速率" class="headerlink" title="5.1 速率"></a>5.1 速率</h2><p><strong>即，bps &lt;==&gt; bit/s</strong></p><p>网络数据传输的各种单位与之对应的常见设备</p><table><thead><tr><th align="center"></th><th align="center">bit</th><th align="center">Byte</th><th align="center">KB</th><th align="center">MB</th><th align="center">GB</th><th align="center">TB</th><th align="center">PB</th><th align="center">EB</th></tr></thead><tbody><tr><td align="center">名字</td><td align="center">比特位</td><td align="center">字节</td><td align="center">千字节</td><td align="center">兆字节</td><td align="center">吉字节</td><td align="center">太字节</td><td align="center">拍字节</td><td align="center">艾字节</td></tr><tr><td align="center">比例</td><td align="center">-</td><td align="center">8bits</td><td align="center">1024B</td><td align="center">1024KB</td><td align="center">1024MB</td><td align="center">1024GB</td><td align="center">1024TB</td><td align="center">1024PB</td></tr><tr><td align="center">常见设备</td><td align="center">门电路</td><td align="center">-</td><td align="center">寄存器</td><td align="center">高速缓存</td><td align="center">内存/硬盘</td><td align="center">硬盘</td><td align="center">云硬盘</td><td align="center">数据仓库</td></tr></tbody></table><p><strong>为什么100M的电信光纤，测试峰值速度只有12M/s呢？</strong></p><p>网络常用的单位为Mbps，因此这里的100M指的是100Mbps。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100 M/s = 100 Mbps = 100 Mbit/s</span><br><span class="line">100 Mbit/s = (100 / 8) MB/s = 12.5 MB/s</span><br></pre></td></tr></table></figure><h2 id="5-2-时延"><a href="#5-2-时延" class="headerlink" title="5.2 时延"></a>5.2 时延</h2><h3 id="5-2-1-发送时延"><a href="#5-2-1-发送时延" class="headerlink" title="5.2.1 发送时延"></a>5.2.1 发送时延</h3><p><strong>发送时延 = 数据长度(bit) / 发送速率(bit/s)</strong>。</p><p>数据长度有用户决定，发送速率有计算机网卡决定。</p><h3 id="5-2-2-传输时延"><a href="#5-2-2-传输时延" class="headerlink" title="5.2.2 传输时延"></a>5.2.2 传输时延</h3><p><strong>传输时延 = 传输路径距离 / 传播速率(bit/s)</strong>。</p><p>传输路径距离由用户决定，传播速率受限于传输介质。</p><h3 id="5-2-3-排队时延"><a href="#5-2-3-排队时延" class="headerlink" title="5.2.3 排队时延"></a>5.2.3 排队时延</h3><p>数据包在网络设备中等待被处理的时间，例如路由器需要一个一个处理完前面的数据包才能处理后面的。</p><h3 id="5-2-4-处理时延"><a href="#5-2-4-处理时延" class="headerlink" title="5.2.4 处理时延"></a>5.2.4 处理时延</h3><p>数据包达到设备或目的机器被处理所需的时间。</p><p><strong>总时延 = 发送时延 + 传输时延 + 排队时延 + 处理时延</strong>。</p><h2 id="5-3-往返时间RTT-Route-Trip-Time"><a href="#5-3-往返时间RTT-Route-Trip-Time" class="headerlink" title="5.3 往返时间RTT(Route-Trip Time)"></a>5.3 往返时间RTT(Route-Trip Time)</h2><ul><li>评估网络质量的一项重要指标。</li><li>表示数据报文在端到端通信中来回一次的时间。</li></ul><p><strong>通常使用ping命令查看RRT</strong></p><h1 id="6-应用层"><a href="#6-应用层" class="headerlink" title="6. 应用层"></a>6. 应用层</h1><p><strong>传输层与之下的层已经提供了完整的通信服务</strong>。而应用层是面向用于的一层。主要用来<strong>定义应用间通信的规则</strong>，例如应用进程的报文类型（请求报文、响应报文）、报文的语法、格式、应用进程发送数据的时机、规则等。</p><h2 id="6-1-DNS（Domain-Name-System）域名系统服务"><a href="#6-1-DNS（Domain-Name-System）域名系统服务" class="headerlink" title="6.1 DNS（Domain Name System）域名系统服务"></a>6.1 DNS（Domain Name System）域名系统服务</h2><p>域即对应的网络号，名即对应的主机名字。</p><h3 id="6-1-1-功能"><a href="#6-1-1-功能" class="headerlink" title="6.1.1 功能"></a>6.1.1 功能</h3><p>通过把没有规则的点分十进制IP地址转换为可以理解的一些域名。</p><h3 id="6-1-2-域名"><a href="#6-1-2-域名" class="headerlink" title="6.1.2 域名"></a>6.1.2 域名</h3><ul><li>使用域名可以帮助记忆。</li><li>域名通过DNS服务可以被转换成IP地址。</li><li>域名是由点、字母和数字组成。</li><li>点分割不同的域。</li><li>域名可以分为顶级域名、二级域、三级域…，如，<a href="http://www.taobao.com" target="_blank" rel="noopener">www.taobao.com</a> -&gt; 三级域.二级域.顶级域。</li></ul><p><strong>顶级域常见分类</strong></p><ul><li>国家<ul><li>cn</li><li>us</li><li>uk</li><li>ca</li></ul></li><li>通用<ul><li>com</li><li>net</li><li>gov</li><li>org</li></ul></li></ul><p><strong>二级域</strong><br>例如：qq、aliyun、taobao、google、facebook等。</p><p>顶级域、二级域、三级域组成了一个树状结构。且在顶级域名服务器上面还有一个根域名服务器。</p><h3 id="6-1-3-域名服务器"><a href="#6-1-3-域名服务器" class="headerlink" title="6.1.3 域名服务器"></a>6.1.3 域名服务器</h3><p>只要有一个外网的服务器就可以搭建一个域名的服务器。</p><h2 id="6-2-DHCP-Dynamic-Host-Configuration-Protocol-动态主机设置协议"><a href="#6-2-DHCP-Dynamic-Host-Configuration-Protocol-动态主机设置协议" class="headerlink" title="6.2 DHCP(Dynamic Host Configuration Protocol)动态主机设置协议"></a>6.2 DHCP(Dynamic Host Configuration Protocol)动态主机设置协议</h2><h3 id="6-2-1-是什么？"><a href="#6-2-1-是什么？" class="headerlink" title="6.2.1 是什么？"></a>6.2.1 是什么？</h3><p>网络管理员只需配置一段共享的IP地址，每一台新接入的机器都可以通过DHCP来这个共享的IP地址里面申请IP地址，就可以自动配置。等用完之后还回去，其他机器也能使用。</p><p>特点如下：</p><ul><li>DHCP是一个局域网协议。</li><li>DHCP是应用UDP协议的应用层协议。</li></ul><h3 id="6-2-2-功能"><a href="#6-2-2-功能" class="headerlink" title="6.2.2 功能"></a>6.2.2 功能</h3><ul><li>即插即用联网。</li><li>在IP配置界面中自动获得IP地址、自动获得DNS服务器地址即可启用DHCP协议去获取一个临时IP（通常是一个内网地址）。</li><li>有一个租期，在租期过半时可以续租。</li></ul><h3 id="6-2-3-DHCP的过程"><a href="#6-2-3-DHCP的过程" class="headerlink" title="6.2.3 DHCP的过程"></a>6.2.3 DHCP的过程</h3><ul><li>1、DHCP服务器监听默认端口：67</li><li>2、主机使用UDP协议广播DHCP发现报文</li><li>3、DHCP服务器发出DHCP提供报文</li><li>4、主机向DHCP服务器发出DHCP请求报文</li><li>5、DHCP服务器回应并提供IP地址</li></ul><h3 id="6-2-4-向DHCP租用的IP地址是有租期的，IP地址如何实现续租呢？"><a href="#6-2-4-向DHCP租用的IP地址是有租期的，IP地址如何实现续租呢？" class="headerlink" title="6.2.4 向DHCP租用的IP地址是有租期的，IP地址如何实现续租呢？"></a>6.2.4 向DHCP租用的IP地址是有租期的，IP地址如何实现续租呢？</h3><p>客户端会在租期过去50%的时候，直接向为其提供IP地址的DHCP服务器发送DHCP request消息报。客户端接收到服务器回应的DHCP ACK消息报后，会根据消息报中提供的新的租期以及其他已经更新的TCP/IP参数更新自己的配置。</p><h2 id="6-3-HTTP（HyperText-Transfer-Protocol）超文本传输协议"><a href="#6-3-HTTP（HyperText-Transfer-Protocol）超文本传输协议" class="headerlink" title="6.3 HTTP（HyperText Transfer Protocol）超文本传输协议"></a>6.3 HTTP（HyperText Transfer Protocol）超文本传输协议</h2><h3 id="6-3-1-是什么？"><a href="#6-3-1-是什么？" class="headerlink" title="6.3.1 是什么？"></a>6.3.1 是什么？</h3><p>HyperText即超文本、超链接，Http是指在电脑中显示的、<strong>含有可以指向其他文本的链接文本</strong>。</p><p>对于这些内容都有一个统一的路径，例如：http(s)://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;。</p><p>HTP协议底层是TCP协议，因此它是可靠的数据传输协议。</p><h3 id="6-3-2-Web服务器"><a href="#6-3-2-Web服务器" class="headerlink" title="6.3.2 Web服务器"></a>6.3.2 Web服务器</h3><p>分为硬件部分（计算机或云上的虚拟设备）和软件部分（Nginx、Apache）。</p><p><strong>过程：</strong></p><ul><li>1、接受客户端连接</li><li>2、接受请求报文</li><li>3、处理请求</li><li>4、访问Web资源</li><li>5、构造应答</li><li>6、发送应答</li></ul><h3 id="6-3-3-HTTP请求方法"><a href="#6-3-3-HTTP请求方法" class="headerlink" title="6.3.3 HTTP请求方法"></a>6.3.3 HTTP请求方法</h3><table><thead><tr><th align="center">header1</th><th align="center">header2</th></tr></thead><tbody><tr><td align="center">GET</td><td align="center">获取指定的服务端资源</td></tr><tr><td align="center">POST</td><td align="center">提交数据到服务端</td></tr><tr><td align="center">DELETE</td><td align="center">删除指定的服务端资源（很少用）</td></tr><tr><td align="center">UPDATE</td><td align="center">更新指定的服务端资源</td></tr><tr><td align="center">PUT</td><td align="center">修改数据</td></tr><tr><td align="center">OPTIONS</td><td align="center">列出可对资源实行的请求方法，用来跨域请求</td></tr><tr><td align="center">CONNECT</td><td align="center">建立连接隧道，用于代理服务器</td></tr><tr><td align="center">HEAD</td><td align="center">获取资源的元信息</td></tr><tr><td align="center">TRACE</td><td align="center">追踪请求-响应的传输路径</td></tr></tbody></table><p><strong>GET和POST的区别：</strong></p><ul><li>1、GET参数通过url传递，POST放在request body中。</li><li>2、GET请求在url中传递的参数是有长度限制的，而POST没有。</li><li>3、GET比POST更不安全，因为参数直接暴露在url中，所以不能用来传递敏感信息。</li><li>4、GET请求只能进行url编码，而POST支持多种编码方式。</li><li>5、GET请求浏览器会主动cache。</li><li>6、GET请求参数会被完整保留在浏览器历史记录中，而POST不会保留。</li><li>7、GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出了一些不同。</li></ul><h3 id="6-3-4-HTTP指定资源"><a href="#6-3-4-HTTP指定资源" class="headerlink" title="6.3.4 HTTP指定资源"></a>6.3.4 HTTP指定资源</h3><p><strong>在地址中指定</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.wanandroid.com/repo/100.html</span><br></pre></td></tr></table></figure><p><code>repo/100.html</code>是指定的请求资源。</p><p><strong>在请求数据中指定</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.wanandroid.com/?sort=0&amp;unlearn=0&amp;page=2</span><br></pre></td></tr></table></figure><p><code>?</code>后面用来指定请求参数。</p><h3 id="6-3-5-HTTP请求报文"><a href="#6-3-5-HTTP请求报文" class="headerlink" title="6.3.5 HTTP请求报文"></a>6.3.5 HTTP请求报文</h3><p>HTTP的请求报文与响应报文都满足如下结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">起始行 + 头部 + 空行 + 实体</span><br></pre></td></tr></table></figure><p>其中空行是用来区分开头部和实体的。</p><p>HTTP请求报文的格式如下：</p><img src="/2020/05/29/Android网络优化-01：网络基础（上）/171e4f5994a7ad72"><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST https://www.wanandroid.com HTTP/1.1</span><br><span class="line">Accept-Encoding:gzip</span><br><span class="line">Accept-Language:zh-CN</span><br><span class="line">...</span><br><span class="line">&#123; 请求的 jsonString 内容&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-6-HTTP应答报文"><a href="#6-3-6-HTTP应答报文" class="headerlink" title="6.3.6 HTTP应答报文"></a>6.3.6 HTTP应答报文</h3><img src="/2020/05/29/Android网络优化-01：网络基础（上）/171e4f5bf97709b5"><h3 id="6-3-7-HTTP应答状态码"><a href="#6-3-7-HTTP应答状态码" class="headerlink" title="6.3.7 HTTP应答状态码"></a>6.3.7 HTTP应答状态码</h3><table><thead><tr><th align="center">header1</th><th align="center">header2</th></tr></thead><tbody><tr><td align="center">100~199</td><td align="center">协议处理的中间状态，还需要后续操作</td></tr><tr><td align="center">200~299</td><td align="center">成功</td></tr><tr><td align="center">300~399</td><td align="center">重定向</td></tr><tr><td align="center">400~499</td><td align="center">客户端错误</td></tr><tr><td align="center">500~599</td><td align="center">服务端错误</td></tr></tbody></table><p><strong>100~199</strong></p><ul><li>101：Switching Protocols，服务器同意将HTTP升级为WebSocket时发送。</li></ul><p><strong>200~299</strong></p><ul><li>200：在响应体中放有数据。</li><li>204：No Connect，响应头后没有body数据。</li><li>206：Partial Content，通常用于HTTP分块下载和断点续传，同时带上相应的响应头字段Content-Range。</li></ul><p><strong>300~399</strong></p><ul><li>301：Moved Permanently，永久重定向。</li><li>302：Found，临时重定向。</li><li>304：Not Modified，协商缓存命中时返回。</li></ul><p><strong>400~499</strong></p><ul><li>400：Bad Request，请求出错。</li><li>403：Forbidden，服务器禁止访问，原因有法律禁止、信息敏感等。</li><li>404：Not Found，资源未找到。</li><li>405：Method Not Allowed，请求方法不被允许。</li><li>406：Not Acceptable，资源无法满足条件。</li><li>408：Request Timeout，请求超时。</li><li>409：Confilict，多个请求发生冲突。</li><li>413：Request Entity Too Larget，请求体的数据过大。- 414：Request-URI Too Long，请求行里的URI太大。</li><li>429：Too Many Request，客户端发送的请求过多。</li><li>431：Request Header Fields Too Large，请求头的字段内容太大。</li></ul><p><strong>500~599</strong></p><ul><li>500：Internal Server Error，服务内部出错。</li><li>501：Not Implemented，请求的功能不支持。</li><li>502：Bad Gateway，服务器自身是正常的，只是数据通道有问题。</li><li>503：Service Unavailable，服务器很忙，无法响应服务。</li></ul><h3 id="6-3-8-HTTP工作结构"><a href="#6-3-8-HTTP工作结构" class="headerlink" title="6.3.8 HTTP工作结构"></a>6.3.8 HTTP工作结构</h3><p><strong>Web缓存</strong></p><ul><li>通常遵循二八原则：一个网站的内容通常分为20%的热门内容，80%的冷门内容。因此可以优先缓存热门内容。</li></ul><p><strong>存储器层次结构</strong></p><ul><li>缓存（CPU高速缓存）/主存（内存）/辅存（磁盘）</li></ul><p><strong>Web代理</strong></p><ul><li>正向代理：代理客户端去访问Server。</li><li>反向代理：代理Server把数据返回给客户端。例如Nginx、HAProxy就是一些著名的代理软件。</li></ul><p><strong>CDN（Content Delivery Network）内容分发网络</strong></p><ul><li>用于即将一些大的内容在临近的服务器留一个备份。</li><li>使用CDN可以进行多媒体内容的加速。</li></ul><p>CDN的基本原理是<strong>广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应</strong>。</p><p><strong>爬虫</strong></p><ul><li>用于在互联网上采集信息，例如百度、Google的本质就是一个爬虫，它们通过把整个网络的数据取下来，并且做一个索引，然后把这些内容提供给大家，在进行搜索时就会匹配这些内容并返回。</li><li>不好的爬虫的缺点：<ul><li>增加网络拥塞</li><li>损耗服务器资源</li></ul></li></ul><h2 id="6-4-HTTPS-Hyper-Text-Transfer-Protocol-over-SecureSocket-Layer-安全的HTTP协议"><a href="#6-4-HTTPS-Hyper-Text-Transfer-Protocol-over-SecureSocket-Layer-安全的HTTP协议" class="headerlink" title="6.4 HTTPS(Hyper Text Transfer Protocol over SecureSocket Layer)安全的HTTP协议"></a>6.4 HTTPS(Hyper Text Transfer Protocol over SecureSocket Layer)安全的HTTP协议</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://&lt;主机&gt;:&lt;443&gt;/&lt;路径&gt;</span><br></pre></td></tr></table></figure><p>HTTP是明文传输，但是有时需要在网络中传输账号密码、个人信息、账号金额、交易信息等敏感信息，HTTP会导致中间人非法截取信息，导致信息泄露。</p><h3 id="6-4-1-加密模型"><a href="#6-4-1-加密模型" class="headerlink" title="6.4.1 加密模型"></a>6.4.1 加密模型</h3><ul><li>对称加密：加密与解密都是用同一个秘钥。</li><li>非对称加密：公钥加密，私钥解密，并且公钥与私钥是拥有一定数学关系的一组秘钥。</li></ul><h3 id="6-4-2-数字证书、签名校验"><a href="#6-4-2-数字证书、签名校验" class="headerlink" title="6.4.2 数字证书、签名校验"></a>6.4.2 数字证书、签名校验</h3><p>数字证书是可信任组织颁发给特定对象的认证。而可信任组织即客户端与服务端都认为安全的组织。</p><p><strong>数字证书格式：</strong></p><ul><li>证书格式、版本号</li><li>证书序列号</li><li>签名算法</li><li>有效期</li><li>对象名称</li><li>对象公开秘钥</li></ul><h3 id="6-4-3-SSL（Secure-Sockets-Layer）安全套接层"><a href="#6-4-3-SSL（Secure-Sockets-Layer）安全套接层" class="headerlink" title="6.4.3 SSL（Secure Sockets Layer）安全套接层"></a>6.4.3 SSL（Secure Sockets Layer）安全套接层</h3><p>SSL位于传输层与应用层之间，它是一个子层，作用主要有两点：</p><ul><li>数据安全（保证数据不会被泄露）与数据完整（保证数据不会被篡改）</li><li>对数据进行加密后传输</li></ul><p><strong>HTTPS的通信过程</strong></p><ul><li>1、433端口的TCP连接。</li><li>2、SSL安全参数握手</li><li>3、客户端发送数据</li><li>4、服务端发送数据</li></ul><p><strong>SSL（Secure Sockets Layer）安全套接层握手过程</strong></p><ul><li>1、生成随机数1、2、3的过程</li></ul><img src="/2020/05/29/Android网络优化-01：网络基础（上）/微信图片_20200530172038.png"><ul><li>2、双端根据随机数1、2、3与相同的算法生成对称秘钥进行加密通信</li></ul><img src="/2020/05/29/Android网络优化-01：网络基础（上）/微信图片_20200530172250.png"><p>HTTPS综合地运用了对称加密与非对称加密，在进行随机数校验的阶段使用了非对称加密来进行通信，然后等双方都确定了三个随机数之后，就可以使用相同的算法来生成对称秘钥进行加密通信。HTTPS的优势在于双端分别生成了秘钥，没有经过传输，减少了秘钥泄露的可能性。</p><h2 id="6-5-HTTP2"><a href="#6-5-HTTP2" class="headerlink" title="6.5 HTTP2"></a>6.5 HTTP2</h2><p>特点：</p><ul><li>头部压缩</li><li>多路复用：多路复用允许同时通过单一的HTTP/2连接发送多重请求-响应信息。改善了在HTTP1.1中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制（连接数量），超过限制会被阻塞。</li><li>提升访问速度：相比HTTP1.1请求资源所需时间更少，访问速度更快</li><li>二进制分帧：HTTP2.0会将所有的传输信息分割成更小的信息或者帧，并对他们进行二进制编码。</li><li>设置请求优先级</li><li>服务端推送</li></ul><h2 id="6-6-Cookie"><a href="#6-6-Cookie" class="headerlink" title="6.6 Cookie"></a>6.6 Cookie</h2><p>HTTP是一个无状态协议，因此Cookie的最大作用就是存储sessionId用来唯一标识用户。并且，Cookie本质上就是浏览器里面存储的一个很小的文本文件，内部以键值对的方式来存储。</p><h3 id="6-6-1-生命周期"><a href="#6-6-1-生命周期" class="headerlink" title="6.6.1 生命周期"></a>6.6.1 生命周期</h3><p>通过Expries和Max-Age两个属性来设置：</p><ul><li>Expries：过期时间</li><li>Max-Age：表示一段时间间隔，单位是秒，从浏览器收到报文开始计算。</li></ul><h3 id="6-6-2-作用域"><a href="#6-6-2-作用域" class="headerlink" title="6.6.2 作用域"></a>6.6.2 作用域</h3><p>可以使用Domain和path属性给Cookie绑定域名和路径。如果在发送请求之前，发现域名或路径和这两个属性不匹配，那么就不会带上Cookie。需要注意，路径中含有<code>/</code>，表示域名下的任意路径都允许使用Cookie。</p><h3 id="6-6-3-安全"><a href="#6-6-3-安全" class="headerlink" title="6.6.3 安全"></a>6.6.3 安全</h3><ul><li>带上Secure：说明只能通过HTTPS传输Cookie。</li><li>带上HttpOnly：说明只能通过HTTP协议传输。</li><li>带上SameSite：预防CSRF攻击。</li></ul><h3 id="6-6-4-缺点"><a href="#6-6-4-缺点" class="headerlink" title="6.6.4 缺点"></a>6.6.4 缺点</h3><ul><li>1、安全缺陷：Cookie容易被非法用户截获，然后进行一系列的篡改，最后在Cookie有效期内重新发送给服务器。</li><li>2、容量缺陷：体积上限只有4KB，只能用来存储少量的信息。</li><li>3、性能缺陷：Cookie紧跟域名，因此域名下的请求都会携带上完整的Cookie，这样随着请求数的增多，将会造成巨大的性能浪费，因此请求携带了很多不必要的内容。这里可以通过Domain和Path指定作用域去解决。</li></ul><h3 id="6-7-HTTP传输中常见的问题"><a href="#6-7-HTTP传输中常见的问题" class="headerlink" title="6.7 HTTP传输中常见的问题"></a>6.7 HTTP传输中常见的问题</h3><ul><li>跨域问题</li><li>数据传输</li><li>队头阻塞</li></ul><h1 id="7-传输层"><a href="#7-传输层" class="headerlink" title="7. 传输层"></a>7. 传输层</h1><p>当设备A和设备B相互通信时，可以认为它们就是通过一个虚拟的互联网络进行连接的。<strong>在虚拟的网络世界里面已经解决了网络拓扑、数据路由的走向等问题。在传输层重点解决的是两个设备它们是如何直接进行通信的。</strong></p><h2 id="7-1-传输层的主要功能"><a href="#7-1-传输层的主要功能" class="headerlink" title="7.1 传输层的主要功能"></a>7.1 传输层的主要功能</h2><h3 id="7-1-1-进程与进程的通信"><a href="#7-1-1-进程与进程的通信" class="headerlink" title="7.1.1 进程与进程的通信"></a>7.1.1 进程与进程的通信</h3><p>不同于在单个操作系统中使用的进程间通信（Unix域套接字、共享内存），网络通信可以跨设备、跨网络进行通信。</p><h3 id="7-1-2-端口的概念"><a href="#7-1-2-端口的概念" class="headerlink" title="7.1.2 端口的概念"></a>7.1.2 端口的概念</h3><p>使用端口来标记不同的网络进程。</p><p>端口使用16比特位表示（0~65535）。</p><p>常见的协议端口有：</p><table><thead><tr><th align="center">协议</th><th align="center">端口</th></tr></thead><tbody><tr><td align="center">FTP</td><td align="center">21</td></tr><tr><td align="center">HTTP</td><td align="center">80</td></tr><tr><td align="center">HTTPS</td><td align="center">443</td></tr><tr><td align="center">DNS</td><td align="center">53</td></tr><tr><td align="center">TELNET</td><td align="center">23</td></tr></tbody></table><h2 id="7-2-UDP（User-Datagram-Protocol）用户数据报协议"><a href="#7-2-UDP（User-Datagram-Protocol）用户数据报协议" class="headerlink" title="7.2 UDP（User Datagram Protocol）用户数据报协议"></a>7.2 UDP（User Datagram Protocol）用户数据报协议</h2><img src="/2020/05/29/Android网络优化-01：网络基础（上）/微信图片_20200531144749.png"><h3 id="7-2-1-功能"><a href="#7-2-1-功能" class="headerlink" title="7.2.1 功能"></a>7.2.1 功能</h3><p>UDP协议不会对数据进行任何处理，即不合并，也不拆分数据。</p><h3 id="7-2-2-特点"><a href="#7-2-2-特点" class="headerlink" title="7.2.2 特点"></a>7.2.2 特点</h3><ul><li>1、无连接：通信时并不需要提前建立连接。</li><li>2、不保证可靠的数据交付：想发就发，无法保证数据在网络传输过程中是否丢失。</li><li>3、面向报文传输：不对数据做任何处理，而是直接将应用层数据塞进报文里面。</li><li>4、没有拥塞控制：不管网络是否拥塞，它都会把数据给交付出去。</li><li>5、首部开销很小：首部仅占用8字节。</li></ul><h3 id="7-2-3-报文结构"><a href="#7-2-3-报文结构" class="headerlink" title="7.2.3 报文结构"></a>7.2.3 报文结构</h3><img src="/2020/05/29/Android网络优化-01：网络基础（上）/171e4f8a2e5c838f"><ul><li>UDP长度最小为8，即仅包括UDP首部。</li><li>校验和用来检测UDP的数据报在传输过程中是否出错。</li></ul><h3 id="7-2-4-基于UDP定制化的5个例子"><a href="#7-2-4-基于UDP定制化的5个例子" class="headerlink" title="7.2.4 基于UDP定制化的5个例子"></a>7.2.4 基于UDP定制化的5个例子</h3><p><strong>1、来自网页或者App的访问</strong></p><p>目前，HTTP往往采用多个数据通道共享一个连接的策略，这样做本来是为了加快传输速度，但是TCP严格的顺序策略使得哪怕通道共享，前一个包不来，后面的包即使与前一个包没有关系，也要等着，这样就会使延时很大。</p><p>而QUIC（Quick UDP Internet Connection，快速UDP互联网连接）协议是Google提供基于UDP改进的通信协议，其目的是降低网络通信的延迟，提供更好的用户体验。</p><p>QUIP会在应用层上自己快速建立连接、减少重传延时、自适应拥塞控制，是应用层定制化的代表。</p><p><strong>2、流媒体协议</strong></p><p>直播通常都使用RTMP（Real Time Messaging Protocol，实时消息传输协议），基于TCP。但对于直播来说，实时性很重要，宁可丢包，也不要卡顿。</p><p>对于视频直播来说，有的包可以丢，有的包不能丢，因为在视频的连续帧里，有的帧重要，有的不重要，如果一定要丢包，隔几个丢一个，看视频的人不会感知，但是如果连续丢帧，就能感知，因此网络条件不好的情况下，应用一般会选择性的丢帧。</p><p>当网络不好的时候，TCP会主动降低发送速度，这对本来就卡的视频来说无疑是雪上加霜。TCP应该让应用层马上重传，而不是主动让步。因此，很多直播应用都是基于UDP实现了自己的视频传输协议。</p><p><strong>3、实时游戏</strong></p><p>维护TCP连接需要在内核维护一些数据结构，但是一台机器能够支撑的TCP连接数目有限。由于UDP是没有连接的，所以在异步I/O机制引入之前，UDP常常是应对海量客户端连接的策略。</p><p>在游戏对实时要求比较严格的情况下，可以采用自定义的可靠UDP来传输数据包，通过使用自定义重传策略，能够使丢包产生的延时降到最低，尽量减少网络问题对游戏造成的影响。</p><p><strong>4、物联网</strong><br>Google旗下的Nest建立了Thread Group，推出物联网通信协议Thread，该协议就是基于UDP的。</p><p><strong>5、移动通信领域</strong><br>在4G网络里，通过移动通信传输数据面对的协议GTP-U就是基于UDP的。关于移动网络的知识下一篇会详细讲解。</p><h2 id="7-3-TCP（Transmission-Control-Protocol）传输控制协议"><a href="#7-3-TCP（Transmission-Control-Protocol）传输控制协议" class="headerlink" title="7.3 TCP（Transmission Control Protocol）传输控制协议"></a>7.3 TCP（Transmission Control Protocol）传输控制协议</h2><img src="/2020/05/29/Android网络优化-01：网络基础（上）/微信图片_20200531144933.png"><h3 id="7-3-1-特点"><a href="#7-3-1-特点" class="headerlink" title="7.3.1 特点"></a>7.3.1 特点</h3><ul><li>1、面向连接：就像打电话时，需要先拨通电话。</li><li>2、点对点通信、</li><li>3、可靠的传输服务。</li><li>4、全双工通信：两个设备在连接时，它们可以同时发送数据与接收数据。</li><li>5、面向字节的协议：TCP处理的是一个一个的字节，所以TCP很可能会取出数据中某一段进行输出，而剩下的数据会把它放到第二段以及之后的TCP报文中进行传输。因此TCP协议可能会对用户的数据进行合并和拆分。</li></ul><p>TCP的缺点在于<strong>传输效率慢，因为它需要建立连接、发送确认包等等</strong>。</p><h3 id="7-3-2-报文首部字段"><a href="#7-3-2-报文首部字段" class="headerlink" title="7.3.2 报文首部字段"></a>7.3.2 报文首部字段</h3><img src="/2020/05/29/Android网络优化-01：网络基础（上）/171e4f8fd9c58bec"><p><strong>序号</strong></p><ul><li>表示范围为<code>0 ~ 2^32 - 1</code>。</li><li>因为TCP是面向字节流的，所以每一字节都有一个与之对应的序号。</li><li>TCP数据报的序号就是数据报中第一个字节的序号。</li></ul><p><strong>确认号</strong></p><ul><li>表示范围<code>0 ~ 2^32 - 1</code>。</li><li>表示期望收到的数据的首字节序号，如果确认号为S，则表示 S - 1序号的数据都已经收到了。</li></ul><p><strong>数据偏移</strong></p><ul><li>占4位：0 ~ 15，单位为：32位字。 =&gt; 首部范围为20~60字节。</li><li>TCP数据偏移首部的距离，因为TCP选项的大小是不确定的，所以需要此数据项。</li></ul><p><strong>TCP标记</strong><br>占6位，每位都有不同的含义。</p><table><thead><tr><th align="center">标记</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">URG(Urgent)</td><td align="center">紧急位，URG = 1，表示紧急数据</td></tr><tr><td align="center">ACK(Acknowledgement)</td><td align="center">确认位，ACK = 1，确认号才生效</td></tr><tr><td align="center">PSH(Push)</td><td align="center">推送位，PSH = 1，表示需要尽快地把数据交付给应用层</td></tr><tr><td align="center">RST(Rest)</td><td align="center">重置位，RST = 1，表示重新建立连接</td></tr><tr><td align="center">SYN(Synchronizeation)</td><td align="center">同步位，SYN = 1，表示连接请求报文</td></tr><tr><td align="center">FIN(Finish)</td><td align="center">终止位，FIN = 1，表示释放连接</td></tr></tbody></table><p><strong>窗口</strong></p><ul><li>占位16位：<code>0 ~ 2^16 - 1</code>.</li><li>窗口指明允许对方发送的数据量。例如，确认号为201，窗口号为300，那么可以接收序号的范围是201~500。</li></ul><p><strong>校验和</strong></p><ul><li>与UDP类似，用来检测TCP的数据在传输过程中是否出错。</li></ul><p><strong>紧急指针</strong></p><ul><li>紧急数据（URG = 1）</li><li>指定紧急数据在报文中的位置</li></ul><p><strong>TCP选项</strong></p><ul><li>最多40字节</li><li>支持未来的扩展</li></ul><h2 id="7-4-可靠传输的基本原理"><a href="#7-4-可靠传输的基本原理" class="headerlink" title="7.4 可靠传输的基本原理"></a>7.4 可靠传输的基本原理</h2><h3 id="7-4-1-停止等待协议"><a href="#7-4-1-停止等待协议" class="headerlink" title="7.4.1 停止等待协议"></a>7.4.1 停止等待协议</h3><p>当发送方发送一个消息时，接收方接收到了并将消息发给发送方，这个过程中<strong>发送方需要停止等待接收方的确认信息</strong>。</p><p><strong>超时重传</strong></p><p>当消息发送出去后，发送方没有在超时时间内接收到接收方的确认消息或者超时之后才接收到消息，此时会向发送方重新发送该消息。超时重传<strong>通常都会处理三种异常情况</strong>，如下：</p><ul><li>发送的消息在路上丢失了</li><li>确认的消息在路上丢失了</li><li>确认的消息超时了才收到</li></ul><p><strong>超时定时器（超时重传定时器）</strong></p><ul><li>1、每发送一个消息，都需要设置一个超时定时器。</li><li>2、主要应用在TCP的可靠传输协议里面，它是为了控制可能发生丢失的报文而设计的定时器，当TCP协议发送端发送一个报文时，就会为该报文设置一个超时定时器。</li><li>3、如果超时定时器在结束之前收到了来自接收端对该报文段的确认，则撤销这个定时器。</li><li>4、如果在超时定时器结束之前仍然没有收到接收端的报文段的确认（超时），则认为这个报文可能已经丢弃，发送端会重新发送该报文，并设置一个超时定时器。</li><li>5、需要注意，发送端在超时定时器撤销之前，必须继续缓存已发送未确认的报文，直到发送端接收到来自接收端的确认。</li></ul><p><strong>特点</strong></p><ul><li>停止等待协议是最简单的可靠传输协议</li><li>对信道的利用率不高</li></ul><h3 id="7-4-2-连续ARQ-Automatic-Repeat-Request-自动重传请求协议"><a href="#7-4-2-连续ARQ-Automatic-Repeat-Request-自动重传请求协议" class="headerlink" title="7.4.2 连续ARQ(Automatic Repeat Request)自动重传请求协议"></a>7.4.2 连续ARQ(Automatic Repeat Request)自动重传请求协议</h3><p>前面说到单个发送和确认效率低，那么是否可以批量发送和确认？</p><p>ARQ是对停止等待协议的改进，可以<strong>大幅提高信道利用率</strong>的一个协议。</p><p><strong>滑动窗口</strong></p><ul><li>1、窗口中的数据都可以发送。</li><li>2、通过移动窗口的方式来标识没有接收到确认的消息。</li><li>3、采用了累积确认的方式，并不需要对每一个消息都进行确认。</li></ul><p><strong>累积确认</strong></p><ul><li>只要收到第5个消息的确认，就表示1~5的消息接收方都收到了。</li></ul><h2 id="7-5-TCP协议的可靠传输"><a href="#7-5-TCP协议的可靠传输" class="headerlink" title="7.5 TCP协议的可靠传输"></a>7.5 TCP协议的可靠传输</h2><p>TCP的可靠传输是基于ARQ协议。</p><ul><li>1、滑动窗口</li><li>2、累积确认</li><li>3、选择重连</li></ul><p><strong>选择重传</strong></p><ul><li>1、选择重传需要制定需要重传的字节。</li><li>2、每一个字节都有唯一的32位序号（4字节）。</li><li>3、要重传的数据是存储在TCP选项中，其中最多只能存储10个序号，即5个范围段的信息。</li><li>4、选择重传的是一个信息边界，即一段字节流，例如：传送1000<del>1200，2000</del>3000这个范围内的信息。</li></ul><h2 id="7-6-TCP协议的流量控制"><a href="#7-6-TCP协议的流量控制" class="headerlink" title="7.6 TCP协议的流量控制"></a>7.6 TCP协议的流量控制</h2><p>流量控制是指<strong>让发送方效率不要太快，TCP使用了滑动窗口来实现流量控制</strong>。</p><h3 id="7-6-1-滑动窗口"><a href="#7-6-1-滑动窗口" class="headerlink" title="7.6.1 滑动窗口"></a>7.6.1 滑动窗口</h3><p>rwnd = 300，表示窗口大小为300。</p><ul><li>占16位，<code>0 ~ 2 ^ 16 - 1</code></li><li>窗口指明允许对方发送的数据量。例如：确认号为201，窗口为300，那么可以接收序号的范围是201 ~ 500</li><li>接收方可以调整滑动窗口的大小来控制发送方发送数据的效率。</li><li>当接收方将rwnd从0调整为1000并将这个信息发送给发送方时，消息丢失了，这就会导致发送方和接收方都会等待，形成一个死锁局面。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如何解决这种死锁局面？</span><br></pre></td></tr></table></figure><h3 id="7-6-2-坚持定时器"><a href="#7-6-2-坚持定时器" class="headerlink" title="7.6.2 坚持定时器"></a>7.6.2 坚持定时器</h3><p>坚持定时器是使用了滑动窗口进行流量控制的时候设置的。</p><ul><li>1、当接收到窗口为0的消息，则启动坚持定时器。</li><li>2、坚持定时器每隔一段时间发送一个窗口探测报文。</li></ul><h2 id="7-7-TCP协议的拥塞控制"><a href="#7-7-TCP协议的拥塞控制" class="headerlink" title="7.7 TCP协议的拥塞控制"></a>7.7 TCP协议的拥塞控制</h2><h3 id="7-7-1-问题"><a href="#7-7-1-问题" class="headerlink" title="7.7.1 问题"></a>7.7.1 问题</h3><ul><li>一条数据链路经常经过非常多的设备。</li><li>数据链路中各个部分都有可能成为网络传输的瓶颈。</li></ul><h3 id="7-7-2-流量控制和拥塞控制的区别"><a href="#7-7-2-流量控制和拥塞控制的区别" class="headerlink" title="7.7.2 流量控制和拥塞控制的区别"></a>7.7.2 流量控制和拥塞控制的区别</h3><p>不同于流量控制的点对点的通信量的控制，拥塞控制考虑的是整个网络，是一个全局性的考虑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如何判断是否拥塞？</span><br></pre></td></tr></table></figure><p><strong>简单的认为报文超时就发生了拥塞</strong>。</p><p><strong>TCP的拥塞控制</strong></p><ul><li>1、慢启动算法<ul><li>有小到大逐渐增加发送数据量（呈指数增长，例如，1、2、4、8、16）</li><li>每收到一个报文确认，就加1</li><li>超过慢启动阈值(ssthresh)，就不再增长</li></ul></li><li>2、拥塞避免算法<ul><li>维护一个拥塞窗口的变量</li><li>只要网络不拥塞，就试探着将拥塞窗口调大</li></ul></li></ul><p><strong>TCP的拥塞控制在前期使用了慢启动算法对窗口大小进行指数增长，直到超过慢启动阈值（ssthresh）则不再增长，后续则启动拥塞避免算法对窗口进行线性增长</strong>。</p><h2 id="7-8-TCP链接的建立-三次握手"><a href="#7-8-TCP链接的建立-三次握手" class="headerlink" title="7.8 TCP链接的建立-三次握手"></a>7.8 TCP链接的建立-三次握手</h2><img src="/2020/05/29/Android网络优化-01：网络基础（上）/微信图片_20200601161619.png"><p><strong>为什么发送方要发出第三个确认报文呢？</strong></p><ul><li>1、已经失效的链接请求报文传送到对方，引出错误：假设两次握手就可以，失效的链接请求报文就会被接收并建立了重复的连接。当使用第三次握手时，比较慢到达接收方的报文也会发送一次确认给发送方，但是发送方已经进行了第三次握手了，因此发送方会忽略掉第二的确认，不会进行任何操作。</li><li>2、因为信道不可靠，而TCP想在不可靠的信道上建立可靠的传输，那么三次通信是理论上的最小值。（而UDP则不需要建立可靠传输，因此UDP不需要三次握手）。</li><li>3、因为双方都需要确认对方收到了自己发送的序号，确认过程最少要进行三次通信。</li></ul><h2 id="7-9-TCP链接的释放-四次挥手"><a href="#7-9-TCP链接的释放-四次挥手" class="headerlink" title="7.9 TCP链接的释放-四次挥手"></a>7.9 TCP链接的释放-四次挥手</h2><img src="/2020/05/29/Android网络优化-01：网络基础（上）/微信图片_20200601163343.png"><h3 id="7-9-1-等待计时器"><a href="#7-9-1-等待计时器" class="headerlink" title="7.9.1 等待计时器"></a>7.9.1 等待计时器</h3><ul><li>会等待2MSL时间 =&gt; 4分钟</li><li>时间等待定时器是由在四次挥手时由主动关闭TCP连接的一方设置的，它主要是为了<strong>保证主动关闭方在对最后一个FIN报文（第三次挥手）发送确认的报文可以到达接收方</strong>。</li><li>MSL（Max Segment Lifetime）：最长报文段寿命。MSL建议设置为2分钟。</li></ul><h3 id="7-9-2-为什么要等待2MSL？"><a href="#7-9-2-为什么要等待2MSL？" class="headerlink" title="7.9.2 为什么要等待2MSL？"></a>7.9.2 为什么要等待2MSL？</h3><ul><li>1、因为最后一个报文没有确认，需要确保发送方的ACK可以到达接收方，如果2MSL时间内没有收到，则接收方会重发。</li><li>2、2MSL时间可以保证当发送方没有收到确认时，接收方可以再次发送FIN报文，并且接收方可以再次收到并重新发送确认，所以2MSL的时间可以保证连接正常结束。</li><li>3、确保当前连接的所有报文都已经过期。</li></ul><h2 id="7-10-TCP与UDP的区别"><a href="#7-10-TCP与UDP的区别" class="headerlink" title="7.10 TCP与UDP的区别"></a>7.10 TCP与UDP的区别</h2><ul><li>1、 UD常用于多媒体信息分发，即视频、语音、实时信息等。而TCP常用于可靠的信息传输，如金融交易、可靠通信、MQ等。</li><li>2、TCP面向连接，UDP是无连接的。</li><li>3、TCP提供可靠的服务，即，通过TCP连接传送的数据，无差错、不丢失、不重复，且按序达到；UDP尽最大的努力交付，但不保证可靠交付。</li><li>4、TCP的逻辑通信信道是全双工的可靠信道；UDP则是不可靠信道。</li><li>5、每一条TCP连接只能是点到点的；UDP支持一对一，一对多，多对一，多对多的交互通信。</li><li>6、TCP面向字节流（可能出现黏包问题），实际上是TCP把数据看成一连串无结构的字节流；UDP是面向报文的（不会出现黏包问题）。</li><li>7、UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）。</li><li>8、TCP首部开销20字节；UDP的首部开销小，只有8字节。</li></ul><h2 id="7-11-套接字（Socket）"><a href="#7-11-套接字（Socket）" class="headerlink" title="7.11 套接字（Socket）"></a>7.11 套接字（Socket）</h2><p>可以使用端口（Port）来标记不同的网络进程，而端口使用了16比特表示（0~65535）。</p><h3 id="7-11-1-Socket概念"><a href="#7-11-1-Socket概念" class="headerlink" title="7.11.1 Socket概念"></a>7.11.1 Socket概念</h3><ul><li>套接字是一个抽象的概念，表示TCP连接的一端。</li><li>通过套接字可以进行数据的发送或接收。</li><li>TCP = {Socket1:Socket2} = {{IP:Port}{IP:Port}}，可以看到，TCP由两个套接字组成。</li></ul><h3 id="7-11-2-Socket编程"><a href="#7-11-2-Socket编程" class="headerlink" title="7.11.2 Socket编程"></a>7.11.2 Socket编程</h3><p><strong>服务端编程</strong></p><ul><li>1、创建Socket</li><li>2、绑定Socket</li><li>3、监听Socket</li><li>4、接收和处理消息</li></ul><p>其代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">server</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 1、创建 Socket</span></span><br><span class="line">    s = socket.socket()</span><br><span class="line">    host = <span class="string">"127.0.0.1"</span></span><br><span class="line">    port = <span class="number">5678</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2、绑定 Socket</span></span><br><span class="line">    s.bind(host, port)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3、监听</span></span><br><span class="line">    s.listen()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4、发送数据</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        c, addr = s.accept()</span><br><span class="line">        print(<span class="string">"connect addr"</span>, addr)</span><br><span class="line">        c.send(<span class="string">b'Socket Study.'</span>)</span><br><span class="line">        c.close()</span><br></pre></td></tr></table></figure><p><strong>客户端编程</strong></p><ul><li>1、创建Socket</li><li>2、连接Socket</li><li>3、发送消息</li></ul><p>其代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client</span><span class="params">(i)</span>:</span></span><br><span class="line">    <span class="comment"># 1、创建 Socket</span></span><br><span class="line">    s = socket.socket()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2、连接 Socket</span></span><br><span class="line">    s.connect((<span class="string">'127.0.0.1'</span>, <span class="number">5678</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3、接收消息</span></span><br><span class="line">    print(<span class="string">"Received message:%s, client Id:%d"</span> % (s.recv(<span class="number">1024</span>), i))</span><br><span class="line">    s.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        client(i)</span><br></pre></td></tr></table></figure><p>单机通信更推荐使用域Socket，相比网络通信数据需要在整个协议栈走一轮，域Socket它的处理流程更加简单，系统消耗更小。此外，如果对Socket IO实现机制有兴趣的可以查看<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Socket.md" target="_blank" rel="noopener">CS-Notes</a>。</p><h2 id="7-12-TCP协议细节之TCP协议的四个定时器"><a href="#7-12-TCP协议细节之TCP协议的四个定时器" class="headerlink" title="7.12 TCP协议细节之TCP协议的四个定时器"></a>7.12 TCP协议细节之TCP协议的四个定时器</h2><ul><li>1、超时定时器</li><li>2、坚持定时器</li><li>3、时间等待定时器</li><li>4、保活定时器：服务端一般都会设置一个保活定时器，为了保活TCP连接而设计的，可以防止TCP连接的两端出现长时间的空闲，当一方出现变化或者故障时，另一方没有察觉的情况。当服务端每次收到对方的数据则重置这个定时器，如果定时器超时，则发送弹出报文段，以此探测客户端是否在线，如果没有收到响应的话，那么则认为客户端已经断开连接，因此服务端也会终止这个连接。如今，很多的分布式系统都会使用保活计时器来检测其他节点是否在线还是已经故障，或者其他节点也会每个一段时间向主节点上报心跳信息以证明在线。</li></ul><h2 id="7-13-TCP在三次握手的时候，IP层和MAC（Medium-Access-Control）层在做什么？"><a href="#7-13-TCP在三次握手的时候，IP层和MAC（Medium-Access-Control）层在做什么？" class="headerlink" title="7.13 TCP在三次握手的时候，IP层和MAC（Medium Access Control）层在做什么？"></a>7.13 TCP在三次握手的时候，IP层和MAC（Medium Access Control）层在做什么？</h2><p>TCP每发送一条消息，都会带着IP层和MAC层。因为TCP每发送一个消息，IP层和MAC层的所有机制都要运行一遍。</p><p>注意，<strong>只要是网络上跑的包，都是完整的。可以有下层没有上层，绝对不会有上层没有下层。所以，对TCP来说，无论是三次握手还是重试，只要想将网络包发送出去，就要有IP层和MAC层，不然发不出去</strong>。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li>1、慕课网之《编程必备基础 计算机组成原理+操作系统+计算机网络》网络部分 9 - 13章</li><li>2、《趣谈网络协议》1 - 5章</li><li>3、《计算机网络 自顶向下方法》前 6 章</li><li>4、<a href="https://juejin.im/post/5e76bd516fb9a07cce750746" target="_blank" rel="noopener">(建议精读)HTTP灵魂之问，巩固你的HTTP知识体系</a></li><li>5、<a href="https://juejin.im/post/5e527c58e51d4526c654bf41" target="_blank" rel="noopener">(建议收藏)TCP协议灵魂之问，巩固你的网路底层基础</a></li><li>6、<a href="https://juejin.im/post/5e91b01651882573716a9b23#heading-90" target="_blank" rel="noopener">一位前端小姐姐的五万字面试宝典</a></li><li>7、<a href="https://juejin.im/post/5ad7e6c35188252ebd06acfa#heading-2" target="_blank" rel="noopener">面试带你飞：这是一份全面的计算机网络基础总结攻略</a></li><li>8、<a href="https://github.com/Snailclimb/JavaGuide#%E7%BD%91%E7%BB%9C" target="_blank" rel="noopener">JavaGuide-网络</a></li><li>9、<a href="https://github.com/huihut/interview#%EF%B8%8F-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C" target="_blank" rel="noopener">interview-网络</a></li><li>10、<a href="https://juejin.im/post/5b44a485e51d4519945fb6b7#heading-38" target="_blank" rel="noopener">总结了17年初到18年初百场前端面试的面试经验(含答案)</a></li><li>11、<a href="https://github.com/CyC2018/CS-Notes#cloud-%E7%BD%91%E7%BB%9C" target="_blank" rel="noopener">CS-Notes-网络</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文地址：&lt;a href=&quot;https://juejin.im/post/5eba5a39e51d454de64e49b1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://juejin.im/post/5eba5a39e51d454de64e
      
    
    </summary>
    
      <category term="Android" scheme="https://tylerLiu.top/categories/Android/"/>
    
      <category term="网络" scheme="https://tylerLiu.top/categories/Android/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="https://tylerLiu.top/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Android蓝牙串口SPP开发</title>
    <link href="https://tylerLiu.top/2020/05/28/Android%E8%93%9D%E7%89%99%E4%B8%B2%E5%8F%A3SPP%E5%BC%80%E5%8F%91/"/>
    <id>https://tylerLiu.top/2020/05/28/Android蓝牙串口SPP开发/</id>
    <published>2020-05-28T00:41:11.000Z</published>
    <updated>2020-05-29T01:53:27.517Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址：<a href="https://blog.gtf35.top/bluetooth_spp/" target="_blank" rel="noopener">https://blog.gtf35.top/bluetooth_spp/</a></p><p>【这里仅供学习】</p><h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h1><p>物联网形势下，经常需要用到蓝牙串口来和单片机通讯。问题：</p><ul><li>蓝牙串口是什么？</li><li>如何扫描蓝牙设备？</li><li>如果连接蓝牙设备？</li><li>如果收发串口数据？</li></ul><h1 id="1-蓝牙串口是什么？"><a href="#1-蓝牙串口是什么？" class="headerlink" title="1. 蓝牙串口是什么？"></a>1. 蓝牙串口是什么？</h1><p>先介绍一下串口，串行接口简称串口，就是一种通信的方式，类似于USB，只是比USB低级多。但是手机等设备没有外设这个串口，解决方案就是用手机蓝牙模块连接一个小硬件，小硬件有个串口，可以和单片机连接，来达到手机和单片机的串口连接，这种方式就是蓝牙串口。</p><p>那个小硬件就是“蓝牙透传模块”，淘宝上有卖，有专用的上位机。</p><img src="/2020/05/28/Android蓝牙串口SPP开发/微信图片_20200528100557.png" title="[蓝牙透传模块]"><p>这里要做的就是打开电脑上蓝牙模块的上位机的串口界面，能正常收发数据即可：</p><img src="/2020/05/28/Android蓝牙串口SPP开发/微信图片_20200528100758.png" title="[蓝牙透传模块上位机图]"><h1 id="2-如何扫描蓝牙设备？"><a href="#2-如何扫描蓝牙设备？" class="headerlink" title="2. 如何扫描蓝牙设备？"></a>2. 如何扫描蓝牙设备？</h1><p>为什么不直接连接，而是扫描呢？</p><p>因为连接需要使用<code>BluetoothDevice</code>，这个东西要么搜索到，要么使用“MAC”地址构造。“MAC”地址是每台设备独一无二的，所以必须要扫描设备，获取周围所有的设备列表，拿到<code>BluetoothDevice</code>来连接。同时取出里面的“MAC”地址，保存，用于下次连接。</p><p>首先获取系统的蓝牙适配器，所有的搜索，连接，等操作都要靠它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BluetoothAdapter mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();</span><br></pre></td></tr></table></figure><p>然后判断用户的蓝牙是否已开启：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获取用户是否打开了蓝牙</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isBluetoothEnable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mBluetoothAdapter.isEnabled();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开启蓝牙：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 开启蓝牙</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enableBluetooth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mBluetoothAdapter.enable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>蓝牙开启之后，就可以搜索设备列表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mBluetoothAdapter.startDiscovery();</span><br></pre></td></tr></table></figure><p>搜索前，还需要判断是不是已经在搜索了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mBluetoothAdapter.isDiscovering();</span><br></pre></td></tr></table></figure><p>如果正在搜索，就取消搜索：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mBluetoothAdapter.cancelDiscovery();</span><br></pre></td></tr></table></figure><p>结合起来就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 开始搜索</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startDiscovery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mBluetoothAdapter.isDiscovering()) mBluetoothAdapter.cancelDiscovery();</span><br><span class="line">    mBluetoothAdapter.startDiscovery();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，结果在哪获取？可以通过广播。</p><p>先定义一个广播接收器，获取搜索结果的<code>Action</code>是<code>BluetoothDevice.ACTION_FOUND</code>，然后在里面取出<code>BluetoothDevice.EXTRA_DEVICE</code>，就可以获得<code>BluetoothDevice</code>了。</p><p>自定义广播：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 搜索到新设备广播广播接收器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BroadcastReceiver mReceiver = <span class="keyword">new</span> BroadcastReceiver() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        String action = intent.getAction();</span><br><span class="line">        <span class="keyword">if</span> (BluetoothDevice.ACTION_FOUND.equals(action)) &#123;</span><br><span class="line">            <span class="comment">// 这就是可爱的 BluetoothDevice 了</span></span><br><span class="line">            BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注册广播：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IntentFilter foundFilter = <span class="keyword">new</span> IntentFilter(BluetoothDevice.ACTION_FOUND);</span><br><span class="line">mContext.registerReceiver(mReceiver, foundFilter);</span><br></pre></td></tr></table></figure><p>添加权限：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--管理蓝牙需要--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.BLUETOOTH"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.BLUETOOTH_ADMIN"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--搜索蓝牙需要，因为蓝牙可以被用来定位，所以需要定位权限--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.ACCESS_COARSE_LOCATION"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.ACCESS_FINE_LOCATION"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>这样在触发搜索逻辑之后，每次找到一个新设备就会收到一个广播，拿到<code>BluetoothDevice</code>之后，就可以获取“MAC“地址：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bluetoothDevice.getAddress();</span><br></pre></td></tr></table></figure><p>保存下来，下次使用的时候就可以用它二次获取<code>BluetoothDevice</code>了:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bluetoothDevice = bluetoothAdapter.getRemoteDevice(<span class="string">"之前保存过的蓝牙MAC地址"</span>);</span><br></pre></td></tr></table></figure><p>到这里，搜索部分结束。</p><h1 id="3-如何连接蓝牙设备"><a href="#3-如何连接蓝牙设备" class="headerlink" title="3. 如何连接蓝牙设备"></a>3. 如何连接蓝牙设备</h1><p>前面说到，拿到<code>BluetoothDevice</code>就可以用来连接了，连接很简单，首先要知道每个蓝牙设备都有一个UUID来描述自己是什么设备，蓝牙串口设备到的缩写是SPP，它的UUID如下，其他的UUID详情，可以参考<a href="https://www.bluetooth.com/specifications/assigned-numbers/service-discovery/" target="_blank" rel="noopener">这里</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UUID SPP_UUID = UUID.fromString(<span class="string">"00001101-0000-1000-8000-00805F9B34FB"</span>);</span><br></pre></td></tr></table></figure><p>然后用前面拿到的<code>BluetoothDevice</code>来打开指定UUID的连接即可获取到蓝牙的<code>Socket</code>，注意，只能和UUID类型对应的设备连接，比如这里设置的UUID是SPP的，和普通的手机就连不上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BluetoothSocket bluetoothSocket = bluetoothDevice.createRfcommSocketToServiceRecord(SPP_UUID);</span><br></pre></td></tr></table></figure><p>调用<code>BluetoothSocket</code>的<code>connect()</code>方法建立和蓝牙模块的连接，如果之前没有配对过，会弹出系统窗口，要求输入配对密码，这里系统会自动处理。要注意<code>connect()</code>方法会阻塞线程，需要在子线程连接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待连接，会阻塞线程</span></span><br><span class="line">bluetoothSocket.connect();</span><br></pre></td></tr></table></figure><p>然后通过<code>BluetoothSocket</code>即可拿到输入流和输出流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来收数据</span></span><br><span class="line">InputStream inputStream = bluetoothSocket.getInputStream();</span><br><span class="line"><span class="comment">// 用来发数据</span></span><br><span class="line">OutputStream outputStream = bluetoothSocket.getOutputStream();</span><br></pre></td></tr></table></figure><h1 id="4-如何收发串口数据"><a href="#4-如何收发串口数据" class="headerlink" title="4. 如何收发串口数据"></a>4. 如何收发串口数据</h1><p>发数据就是传统的流操作，调用<code>OutputStream</code>的<code>write(byte[])</code>方法来写入流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> msg 内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">byte</span>[] msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        bluetoothSocket.getOutputStream().write(msg);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e)&#123;e.printStackTrace();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>收数据需要注意，需要写一个死循环，反复读取，因为串口发来的一句话很可能是分成好几段发来的，和单片机的开发约定好一个停止位，没收到停止位之前，就一直累加，这里给出一个调试好的模板代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录标志位，开始运行</span></span><br><span class="line"><span class="keyword">boolean</span> isRunning = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 约定好的停止位</span></span><br><span class="line">String stopString = <span class="string">"\r\n"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 开始监听数据接收</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    InputStream inputStream = bluetoothSocket.getInputStream();</span><br><span class="line">    <span class="keyword">byte</span>[] result = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span> (isRunning) &#123;</span><br><span class="line">        logD(<span class="string">"looping"</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="comment">// 等待有数据</span></span><br><span class="line">        <span class="keyword">while</span> (inputStream.available() == <span class="number">0</span> &amp;&amp; isRunning) &#123;<span class="keyword">if</span> (System.currentTimeMillis() &lt; <span class="number">0</span>) <span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">while</span> (isRunning) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> num = inputStream.read(buffer);</span><br><span class="line">                <span class="keyword">byte</span>[] temp = <span class="keyword">new</span> <span class="keyword">byte</span>[result.length + num];</span><br><span class="line">                System.arraycopy(result, <span class="number">0</span>, temp, <span class="number">0</span>, result.length);</span><br><span class="line">                System.arraycopy(buffer, <span class="number">0</span>, temp, result.length, num);</span><br><span class="line">                result = temp;</span><br><span class="line">                <span class="keyword">if</span> (inputStream.available() == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="comment">// todo:处理接收数据单次失败</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 返回数据</span></span><br><span class="line">            logD(<span class="string">"当前累计收到的数据=&gt;"</span> + byte2Hex(result));</span><br><span class="line">            <span class="keyword">byte</span>[] stopFlag = stopString.getBytes();</span><br><span class="line">            <span class="keyword">int</span> stopFlagSize = stopFlag.length;</span><br><span class="line">            <span class="keyword">boolean</span> shouldCallOnReceiveBytes = <span class="keyword">false</span>;</span><br><span class="line">            logD(<span class="string">"标志位为："</span> + byte2Hex(stopFlag));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = stopFlagSize - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">int</span> indexInResult = result.length - (stopFlagSize - i);</span><br><span class="line">                <span class="keyword">if</span> (indexInResult &gt;= result.length || indexInResult &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    shouldCallOnReceiveBytes = <span class="keyword">false</span>;</span><br><span class="line">                    logD(<span class="string">"收到的数据比停止字符串短"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (stopFlag[i] == result[indexInResult]) &#123;</span><br><span class="line">                    logD(<span class="string">"发现"</span> + byte2Hex(stopFlag[i]) + <span class="string">"等于"</span> + byte2Hex(result[indexInResult]));</span><br><span class="line">                    shouldCallOnReceiveBytes = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    logD(<span class="string">"发现"</span> + byte2Hex(stopFlag[i]) + <span class="string">"不等于"</span> + byte2Hex(result[indexInResult]));</span><br><span class="line">                    shouldCallOnReceiveBytes = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldCallOnReceiveBytes) &#123;</span><br><span class="line">                <span class="comment">// 到了这里，byte 数组 result 就是收到的数据了</span></span><br><span class="line">                <span class="comment">// todo: 执行收到数据逻辑</span></span><br><span class="line">                <span class="comment">// 清空之前的</span></span><br><span class="line">                result = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="comment">// todo:处理验证收到数据结束标志出错</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    <span class="comment">// todo:处理接收数据失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><p>主要流程基本结束，后面不要忘记关闭线程，关闭流，解除注册广播等。</p><p>源码地址：<a href="https://gitee.com/QingFengBaiYu/BluetoothLowEnergyDemo" target="_blank" rel="noopener">BluetoothLowEnergyDemo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文地址：&lt;a href=&quot;https://blog.gtf35.top/bluetooth_spp/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.gtf35.top/bluetooth_spp/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【这里仅
      
    
    </summary>
    
      <category term="Android" scheme="https://tylerLiu.top/categories/Android/"/>
    
      <category term="蓝牙" scheme="https://tylerLiu.top/categories/Android/%E8%93%9D%E7%89%99/"/>
    
    
      <category term="蓝牙" scheme="https://tylerLiu.top/tags/%E8%93%9D%E7%89%99/"/>
    
  </entry>
  
  <entry>
    <title>慕课网《编程必备基础 计算机组成原理+操作系统+计算机网络》-01</title>
    <link href="https://tylerLiu.top/2020/05/22/%E6%85%95%E8%AF%BE%E7%BD%91%E3%80%8A%E7%BC%96%E7%A8%8B%E5%BF%85%E5%A4%87%E5%9F%BA%E7%A1%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B-01/"/>
    <id>https://tylerLiu.top/2020/05/22/慕课网《编程必备基础-计算机组成原理-操作系统-计算机网络》-01/</id>
    <published>2020-05-22T02:03:00.000Z</published>
    <updated>2020-05-22T02:04:35.677Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="计算机基础" scheme="https://tylerLiu.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="计算机组成原理" scheme="https://tylerLiu.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机组成原理" scheme="https://tylerLiu.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>HashMap解析-02：手写HashMap（基于JDK1.7，只写数组+链表）</title>
    <link href="https://tylerLiu.top/2020/05/21/HashMap%E8%A7%A3%E6%9E%90-02%EF%BC%9A%E6%89%8B%E5%86%99HashMap/"/>
    <id>https://tylerLiu.top/2020/05/21/HashMap解析-02：手写HashMap/</id>
    <published>2020-05-21T08:55:29.000Z</published>
    <updated>2020-05-22T01:17:07.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p><code>HashMap</code>的存储结构为散列表，解决哈希冲突是用过链表法解决的，结构如下：</p><img src="/2020/05/21/HashMap解析-02：手写HashMap/微信图片_20200521170634.png"><p>下面主要实现这个结构。</p><h1 id="1、定义接口"><a href="#1、定义接口" class="headerlink" title="1、定义接口"></a>1、定义接口</h1><p><code>HashMap</code>是实现了<code>Map</code>接口的，这里也需要定义个类似的接口，主要包括存取数据，以及存取数据结构的接口（包括取键和取值）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(K k)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">put</span><span class="params">(K k, V v)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 内部接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 取值</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function">V <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 取键</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> 键</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function">K <span class="title">getKey</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2、自定义HashMap实现自定义的Map接口"><a href="#2、自定义HashMap实现自定义的Map接口" class="headerlink" title="2、自定义HashMap实现自定义的Map接口"></a>2、自定义HashMap实现自定义的Map接口</h1><p>实现自定义的接口，并且定义默认的容量，默认加载因子（0.75），以及数组使用长度，存储的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">MyMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> DEFAULT_LENGTH = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认加载因子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> LOADER = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Map使用数组长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> useSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Entry&lt;K, V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">16</span>, <span class="number">0.75f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHashMap</span><span class="params">(<span class="keyword">int</span> defaultLength, <span class="keyword">float</span> loader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (defaultLength &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"数组异常"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (loader &lt;= <span class="number">0</span> || Float.isNaN(loader)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"加载因子异常"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.DEFAULT_LENGTH = defaultLength;</span><br><span class="line">        <span class="keyword">this</span>.LOADER = loader;</span><br><span class="line">        table = <span class="keyword">new</span> Entry[DEFAULT_LENGTH];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K k, V v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3、HashMap存储结构"><a href="#3、HashMap存储结构" class="headerlink" title="3、HashMap存储结构"></a>3、HashMap存储结构</h1><p>下面实现内部接口，来自定义每个点的存储结构，需要有键，值，及指向下一节点的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存储结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">MyMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> K key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> V value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表指向下一个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Entry&lt;K, V&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Entry</span><span class="params">(K key, V value, Entry&lt;K, V&gt; next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4、实现HashMap的HashCode来计算下标"><a href="#4、实现HashMap的HashCode来计算下标" class="headerlink" title="4、实现HashMap的HashCode来计算下标"></a>4、实现HashMap的HashCode来计算下标</h1><p>实现<code>HashCode</code>来自定义确定key所对应的下标。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用每个object的hashCode计算hashCode</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> hashCode)</span> </span>&#123;</span><br><span class="line">    hashCode = hashCode ^ ((hashCode &gt;&gt;&gt; <span class="number">20</span>) ^ (hashCode &gt;&gt;&gt; <span class="number">12</span>));</span><br><span class="line">    <span class="keyword">return</span> hashCode ^ ((hashCode &gt;&gt;&gt; <span class="number">7</span>) ^ hashCode &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取下标</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k      键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length 数组长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(K k, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index = hash(k.hashCode()) &amp; m;</span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> ? index : -index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5、实现HashMap的put方法"><a href="#5、实现HashMap的put方法" class="headerlink" title="5、实现HashMap的put方法"></a>5、实现HashMap的put方法</h1><p>通过key确定对于数组的下标，再确定有没有哈希冲突，有则往后追加，没有则直接存放。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> v 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K k, V v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 扩容</span></span><br><span class="line">    <span class="keyword">if</span> (useSize &gt;= DEFAULT_LENGTH * LOADER) &#123;</span><br><span class="line">        resize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算下标</span></span><br><span class="line">    <span class="keyword">int</span> index = getIndex(k, table.length);</span><br><span class="line">    Entry&lt;K, V&gt; entry = table[index];</span><br><span class="line">    Entry&lt;K, V&gt; newEntry = <span class="keyword">new</span> Entry&lt;K, V&gt;(k, v, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == entry) &#123;</span><br><span class="line">        <span class="comment">// 直接插入第一个</span></span><br><span class="line">        table[index] = newEntry;</span><br><span class="line">        useSize++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Entry&lt;K, V&gt; t = entry;</span><br><span class="line">        <span class="keyword">if</span> (t.getKey() == k || (t.getKey() != <span class="keyword">null</span> &amp;&amp; t.getKey().equals(k))) &#123;</span><br><span class="line">            <span class="comment">// 已经存在，替换</span></span><br><span class="line">            t.value = v;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (t.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t.getKey() == k || (t.getKey() != <span class="keyword">null</span> &amp;&amp; t.getKey().equals(k))) &#123;</span><br><span class="line">                    <span class="comment">// 已经存在，替换</span></span><br><span class="line">                    t.value = v;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    t = t.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (t.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 不存在，追加在链表后面</span></span><br><span class="line">                t.next = newEntry;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newEntry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6、HashMap的扩容方法resize"><a href="#6、HashMap的扩容方法resize" class="headerlink" title="6、HashMap的扩容方法resize"></a>6、HashMap的扩容方法resize</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry&lt;K, V&gt;[] newTable = <span class="keyword">new</span> Entry[DEFAULT_LENGTH * <span class="number">2</span>];</span><br><span class="line">    List&lt;Entry&lt;K, V&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 循环遍历取出就数组的数据</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K, V&gt; kvEntry : table) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == kvEntry) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Entry&lt;K, V&gt; entry = kvEntry;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != entry) &#123;</span><br><span class="line">            list.add(entry);</span><br><span class="line">            entry = entry.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新放回数组</span></span><br><span class="line">    <span class="keyword">if</span> (list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        useSize = <span class="number">0</span>;</span><br><span class="line">        DEFAULT_LENGTH = DEFAULT_LENGTH * <span class="number">2</span>;</span><br><span class="line">        table = newTable;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K, V&gt; entry : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                entry.next = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            put(entry.getKey(), entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7、实现HashMap的get方法"><a href="#7、实现HashMap的get方法" class="headerlink" title="7、实现HashMap的get方法"></a>7、实现HashMap的get方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = getIndex(k, table.length);</span><br><span class="line">    Entry&lt;K, V&gt; entry = table[index];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != entry) &#123;</span><br><span class="line">        <span class="keyword">while</span> (entry.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.getKey() == k || (entry.getKey() != <span class="keyword">null</span> &amp;&amp; entry.getKey().equals(k))) &#123;</span><br><span class="line">                <span class="keyword">return</span> entry.getValue();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                entry = entry.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (entry.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.getKey() == k || (entry.getKey() != <span class="keyword">null</span> &amp;&amp; entry.getKey().equals(k))) &#123;</span><br><span class="line">                <span class="keyword">return</span> entry.getValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码地址：<a href="https://gitee.com/QingFengBaiYu/HandWriteHashMap" target="_blank" rel="noopener">HandWriteHashMap</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;思考&quot;&gt;&lt;a href=&quot;#思考&quot; class=&quot;headerlink&quot; title=&quot;思考&quot;&gt;&lt;/a&gt;思考&lt;/h1&gt;&lt;p&gt;&lt;code&gt;HashMap&lt;/code&gt;的存储结构为散列表，解决哈希冲突是用过链表法解决的，结构如下：&lt;/p&gt;
&lt;img src=&quot;/202
      
    
    </summary>
    
      <category term="Java" scheme="https://tylerLiu.top/categories/Java/"/>
    
      <category term="源码" scheme="https://tylerLiu.top/categories/Java/%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="源码" scheme="https://tylerLiu.top/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>HashMap解析-01：HashMap源码解析（基于JDK1.8）</title>
    <link href="https://tylerLiu.top/2020/05/16/HashMap%E8%A7%A3%E6%9E%90-01%EF%BC%9AHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://tylerLiu.top/2020/05/16/HashMap解析-01：HashMap源码解析/</id>
    <published>2020-05-16T05:58:48.000Z</published>
    <updated>2020-05-21T08:53:37.987Z</updated>
    
    <content type="html"><![CDATA[<h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p><a href="https://www.cnblogs.com/biehongli/p/11672380.html" target="_blank" rel="noopener">时间复杂度O(1), O(n), O(logn), O(nlogn)</a></p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和元素，时间复杂度为O(n)，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n)。</p><h2 id="线性列表"><a href="#线性列表" class="headerlink" title="线性列表"></a>线性列表</h2><p>对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理节点间的引用即可，时间复杂度为O(1)，而查找操作需要遍历链表逐一进行对比，复杂度为O(n)。</p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p><strong>红黑树（Red Black Tree）是一种自平衡二叉查找树</strong>，其典型的用途是实现关联数组。除了二叉树强制的一般要求外，红黑树还需要：</p><ul><li>1、节点是红色或黑色；</li><li>2、根节点是黑色；</li><li>3、每个叶节点（NIL节点，空节点）是黑色；</li><li>4、每个红色节点的两个子节点都是黑色。（从每个叶子到根的所有路径上不能有两个连续的红色节点）</li><li>5、从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</li></ul><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p><strong>散列表</strong>（Hash Table，也成哈希表），是根据关键码值（key value）而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中的一个位置来访问记录，以加快查找速度。这个映射函数叫做散列函数，存放记录的数组叫散列表。</p><p>给定表M，存在函数f(key)，对任意给定的关键字key，带入函数后如果能包含该关键字的记录在表中的地址，则成表M为哈希（Hash）表，函数f(key)为哈希（Hash）函数。</p><h2 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h2><p>如果两个不同的元素，通过哈希函数得出的实际存储地址相同怎么办？也就是说，当对某个元素进行哈希运算，得到一个存储地址，然后要进行插入时，发现已经被其他元素占用了，这就是哈希冲突，也叫哈希碰撞。前面提到，哈希函数的设计至关重要，好的哈希函数会尽可能保证计算简单和散列地址分布均匀，但是，需要清楚的是，数组是一块连续的固定长度的内存空间，再好的哈希函数也不能保证得到的存储地址绝不发生冲突。那么哈希冲突如何解决呢？哈希冲突的解决方案有多种：开放定址法（发生冲突，继续寻找下一块未被占用的存储地址）、再散列函数法、链地址法，HashMap采用的是再散列函数法，即<strong>数组+链表</strong>的方式。</p><h1 id="HashMap在JDK1-8中的源码"><a href="#HashMap在JDK1-8中的源码" class="headerlink" title="HashMap在JDK1.8中的源码"></a>HashMap在JDK1.8中的源码</h1><p>源码注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、哈希表基于map接口的实现，这个实现提供了map所有的操作，并且提供了key和value可以为null，(HashMap和HashTable大致上市一样的除了hashmap是异步的和允许key和value为null)，这个类不确定map中元素的位置，特别要提的是，这个类也不确定元素的位置随着时间会不会保持不变。</span></span><br><span class="line">Hash table based implementation of the Map <span class="class"><span class="keyword">interface</span>. <span class="title">This</span> <span class="title">implementation</span> <span class="title">provides</span> <span class="title">all</span> <span class="title">of</span> <span class="title">the</span> <span class="title">optional</span> <span class="title">map</span> <span class="title">operations</span>, <span class="title">and</span> <span class="title">permits</span> <span class="title">null</span> <span class="title">values</span> <span class="title">and</span> <span class="title">the</span> <span class="title">null</span> <span class="title">key</span>. </span></span><br><span class="line"><span class="class">(<span class="title">The</span> <span class="title">HashMap</span> <span class="title">class</span> <span class="title">is</span> <span class="title">roughly</span> <span class="title">equivalent</span> <span class="title">to</span> <span class="title">Hashtable</span>, <span class="title">except</span> <span class="title">that</span> <span class="title">it</span> <span class="title">is</span> <span class="title">unsynchronized</span> <span class="title">and</span> <span class="title">permits</span> <span class="title">nulls</span>.) <span class="title">This</span> <span class="title">class</span> <span class="title">makes</span> <span class="title">no</span> <span class="title">guarantees</span> <span class="title">as</span> <span class="title">to</span> <span class="title">the</span> <span class="title">order</span> <span class="title">of</span> <span class="title">the</span> <span class="title">map</span></span>;</span><br><span class="line"> in particular, it does not guarantee that the order will remain constant over time. </span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设哈希函数将元素合适的分到了每个桶(其实就是指的数组中位置上的链表)中，则这个实现为基本的操作(get、put)提供了稳定的性能，迭代这个集合视图需要的时间跟hashMap实例(key-value映射的数量)的容量(在桶中)</span></span><br><span class="line">成正比，因此，如果迭代的性能很重要的话，就不要将初始容量设置的太高或者loadfactor设置的太低，【这里的桶，相当于在数组中每个位置上放一个桶装元素】</span><br><span class="line">This implementation provides constant-<span class="function">time performance <span class="keyword">for</span> the basic <span class="title">operations</span> <span class="params">(get and put)</span>, assuming the hash function disperses the elements properly among the buckets.</span></span><br><span class="line"><span class="function"> Iteration over collection views <span class="keyword">requires</span> time proportional to the "capacity" of the HashMap <span class="title">instance</span> <span class="params">(the number of buckets)</span> plus its <span class="title">size</span> <span class="params">(the number of key-value mappings</span></span></span><br><span class="line"><span class="function"><span class="params">)</span>. Thus, it's very important not to set the initial capacity too <span class="title">high</span> <span class="params">(or the load factor too low)</span> <span class="keyword">if</span> iteration performance is important.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// HashMap的实例有两个参数影响性能，初始化容量(initialCapacity)和loadFactor加载因子，在哈希表中这个容量是桶的数量【也就是数组的长度】，一个初始化容量仅仅是在哈希表被创建时容量，在</span></span></span><br><span class="line"><span class="function">容量自动增长之前加载因子是衡量哈希表被允许达到的多少的。当entry的数量在哈希表中超过了加载因子乘以当前的容量，那么哈希表被修改<span class="params">(内部的数据结构会被重新建立)</span>所以哈希表有大约两倍的桶的数量</span></span><br><span class="line"><span class="function">An instance of HashMap has two parameters that affect its performance: initial capacity and load factor. The capacity is the number of buckets in the hash table, </span></span><br><span class="line"><span class="function">and the initial capacity is simply the capacity at the time the hash table is created. The load factor is a measure of how full the hash table is allowed to get before</span></span><br><span class="line"><span class="function"> its capacity is automatically increased. When the number of entries in the hash table exceeds the product of the load factor and the current capacity, the hash table </span></span><br><span class="line"><span class="function">is <span class="title">rehashed</span> <span class="params">(that is, internal data structures are rebuilt)</span> so that the hash table has approximately twice the number of buckets.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 通常来讲，默认的加载因子(0.75)能够在时间和空间上提供一个好的平衡，更高的值会减少空间上的开支但是会增加查询花费的时间（体现在HashMap类中get、put方法上），当设置初始化容量时，应该考虑到map中会存放</span></span></span><br><span class="line"><span class="function">entry的数量和加载因子，以便最少次数的进行rehash操作，如果初始容量大于最大条目数除以加载因子，则不会发生 rehash 操作。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">As a general rule, the <span class="keyword">default</span> load <span class="title">factor</span> <span class="params">(<span class="number">.75</span>)</span> offers a good tradeoff between time and space costs. Higher values decrease the space overhead but increase the lookup</span></span><br><span class="line"><span class="function"> <span class="title">cost</span> <span class="params">(reflected in most of the operations of the HashMap class, including get and put)</span>. The expected number of entries in the map and its load factor should be taken </span></span><br><span class="line"><span class="function">into account when setting its initial capacity, so as to minimize the number of rehash operations. If the initial capacity is greater than the maximum number of</span></span><br><span class="line"><span class="function"> entries divided by the load factor, no rehash operations will ever occur.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 如果很多映射关系要存储在 HashMap 实例中，则相对于按需执行自动的 rehash 操作以增大表的容量来说，使用足够大的初始容量创建它将使得映射关系能更有效地存储。</span></span></span><br><span class="line"><span class="function">If many mappings are to be stored in a HashMap instance, creating it with a sufficiently large capacity will allow the mappings to be stored more efficiently than letting </span></span><br><span class="line"><span class="function">it perform automatic rehashing as needed to grow the table</span></span><br></pre></td></tr></table></figure><h1 id="HashMap的继承关系"><a href="#HashMap的继承关系" class="headerlink" title="HashMap的继承关系"></a>HashMap的继承关系</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"> <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/****省略代码****/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap继承了<code>AbstractMap</code>实现了<code>Map</code>、<code>Cloneable</code>、<code>Serializable</code>接口。</p><h1 id="HashMap的属性"><a href="#HashMap的属性" class="headerlink" title="HashMap的属性"></a>HashMap的属性</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"> <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 序列号，序列化的时候使用。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;</span><br><span class="line">    <span class="comment">/**默认容量，1向左移位4个，00000001变成00010000，也就是2的4次方为16，使用移位是因为移位是计算机基础运算，效率比加减乘除快。**/</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 最大容量，2的30次方。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// 加载因子，用于扩容使用。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line">    <span class="comment">// 当某个桶节点数量大于8时，会转换为红黑树。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 当某个桶节点数量小于6时，会转换为链表，前提是它当前是红黑树结构。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 当整个hashMap中元素数量大于64时，也会进行转为红黑树结构。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line">    <span class="comment">// 存储元素的数组，transient关键字表示该属性不能被序列化</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line">    <span class="comment">// 将数据转换成set的另一种存储形式，这个变量主要用于迭代功能。</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line">    <span class="comment">// 元素数量</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">// 统计该map修改的次数</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line">    <span class="comment">// 临界值，也就是元素数量达到临界值时，会进行扩容。</span></span><br><span class="line">    <span class="keyword">int</span> threshold;</span><br><span class="line">    <span class="comment">// 也是加载因子，只不过这个是变量。</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/****省略代码****/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认容量16，默认加载因子0.75。</p><h1 id="HashMap构造方法"><a href="#HashMap构造方法" class="headerlink" title="HashMap构造方法"></a>HashMap构造方法</h1><img src="/2020/05/16/HashMap解析-01：HashMap源码解析/微信图片_20200516163444.png"><p>HashMap有四个构造方法：</p><ul><li>1、空参构造方法，使用默认的负载因子0.75；</li><li>2、设置初始容量并使用默认加载因子；</li><li>3、设置容量和加载因子，第二个构造方法最终还是调用了第三个构造方法；</li><li>4、将一个Map转换为HashMap。</li></ul><p>第四个构造方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取该map的实际长度</span></span><br><span class="line">    <span class="keyword">int</span> s = m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断table是否初始化，如果没有初始化</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="comment">/**求出需要的容量，因为实际使用的长度=容量*0.75得来的，+1是因为小数相除，基本都不会是整数，容量大小不能为小数的，后面转换为int，多余的小数就要被丢掉，所以+1，例如，map实际长度22，22/0.75=29.3,所需要的容量肯定为30，有人会问如果刚刚好除得整数呢，除得整数的话，容量大小多1也没什么影响**/</span></span><br><span class="line">            <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="comment">//判断该容量大小是否超出上限。</span></span><br><span class="line">            <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="comment">/**对临界值进行初始化，tableSizeFor(t)这个方法会返回大于t值的，且离其最近的2次幂，例如t为29，则返回的值是32**/</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果table已经初始化，则进行扩容操作，resize()就是扩容。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">// 遍历，把map中的数据转到hashMap中。</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数中传入了一个Map，然后把这个Map转换为HashMap，这里还调用了<code>resize()</code>进行扩容。</p><p>在上面的<code>entrySet()</code>中返回一个<code>Set&lt;Map.Entry&lt;K, V&gt;&gt;</code>，泛型为<code>Map</code>的内部类<code>Entry</code>，它是一个存放key-value的实例，因为hash表的遍历，插入效率高。</p><p>构造函数就到这里，下面重点看看<code>HashMap</code>是如何将key和value存储的。下面看看<code>HashMap</code>的<code>put(K key,V value)</code>方法。</p><h1 id="HashMap的put方法"><a href="#HashMap的put方法" class="headerlink" title="HashMap的put方法"></a>HashMap的put方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**四个参数，第一个hash值，第四个参数表示如果该key存在值，如果为null的话，则插入新的value，最后一个参数，在hashMap中没有用，可以不用管，使用默认的即可**/</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用了<code>putVal</code>之前调用了hash方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将键值的<code>hashCode</code>做异或运算，目的是为了减少哈希冲突。</p><p>下面看看<code>putVal</code>的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// tab:哈希数组，p:该哈希桶的首节点，n:hashMap的长度，i:计算出的数组下标</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 获取长度并进行扩容，使用的是懒加载，table一开始是没有加载的，等put后才开始加载</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">/**如果计算出的该哈希桶的位置没有值，则把新插入的key-value放到此处，此处就算没有插入成功，也就是发生哈希冲突时也会把哈希桶的首节点赋予p**/</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 发生哈希冲突的几种情况</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// e:临时节点的作用，k:存放该当前节点的key </span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 第一种，插入的key-value的hash值，key都与当前节点的相等，e = p，则表示为首节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 第二种，hash值不等于首节点，判断该p是否属于红黑树的节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">/**为红黑树的节点，则在红黑树中进行添加，如果该节点已经存在，则返回该节点（不为null），该值很重要，用来判断put操作是否成功，如果添加成功返回null**/</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 第三种，hash值不等于首节点，不为红黑树的节点，则为链表的节点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 遍历该链表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 如果找到尾部，则表明添加的key-value没有重复，在尾部进行添加</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 判断是否要转换为红黑树结构</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果链表中有重复的key，e则为当前重复的节点，结束循环</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有重复的key，则用待插入值进行覆盖，返回旧值。</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; </span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 到了此步骤，则表明待插入的key-value是没有key的重复，因为插入成功e节点的值为null</span></span><br><span class="line">    <span class="comment">// 修改次数+1</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 实际长度+1，判断是否大于临界值，大于则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="comment">// 添加成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要有以下几个步骤：</p><ul><li>1、根据key计算处在数组中存储的下标；</li><li>2、根据使用的大小，判断是否需要扩容；</li><li>3、根据数组下标判断是否当前下标已存储数据，如果没有，则直接插入；</li><li>4、如果存储了，则存在哈希冲突，判断当前entry的key是否相等，如果相等则替换，否则判断下一个节点是否为空，为空则直接插入，否则取下一节点重复上述步骤；</li><li>5、判断链表长度是否大于8，当达到8时，转换为红黑树。</li></ul><h1 id="HashMap的扩容函数resize"><a href="#HashMap的扩容函数resize" class="headerlink" title="HashMap的扩容函数resize()"></a>HashMap的扩容函数resize()</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">// 把没插入之前的哈希数组作为oldTal</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">// old的长度</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">// old的临界值</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="comment">// 初始化new的长度和临界值</span></span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// oldCap &gt; 0也就是说不是首次初始化，因为hashMap用的是懒加载</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 大于最大值</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">// 临界值为整数的最大值</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 标记##，其它情况，扩容两倍，并且扩容后的长度要小于最大值，old长度也要大于16</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">// 临界值也扩容为old的临界值2倍</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**如果oldCap&lt;0，但是已经初始化了，像把元素删除完之后的情况，那么它的临界值肯定还存在，        </span></span><br><span class="line"><span class="comment">       如果是首次初始化，它的临界值则为0</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) </span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">// 首次初始化，给与默认的值</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               </span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        <span class="comment">// 临界值等于容量*加载因子</span></span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此处的if为上面标记##的补充，也就是初始化时容量小于默认值16的，此时newThr没有赋值</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// new的临界值</span></span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        <span class="comment">// 判断是否new容量是否大于最大值，临界值是否大于最大值</span></span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把上面各种情况分析出的临界值，在此处真正进行改变，也就是容量和临界值都改变了。</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="comment">// 表示忽略该警告</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    <span class="comment">// 赋予当前的table</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">// 此处自然是把old中的元素，遍历到new中</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            <span class="comment">// 临时变量</span></span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="comment">// 当前哈希桶的位置值不为null，也就是数组下标处有值，因为有值表示可能会发生冲突</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 把已经赋值之后的变量置位null，当然是为了好回收，释放内存</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 如果下标处的节点没有下一个元素</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// 把该变量的值存入newCap中，e.hash &amp; (newCap - 1)并不等于j</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 该节点为红黑树结构，也就是存在哈希冲突，该哈希桶中有多个元素</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// ✨✨✨把此树进行转移到newCap中✨✨✨</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">/**此处表示为链表结构，同样把链表转移到newCap中，就是把链表遍历后，把值转过去，在置位null**/</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回扩容后的hashMap</span></span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HashMap</code>的结构为数组+链表（红黑树）。</p><p>逻辑：</p><ul><li>1、对数组进行扩容；</li><li>2、扩容后重新计算<code>hashCode</code>，即key的下标，将原始数据放入扩容后的数据结构中；</li><li>3、当存在哈希冲突时，在数组后面以链表的形式追加到后面，当链表长度达到8时，就会将链表转换为红黑树。</li></ul><p>对于红黑树新增节点，需要考虑前面所说的红黑树性质。就需要对红黑树做调整，使红黑树达到平衡。这种平衡就是红黑树的旋转。</p><h1 id="红黑树的旋转"><a href="#红黑树的旋转" class="headerlink" title="红黑树的旋转"></a>红黑树的旋转</h1><p>分为左旋和右旋，以某个节点为圆心向左或向右旋转。<a href="https://www.cnblogs.com/CarpenterLee/p/5503882.html" target="_blank" rel="noopener">史上最清晰的红黑树讲解</a></p><h2 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h2><img src="/2020/05/16/HashMap解析-01：HashMap源码解析/微信图片_20200521094557.png"><p>上图中各子树可以是多个节点构成的子树，也可以是一个具体的节点，也可以是null。</p><img src="/2020/05/16/HashMap解析-01：HashMap源码解析/微信图片_20200521093955.png"><h2 id="HashMap中红黑树的左旋"><a href="#HashMap中红黑树的左旋" class="headerlink" title="HashMap中红黑树的左旋"></a>HashMap中红黑树的左旋</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateLeft</span><span class="params">(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; r, pp, rl;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (r = p.right) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((rl = p.right = r.left) != <span class="keyword">null</span>)</span><br><span class="line">            rl.parent = p;</span><br><span class="line">        <span class="keyword">if</span> ((pp = r.parent = p.parent) == <span class="keyword">null</span>)</span><br><span class="line">            (root = r).red = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p)</span><br><span class="line">            pp.left = r;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = r;</span><br><span class="line">        r.left = p;</span><br><span class="line">        p.parent = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2020/05/16/HashMap解析-01：HashMap源码解析/微信图片_20200521101422.png"><p>上图中各子树可以是多个节点构成的子树，也可以是一个具体的节点，也可以是null。</p><h2 id="HashMap中红黑树的右旋"><a href="#HashMap中红黑树的右旋" class="headerlink" title="HashMap中红黑树的右旋"></a>HashMap中红黑树的右旋</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateRight</span><span class="params">(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; l, pp, lr;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (l = p.left) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((lr = p.left = l.right) != <span class="keyword">null</span>)</span><br><span class="line">            lr.parent = p;</span><br><span class="line">        <span class="keyword">if</span> ((pp = l.parent = p.parent) == <span class="keyword">null</span>)</span><br><span class="line">            (root = l).red = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pp.right == p)</span><br><span class="line">            pp.right = l;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.left = l;</span><br><span class="line">        l.right = p;</span><br><span class="line">        p.parent = l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="红黑树新增节点的例子"><a href="#红黑树新增节点的例子" class="headerlink" title="红黑树新增节点的例子"></a>红黑树新增节点的例子</h2><p><code>TreeMap</code>的结构也是红黑树，它新增节点的过程如下：这里跟<code>HashMap</code>的红黑树的新增原理一样:</p><img src="/2020/05/16/HashMap解析-01：HashMap源码解析/微信图片_20200521155212.png"><p>现在回到<code>resize()</code>，里面有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ✨✨✨把此树进行转移到newCap中✨✨✨</span></span><br><span class="line">((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br></pre></td></tr></table></figure><h2 id="HashMap中TreeNode-split"><a href="#HashMap中TreeNode-split" class="headerlink" title="HashMap中TreeNode.split"></a>HashMap中TreeNode.split</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; b = <span class="keyword">this</span>;<span class="comment">// 拿到调用此方法的节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>; <span class="comment">// 存储跟原索引位置相同的节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>; <span class="comment">// 存储索引位置为:原索引+oldCap的节点</span></span><br><span class="line">    <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123;<span class="comment">// 从b节点开始遍历</span></span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)e.next;   <span class="comment">// next赋值为e的下个节点</span></span><br><span class="line">        e.next = <span class="keyword">null</span>;  <span class="comment">// 同时将老表的节点设置为空，以便垃圾收集器回收</span></span><br><span class="line">        <span class="comment">//如果e的hash值与老表的容量进行与运算为0,则扩容后的索引位置跟老表的索引位置一样</span></span><br><span class="line">        <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)  <span class="comment">// 如果loTail为空, 代表该节点为第一个节点</span></span><br><span class="line">                loHead = e; <span class="comment">// 则将loHead赋值为第一个节点</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;    <span class="comment">// 否则将节点添加在loTail后面</span></span><br><span class="line">            loTail = e; <span class="comment">// 并将loTail赋值为新增的节点</span></span><br><span class="line">            ++lc;   <span class="comment">// 统计原索引位置的节点个数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果e的hash值与老表的容量进行与运算为1,则扩容后的索引位置为:老表的索引位置＋oldCap</span></span><br><span class="line">        <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)  <span class="comment">// 如果hiHead为空, 代表该节点为第一个节点</span></span><br><span class="line">                hiHead = e; <span class="comment">// 则将hiHead赋值为第一个节点</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;    <span class="comment">// 否则将节点添加在hiTail后面</span></span><br><span class="line">            hiTail = e; <span class="comment">// 并将hiTail赋值为新增的节点</span></span><br><span class="line">            ++hc;   <span class="comment">// 统计索引位置为原索引+oldCap的节点个数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;   <span class="comment">// 原索引位置的节点不为空</span></span><br><span class="line">        <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)  <span class="comment">// 节点个数少于6个则将红黑树转为链表结构</span></span><br><span class="line">            tab[index] = loHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index] = loHead;    <span class="comment">// 将原索引位置的节点设置为对应的头结点</span></span><br><span class="line">            <span class="comment">// hiHead不为空则代表原来的红黑树(老表的红黑树由于节点被分到两个位置)</span></span><br><span class="line">            <span class="comment">// 已经被改变, 需要重新构建新的红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) </span><br><span class="line">                loHead.treeify(tab);    <span class="comment">// 以loHead为根结点, 构建新的红黑树</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;   <span class="comment">// 索引位置为原索引+oldCap的节点不为空</span></span><br><span class="line">        <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)  <span class="comment">// 节点个数少于6个则将红黑树转为链表结构</span></span><br><span class="line">            tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index + bit] = hiHead;  <span class="comment">// 将索引位置为原索引+oldCap的节点设置为对应的头结点</span></span><br><span class="line">            <span class="comment">// loHead不为空则代表原来的红黑树(老表的红黑树由于节点被分到两个位置)</span></span><br><span class="line">            <span class="comment">// 已经被改变, 需要重新构建新的红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) </span><br><span class="line">                hiHead.treeify(tab);    <span class="comment">// 以hiHead为根结点, 构建新的红黑树</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面看看<code>treeify()</code></p><h2 id="HashMap中的treeify"><a href="#HashMap中的treeify" class="headerlink" title="HashMap中的treeify()"></a>HashMap中的treeify()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;   <span class="comment">// 构建红黑树</span></span><br><span class="line">    TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;<span class="comment">// this即为调用此方法的TreeNode</span></span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)x.next;   <span class="comment">// next赋值为x的下个节点</span></span><br><span class="line">        x.left = x.right = <span class="keyword">null</span>;    <span class="comment">// 将x的左右节点设置为空</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="comment">// 如果还没有根结点, 则将x设置为根结点</span></span><br><span class="line">            x.parent = <span class="keyword">null</span>;    <span class="comment">// 根结点没有父节点</span></span><br><span class="line">            x.red = <span class="keyword">false</span>;  <span class="comment">// 根结点必须为黑色</span></span><br><span class="line">            root = x;   <span class="comment">// 将x设置为根结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            K k = x.key;<span class="comment">// k赋值为x的key</span></span><br><span class="line">            <span class="keyword">int</span> h = x.hash;<span class="comment">// h赋值为x的hash值</span></span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 如果当前节点x不是根结点, 则从根节点开始查找属于该节点的位置</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> dir, ph;</span><br><span class="line">                K pk = p.key;   </span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)  <span class="comment">// 如果x节点的hash值小于p节点的hash值</span></span><br><span class="line">                    dir = -<span class="number">1</span>;   <span class="comment">// 则将dir赋值为-1, 代表向p的左边查找</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)    <span class="comment">// 与上面相反, 如果x节点的hash值大于p节点的hash值</span></span><br><span class="line">                    dir = <span class="number">1</span>;    <span class="comment">// 则将dir赋值为1, 代表向p的右边查找</span></span><br><span class="line">                <span class="comment">// 走到这代表x的hash值和p的hash值相等，则比较key值</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp; <span class="comment">// 如果k没有实现Comparable接口 或者 x节点的key和p节点的key相等</span></span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 使用定义的一套规则来比较x节点和p节点的大小，用来决定向左还是向右查找</span></span><br><span class="line">                    dir = tieBreakOrder(k, pk); </span><br><span class="line"> </span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;   <span class="comment">// xp赋值为x的父节点,中间变量用于下面给x的父节点赋值</span></span><br><span class="line">                <span class="comment">// dir&lt;=0则向p左边查找,否则向p右边查找,如果为null,则代表该位置即为x的目标位置</span></span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123; </span><br><span class="line">                    x.parent = xp;  <span class="comment">// x的父节点即为最后一次遍历的p节点</span></span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)   <span class="comment">// 如果时dir &lt;= 0, 则代表x节点为父节点的左节点</span></span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span>    <span class="comment">// 如果时dir &gt; 0, 则代表x节点为父节点的右节点</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    <span class="comment">// 进行红黑树的插入平衡(通过左旋、右旋和改变节点颜色来保证当前树符合红黑树的要求)</span></span><br><span class="line">                    root = balanceInsertion(root, x);   </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    moveRootToFront(tab, root); <span class="comment">// 如果root节点不在table索引位置的头结点, 则将其调整为头结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>balanceInsertion()</code>使红黑树达到平衡。要平衡红黑树，就要进行左旋或右旋。</p><h2 id="HashMap中的balanceInsertion"><a href="#HashMap中的balanceInsertion" class="headerlink" title="HashMap中的balanceInsertion()"></a>HashMap中的balanceInsertion()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">     x.red = <span class="keyword">true</span>;</span><br><span class="line">     <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">         <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">             x.red = <span class="keyword">false</span>;</span><br><span class="line">             <span class="keyword">return</span> x;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="keyword">null</span>)</span><br><span class="line">             <span class="keyword">return</span> root;</span><br><span class="line">         <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class="line">             <span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123;</span><br><span class="line">                 xppr.red = <span class="keyword">false</span>;</span><br><span class="line">                 xp.red = <span class="keyword">false</span>;</span><br><span class="line">                 xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                 x = xpp;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="keyword">if</span> (x == xp.right) &#123;</span><br><span class="line">                     root = rotateLeft(root, x = xp);<span class="comment">//对红黑树进行左旋</span></span><br><span class="line">                     xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                     xp.red = <span class="keyword">false</span>;</span><br><span class="line">                     <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                         xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                         root = rotateRight(root, xpp);<span class="comment">//对红黑树进行右旋</span></span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">if</span> (xppl != <span class="keyword">null</span> &amp;&amp; xppl.red) &#123;</span><br><span class="line">                 xppl.red = <span class="keyword">false</span>;</span><br><span class="line">                 xp.red = <span class="keyword">false</span>;</span><br><span class="line">                 xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                 x = xpp;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="keyword">if</span> (x == xp.left) &#123;</span><br><span class="line">                     root = rotateRight(root, x = xp);<span class="comment">//对红黑树进行右旋</span></span><br><span class="line">                     xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                     xp.red = <span class="keyword">false</span>;</span><br><span class="line">                     <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                         xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                         root = rotateLeft(root, xpp);<span class="comment">//对红黑树进行左旋</span></span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="HashMap的存储结构"><a href="#HashMap的存储结构" class="headerlink" title="HashMap的存储结构"></a>HashMap的存储结构</h2><p>数组+链表+红黑树</p><img src="/2020/05/16/HashMap解析-01：HashMap源码解析/微信图片_20200521162526.png"><h2 id="HashMap扩容"><a href="#HashMap扩容" class="headerlink" title="HashMap扩容"></a>HashMap扩容</h2><p>扩容过程:</p><img src="/2020/05/16/HashMap解析-01：HashMap源码解析/微信图片_20200521165320.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;相关概念&quot;&gt;&lt;a href=&quot;#相关概念&quot; class=&quot;headerlink&quot; title=&quot;相关概念&quot;&gt;&lt;/a&gt;相关概念&lt;/h1&gt;&lt;h2 id=&quot;时间复杂度&quot;&gt;&lt;a href=&quot;#时间复杂度&quot; class=&quot;headerlink&quot; title=&quot;时间复杂度&quot;&gt;
      
    
    </summary>
    
      <category term="Java" scheme="https://tylerLiu.top/categories/Java/"/>
    
      <category term="源码" scheme="https://tylerLiu.top/categories/Java/%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="源码" scheme="https://tylerLiu.top/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Android-RecyclerView的缓存机制</title>
    <link href="https://tylerLiu.top/2020/05/15/Android-RecyclerView%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <id>https://tylerLiu.top/2020/05/15/Android-RecyclerView的缓存机制/</id>
    <published>2020-05-15T01:43:45.000Z</published>
    <updated>2020-05-16T05:54:24.150Z</updated>
    
    <content type="html"><![CDATA[<p>使用<code>ScrollView</code>时，它的所有子<code>View</code>会一次性加载出来。<code>RecyclerView</code>可以做到按需加载、按需绑定，并实现复用。这里主要分析<code>RecyclerView</code>缓存复用的原理。</p><h1 id="从缓存获取ViewHolder流程概览"><a href="#从缓存获取ViewHolder流程概览" class="headerlink" title="从缓存获取ViewHolder流程概览"></a>从缓存获取ViewHolder流程概览</h1><img src="/2020/05/15/Android-RecyclerView的缓存机制/微信图片_20200515155023.png"><p>说明：</p><p>在创建<code>ViewHolder</code>之前，<code>RecyclerView</code>会先从缓存中尝试获取是否有符合要求的<code>ViewHolder</code>，详见<code>RecyclerView#tryGetViewHolderForPositionByDeadline</code>方法。</p><ul><li>第一次，尝试从<code>mChangedScrap</code>中获取。<ul><li>只有在<code>mState.isPreLayout()</code>为<code>true</code>时，也就是预布局阶段，才做这次尝试。</li></ul></li><li>第二次，<code>getScrapOrHiddenOrCachedHolderForPosition()</code>获得<code>ViewHolder</code>。<ul><li>尝试从<code>mAttachedScrap</code>、<code>mHiddenViews</code>或<code>mCachedViews</code>中查找<code>ViewHolder</code>。<ul><li>其中<code>mAttachedScrap</code>和<code>mCachedViews</code>都是<code>Recycler</code>的成员变量。</li><li>如果成功获得<code>ViewHolder</code>则检验其有效性，<ul><li>若<strong>检验失败则将其收回</strong>到<code>RecyclerViewPool</code>中</li><li>检验成功，则可以正常使用</li></ul></li></ul></li></ul></li><li>第三次，如果给<code>Adapter</code>设置了<code>stableld</code>，调用<code>getScrappOrCachedViewForld</code>尝试获取<code>ViewHolder</code>。<ul><li>和第二次的区别在于，之前是根据<code>position</code>查找，现在是根据<code>id</code>查找</li></ul></li><li>第四次，<code>mViewCahceExtension</code>不为空的话，则调用<code>ViewCacheExtension#getViewForPositionAndType</code>方法尝试获取<code>View</code>。<ul><li>注，<code>ViewCacheExtension</code>是由开发者设置的，默认情况下为空，一般不会设置。这层缓存大部分情况下可以忽略。</li></ul></li><li>第五次，尝试从<code>RecyclerViewPool</code>中获取，相较于<code>mCacheViews</code>，从<code>RecyclerViewPool</code>中成功获取<code>ViewHolder</code>对象后并没有做合法性和<code>item</code>的位置校验，只检验<code>viewtype</code>是否一致。<ul><li>从<code>RecyclerViewPool</code>中取出来的<code>ViewHodler</code>需要重新执行<code>bind</code>才能使用。</li></ul></li><li>如果上面的五次尝试都失败了，就调用<code>RecyclerView.Adapter#createViewHolder</code>新建一个<code>ViewHolder</code>。</li><li>最后根据<code>ViewHodler</code>的状态，确定是否需要调用<code>bindViewHolder</code>进行数据绑定。</li></ul><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="预布局、预测动画是什么？"><a href="#预布局、预测动画是什么？" class="headerlink" title="预布局、预测动画是什么？"></a>预布局、预测动画是什么？</h2><p>理解“预布局”就需要理解“预测动画”。例如：</p><p>用户有A、B、C三个item，A、B正好显示在屏幕中，这时，用户把B删除了，最终C会显示在原先B的位置。</p><img src="/2020/05/15/Android-RecyclerView的缓存机制/微信图片_20200515132105.png"><p>如果C从底部平滑地滑动到B的位置会更加合适，但是要想实现，并不简单。因为知道C的最终位置，但是不知道C的起始位置，就无法确定C应该从哪里滑动过来。有可能是底部，也可能是侧边。</p><p>根据原状态和最终状态之间的差异，是无法得出应该执行怎样的动画的。</p><p>设计<code>RecyclerView</code>的工程师是这样解决的。当<code>Adapter</code>发生变化时，<code>RecyclerView</code>会让<code>LayoutManager</code>进行两次布局。</p><ul><li>第一次是<strong>预布局</strong>，将之前原状态下的item都布局出来。并且根据<code>Adapter</code>的<code>notify</code>信息，知道哪些item即将变化，所以可以<strong>加载出另外的View</strong>。上述例子中，因为知道B已经被删除，所以可以<strong>把屏幕之外的C也加载进来</strong>。</li><li>第二，最终的布局。</li></ul><img src="/2020/05/15/Android-RecyclerView的缓存机制/微信图片_20200515143312.png"><p>这样只要比较前后布局的变化，就能得出应该执行什么动画了。</p><p>这种负责执行动画的View在原布局或新布局中不存在的动画，就是<strong>预测动画</strong>。</p><p><strong>预布局</strong>是实现预测动画的一个步骤。</p><p>下面两个动图展示了普通动画和预测动画的区别。</p><p>普通动画：</p><img src="/2020/05/15/Android-RecyclerView的缓存机制/171d8db8bf70b9ce"><p>预测动画：</p><img src="/2020/05/15/Android-RecyclerView的缓存机制/171d8e01b6b0ba6c"><p>关于预测动画，可以阅读<a href="http://frogermcs.github.io/recyclerview-animations-androiddevsummit-write-up/" target="_blank" rel="noopener">文章</a>。</p><h1 id="关于Scrap"><a href="#关于Scrap" class="headerlink" title="关于Scrap"></a>关于Scrap</h1><p><code>Scrap</code>，缓存列表（<code>mChangedScrap</code>、<code>mAttachedScrap</code>）是<code>RecyclerView</code>最先查找<code>ViewHolder</code>的地方，它跟<code>RecyclerViewPool</code>或者<code>ViewCache</code>有很大的区别。</p><p><code>mChangedScrap</code>和<code>mAttchedScrap</code>只在布局阶段使用。其他时候它们为空。布局完成之后，这两个缓存中的<code>ViewHolder</code>，会移到<code>mCacheView</code>和<code>RecyclerViewPool</code>中。</p><p>当<code>LayoutManage</code>开始布局的时候（预布局或者是最终布局），当前布局中的所有view，都会被dump到scrap中（具体可见<code>LinearLayoutManage#onLayoutChildren</code>中调用的了<code>detachAndScrap</code>），然后<code>LayoutManager</code>挨个取回view，除非view发生了什么变化，否则它会马上从scrap中回到原来的位置。</p><img src="/2020/05/15/Android-RecyclerView的缓存机制/微信图片_20200515155901.png"><p>以上图为例，删除B，调用<code>notifyItemRemove()</code>方法，触发重新布局，这时，A、B、C都会被dump到scrap中，然后<code>LayoutManager</code>会从scrap中取回A和C。</p><p>此时，B去哪里了？<code>RecyclerView</code>看到B没有出现在最终布局中，会unscrap它，让他它执行一个消失的动画，然后隐藏。动画执行结束后，B会放到<code>RecyclerViewPool</code>中。</p><p>为什么<code>LayoutManager</code>需要先执行<code>detach</code>，然后再重新<code>attach</code>这些view，而不是只移除那些变化的子view呢？Scrap缓存列表的存在，是为了隔离<code>LayoutManager</code>和<code>RecyclerView.Recycler</code>之间的关注点/职责。<code>LayoutManager</code>不需要知道哪些子view需要保留或者被回收到<code>RecyclerViewPool</code>或者其他地方。这是<code>Recycler</code>的职责。</p><p>除了在布局时不为空之外，还有另外一个与scrap有关的规律：所有scrap的view都会跟<code>RecyclerView</code>分离。<code>ViewGroup</code>中的<code>attachView</code>和<code>detachView</code>方法跟<code>addView</code>和<code>removeView</code>很像，但是不会触发请求布局重绘的事件。它们只是从<code>ViewGroup</code>的子view列表中删除对应的子view。，并将该子view的parent设置为null。<code>detached</code>状态必须是临时的，后面紧随着<code>attach</code>或<code>remove</code>事件。</p><p>如果在计算一个新布局的时候，已经添加了一堆子view，可以放心的将它们<code>detach</code>，<code>RecyclerView</code>也是这么做的。</p><h1 id="Attached-VS-Changed-scrap"><a href="#Attached-VS-Changed-scrap" class="headerlink" title="Attached VS Changed scrap"></a>Attached VS Changed scrap</h1><p><code>Recycler</code>中，可以看到两个单独的scrap容器：<code>mAttachedScrap</code>和<code>mChangedScrap</code>。为什么需要两个呢？</p><p><code>ViewHolder</code>只有在满足下面情况才会被添加到<code>mChangedScrap</code>：当它关联的item发生变化（<code>notifyItemChanged</code>或<code>notifyItemRangeChanged</code>被调用），并且<code>ItemAnimator</code>调用<code>ViewHolder#canReuseUpdatedViewHolder</code>方法时，返回<code>false</code>。否则，<code>ViewHolder</code>会被添加到<code>AttachScrap</code>中。</p><p><code>canReuseUpdatedViewHolder</code>返回<code>false</code>表示要执行用一个view替换另一个view的动画，<code>true</code>表示动画在内部发生。</p><p><code>mAttachedScrap</code>在整个布局过程中都能使用，但是changed scrap只能在预布局阶段使用。</p><p>原因：在布局后，新的<code>ViewHolder</code>应该替换调“改变了的”视图，因此<code>AttachedScrap</code>在布局后是没有用的。更改动画执行完成后，changed scrop将按照预期方式转存到pool中。</p><p>默认的<code>ItemAnimator</code>可以在3种情况下重用更新的<code>ViewHolder</code>：</p><ul><li>调用<code>setSupportsChangeAnimation(false)</code></li><li>调用<code>notifyDataSetChanged()</code>而不是<code>notifyItemChanged()</code>或<code>notifyItemRangeChanged()</code></li><li>提供这样的更改playload: <code>adapter.notifyItemChanged(index, anyObject)</code></li></ul><p>最后一种显示了一种很好的方法，当只想更改一些内部元素时，可以避免创建/绑定新的<code>ViewHolder</code>。</p><h1 id="Hidden-View-是什么？"><a href="#Hidden-View-是什么？" class="headerlink" title="Hidden View 是什么？"></a>Hidden View 是什么？</h1><p>前面说的第二次尝试获取<code>ViewHodler</code>时，有一个子步骤会从hidden view中搜索。hidden view指的是那些正在从<code>RecyclerView</code>边界中脱离的view。为了让这些view正确的执行对应的分离动画，它们仍然作为<code>RecyclerView</code>的子view被保留下来。</p><p>站在<code>LayoutManager</code>的角度，这些view已经不存在了，因此不应该被包含在计算里面。比如在部分view正在执行消失动画过程中，调用<code>LayoutManager#getChildAt</code>方法，这些view不算在下标里面。来自<code>LayoutManager</code>的所有对<code>getChild()</code>、<code>getChildCount()</code>、<code>addView()</code>等的方法调用在应用到实际的可回收view之前，都要通过<code>ChildHelper</code>处理，<code>ChildHelper</code>的职责是重新计算非隐藏的子view列表和完整的子view列表之间的索引。</p><p>注意，正在搜索要提供给<code>LayoutManager</code>的视图，<strong>但是<code>LayoutManager</code>不应了解隐藏View</strong>。</p><p>举一个实际的例子：这种“从隐藏的view弹跳”（bounching from hidden views）机制对于处理下面这种情况很有必要。现在要插入一个item，然后在插入动画完成之前，马上删除该item：</p><img src="/2020/05/15/Android-RecyclerView的缓存机制/微信图片_20200515174940.png"><p>想要看到B从C移除的位置开始向上平移。但是在那个时候，B是一个隐藏的view。如果忽略它（”隐藏“的B），那么会导致在现有B下面创建一个新的B。更糟糕的是，这两个view会重叠，因为新的B会往上，旧的B会往下。为了避免这种错误，在搜索<code>ViewHolder</code>的较早步骤中，<code>RecyclerView</code>会询问<code>ChildHelper</code>是否具有合适的hidden view。所谓”合适“，表示这个view和需要的位置相关联，并具有正确的view type，并且这个view的被隐藏的原因不是为了移除它。</p><p>如果有这样的view，<code>RecyclerView</code>会将其返回到<code>LayoutManger</code>并将其添加到<code>preLayout</code>中以标记应从其进行动画处理的位置（详见<code>recordAnimationInfoIfBouncedHiddenView()</code>方法）。</p><p>在布局前后添加内容的不应该是<code>LayoutManager</code>的职责吗？怎么现在<code>RecyclerView</code>也往<code>preLayout</code>中添加view？这有必要了解。</p><h1 id="Stable-Id的作用？"><a href="#Stable-Id的作用？" class="headerlink" title="Stable Id的作用？"></a>Stable Id的作用？</h1><p>Stable Id只会在调用<code>notifyDataSetChanged()</code>方法之后，影响<code>RecyclerView</code>的行为。</p><p>如果调用<code>notifyDataSetChanged()</code>的时候，<code>Adapter</code>并没有设置<code>hasStableId</code>，<code>RecyclerView</code>不知道发生了什么，哪一些东西变化了，所以，它假设所有东西都变了，每一个<code>ViewHolder</code>都是无效的，因此应该把它们放到<code>RecyclerViewPool</code>而不是scrap中。</p><img src="/2020/05/15/Android-RecyclerView的缓存机制/微信图片_20200515194333.png"><p>如果有Stable Id，就会如下：</p><img src="/2020/05/15/Android-RecyclerView的缓存机制/微信图片_20200515194749.png"><p><code>ViewHolder</code>会进入scrap而不是pool中。然后会通过特定的Id（<code>Adapter</code>中的<code>getItemId()</code>获取到的<code>id</code>），而不是<code>position</code>到scrap中查找<code>ViewHodler</code>。</p><p>好处：</p><ul><li>1、不会导致<code>RecyclerViewPool</code>溢出，因此非必须情况下，不需要创建新的<code>ViewHoler</code>。之前的<code>ViewHolder</code>会重新绑定，因为Id没有变化不代表内容没有变化</li><li>2、最大的好处是支持动画。上面移动item4到item6的位置。通常，需要调用<code>notifyItemMoved(4, 6)</code>才能得到一个移动动画。但是通过stable id，调用<code>notifyDataSetChanged()</code>也可以实现。因为<code>RecyclerView</code>可以看到特定id的view在新旧布局的位置。<ul><li>注意，这里的动画只支持简单的动画，预测动画无法支持。如果在新布局中看到一些id，而旧布局中没有，那么如何知道它是新插入的item还是从某处移入的item，后一种情况item究竟是从哪来的？通常，这些问题的答案在预布局中可以找到，根据适配器的更改，该布局已经超出<code>RecyclerView</code>的范围，但现在这种情况下，不知道聚义更改了什么。</li></ul></li></ul><p>总之，stable id的使用场景比较有限，不过，还是有一个使用场景：如果是从<code>ListView</code>迁移到<code>RecyclerView</code>，将所有<code>notifyDataSetChanged()</code>调用，都转换为特定更改的通知可能会很麻烦，这时，stable id可以提供简单的<code>RecyclerView</code>动画。</p><h1 id="缓存优化实践"><a href="#缓存优化实践" class="headerlink" title="缓存优化实践"></a>缓存优化实践</h1><ul><li><p>尽量使用<code>notifyItemXxx</code>方法进行通知更新，而不是<code>notifyDataSetChanged()</code></p><ul><li>如果变更前后是两个数据集，无法确定具体哪一些数据项变化了，可以考虑使用<a href="https://developer.android.google.cn/reference/androidx/recyclerview/widget/DiffUtil" target="_blank" rel="noopener">DiffUtil</a></li><li>如果数据集较大，建议结合使用<a href="https://developer.android.google.cn/reference/androidx/recyclerview/widget/AsyncListDiffer" target="_blank" rel="noopener">AsyncListDiffer</a>在子线程做diff运算。</li></ul></li><li><p>如果特定viewType的item只有一个，可以通过<code>RecyclerView#getRecycledViewPool()#setMaxRecycledViews(viewType, 1);</code>来调整缓存区的大小，减少内存占用</p></li><li><p>如果特定viewType的item特别多，但是不得不通过<code>notifyDataSetChanged()</code>方法更新数据，可以通过下面这种方式，在变更前调大缓存，变更完成后，调小缓存。这样布局变化也可以最大程度地复用已有的<code>ViewHolder</code>。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mRecyclerView.getRecycledViewPool().setMaxRecycledViews(<span class="number">0</span>, 屏幕显示的item总数 + <span class="number">7</span>);</span><br><span class="line">mAdapter.notifyDataSetChanged();</span><br><span class="line"><span class="keyword">new</span> Handler().post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mRecyclerView.getRecycledViewPool().setMaxRecycledViews(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>如果<code>RecyclerView</code>中每个item都是一个<code>RecycleyView</code>，并且子<code>RecyclerView</code>的item type相同可以通过<code>RecyclerView#setRecycledViewPool()</code>方法，实现缓存池复用。</p></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://www.programmersought.com/article/4558924504/" target="_blank" rel="noopener">RecyclerView caching mechanism ( multiplexing?)</a></p><p><a href="https://juejin.im/post/5b79a0b851882542b13d204b" target="_blank" rel="noopener">RecyclerView缓存原理，有图有真相</a></p><p><a href="https://juejin.im/post/5c696ba9e51d457f136d24ff" target="_blank" rel="noopener">RecyclerView缓存机制（咋复用？）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用&lt;code&gt;ScrollView&lt;/code&gt;时，它的所有子&lt;code&gt;View&lt;/code&gt;会一次性加载出来。&lt;code&gt;RecyclerView&lt;/code&gt;可以做到按需加载、按需绑定，并实现复用。这里主要分析&lt;code&gt;RecyclerView&lt;/code&gt;缓存复
      
    
    </summary>
    
      <category term="Android" scheme="https://tylerLiu.top/categories/Android/"/>
    
      <category term="View" scheme="https://tylerLiu.top/categories/Android/View/"/>
    
    
      <category term="RecyclerView" scheme="https://tylerLiu.top/tags/RecyclerView/"/>
    
  </entry>
  
  <entry>
    <title>Binder原理 04：ServiceManager的启动过程（基于Android 9.0/goldfish3.4）</title>
    <link href="https://tylerLiu.top/2019/12/09/Binder%E5%8E%9F%E7%90%86-04%EF%BC%9AServiceManager%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"/>
    <id>https://tylerLiu.top/2019/12/09/Binder原理-04：ServiceManager的启动过程/</id>
    <published>2019-12-09T01:38:18.000Z</published>
    <updated>2019-12-12T08:07:21.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面以<code>MediaPlayerService</code>为例，讲解了系统服务是如何注册的（<code>addService()</code>），既然有注册，就会有获取，但是在获取服务之前，需要先了解<code>ServiceManager</code>的启动过程，有助于理解系统服务的注册和获取的过程。<br>另外，想要了解<code>ServiceManager</code>的启动过程，需要查看Kernel Binder部分的源码，这部分源码包含在内核源码中，AOSP不包含内核源码，需要单独下载。</p><h1 id="1-ServiceManager的入口函数"><a href="#1-ServiceManager的入口函数" class="headerlink" title="1. ServiceManager的入口函数"></a>1. ServiceManager的入口函数</h1><p><code>ServiceManager</code>是init进程负责启动的，具体在解析init.rc配置文件时启动的，init进程是在系统启动时启动的，因此<code>ServiceManager</code>也是。<br>rc文件内部由Android初始化语言（Android Init Language）编写的脚本，主要包含五种类型语句：Action、Commands、Servcies、Options和Import。<br>在Android 7.0中对init.rc文件进行了拆分，每个服务一个rc文件。<code>ServiceManager</code>的启动脚本在servicemanager.rc中：frameworks/native/cmds/servicemanager/servicemanager.rc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">service servicemanager /system/bin/servicemanager</span><br><span class="line">    class core animation</span><br><span class="line">    user system  // 1</span><br><span class="line">    group system readproc</span><br><span class="line">    critical // 2</span><br><span class="line">    onrestart restart healthd  </span><br><span class="line">    onrestart restart zygote</span><br><span class="line">    onrestart restart audioserver</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart surfaceflinger</span><br><span class="line">    onrestart restart inputflinger</span><br><span class="line">    onrestart restart drm</span><br><span class="line">    onrestart restart cameraserver</span><br><span class="line">    onrestart restart keystore</span><br><span class="line">    onrestart restart gatekeeperd</span><br><span class="line">    writepid /dev/cpuset/system-background/tasks</span><br><span class="line">    shutdown critical</span><br></pre></td></tr></table></figure><p><code>service</code>用于通知init进程创建名为servicemanager的进程，这个servicemanager进程执行程序的路径为/system/bin/servicemanager。<br>注释1，关键字<code>user</code>说明servicemanager是以用户systemdd的身份运行的。<br>注释2，<code>critical</code>说明servicemanager是系统中的关键服务，关键服务是不会退出的，如果退出了，系统就会重启，当系统重启时，就会启动onrestart关键字修饰的进程，比如，zygote、media、surfaceflinger等。<br>servicemanager的入口函数在service_manager.c中：frameworks/native/cmds/servicemanager/service_manager.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_state</span> *<span class="title">bs</span>;</span> <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">union</span> selinux_callback cb;</span><br><span class="line">    <span class="keyword">char</span> *driver;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        driver = argv[<span class="number">1</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        driver = <span class="string">"/dev/binder"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bs = binder_open(driver, <span class="number">128</span>*<span class="number">1024</span>); <span class="comment">// 2</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (binder_become_context_manager(bs)) &#123; <span class="comment">// 3</span></span><br><span class="line">        ALOGE(<span class="string">"cannot become context manager (%s)\n"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (getcon(&amp;service_manager_context) != <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"SELinux: Failed to acquire service_manager context. Aborting.\n"</span>);</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    binder_loop(bs, svcmgr_handler); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，<code>binder_state</code>结构体用来存储<code>binder</code>的三个信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd; <span class="comment">// binder设备的文件描述符</span></span><br><span class="line">    <span class="keyword">void</span> *mapped; <span class="comment">// binder设备文件映射到进程的地址空间</span></span><br><span class="line">    <span class="keyword">size_t</span> mapsize; <span class="comment">// 内存映射后，系统分配的地址空间的大小，默认为128KB</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>main()</code>函数主要做了三件事：</p><ol><li>注释2调用<code>binder</code>设备文件，并申请了128KB字节大小的内存空间。</li><li>注释3调用<code>binder_become_context_manager()</code>函数，将servicemanager注册成Binder机制的上下文管理者。</li><li>注释4调用<code>binder_loop()</code>函数，循环等待和处理client端发来的请求。</li></ol><p>下面详细讲解。</p><h2 id="1-1-打开binder设备"><a href="#1-1-打开binder设备" class="headerlink" title="1.1 打开binder设备"></a>1.1 打开binder设备</h2><p><code>binder_open()</code>函数用于打开binder设备文件，并将它映射到进程的地址空间，如下。frameworks/native/cmds/servicemanager/binder.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct binder_state *<span class="title">binder_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* driver, <span class="keyword">size_t</span> mapsize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_state</span> *<span class="title">bs</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_version</span> <span class="title">vers</span>;</span></span><br><span class="line"></span><br><span class="line">    bs = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*bs));</span><br><span class="line">    <span class="keyword">if</span> (!bs) &#123;</span><br><span class="line">        errno = ENOMEM;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bs-&gt;fd = open(driver, O_RDWR | O_CLOEXEC); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> (bs-&gt;fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"binder: cannot open %s (%s)\n"</span>,</span><br><span class="line">                driver, strerror(errno));</span><br><span class="line">        <span class="keyword">goto</span> fail_open;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取Binder的version</span></span><br><span class="line">    <span class="keyword">if</span> ((ioctl(bs-&gt;fd, BINDER_VERSION, &amp;vers) == <span class="number">-1</span>) ||</span><br><span class="line">        (vers.protocol_version != BINDER_CURRENT_PROTOCOL_VERSION)) &#123; <span class="comment">// 2</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,</span><br><span class="line">                <span class="string">"binder: kernel driver version (%d) differs from user space version (%d)\n"</span>,</span><br><span class="line">                vers.protocol_version, BINDER_CURRENT_PROTOCOL_VERSION);</span><br><span class="line">        <span class="keyword">goto</span> fail_open;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bs-&gt;mapsize = mapsize;</span><br><span class="line">    bs-&gt;mapped = mmap(<span class="literal">NULL</span>, mapsize, PROT_READ, MAP_PRIVATE, bs-&gt;fd, <span class="number">0</span>); <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">if</span> (bs-&gt;mapped == MAP_FAILED) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"binder: cannot map device (%s)\n"</span>,</span><br><span class="line">                strerror(errno));</span><br><span class="line">        <span class="keyword">goto</span> fail_map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bs;</span><br><span class="line"></span><br><span class="line">fail_map:</span><br><span class="line">    close(bs-&gt;fd);</span><br><span class="line">fail_open:</span><br><span class="line">    <span class="built_in">free</span>(bs);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，打开binder设备文件，后面会进行分析。<br>注释2，<code>ioct()</code>函数用于获取Binder的版本，如果获取不到或者内核空间和用户空间的binder不是同一个版本，就会直接<code>goto</code>到<code>fail_open</code>标签，释放binder的内存空间。<br>注释3，调用<code>mmap()</code>函数进行内存映射，通俗来讲就是将binder设备文件映射到进程的地址空间，地址空间的大小为<code>mapsize</code>，即128K。映射完毕后会将地址空间的起始地址和大小保存在<code>binder_state</code>结构体中的<code>mmaped</code>和<code>mapsize</code>变量中。</p><p>这里说明一下<code>open()</code>函数，它会调用Kernel Binder部分的<code>binder_open()</code>函数，这部分的源码在内核源码中，这里展示的代码版本为goldfish 3.4。</p><h4 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h4><p>Intel的X86架构的CPU提供了0~3四个特权级别，数字越小，权限越高，Linux系统主要采用了0和3两个特权级别，分别对应内核态和用户态。用户态的特权级别低，因此进程在用户态下不经过系统调用是无法主动访问到内核空间中的数据的，这样用户无法随意进入所有进程共享的内核空间，起到保护作用。<br>当一个进程在执行用户自己的代码时处于用户态，比如<code>open()</code>函数，它运行在用户空间，当前的进程处于用户态。<br>当一个进程因为系统调用进入内核代码中执行时，就处于内核态，比如<code>open()</code>函数通过系统调用（<code>_open()</code>函数），查找到了<code>open()</code>函数在Kernel Binder对应的函数为<code>binder_open()</code>，这是<code>binder_open()</code>运行在内核空间，当前的进程由用户态切换到内核态。<br>kernel/goldfish/drivers/staging/android/binder.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_open</span><span class="params">(struct inode *nodp, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">// 代表Binder进程</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span>;</span> <span class="comment">// 1</span></span><br><span class="line">binder_debug(BINDER_DEBUG_OPEN_CLOSE, <span class="string">"binder_open: %d:%d\n"</span>,</span><br><span class="line">     current-&gt;group_leader-&gt;pid, current-&gt;pid);</span><br><span class="line">    <span class="comment">// 分配内存空间</span></span><br><span class="line">proc = kzalloc(<span class="keyword">sizeof</span>(*proc), GFP_KERNEL); <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">if</span> (proc == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">get_task_struct(current);</span><br><span class="line">proc-&gt;tsk = current;</span><br><span class="line">INIT_LIST_HEAD(&amp;proc-&gt;todo);</span><br><span class="line">init_waitqueue_head(&amp;proc-&gt;wait);</span><br><span class="line">proc-&gt;default_priority = task_nice(current);</span><br><span class="line">    <span class="comment">// binder同步锁</span></span><br><span class="line">binder_lock(__func__);</span><br><span class="line"></span><br><span class="line">binder_stats_created(BINDER_STAT_PROC);</span><br><span class="line">hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs);</span><br><span class="line">proc-&gt;pid = current-&gt;group_leader-&gt;pid;</span><br><span class="line">INIT_LIST_HEAD(&amp;proc-&gt;delivered_death);</span><br><span class="line">filp-&gt;private_data = proc; <span class="comment">// 3</span></span><br><span class="line">    <span class="comment">// binder同步锁释放</span></span><br><span class="line">binder_unlock(__func__);</span><br><span class="line">......</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，<code>binder_proc</code>结构体代表binder进程，用于管理binder的各种信息。<br>注释2，用于为<code>binder_proc</code>分配内存空间。<br>注释3，将<code>binder_proc</code>赋值给<code>file</code>指针的<code>private_data</code>变量，下一小节会再次提到变量<code>private_data</code>。</p><h2 id="1-2-注册称为Binder机制的上下文管理者"><a href="#1-2-注册称为Binder机制的上下文管理者" class="headerlink" title="1.2 注册称为Binder机制的上下文管理者"></a>1.2 注册称为Binder机制的上下文管理者</h2><p><code>binder_become_context_manager()</code>函数用于将servicemanager注册成为Binder机制的上下文管理者，这个管理者在整个系统只有一个，代码如下。frameworks/native/cmds/servicemanager/binder.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_become_context_manager</span><span class="params">(struct binder_state *bs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ioctl(bs-&gt;fd, BINDER_SET_CONTEXT_MGR, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前面以&lt;code&gt;MediaPlayerService&lt;/code&gt;为例，讲解了系统服务是如何注册的（&lt;code&gt;addService()&lt;
      
    
    </summary>
    
      <category term="Android进阶" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
      <category term="框架层" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/"/>
    
      <category term="Binder原理" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/Binder%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="Binder" scheme="https://tylerLiu.top/tags/Binder/"/>
    
  </entry>
  
  <entry>
    <title>Binder原理 03：系统服务的注册过程（基于Android 9.0）</title>
    <link href="https://tylerLiu.top/2019/11/15/Binder%E5%8E%9F%E7%90%86-03%EF%BC%9A%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B3%A8%E5%86%8C%E8%BF%87%E7%A8%8B/"/>
    <id>https://tylerLiu.top/2019/11/15/Binder原理-03：系统服务的注册过程/</id>
    <published>2019-11-15T07:39:27.000Z</published>
    <updated>2019-12-09T01:36:56.321Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面学习了<code>ServiceManager</code>中的<code>Binder</code>机制，但是并没有看到<code>MediaPlayerService</code>是如何注册的。下面通过了解<code>MediaPlayerService</code>的注册，看看系统服务的注册过程。</p><h1 id="1-从调用链角度说明MediaPlayerService是如何注册的"><a href="#1-从调用链角度说明MediaPlayerService是如何注册的" class="headerlink" title="1. 从调用链角度说明MediaPlayerService是如何注册的"></a>1. 从调用链角度说明MediaPlayerService是如何注册的</h1><p><code>MediaServer</code>的入口函数。frameworks/av/media/mediaserver/main_mediaserver.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc __unused, <span class="keyword">char</span> **argv __unused)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    signal(SIGPIPE, SIG_IGN);</span><br><span class="line">    <span class="comment">// 获取ProcessState实例</span></span><br><span class="line">    sp&lt;ProcessState&gt; proc(ProcessState::self());</span><br><span class="line">    sp&lt;IServiceManager&gt; sm(defaultServiceManager());</span><br><span class="line">    ALOGI(<span class="string">"ServiceManager: %p"</span>, sm.get());</span><br><span class="line">    InitializeIcuOrDie();</span><br><span class="line">    <span class="comment">// 注册MediaPlayerService</span></span><br><span class="line">    MediaPlayerService::instantiate(); <span class="comment">// 1</span></span><br><span class="line">    ResourceManagerService::instantiate();</span><br><span class="line">    registerExtensions();</span><br><span class="line">    <span class="comment">// 启动Binder线程池</span></span><br><span class="line">    ProcessState::self()-&gt;startThreadPool();</span><br><span class="line">    <span class="comment">// 当前线程加入到线程池</span></span><br><span class="line">    IPCThreadState::self()-&gt;joinThreadPool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在注释1处注册了<code>MediaPlayerService</code>。frameworks/av/media/libmediaplayerservice/MediaPlayerService.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MediaPlayerService::instantiate() &#123;</span><br><span class="line">    defaultServiceManager()-&gt;addService(</span><br><span class="line">            String16(<span class="string">"media.player"</span>), <span class="keyword">new</span> MediaPlayerService，());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>defaultServiceManager()</code>返回的是<code>BpServiceManager</code>。参数是字符串和<code>MediaPlayerService</code>，就像key/value的形式来完成注册，接着看<code>addService()</code>。frameworks/native/libs/binder/IServiceManager.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> status_t <span class="title">addService</span><span class="params">(<span class="keyword">const</span> String16&amp; name, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; service,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">bool</span> allowIsolated, <span class="keyword">int</span> dumpsysPriority)</span> </span>&#123;</span><br><span class="line">    Parcel data, reply; <span class="comment">// 数据包</span></span><br><span class="line">    data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor());</span><br><span class="line">    data.writeString16(name); <span class="comment">// name值为"media.player"</span></span><br><span class="line">    data.writeStrongBinder(service); <span class="comment">// service值为MediaPlayerService</span></span><br><span class="line">    data.writeInt32(allowIsolated ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    data.writeInt32(dumpsysPriority);</span><br><span class="line">    <span class="keyword">status_t</span> err = remote()-&gt;transact(ADD_SERVICE_TRANSACTION, data, &amp;reply); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> err == NO_ERROR ? reply.readExceptionCode() : err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>data</code>是一个数据包，后面会不断的将数据写入<code>data</code>中。<br>注释1，<code>remote()</code>指的是<code>mRemote</code>，也就是<code>BpBinder</code>。<br><code>addService()</code>函数的作用就是将请求数据打包成<code>data</code>，然后传给<code>BpBinder</code>的<code>transact()</code>函数。frameworks/native/libs/binder/BpBinder.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> BpBinder::transact(</span><br><span class="line">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mAlive) &#123;</span><br><span class="line">        <span class="keyword">status_t</span> status = IPCThreadState::self()-&gt;transact(</span><br><span class="line">            mHandle, code, data, reply, flags);</span><br><span class="line">        <span class="keyword">if</span> (status == DEAD_OBJECT) mAlive = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DEAD_OBJECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BpBinder</code>将逻辑处理交给了<code>IPCThreadState</code>，先来看看<code>IPCThreadState::self()</code>。frameworks/native/libs/binder/IPCThreadState.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">IPCThreadState* IPCThreadState::self()</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">// 首次进来gHaveTLS的值为false</span></span><br><span class="line">    <span class="keyword">if</span> (gHaveTLS) &#123;</span><br><span class="line">restart:</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">pthread_key_t</span> k = gTLS; <span class="comment">// 1</span></span><br><span class="line">        IPCThreadState* st = (IPCThreadState*)pthread_getspecific(k); <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">if</span> (st) <span class="keyword">return</span> st;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IPCThreadState; <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    pthread_mutex_unlock(&amp;gTLSMutex);</span><br><span class="line">    <span class="keyword">goto</span> restart;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，TLS的全称为Thread local storge，线程本地存储空间，在每个线程中都有TLS，并且线程间不共享。<br>注释2，获取TLS中的内容并赋值给<code>IPCThreadState</code>指针。<br>注释3，新建一个<code>IPCThreadState</code>，这里可以得知<code>IPCThreadState::self()</code>实际上是为了创建<code>IPCThreadState</code>，它的构造函数如下。frameworks/native/libs/binder/IPCThreadState.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">IPCThreadState::IPCThreadState()</span><br><span class="line">    : mProcess(ProcessState::self()),</span><br><span class="line">      mStrictModePolicy(<span class="number">0</span>),</span><br><span class="line">      mLastTransactionBinderFlags(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    pthread_setspecific(gTLS, <span class="keyword">this</span>); <span class="comment">// 1</span></span><br><span class="line">    clearCaller();</span><br><span class="line">    mIn.setDataCapacity(<span class="number">256</span>);</span><br><span class="line">    mOut.setDataCapacity(<span class="number">256</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，<code>pthread_setspecific()</code>函数用于设置TLS，将<code>IPCThreadState::self()</code>获得的TLS和自身传进去。<code>IPCThreadState</code>还包含一个<code>mIn</code>和一个<code>mOut</code>，<code>mIn</code>用来接收来自<code>Binder</code>驱动的数据，<code>mOut</code>用来存储发往<code>Binder</code>驱动的数据，默认大小都是256字节。再来看看<code>IPCThreadState</code>的<code>transact()</code>函数。frameworks/native/libs/binder/IPCThreadState.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::transact(<span class="keyword">int32_t</span> handle,</span><br><span class="line">                                  <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data,</span><br><span class="line">                                  Parcel* reply, <span class="keyword">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    flags |= TF_ACCEPT_FDS;</span><br><span class="line">    ......</span><br><span class="line">    err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, <span class="literal">NULL</span>); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (reply) reply-&gt;setError(err);</span><br><span class="line">        <span class="keyword">return</span> (mLastError = err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">            err = waitForResponse(reply); <span class="comment">// 2</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Parcel fakeReply;</span><br><span class="line">            err = waitForResponse(&amp;fakeReply);</span><br><span class="line">        &#125;</span><br><span class="line">       ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 不需要等待reply的分支</span></span><br><span class="line">        err = waitForResponse(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>BpBinder</code>的<code>transact()</code>函数实际上就是调用<code>IPCThreadState</code>的<code>transact()</code>函数。<br>注释1，<code>writeTransactionData()</code>函数用于传输数据，其中第一个参数<code>BC_TRANSACTION</code>代表向Binder驱动发送命令协议，向Binder设备发送的命令协议都以<code>BC_</code>开头，而Binder驱动返回的命令都以<code>BR_</code>开头。<br>现在来分别分析注释1的<code>writeTransactionData()</code>和注释2的<code>waitForResponse()</code>函数。</p><h2 id="1-1-writeTransactionData"><a href="#1-1-writeTransactionData" class="headerlink" title="1.1 writeTransactionData()"></a>1.1 writeTransactionData()</h2><p>frameworks/native/libs/binder/IPCThreadState.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::writeTransactionData(<span class="keyword">int32_t</span> cmd, <span class="keyword">uint32_t</span> binderFlags,</span><br><span class="line">    <span class="keyword">int32_t</span> handle, <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, <span class="keyword">status_t</span>* statusBuffer)</span><br><span class="line">&#123;</span><br><span class="line">    binder_transaction_data tr; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    tr.target.ptr = <span class="number">0</span>; </span><br><span class="line">    tr.target.handle = handle; <span class="comment">// 2</span></span><br><span class="line">    tr.code = code; <span class="comment">// code=ADD_SERVICE_TRANSACTION</span></span><br><span class="line">    tr.flags = binderFlags;</span><br><span class="line">    tr.cookie = <span class="number">0</span>;</span><br><span class="line">    tr.sender_pid = <span class="number">0</span>;</span><br><span class="line">    tr.sender_euid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">status_t</span> err = data.errorCheck(); <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        tr.data_size = data.ipcDataSize();</span><br><span class="line">        tr.data.ptr.buffer = data.ipcData();</span><br><span class="line">        tr.offsets_size = data.ipcObjectsCount()*<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>);</span><br><span class="line">        tr.data.ptr.offsets = data.ipcObjects();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (statusBuffer) &#123;</span><br><span class="line">        tr.flags |= TF_STATUS_CODE;</span><br><span class="line">        *statusBuffer = err;</span><br><span class="line">        tr.data_size = <span class="keyword">sizeof</span>(<span class="keyword">status_t</span>);</span><br><span class="line">        tr.data.ptr.buffer = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(statusBuffer);</span><br><span class="line">        tr.offsets_size = <span class="number">0</span>;</span><br><span class="line">        tr.data.ptr.offsets = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (mLastError = err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mOut.writeInt32(cmd); <span class="comment">// cmd=BC_TRANSACTION</span></span><br><span class="line">    mOut.write(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，<code>binder_transaction_data</code>结构体（tr结构体）是向Binder驱动通信的数据结构。<br>注释2，将<code>handle</code>传递给<code>target</code>的<code>handle</code>，用于标识目标，这里的<code>handle</code>的值为0，代表了<code>ServiceManager</code>。<br>注释3，对数据<code>data</code>进行错误检查，如果没有错误，就将数据赋值给对应的tr结构体。最后会将<code>BC_TRANSACTION</code>和tr结构体写入到<code>mOut</code>中。</p><img src="/2019/11/15/Binder原理-03：系统服务的注册过程/1575253205.jpg"><h2 id="1-2-waitForResponse函数分析"><a href="#1-2-waitForResponse函数分析" class="headerlink" title="1.2 waitForResponse函数分析"></a>1.2 waitForResponse函数分析</h2><p><code>waitForResponse()</code>中有很多<code>case</code>语句，这里截取部分。frameworks/native/libs/binder/IPCThreadState.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::waitForResponse(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">    <span class="keyword">int32_t</span> err;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="keyword">break</span>; <span class="comment">// 1</span></span><br><span class="line">        err = mIn.errorCheck();</span><br><span class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (mIn.dataAvail() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        cmd = (<span class="keyword">uint32_t</span>)mIn.readInt32();</span><br><span class="line">        IF_LOG_COMMANDS() &#123;</span><br><span class="line">            alog &lt;&lt; <span class="string">"Processing waitForResponse Command: "</span></span><br><span class="line">                &lt;&lt; getReturnString(cmd) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION_COMPLETE:</span><br><span class="line">            <span class="keyword">if</span> (!reply &amp;&amp; !acquireResult) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BR_DEAD_REPLY:</span><br><span class="line">            err = DEAD_OBJECT;</span><br><span class="line">            <span class="keyword">goto</span> finish;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// 处理各种命令协议</span></span><br><span class="line">            err = executeCommand(cmd);</span><br><span class="line">            <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">finish:</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，<code>talkWithDriver()</code>内部通过<code>ioctl</code>与<code>Binder</code>驱动进行通信。frameworks/native/libs/binder/IPCThreadState.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::talkWithDriver(<span class="keyword">bool</span> doReceive)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mProcess-&gt;mDriverFD &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -EBADF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 和Binder驱动通信的结构体</span></span><br><span class="line">    binder_write_read bwr; <span class="comment">// 1</span></span><br><span class="line">    <span class="comment">// mIn是否有可读的数据，接收的数据存储在mIn</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> needRead = mIn.dataPosition() &gt;= mIn.dataSize();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> outAvail = (!doReceive || needRead) ? mOut.dataSize() : <span class="number">0</span>;</span><br><span class="line">    bwr.write_size = outAvail;</span><br><span class="line">    bwr.write_buffer = (<span class="keyword">uintptr_t</span>)mOut.data(); <span class="comment">// 2</span></span><br><span class="line">    <span class="comment">// 这时doReceive的值为true</span></span><br><span class="line">    <span class="keyword">if</span> (doReceive &amp;&amp; needRead) &#123;</span><br><span class="line">        bwr.read_size = mIn.dataCapacity();</span><br><span class="line">        bwr.read_buffer = (<span class="keyword">uintptr_t</span>)mIn.data(); <span class="comment">// 3</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bwr.read_size = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> ((bwr.write_size == <span class="number">0</span>) &amp;&amp; (bwr.read_size == <span class="number">0</span>)) <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        IF_LOG_COMMANDS() &#123;</span><br><span class="line">            alog &lt;&lt; <span class="string">"About to read/write, write size = "</span> &lt;&lt; mOut.dataSize() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> defined(__ANDROID__)</span></span><br><span class="line">        <span class="keyword">if</span> (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="number">0</span>) <span class="comment">// 4</span></span><br><span class="line">            err = NO_ERROR;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            err = -errno;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        err = INVALID_OPERATION;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">while</span> (err == -EINTR);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，<code>binder_write_read</code>是与<code>Binder</code>驱动通信的结构体，在注释2和3处将<code>mOut</code>、<code>mIn</code>赋值给<code>binder_write_read</code>的相应字段，最终通过注释4的<code>ioctl()</code>函数和<code>Binder</code>驱动进行通信，这部分涉及Kernel Binder的内容，在Kernel Binder中会记录服务名和handle，用于后续的服务查询。</p><h2 id="1-3-小结"><a href="#1-3-小结" class="headerlink" title="1.3 小结"></a>1.3 小结</h2><p>从调用链的角度来看，<code>MediaPlayerService</code>注册并不复杂，这里只是简单介绍了一个调用链的分支，可以简单总结为以下步骤：</p><ol><li><code>addService()</code>函数将数据打包发送给<code>BpBinder</code>来进行处理。</li><li><code>BpBinder</code>新建一个<code>IPCThreadState</code>对象，并将通信的任务交给<code>IPCThreadState</code>。</li><li><code>IPCThreadState</code>的<code>writeTransactionData()</code>函数用于将命令协议和数据写入到<code>mOut</code>中。</li><li><code>IPCThreadState</code>的<code>waitForResponse()</code>函数主要做两件事，一是通过<code>ioctl()</code>函数操作<code>mOut</code>和<code>mIn</code>来与Binder驱动进行数据交互，二是处理各种命令协议。</li></ol><h1 id="2-从进程角度说明MediaPlayerService是如何注册的"><a href="#2-从进程角度说明MediaPlayerService是如何注册的" class="headerlink" title="2. 从进程角度说明MediaPlayerService是如何注册的"></a>2. 从进程角度说明MediaPlayerService是如何注册的</h1><img src="/2019/11/15/Binder原理-03：系统服务的注册过程/1575446811.jpg"><p>从图中可以看出是以C/S架构为基础的，<code>addService()</code>是在<code>MediaPlayerService</code>进行的，它是Client端，用于请求添加系统服务。而Server端则指的是<code>ServiceManager</code>，用于完成系统服务的添加。<br>Client端和Server端分别运行在两个进程中，通过Binder驱动来进行通信。两端通过向Binder驱动发送命令协议来完成系统服务的添加。其中命令协议非常多，过程比较复杂，这里对命令协议进行了简化，只涉及四个命令协议，其中<code>BC_TRANSACTION</code>和<code>BR_TRANSACTION</code>过程是一个完整的事务，<code>BC_REPLAY</code>和<code>BR_REPLAY</code>过程是一个完整的事务。<br>Client端和Server端向Binder驱动发送命令协议以BC开头，而Binder驱动向Client端和Server端返回的命令协议以BR开头。<br>步骤如下：</p><ol><li>Client端向Binder驱动发送<code>BC_TRANSACTION</code>命令。</li><li>Binder驱动接收请求后生成<code>BR_TRANSACTION</code>命令，唤醒Server端的线程后将<code>BR_TRANSACTION</code>命令发送给<code>ServiceManager</code>。</li><li>Server端中的服务注册完成后，生成<code>BC_REPLAY</code>命令发动给Binder驱动。</li><li>Binder驱动生成<code>BR_REPLAY</code>命令，唤醒Client端的线程后将<code>BR_REPLAY</code>命令发送给Client端。</li></ol><p>通过这些协议命令来完成系统服务的注册。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前面学习了&lt;code&gt;ServiceManager&lt;/code&gt;中的&lt;code&gt;Binder&lt;/code&gt;机制，但是并没有看到&lt;code&gt;M
      
    
    </summary>
    
      <category term="Android进阶" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
      <category term="框架层" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/"/>
    
      <category term="Binder原理" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/Binder%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="Binder" scheme="https://tylerLiu.top/tags/Binder/"/>
    
  </entry>
  
  <entry>
    <title>Binder原理 02：ServiceManager中的Binder机制（基于Android 9.0）</title>
    <link href="https://tylerLiu.top/2019/11/12/Binder%E5%8E%9F%E7%90%86-02%EF%BC%9AServiceManager%E4%B8%AD%E7%9A%84Binder%E6%9C%BA%E5%88%B6/"/>
    <id>https://tylerLiu.top/2019/11/12/Binder原理-02：ServiceManager中的Binder机制/</id>
    <published>2019-11-12T07:41:04.000Z</published>
    <updated>2019-11-15T07:38:11.546Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面说到<code>Binder</code>机制分成三个部分：Java Binder、Native Binder、Kernel Binder，其中Java Binder和Native Binder都是应用开发需要掌握的的。Java Binder是需要借助Native Binder来工作的，因此需要先了解Native Binder，Native Binder架构的原型就是基于Binder通信的C/S架构。</p><h1 id="1-基于Binder通信的C-S架构"><a href="#1-基于Binder通信的C-S架构" class="headerlink" title="1. 基于Binder通信的C/S架构"></a>1. 基于Binder通信的C/S架构</h1><p>在Android系统中，<code>Binder</code>进程间的通信的使用很普遍，在MadiaPlayer框架中，就是基于C/S架构，并采用了<code>Binder</code>来进行进程间通信的。</p><img src="/2019/11/12/Binder原理-02：ServiceManager中的Binder机制/1573615014.jpg"><p>从上图可以看出，除了常规C/S架构的Client端和Server端，还包括了<code>ServiceManager</code>，用于管理系统中的服务。<br>首先，Server进程会注册一些Service到<code>ServiceManager</code>中，Client要使用某个Service，则需要先到<code>ServiceManager</code>查询Service的相关信息，然后根据Service的相关信息与Service所在的Server进程建立通信通路，这样Client就可以使用Service了。</p><h1 id="2-MediaServer的main函数"><a href="#2-MediaServer的main函数" class="headerlink" title="2. MediaServer的main函数"></a>2. MediaServer的main函数</h1><p>Client、Server、ServiceManager三者的交互都是基于<code>Binder</code>通信的，可以说Native Binder的原理的核心就是<code>ServiceManager</code>的原理，为了更好了解<code>ServiceManager</code>，这里拿<code>MediaPlayer</code>框架为例。</p><img src="/2019/11/12/Binder原理-02：ServiceManager中的Binder机制/1573693782.jpg"><p>可以看到，<code>MediaPlayer</code>和<code>MediaPlayerService</code>是通过<code>Binder</code>通信的，<code>MediaPlayer</code>是Client端，<code>MediaPlayerService</code>是Server端，<code>MediaPlayerService</code>是系统多媒体服务的一种，系统多媒体服务是由一个叫<code>MediaServer</code>的服务进程提供的，它是一个可执行程序，在Android系统启动时，<code>MediaServer</code>也被启动，它的函数入口如下。frameworks/av/media/mediaserver/main_mediaserver.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc __unused, <span class="keyword">char</span> **argv __unused)</span></span>&#123;</span><br><span class="line">    signal(SIGPIPE, SIG_IGN);</span><br><span class="line">    <span class="comment">// 获取ProcessState实例</span></span><br><span class="line">    sp&lt;ProcessState&gt; proc(ProcessState::self()); <span class="comment">// 1</span></span><br><span class="line">    sp&lt;IServiceManager&gt; sm(defaultServiceManager()); <span class="comment">// 2</span></span><br><span class="line">    ALOGI(<span class="string">"ServiceManager: %p"</span>, sm.get());</span><br><span class="line">    InitializeIcuOrDie();</span><br><span class="line">    <span class="comment">// 注册MediaPlayerService</span></span><br><span class="line">    MediaPlayerService::instantiate(); <span class="comment">// 3</span></span><br><span class="line">    ResourceManagerService::instantiate();</span><br><span class="line">    registerExtensions();</span><br><span class="line">    <span class="comment">// 启动Binder线程池</span></span><br><span class="line">    ProcessState::self()-&gt;startThreadPool();</span><br><span class="line">    <span class="comment">// 当前线程加入到线程池</span></span><br><span class="line">    IPCThreadState::self()-&gt;joinThreadPool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，用于获取<code>ProcessState</code>实例，在这一过程中会打开/dev/binder设备，并使用mmap为Binder驱动分配一个虚拟地址空间来接收数据。<br>注释2，获取一个<code>IServiceManager</code>，通过这个<code>IServiceManager</code>，其他进程就可以和当前的<code>ServiceManager</code>进行交互，这里就用到<code>Binder</code>通信。<br>注释3，注册<code>MediaPlayerService</code>。</p><h1 id="3-每个进程唯一的ProcessState"><a href="#3-每个进程唯一的ProcessState" class="headerlink" title="3. 每个进程唯一的ProcessState"></a>3. 每个进程唯一的ProcessState</h1><p><code>ProcessState</code>用于表示进程的状态，先从<code>ProcessState</code>的<code>self()</code>函数开始。frameworks/native/libs/binder/ProcessState.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;ProcessState&gt; ProcessState::self()&#123;</span><br><span class="line">    Mutex::Autolock _l(gProcessMutex);</span><br><span class="line">    <span class="keyword">if</span> (gProcess != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> gProcess;</span><br><span class="line">    &#125;</span><br><span class="line">    gProcess = <span class="keyword">new</span> ProcessState(<span class="string">"/dev/binder"</span>); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> gProcess;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用了单例模式，确保每个进程只有一个<code>ProcessState</code>。注释1，创建一个<code>ProcessState</code>实例，参数为<code>&quot;/dev/Binder&quot;</code>。接着查看<code>ProcessState</code>的构造函数。frameworks/native/libs/binder/ProcessState.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ProcessState::ProcessState(<span class="keyword">const</span> <span class="keyword">char</span> *driver)</span><br><span class="line">    : mDriverName(String8(driver))</span><br><span class="line">    , mDriverFD(open_driver(driver)) <span class="comment">// 1</span></span><br><span class="line">    , mVMStart(MAP_FAILED)</span><br><span class="line">    , mThreadCountLock(PTHREAD_MUTEX_INITIALIZER)</span><br><span class="line">    , mThreadCountDecrement(PTHREAD_COND_INITIALIZER)</span><br><span class="line">    , mExecutingThreadsCount(<span class="number">0</span>)</span><br><span class="line">    , mMaxThreads(DEFAULT_MAX_BINDER_THREADS)</span><br><span class="line">    , mStarvationStartTimeMs(<span class="number">0</span>)</span><br><span class="line">    , mManagesContexts(<span class="literal">false</span>)</span><br><span class="line">    , mBinderContextCheckFunc(<span class="literal">NULL</span>)</span><br><span class="line">    , mBinderContextUserData(<span class="literal">NULL</span>)</span><br><span class="line">    , mThreadPoolStarted(<span class="literal">false</span>)</span><br><span class="line">    , mThreadPoolSeq(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDriverFD &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        mVMStart = mmap(<span class="number">0</span>, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, <span class="number">0</span>); <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">if</span> (mVMStart == MAP_FAILED) &#123;</span><br><span class="line">            <span class="comment">// *sigh*</span></span><br><span class="line">            ALOGE(<span class="string">"Using %s failed: unable to mmap transaction memory.\n"</span>, mDriverName.c_str());</span><br><span class="line">            close(mDriverFD);</span><br><span class="line">            mDriverFD = <span class="number">-1</span>;</span><br><span class="line">            mDriverName.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(mDriverFD &lt; <span class="number">0</span>, <span class="string">"Binder driver could not be opened.  Terminating."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，打开/dev/Binder设备。<br>注释2，<code>mmap()</code>函数会在内核虚拟地址空间中申请一块与用户虚拟内存相同大小的内存，然后再申请物理内存，将同一块物理内存分别映射到内核虚拟地址空间和用户虚拟内存空间，实现内核虚拟地址空间和用户虚拟内存空间的数据同步操作，即内存映射。<br><code>mmap()</code>函数用于对Binder设备进行内存映射，除了它还有<code>open()</code>、<code>ioct()</code>函数，下面来看看它们实现了什么。<br><code>open_driver()</code>。frameworks/native/libs/binder/ProcessState.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">open_driver</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *driver)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(driver, O_RDWR | O_CLOEXEC); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">size_t</span> maxThreads = DEFAULT_MAX_BINDER_THREADS;</span><br><span class="line">        result = ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads); <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">"Binder ioctl to set max threads failed: %s"</span>, strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ALOGW(<span class="string">"Opening '%s' failed: %s\n"</span>, driver, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，打开/dev/Binder设备并返回文件操作符<code>fd</code>，这样就可以操作内核的Binder驱动了。<br>注释2，<code>ioct()</code>函数的作用就是和Binder设备进行参数的传递，这里的<code>ioct()</code>函数用于设定<code>binder</code>支持的最大线程数为15（<code>maxThreads</code>的值为15）。最终<code>open_driver()</code>函数返回文件操作符<code>fd</code>。</p><p><code>ProcessState</code>主要做了两件事：</p><ol><li>打开/dev/Binder设备并设定<code>Binder</code>最大的支持线程数。</li><li>通过<code>mmap()</code>为<code>binder</code>分配一块虚拟地址空间，达到内存映射的目的。</li></ol><h1 id="4-ServiceManager中的Binder机制"><a href="#4-ServiceManager中的Binder机制" class="headerlink" title="4. ServiceManager中的Binder机制"></a>4. ServiceManager中的Binder机制</h1><p>回到<code>MediaServer</code>的入口函数，在注释2调用了<code>defaultServiceManager()</code>函数。frameworks/native/libs/binder/IServiceManager.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IServiceManager&gt; defaultServiceManager()&#123;</span><br><span class="line">    <span class="keyword">if</span> (gDefaultServiceManager != <span class="literal">NULL</span>) <span class="keyword">return</span> gDefaultServiceManager;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        AutoMutex _l(gDefaultServiceManagerLock);</span><br><span class="line">        <span class="keyword">while</span> (gDefaultServiceManager == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;(</span><br><span class="line">                ProcessState::self()-&gt;getContextObject(<span class="literal">NULL</span>)); <span class="comment">// 1</span></span><br><span class="line">            <span class="keyword">if</span> (gDefaultServiceManager == <span class="literal">NULL</span>)</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> gDefaultServiceManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从<code>IServiceManager</code>所在文件路径就可以知道，<code>ServiceManager</code>中不仅仅使用了<code>Binder</code>通信，它自身也属于<code>Binder</code>体系。<code>defaultServiceManager()</code>中同样使用了单例。<br>注释1，<code>interface_cast()</code>函数生成了<code>gDefaultServiceManager</code>，其内部调用了<code>ProcessState</code>的<code>getContextObject()</code>函数。frameworks/native/libs/binder/ProcessState.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IBinder&gt; ProcessState::getContextObject(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; <span class="comment">/*caller*/</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> getStrongProxyForHandle(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(<span class="keyword">int32_t</span> handle)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;IBinder&gt; result;</span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line">    handle_entry* e = lookupHandleLocked(handle); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        IBinder* b = e-&gt;binder;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">NULL</span> || !e-&gt;refs-&gt;attemptIncWeak(<span class="keyword">this</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (handle == <span class="number">0</span>) &#123;</span><br><span class="line">                Parcel data;</span><br><span class="line">                <span class="keyword">status_t</span> status = IPCThreadState::self()-&gt;transact(</span><br><span class="line">                        <span class="number">0</span>, IBinder::PING_TRANSACTION, data, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (status == DEAD_OBJECT)</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            b = BpBinder::create(handle); <span class="comment">// 2</span></span><br><span class="line">            e-&gt;binder = b;</span><br><span class="line">            <span class="keyword">if</span> (b) e-&gt;refs = b-&gt;getWeakRefs();</span><br><span class="line">            result = b;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.force_set(b);</span><br><span class="line">            e-&gt;refs-&gt;decWeak(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getContextObject()</code>函数中直接调用了<code>getStrongProxyForHandle()</code>函数，传入的参数的值为0，即<code>handle</code>的值就是0，<code>handle</code>是一个资源标识。<br>注释1，查询这个资源标识对应的资源<code>handle_entry</code>是否存在，如果不存在就会在注释2处新建<code>BpBinder</code>，并在注释3赋值给<code>handle_entry</code>的<code>binder</code>。最终返回的<code>result</code>的值为<code>BpBinder</code>。</p><h2 id="4-1-BpBinder和BBinder"><a href="#4-1-BpBinder和BBinder" class="headerlink" title="4.1 BpBinder和BBinder"></a>4.1 BpBinder和BBinder</h2><p>它们都继承了<code>IBinder</code>。<br><code>BpBinder</code>是Client端与Server交互的代理类，<code>BBinder</code>代表了Server端。<code>BpBinder</code>和<code>BBinder</code>是一一对应的，<code>BpBinder</code>会通过<code>handle</code>来找到对应的<code>BpBinder</code>。<br>在<code>ServiceManager</code>中创建<code>BpBinder</code>，通过<code>handle</code>（值为0）可以找到对应的<code>BBinder</code>。</p><p>分析完<code>ProcessState</code>的<code>getContextObject()</code>函数，回到<code>interface_cast()</code>函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;(ProcessState::self()-&gt;getContextObject(<span class="literal">NULL</span>));</span><br></pre></td></tr></table></figure><p><code>interface_cast()</code>函数的具体实现如下。frameworks/native/libs/binder/include/binder/IInterface.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> INTERFACE&gt;</span><br><span class="line"><span class="keyword">inline</span> sp&lt;INTERFACE&gt; interface_cast(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> INTERFACE::asInterface(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前场景中，<code>INTERFACE</code>的值为<code>IServiceManager</code>，那么替换后代码如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> sp&lt;IServiceManager&gt; interface_cast(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> IServiceManager::asInterface(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来分析<code>IServiceManager</code>。</p><h2 id="4-2-IServiceManager"><a href="#4-2-IServiceManager" class="headerlink" title="4.2 IServiceManager"></a>4.2 IServiceManager</h2><p><code>BpBinder</code>和<code>BBinder</code>负责<code>Binder</code>通信，而<code>IServiceManager</code>用于处理<code>ServiceManager</code>的业务，<code>IServiceManager</code>是C++代码，因此它被定义在<code>IServiceManager.h</code>中。frameworks/native/libs/binder/include/binder/IServiceManager.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IServiceManager</span> :</span> <span class="keyword">public</span> IInterface</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DECLARE_META_INTERFACE(ServiceManager) <span class="comment">// 1</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 一些操作Service的函数</span></span><br><span class="line">    <span class="keyword">virtual</span> sp&lt;IBinder&gt;    getService( <span class="keyword">const</span> String16&amp; name) <span class="keyword">const</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> sp&lt;IBinder&gt;    checkService( <span class="keyword">const</span> String16&amp; name) <span class="keyword">const</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">addService</span><span class="params">(<span class="keyword">const</span> String16&amp; name, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; service,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">bool</span> allowIsolated = <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> dumpsysFlags = DUMP_FLAG_PRIORITY_DEFAULT)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> Vector&lt;String16&gt; listServices(<span class="keyword">int</span> dumpsysFlags = DUMP_FLAG_PRIORITY_ALL) = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        GET_SERVICE_TRANSACTION = IBinder::FIRST_CALL_TRANSACTION,</span><br><span class="line">        CHECK_SERVICE_TRANSACTION,</span><br><span class="line">        ADD_SERVICE_TRANSACTION,</span><br><span class="line">        LIST_SERVICES_TRANSACTION,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>IServiceManager</code>继承了<code>IInterface</code>，其内部定义了一些常量和一些操作Service的函数，在注释1调用了<code>DECLARE_META_INTERFACE()</code>宏，它的定义在<code>IInterface.h</code>中。frameworks/native/libs/binder/include/binder/IInterface.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_META_INTERFACE(INTERFACE)                               \</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> ::android::String16 descriptor;                        \</span><br><span class="line">    <span class="keyword">static</span> ::android::sp&lt;I##INTERFACE&gt; asInterface(                     \</span><br><span class="line">            <span class="keyword">const</span> ::android::sp&lt;::android::IBinder&gt;&amp; obj);              \</span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">const</span> ::android::<span class="function">String16&amp; <span class="title">getInterfaceDescriptor</span><span class="params">()</span> <span class="keyword">const</span></span>;  \</span><br><span class="line">    I##INTERFACE();                                                     \</span><br><span class="line">    <span class="keyword">virtual</span> ~I##INTERFACE();     </span><br><span class="line">```    </span><br><span class="line">其中`INTERFACE`的值为`ServiceManager`，那么经过替换后的代码如下所示。</span><br><span class="line">```cpp               </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> ::android::String16 descriptor;</span><br><span class="line">    <span class="comment">// 定义asInterface函数</span></span><br><span class="line">    <span class="keyword">static</span> ::android::sp&lt;IServiceManager&gt; asInterface(                    </span><br><span class="line">            <span class="keyword">const</span> ::android::sp&lt;::android::IBinder&gt;&amp; obj);</span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">const</span> ::android::<span class="function">String16&amp; <span class="title">getInterfaceDescriptor</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">// 定义IServiceManager构造函数</span></span><br><span class="line">    IServiceManager();</span><br><span class="line">    <span class="comment">// 定义IServiceManager析构函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~IServiceManager();</span><br></pre></td></tr></table></figure><p>从<code>DECLARE_META_INTERFACE</code>宏的名称和上面的代码中，可以发现它主要声明了一些函数和一个变量。那么这些函数和变量的实现在哪呢？答案还是在IInterface.h中，叫做<code>IMPLEMENT_META_INTERFACE</code>宏，代码如下所示.frameworks/native/libs/binder/include/binder/IInterface.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPLEMENT_META_INTERFACE(INTERFACE, NAME)                   \</span></span><br><span class="line"><span class="keyword">const</span> ::android::String16 I##INTERFACE::descriptor(NAME);           \</span><br><span class="line"><span class="keyword">const</span> ::android::String16&amp;                                          \</span><br><span class="line">        I##INTERFACE::getInterfaceDescriptor() <span class="keyword">const</span> &#123;              \</span><br><span class="line">    <span class="keyword">return</span> I##INTERFACE::descriptor;                                \</span><br><span class="line">&#125;                                                                   \</span><br><span class="line">::android::sp&lt;I##INTERFACE&gt; I##INTERFACE::asInterface(              \</span><br><span class="line">        <span class="keyword">const</span> ::android::sp&lt;::android::IBinder&gt;&amp; obj)               \</span><br><span class="line">&#123;                                                                   \</span><br><span class="line">    ::android::sp&lt;I##INTERFACE&gt; intr;                               \</span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="literal">NULL</span>) &#123;                                              \</span><br><span class="line">        intr = <span class="keyword">static_cast</span>&lt;I##INTERFACE*&gt;(                          \</span><br><span class="line">            obj-&gt;queryLocalInterface(                               \</span><br><span class="line">                    I##INTERFACE::descriptor).get());               \</span><br><span class="line">        <span class="keyword">if</span> (intr == <span class="literal">NULL</span>) &#123;                                         \</span><br><span class="line">            intr = <span class="keyword">new</span> Bp##INTERFACE(obj);                          \</span><br><span class="line">        &#125;                                                           \</span><br><span class="line">    &#125;                                                               \</span><br><span class="line">    <span class="keyword">return</span> intr;                                                    \</span><br><span class="line">&#125;                                                                   \</span><br><span class="line">I##INTERFACE::I##INTERFACE() &#123; &#125;                                    \</span><br><span class="line">I##INTERFACE::~I##INTERFACE() &#123; &#125;                                   \</span><br></pre></td></tr></table></figure><p><code>DECLARE_META_INTERFACE()</code>和<code>IMPLEMENT_META_INTERFACE()</code>宏是配合使用的，很多系统服务都使用它们，<code>IServiceManager</code>使用<code>IMPLEMENT_META_INTERFACE()</code>宏只有一行代码，如下。frameworks/native/libs/binder/IServiceManager.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IMPLEMENT_META_INTERFACE(ServiceManager, <span class="string">"android.os.IServiceManager"</span>);</span><br></pre></td></tr></table></figure><p><code>IMPLEMENT_META_INTERFACE()</code>宏的<code>INTERFACE</code>值为<code>ServiceManager</code>，<code>NAME</code>值为<code>&quot;android.os.IServiceManager&quot;</code>，进行替换后，代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ::android::String16 IServiceManager::descriptor(<span class="string">"android.os.IServiceManager"</span>);          </span><br><span class="line"><span class="keyword">const</span> ::android::String16&amp;                                          </span><br><span class="line">        IServiceManager::getInterfaceDescriptor() <span class="keyword">const</span> &#123;              </span><br><span class="line">    <span class="keyword">return</span> IServiceManager::descriptor;                                </span><br><span class="line">&#125; </span><br><span class="line"> <span class="comment">// 实现了asInterface函数</span></span><br><span class="line">::android::sp&lt;IServiceManager&gt; IServiceManager::asInterface(              </span><br><span class="line">        <span class="keyword">const</span> ::android::sp&lt;::android::IBinder&gt;&amp; obj)               </span><br><span class="line">&#123;                                                                   </span><br><span class="line">    ::android::sp&lt;IServiceManager&gt; intr;                               </span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="literal">NULL</span>) &#123;                                              </span><br><span class="line">        intr = <span class="keyword">static_cast</span>&lt;IServiceManager&gt;(                          </span><br><span class="line">            obj-&gt;queryLocalInterface(                               </span><br><span class="line">                    IServiceManager::descriptor).get());               </span><br><span class="line">        <span class="keyword">if</span> (intr == <span class="literal">NULL</span>) &#123;                                         </span><br><span class="line">            intr = <span class="keyword">new</span> BpServiceManager(obj); <span class="comment">// 1                        </span></span><br><span class="line">        &#125;                                                           </span><br><span class="line">    &#125;                                                               </span><br><span class="line">    <span class="keyword">return</span> intr;                                                    </span><br><span class="line">&#125;                                                                   </span><br><span class="line">IServiceManager::IServiceManager() &#123; &#125;                                    </span><br><span class="line">IServiceManager::~IServiceManager() &#123; &#125;</span><br></pre></td></tr></table></figure><p>关键在于注释1，新建一个<code>BpServiceManager</code>，传入的参数<code>obj</code>的值为<code>BpBinder</code>。所以，<code>asInterface()</code>函数就是用<code>BpBinder</code>为参数创建<code>BpServiceManager</code>，从而推断出<code>interface_cast()</code>函数创建了<code>BpServiceManager</code>，再往上推断，<code>IServiceManager</code>的<code>defaultServiceManaher()</code>函数返回的就是<code>BpServiceManager</code>。<br><code>BpServiceManager</code>有什么作用？先来看看它的构造函数。frameworks/native/libs/binder/IServiceManager.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BpServiceManager</span> :</span> <span class="keyword">public</span> BpInterface&lt;IServiceManager&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">BpServiceManager</span><span class="params">(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; impl)</span></span></span><br><span class="line">        : BpInterface&lt;IServiceManager&gt;(impl)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>impl</code>的值就是<code>BpBinder</code>，<code>BpServiceManager</code>的构造函数调用了基类<code>BpInterface</code>的构造函数。frameworks/native/libs/binder/include/binder/IInterface.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> INTERFACE&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BpInterface</span> :</span> <span class="keyword">public</span> INTERFACE, <span class="keyword">public</span> BpRefBase</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>BpInterface</code>又继承了<code>BpRefBase</code>。<code>BpRefBase</code>的实现如下。frameworks/native/libs/binder/Binder.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BpRefBase::BpRefBase(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; o)</span><br><span class="line">    : mRemote(o.get()), mRefs(<span class="literal">NULL</span>), mState(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    extendObjectLifetime(OBJECT_LIFETIME_WEAK);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mRemote) &#123;</span><br><span class="line">        mRemote-&gt;incStrong(<span class="keyword">this</span>);           </span><br><span class="line">        mRefs = mRemote-&gt;createWeak(<span class="keyword">this</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mRemote</code>是一个<code>IBinder*</code>指针，它的最终指向为<code>BpBinder</code>，即<code>BpServiceManager</code>的<code>mRemote</code>指向了<code>BpBinder</code>。那么<code>BpServiceManager</code>的作用就是实现了<code>IServiceManager</code>，并通过<code>BpBinder</code>实现通信。</p><h2 id="4-3-IServiceManager关系图"><a href="#4-3-IServiceManager关系图" class="headerlink" title="4.3 IServiceManager关系图"></a>4.3 IServiceManager关系图</h2><img src="/2019/11/12/Binder原理-02：ServiceManager中的Binder机制/1573802832.jpg"><ol><li><code>BpBinder</code>和<code>BBinder</code>都和通信有关，它们都继承了<code>IBinder</code>。</li><li><code>BpServiceManager</code>派生自<code>IServiceManager</code>，它们都和业务有关。</li><li><code>BpRefBase</code>包含了<code>mRemote</code>，通过不断地派生，<code>BpServiceManager</code>也同样包含<code>mRemote</code>，它指向了<code>BpBidner</code>，通过<code>BpBinder</code>来实现通信。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前面说到&lt;code&gt;Binder&lt;/code&gt;机制分成三个部分：Java Binder、Native Binder、Kernel Binde
      
    
    </summary>
    
      <category term="Android进阶" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
      <category term="框架层" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/"/>
    
      <category term="Binder原理" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/Binder%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="Binder" scheme="https://tylerLiu.top/tags/Binder/"/>
    
  </entry>
  
  <entry>
    <title>Binder原理 01：基础知识（基于Android 9.0）</title>
    <link href="https://tylerLiu.top/2019/11/05/Binder%E5%8E%9F%E7%90%86-01%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://tylerLiu.top/2019/11/05/Binder原理-01：基础知识/</id>
    <published>2019-11-05T06:53:09.000Z</published>
    <updated>2019-11-12T07:37:34.750Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Linux和Android的IPC机制种类"><a href="#1-Linux和Android的IPC机制种类" class="headerlink" title="1. Linux和Android的IPC机制种类"></a>1. Linux和Android的IPC机制种类</h1><p>IPC全称Inter-Process Communication，进程间通信，指两个进程间进行数据交换的过程。Android和Linux各有各的IPC机制。</p><h2 id="1-1-Linux中IPC机制种类"><a href="#1-1-Linux中IPC机制种类" class="headerlink" title="1.1 Linux中IPC机制种类"></a>1.1 Linux中IPC机制种类</h2><ul><li>管道（pipe）</li><li>信号（sinal）</li><li>信号量（semophore）</li><li>消息队列（Message）</li><li>内存共享（Share  Memory）</li><li>套接字（Socket）</li><li>……等</li></ul><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>管道是Linux从Unix继承过来的，它是Unix早期的一个重要通信机制。管道的主要思想是，在内存中创建一个共享文件，从而使通信双方利用这个共享文件来传递信息。这个共享文件比较特殊，它不属于系统文件并且只存在于内存中。另外，管道采用的是半双工通信方式，数据只能在一个方向上流动。</p><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>信号是软件层次上对中断机制的一种模拟，是一种异步通信方式，进程不必通过任何操作来等待信号的到达。信号可以在用户空间进程和内核之间直接交互，内核可以利用信号来通知用户空间的进程发生了哪些系统事件。信号不适用于信息交换，比较适用于进程中断控制。</p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量是一个计数器，用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程访问该资源。主要作为进程间以及同一进程内不用线程之间的同步手段。</p><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>消息队列是消息的链表，具有特定的格式，存放在内存中并由消息队列标识符标识，并且允许一个或多个进程向它写入和读取消息。信息会复制两次，因此对于频繁或信息量大的通信不宜使用消息队列。</p><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>多个进程可以直接读写的一块内存空间，是针对其他通信机制运行效率较低而设计的。为了在多个进程间交换信息，内核专门留了一块内存区域，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这块内存而不需要进行数据的拷贝，从而提高效率。</p><h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><p>更为基础的进程间通信机制，与其他的方式不同的是，套接字可用于不同机器之间的进程间通信。</p><h2 id="1-2-Android中的IPC机制"><a href="#1-2-Android中的IPC机制" class="headerlink" title="1.2 Android中的IPC机制"></a>1.2 Android中的IPC机制</h2><p>Android系统是基于Linux内核的，在Linux内核的基础上，拓展了一些IPC的机制。Android系统除了支持套接字，还支持序列化、Messenger、AIDL、Bundle、文件共享、ContentProvider、Binder等。</p><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>指的是<code>Serializable</code>/<code>Parcelable</code>，<code>Serializable</code>是Java提供的一个序列化接口，是一个空接口，为对象提供标准的序列化和反序列化操作。<code>Parcelable</code>接口是Android中的序列化方式，用起来比较麻烦，但效率更高。</p><h3 id="Messenger"><a href="#Messenger" class="headerlink" title="Messenger"></a>Messenger</h3><p>在Android应用开发中使用率不高，可以在不同进程中传递Message对象，在Message中加入想要传递的数据就可以在进程间进行数据传递了。Messenger是轻量级的IPC方案，并对AIDL进行了封装。</p><h3 id="AIDL"><a href="#AIDL" class="headerlink" title="AIDL"></a>AIDL</h3><p>全称Android interface definition Language，即Android接口定义语言。Messenger是以串行的方式来处理客户端发来的信息，如果有大量的消息发送到服务端，服务端仍然是一个一个的处理，再响应客户端，显然是不合适的。另外，Messenger用来进行进程间的数据传递，但是不能满足跨进程的方法调用，这时就需要使用AIDL。</p><h3 id="Bundle"><a href="#Bundle" class="headerlink" title="Bundle"></a>Bundle</h3><p>实现了<code>Parcelable</code>接口，可以方便的在不同的进程间传输。Activity、Service、Receiver都在<code>Intent</code>中通过<code>Bundle</code>来传递数据。</p><h3 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h3><p>两个进程通过读写一个文件来进行数据共享，共享的文件可以是文本、XML、Json。文件共享适用于对数据同步要求不高的进程间通信。</p><h3 id="ContentProvier"><a href="#ContentProvier" class="headerlink" title="ContentProvier"></a>ContentProvier</h3><p><code>ContentProvier</code>为存储和获取数据提供了统一的接口，它可以在不同的应用程序间共享数据，本身就适合进程间通信。<code>ContentProvier</code>底层实现也是<code>Binder</code>，但是使用要比AIDL容易。系统很多操作都采用了<code>ContentProvider</code>，如通讯录、音频等，这些操作本身就是跨进程进行通信。</p><h1 id="2-Linux和Binder的IPC通信原理"><a href="#2-Linux和Binder的IPC通信原理" class="headerlink" title="2. Linux和Binder的IPC通信原理"></a>2. Linux和Binder的IPC通信原理</h1><img src="/2019/11/05/Binder原理-01：基础知识/1573103888.jpg"><p>先看看几个基本概念：</p><h3 id="内核空间（Kernel-space）和用户空间（User-space）"><a href="#内核空间（Kernel-space）和用户空间（User-space）" class="headerlink" title="内核空间（Kernel space）和用户空间（User space）"></a>内核空间（Kernel space）和用户空间（User space）</h3><p>为了确保用户进程不能直接操作内核，保证内核的安全，操作系统从逻辑上将虚拟空间划分为用户空间和内核空间。Linux操作系统将最高的1GB字节供内核使用，称为内核空间，较低的3GB字节供进程使用，称为用户空间。<br>内核空间是Linux内核运行的空间，用户空间是用户程序的运行空间。为了安全，它们是隔离的，即使用户的程序崩溃了，内核也不受影响。内核空间的数据是可以进程间共享的，而用户空间则不可以。</p><h3 id="进程隔离"><a href="#进程隔离" class="headerlink" title="进程隔离"></a>进程隔离</h3><p>一个进程不能直接操作或访问另一个进程。</p><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>用户空间需要访问内核空间，就需要借助系统调用来实现。系统调用是用户空间访问内核空间的唯一方式，保证了所有的资源访问都是在内核的控制下进行的，避免用户程序对系统资源的越权访问，提升系统安全性和稳定性。<br>进程A和进程B的用户空间可以通过如下系统函数与内核空间进行交互。</p><ul><li>copy_from_user：将用户空间数据拷贝到内核空间</li><li>copy_to_user：将内核空间的数据拷贝到用户空间</li></ul><h3 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h3><p>由于应用程序不能直接操作设备硬件地址，所以操作系统提供了一种机制：内存映射，把设备地址映射到进程虚拟内存区。</p><img src="/2019/11/05/Binder原理-01：基础知识/1573116084.jpg"><p>由于新建虚拟内存区域，磁盘文件和虚拟内存区域就可以直接映射，少了一次拷贝。<br>内存映射全称Memory Map，在Linux中通过系统调用函数<code>mmap()</code>来实现内存映射。将用户空间的一块内存区域映射到内核空间。映射关系建立之后，用户对这块内存区域的修改可以直接反映到内核空间，反之也是。内u才能映射能减少数据拷贝的次数，实现用户空间和内核空间的高效互动。</p><h2 id="2-1-Linux的IPC通信原理"><a href="#2-1-Linux的IPC通信原理" class="headerlink" title="2.1 Linux的IPC通信原理"></a>2.1 Linux的IPC通信原理</h2><img src="/2019/11/05/Binder原理-01：基础知识/1573196083.jpg"><p>内核程序在内核空间分配内存并开辟一块内核缓存区，发送进程通过<code>copy_from_user()</code>函数将数据拷贝到内核空间的缓存区中。同样的，接收进程在接收数据时在自己的用户空间开辟一块内存缓存区，然后内核程序调用<code>copy_to_user()</code>函数将数据从内核缓存区拷贝到接收进程。这样数据发送进程和数据接收进程完成一次数据传输，即一次进程间通信。<br>Linux的IPC通信原理有两个问题：</p><ol><li>一次数据传递需要经历：用户空间 -&gt; 内核缓存区 -&gt; 用户空间，需要2次数据拷贝，效率不高。</li><li>接收数据的缓存区由数据接收进程提供，但是接收进程并不知道需要多大的空间来存放将要传递过来的数据，因此只能开辟尽可能大的内存空间或者先调用API接收消息头来获取消息体的大小，这样就会浪费空间或时间。</li></ol><h2 id="2-2-Binder通信原理"><a href="#2-2-Binder通信原理" class="headerlink" title="2.2 Binder通信原理"></a>2.2 Binder通信原理</h2><p><code>Binder</code>是基于开源的OpenBinder实现的，OpenBinder最早并不是Google开发的，而是BeInc开发的，接着由Palm, Inc.负责开发。后来OpenBinder作者加入了Google，并负责Android平台的开发，也就将<code>Binder</code>带到了Android。<br><code>Binder</code>是基于内存映射来实现的，内存映射通常是用在物理介质的文件系统上的，<code>Binder</code>没有物理介质，它使用内存映射是为了跨进程传递数据。</p><img src="/2019/11/05/Binder原理-01：基础知识/1573204355.jpg"><p><code>Binder</code>通信步骤：</p><ol><li><code>Binder</code>驱动在内核空间创建一个数据接收缓存区。</li><li>在内核空间开辟一块内存缓存区，建立内存缓存区和数据接收缓存区的映射关系，以及数据接收缓存区和接收进程用户空间地址的映射关系。</li><li>发送进程通过<code>copy_to_user()</code>函数将数据拷贝到内核中的内核缓存区，由于内核缓存区和接收的用户空间存在内存映射，因此就相当于把数据发送到了接收进程的用户空间，这样就完成了一次进程间通信。</li></ol><p>整个过程只使用一次拷贝，不会因为不知道数据的大小而浪费空间和时间，效率更高。</p><h1 id="3-为什么要使用Binder"><a href="#3-为什么要使用Binder" class="headerlink" title="3. 为什么要使用Binder"></a>3. 为什么要使用Binder</h1><p>Android是基于Linux内核的，Linux提供了很多IPC机制，而Android自己设计了<code>Binder</code>来进行通信，主要有以下几点原因。</p><h3 id="性能方面"><a href="#性能方面" class="headerlink" title="性能方面"></a>性能方面</h3><p>性能方面的主要影响因素是拷贝次数，管道、消息队列、Socket的拷贝次数都是两次，性能不是很好，共享内存不需要拷贝，性能最好，<code>Binder</code>的拷贝次数为一次，性能仅次于内存拷贝。</p><h3 id="稳定性方面"><a href="#稳定性方面" class="headerlink" title="稳定性方面"></a>稳定性方面</h3><p><code>Binder</code>是基于C/S架构的，这个架构通常采用两层结构，技术上已经很成熟。共享内存没有分层，难以控制，并发同步访问临界资源时，可能会产生死锁。从稳定性角度来看，<code>Binder</code>优于共享内存。</p><h3 id="安全方面"><a href="#安全方面" class="headerlink" title="安全方面"></a>安全方面</h3><p>Android是一个开源系统，并且拥有开放的平台，因此安全性对于Android平台很重要。<br>传统的IPC接收方法无法获得对方可靠的进程用户ID/进程ID（UID/PID），无法鉴别对方的身份。<br>Android为每个安装好的APP分配了自己的UID，通过进程的UID来鉴别进程身份。另外，Android系统中的Server端会判断UID/PID是否满足访问权限，而对外只暴露Client端，加强了系统的安全性。</p><h3 id="语言方面"><a href="#语言方面" class="headerlink" title="语言方面"></a>语言方面</h3><p>Linux是基于C语言的，C语言是面向过程的，Android应用层和Java Framework是基于Java语言的，是面向对象的。<code>Binder</code>本身符合面向对象的思想，因此作为Android的通信机制更加合适。</p><blockquote><p>从以上四个方面来看，Linux提供的大部分IPC机制无法和<code>Binder</code>相比较，而共享内存只在性能方面优于<code>Binder</code>，这就是为什么Android使用<code>Binder</code>进行进程间通信。当然系统中并不是所有的进程间通信都使用<code>Bidner</code>，也要结合不同场景，如Zygote进程与AMS通信使用的是Socket，Kill Process使用的是信号。</p></blockquote><h1 id="4-为什么要学习Binder？"><a href="#4-为什么要学习Binder？" class="headerlink" title="4. 为什么要学习Binder？"></a>4. 为什么要学习Binder？</h1><p><code>Binder</code>机制在Android中很重要，许多需要掌握的原理都和<code>Binder</code>有关：</p><ul><li>系统中各个进程是如何通信的？</li><li>Android系统启动过程</li><li>AMS、PMS的原理</li><li>四大组件的原理，比如Activity是如何启动的？</li><li>插件化原理</li><li>系统服务的Client端和Server端如何进行通信？（比如<code>MediaPlayer</code>和<code>MediaPlayerService</code>）</li><li>……</li></ul><p>上面只是列出一小部分，简单来说，比如在系统启动过程时，<code>SystemServer</code>进程启动过程后会创建<code>Binder</code>线程池，目的是通过<code>Binder</code>，使得在<code>SystemServer</code>进程中的服务可以和其他进程进行通信。再比如常说的AMS、PMS都是基于<code>Binder</code>来实现的，拿PMS来说，PMS运行在<code>SystemServer</code>进程，如果它想要和<code>DefaultContainerService</code>通信（是用于检查和复制可移动文件的系统服务），就需要通过<code>Binder</code>，因为<code>DefaultContainerService</code>运行在<code>com.android.defcontainer</code>进程。<br>还有一个比较常见的C/S架构间通信的问题，Client端的<code>MediaPlayer</code>和Server端的<code>MediaPlayerService</code>不是运行在一个进程中的，同样需要<code>Binder</code>来实现通信。<br>可以说<code>Binder</code>机制是掌握系统底层原理的基石。根据Android系统的分层，<code>Binder</code>机制主要分为以下几个部分。</p><img src="/2019/11/05/Binder原理-01：基础知识/1573543084.jpg"><p>根据Android系统的分层，将<code>Binder</code>机制分为Java Binder、Native Binder和Kernel Binder，后面会主要讲解Java Binder和Native Binder。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Linux和Android的IPC机制种类&quot;&gt;&lt;a href=&quot;#1-Linux和Android的IPC机制种类&quot; class=&quot;headerlink&quot; title=&quot;1. Linux和Android的IPC机制种类&quot;&gt;&lt;/a&gt;1. Linux和Android
      
    
    </summary>
    
      <category term="Android进阶" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
      <category term="框架层" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/"/>
    
      <category term="Binder原理" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/Binder%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="Binder" scheme="https://tylerLiu.top/tags/Binder/"/>
    
  </entry>
  
  <entry>
    <title>Android解析WindowManagerService 03：Window的删除过程（基于Android 8.0）</title>
    <link href="https://tylerLiu.top/2019/11/04/Android%E8%A7%A3%E6%9E%90WindowManagerService-03%EF%BC%9AWindow%E7%9A%84%E5%88%A0%E9%99%A4%E8%BF%87%E7%A8%8B/"/>
    <id>https://tylerLiu.top/2019/11/04/Android解析WindowManagerService-03：Window的删除过程/</id>
    <published>2019-11-04T02:14:59.000Z</published>
    <updated>2019-11-05T06:49:02.396Z</updated>
    
    <content type="html"><![CDATA[<p>和<a href="https://tylerliu.top/2019/10/29/Android解析WindowManagerService-02%EF%BC%9AWMS的重要成员和Window的添加过程/">Android解析WindowManagerService 02：WMS的重要成员和Window的添加过程（基于Android 8.0）</a>中Window的创建和更新过程类似，要删除Window需要先调用<code>WindowManagerImpl</code>的<code>removeView()</code>方法，<code>removeView()</code>方法中调用<code>WindowManagerGlobal</code>的<code>removeView()</code>方法。frameworks/base/core/java/android/view/WindowManagerGlobal.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeView</span><span class="params">(View view, <span class="keyword">boolean</span> immediate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"view must not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = findViewLocked(view, <span class="keyword">true</span>); <span class="comment">// 1</span></span><br><span class="line">        View curView = mRoots.get(index).getView();</span><br><span class="line">        removeViewLocked(index, immediate); <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">if</span> (curView == view) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Calling with view "</span> + view</span><br><span class="line">                + <span class="string">" but the ViewAncestor is attached to "</span> + curView);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，找到要删除的View在<code>view</code>列表中的索引。注释2，调用<code>removeViewLocked()</code>将该索引传入。frameworks/base/core/java/android/view/WindowManagerGlobal.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeViewLocked</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">boolean</span> immediate)</span> </span>&#123;</span><br><span class="line">    ViewRootImpl root = mRoots.get(index); <span class="comment">// 1</span></span><br><span class="line">    View view = root.getView();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">        InputMethodManager imm = InputMethodManager.getInstance(); <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">if</span> (imm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            imm.windowDismissed(mViews.get(index).getWindowToken()); <span class="comment">// 3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> deferred = root.die(immediate); <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">        view.assignParent(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (deferred) &#123;</span><br><span class="line">            mDyingViews.add(view);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，根据传入的索引在<code>ViewRootImpl</code>列表中获得需要删除的Window的<code>ViewRootImpl</code>。<br>注释2，获取<code>InputMethodManager</code>实例，如果<code>InputMethodManager</code>实例不为空，则在注释3调用<code>InputMethodManager</code>的<code>windowDismissed()</code>来结束需要删除的Window的输入法相关的逻辑。<br>注释4，调用<code>ViewRootImpl</code>的<code>die()</code>方法。frameworks/base/core/java/android/view/ViewRootImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">die</span><span class="params">(<span class="keyword">boolean</span> immediate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Make sure we do execute immediately if we are in the middle of a traversal or the damage</span></span><br><span class="line">    <span class="comment">// done by dispatchDetachedFromWindow will cause havoc on return.</span></span><br><span class="line">    <span class="comment">// die()方法需要立即被执行并且此时ViewRootImpl不在执行performTraversals()方法</span></span><br><span class="line">    <span class="keyword">if</span> (immediate &amp;&amp; !mIsInTraversal) &#123; <span class="number">1</span><span class="comment">// </span></span><br><span class="line">        doDie(); <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mIsDrawing) &#123;</span><br><span class="line">        destroyHardwareRenderer();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    mHandler.sendEmptyMessage(MSG_DIE);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1的<code>immediate</code>如果为<code>true</code>（需要立即执行），并且<code>mIsTraversal</code>为<code>false</code>则执行注释2的代码，<code>mIsTraverrsal</code>在执行<code>ViewRootImpl</code>的<code>performTraversals()</code>方法时被设置为<code>true</code>，在<code>performTraversals()</code>方法执行结束时被设置为<code>false</code>，因此注释1可以理解为<code>die()</code>方法需要立即执行并且此时<code>ViewRootImpl</code>不在执行<code>performTraversals()</code>方法。<br>注释2，<code>doDie()</code>。frameworks/base/core/java/android/view/ViewRootImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doDie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查执行方法线程的正确性</span></span><br><span class="line">    checkThread(); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> (LOCAL_LOGV) Log.v(mTag, <span class="string">"DIE in "</span> + <span class="keyword">this</span> + <span class="string">" of "</span> + mSurface);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mRemoved) &#123; <span class="comment">// 2</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mRemoved = <span class="keyword">true</span>; <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">if</span> (mAdded) &#123; <span class="comment">// 4</span></span><br><span class="line">            dispatchDetachedFromWindow(); <span class="comment">// 5</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mAdded &amp;&amp; !mFirst) &#123; <span class="comment">// 6</span></span><br><span class="line">            destroyHardwareRenderer();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mView != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> viewVisibility = mView.getVisibility();</span><br><span class="line">                <span class="keyword">boolean</span> viewVisibilityChanged = mViewVisibility != viewVisibility;</span><br><span class="line">                <span class="keyword">if</span> (mWindowAttributesChanged || viewVisibilityChanged) &#123;</span><br><span class="line">                    <span class="comment">// If layout params have been changed, first give them</span></span><br><span class="line">                    <span class="comment">// to the window manager to make sure it has the correct</span></span><br><span class="line">                    <span class="comment">// animation info.</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((relayoutWindow(mWindowAttributes, viewVisibility, <span class="keyword">false</span>)</span><br><span class="line">                                &amp; WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != <span class="number">0</span>) &#123;</span><br><span class="line">                            mWindowSession.finishDrawing(mWindow);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                mSurface.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mAdded = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    WindowManagerGlobal.getInstance().doRemoveView(<span class="keyword">this</span>); <span class="comment">// 7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，检查执行<code>duDie()</code>方法的线程的正确性，<code>checkThread()</code>内部会判断执行<code>duDie()</code>方法线程是否是创建需要删除的Window的原始线程，如果不是，就抛出异常，因为只有创建需要删除的Window的原始线程才能操作该Window。<br>注释2、3，用于防止<code>doDie()</code>方法被重复调用。<br>注释4，需要删除的Window有子<code>View</code>，就会调用<code>dispatchDetachedFromWindow()</code>方法来销毁<code>View</code>。<br>注释6，如果需要删除的Window有子<code>View</code>并且不是第一次被添加，就会执行后面的代码。<br>注释7，<code>WindowManagerGlobal</code>的<code>doRemoveView()</code>方法。frameworks/base/core/java/android/view/WindowManagerGlobal.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doRemoveView</span><span class="params">(ViewRootImpl root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> index = mRoots.indexOf(root); <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            mRoots.remove(index);</span><br><span class="line">            mParams.remove(index);</span><br><span class="line">            <span class="keyword">final</span> View view = mViews.remove(index);</span><br><span class="line">            mDyingViews.remove(view);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ThreadedRenderer.sTrimForeground &amp;&amp; ThreadedRenderer.isAvailable()) &#123;</span><br><span class="line">        doTrimForeground();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>WindowManagerGlobal</code>中维护了和<code>Window</code>操作相关的三个列表，<code>doRemoveView()</code>方法会从这三个列表中清除需要删除的Window对应的元素。<br>注释1，找到需要删除的Window对应的<code>ViewRootImpl</code>在<code>ViewRootImpl</code>列表中的索引，接着根据这个索引从<code>ViewRootImpl</code>列表、布局参数列表和<code>View</code>列表中删除与需要删除的Window对应的元素。<br>再回到<code>doDie()</code>方法，注释5，<code>dispatchDetachedFromWindow()</code>。<br>frameworks/base/core/java/android/view/ViewRootImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchDetachedFromWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mWindowSession.remove(mWindow);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用了<code>IWindowSession</code>的<code>remove()</code>方法，<code>IWindowSession</code>在Server端的实现为<code>Session</code>，<code>Session</code>的<code>remove()</code>方法如下：<br>frameworks/base/services/core/java/com/android/server/wm/Session.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(IWindow window)</span> </span>&#123;</span><br><span class="line">    mService.removeWindow(<span class="keyword">this</span>, window);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来查看WMS的<code>removeWindow()</code>。frameworks/base/services/core/java/com/android/server/wm/WindowManagerService .java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeWindow</span><span class="params">(Session session, IWindow client)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(mWindowMap) &#123;</span><br><span class="line">        WindowState win = windowForClientLocked(session, client, <span class="keyword">false</span>); <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">if</span> (win == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        win.removeIfPossible(); <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，用于获取<code>Window</code>对应的<code>WindowState</code>，<code>WindowState</code>用于保存窗口的信息，在WMS中它用来描述一个窗口。<br>注释2，调用<code>WindowState</code>的<code>removeIfPossible()</code>方法。frameworks/base/services/core/java/com/android/server/wm/WindowState.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeIfPossible</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.removeIfPossible();</span><br><span class="line">    removeIfPossible(<span class="keyword">false</span> <span class="comment">/*keepVisibleDeadWindow*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeIfPossible</span><span class="params">(<span class="keyword">boolean</span> keepVisibleDeadWindow)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 条件判断过滤，满足其中一个条件就会return，推迟删除操作</span></span><br><span class="line">    ......</span><br><span class="line">    removeImmediately();</span><br><span class="line">    <span class="comment">// Removing a visible window will effect the computed orientation</span></span><br><span class="line">    <span class="comment">// So just update orientation if needed.</span></span><br><span class="line">    <span class="keyword">if</span> (wasVisible &amp;&amp; mService.updateOrientationFromAppTokensLocked(<span class="keyword">false</span>, displayId)) &#123;</span><br><span class="line">        mService.mH.obtainMessage(SEND_NEW_CONFIGURATION, displayId).sendToTarget();</span><br><span class="line">    &#125;</span><br><span class="line">    mService.updateFocusedWindowLocked(UPDATE_FOCUS_NORMAL, <span class="keyword">true</span> <span class="comment">/*updateInputWindows*/</span>);</span><br><span class="line">    Binder.restoreCallingIdentity(origId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>removeIfPossible()</code>不会立即执行删除操作，而是进行了多个条件过滤，只要其中一个条件，就会<code>return</code>，推迟删除操作。<br>条件判断都通过的话，就会调用<code>removeImmediately()</code>。frameworks/base/services/core/java/com/android/server/wm/WindowState.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeImmediately</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.removeImmediately();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mRemoved) &#123; <span class="comment">// 1</span></span><br><span class="line">        <span class="comment">// Nothing to do.</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mRemoved = <span class="keyword">true</span>; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    mPolicy.removeWindowLw(<span class="keyword">this</span>); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    disposeInputChannel();</span><br><span class="line"></span><br><span class="line">    mWinAnimator.destroyDeferredSurfaceLocked();</span><br><span class="line">    mWinAnimator.destroySurfaceLocked();</span><br><span class="line">    mSession.windowRemovedLocked(); <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mClient.asBinder().unlinkToDeath(mDeathRecipient, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mService.postWindowRemoveCleanupLocked(<span class="keyword">this</span>); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，<code>mRemoved</code>为<code>true</code>意味着正在执行删除Window操作，注释1到注释2之间的代码用于防止重复删除操作。<br>注释3，如果当前要删除的Window是<code>StatusBar</code>或者<code>NavigationBar</code>就会将这个Window从对应的控制器中删除。<br>注释4，将需要删除的Window对应的<code>Session</code>从WMS的<code>ArraySet&lt;Session&gt; mSession</code>中删除并清除<code>Session</code>对应的<code>SurfaceSession</code>资源（<code>SurfaceSession</code>是<code>SurfaceFlinger</code>的一个连接，通过这个连接可以创建一个或多个<code>Surface</code>并渲染到屏幕上）。<br>注释5，调用WMS的<code>postWindowRemoveCleanupLocked()</code>方法用于对需要删除的Window进行一些集中的清理工作。<br>删除的逻辑总结如下：</p><ol><li>检查删除线程的正确性，如果不正确则抛出异常；</li><li>从<code>ViewRootImpl</code>列表、布局参数列表和<code>View</code>列表中删除与需要删除的Window对应的元素；</li><li>判断是否可以直接执行删除操作，如果不能，就推迟删除操作；</li><li>执行删除操作，清理和释放与需要删除的Window相关的资源。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;和&lt;a href=&quot;https://tylerliu.top/2019/10/29/Android解析WindowManagerService-02%EF%BC%9AWMS的重要成员和Window的添加过程/&quot;&gt;Android解析WindowManagerService 0
      
    
    </summary>
    
      <category term="Android进阶" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
      <category term="框架层" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/"/>
    
      <category term="解析WindowManagerService" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/%E8%A7%A3%E6%9E%90WindowManagerService/"/>
    
    
      <category term="WindowManagerService" scheme="https://tylerLiu.top/tags/WindowManagerService/"/>
    
  </entry>
  
  <entry>
    <title>Android解析WindowManagerService 02：WMS的重要成员和Window的添加过程（基于Android 8.0）</title>
    <link href="https://tylerLiu.top/2019/10/29/Android%E8%A7%A3%E6%9E%90WindowManagerService-02%EF%BC%9AWMS%E7%9A%84%E9%87%8D%E8%A6%81%E6%88%90%E5%91%98%E5%92%8CWindow%E7%9A%84%E6%B7%BB%E5%8A%A0%E8%BF%87%E7%A8%8B/"/>
    <id>https://tylerLiu.top/2019/10/29/Android解析WindowManagerService-02：WMS的重要成员和Window的添加过程/</id>
    <published>2019-10-29T05:35:02.000Z</published>
    <updated>2019-11-04T02:09:21.346Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>WMS在创建之后，它的重要成员有哪些？Window添加过程的WMS部分做了什么？</p><h1 id="1-WMS的重要成员"><a href="#1-WMS的重要成员" class="headerlink" title="1. WMS的重要成员"></a>1. WMS的重要成员</h1><p>即WMS的重要成员变量，如下：frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> WindowManagerPolicy mPolicy;</span><br><span class="line"><span class="keyword">final</span> IActivityManager mActivityManager;</span><br><span class="line"><span class="keyword">final</span> ActivityManagerInternal mAmInternal;</span><br><span class="line"><span class="keyword">final</span> AppOpsManager mAppOps;</span><br><span class="line"><span class="keyword">final</span> DisplaySettings mDisplaySettings;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">final</span> ArraySet&lt;Session&gt; mSessions = <span class="keyword">new</span> ArraySet&lt;&gt;();</span><br><span class="line"><span class="keyword">final</span> WindowHashMap mWindowMap = <span class="keyword">new</span> WindowHashMap();</span><br><span class="line"><span class="keyword">final</span> ArrayList&lt;AppWindowToken&gt; mFinishedStarting = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">final</span> ArrayList&lt;AppWindowToken&gt; mFinishedEarlyAnim = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">final</span> ArrayList&lt;AppWindowToken&gt; mWindowReplacementTimeouts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">final</span> ArrayList&lt;WindowState&gt; mResizingWindows = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">final</span> ArrayList&lt;WindowState&gt; mPendingRemove = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">WindowState[] mPendingRemoveTmp = <span class="keyword">new</span> WindowState[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">final</span> ArrayList&lt;WindowState&gt; mDestroySurface = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">final</span> ArrayList&lt;WindowState&gt; mDestroyPreservedSurface = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">......</span><br><span class="line"><span class="keyword">final</span> H mH = <span class="keyword">new</span> H();</span><br><span class="line">......</span><br><span class="line"><span class="keyword">final</span> WindowAnimator mAnimator;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">final</span> InputManagerService mInputManager</span><br></pre></td></tr></table></figure><ul><li><p><code>WindowManagerPolicy mPolicy</code>：<code>WindowManagerPolicy</code>是窗口管理策略的接口类，用来定义一个窗口策略所要遵循的通用规范，并提供了<code>WindowManager</code>所有的特定的UI行为。其具体实现类为<code>PhoneWindowManager</code>，这个实现类在WMS创建时被创建。WMP允许定制窗口层级和特殊窗口类型以及关键的调度和布局。</p></li><li><p><code>ArraySet mSessions</code>：在<a href="https://tylerliu.top/2019/10/24/Android解析WindowManager-03%EF%BC%9AWindow的添加过程/">Android解析WindowManager 03：Window的添加过程</a>这篇文章中提到过<code>Session</code>，它主要用于进程间通信，其他的应用程序进程想要和WMS进程进行通信就需要经过<code>Session</code>，并且每个应用程序进程都会对应一个<code>Session</code>，WMS保存这些<code>Session</code>用来记录所有向WMS提出窗口管理服务的客户端。</p></li><li><p><code>WindowHashMap mWindowMap</code>：<code>WindowHashMap</code>继承了<code>HashMap</code>，它限制了<code>HashMap</code>的<code>key</code>值的类型为<code>IBinder</code>，<code>value</code>值的类型为<code>WindowState</code>。<code>WindowState</code>用户保存窗口的信息，在WMS中，它用来描述一个窗口。综上，<code>mWindowMap</code>就是用来保存WMS中各种窗口的集合。</p></li><li><p><code>ArrayList mFinishedStarting</code>：<code>AppWindowToken</code>的集合，<code>AppWindowToken</code>是<code>WindowToken</code>的子类。要想理解<code>mFinishedStarting</code>的意义，需要先理解<code>WindowToken</code>。<code>WindowToken</code>主要有两个作用：</p><ul><li><p>可以理解为窗口令牌，当应用程序想要向WMS申请新创建一个窗口，则需要向WMS出示有效的的<code>WindowToken</code>。<code>AppWindowToken</code>作为<code>WindowToken</code>的子类，主要用来描述应用程序的<code>WindowToken</code>结构。<br>应用程序中每个Activity都对应一个<code>AppWindowToken</code>。</p></li><li><p><code>WindowToken</code>会将相同组件（比如Activity）的窗口（<code>WindowState</code>）集合在一起，方便管理。</p><p><code>mFinishedStarting</code>就是用于存储已经完成启动的应用程序窗口（比如Activity）的<code>AppWindowToken</code>的列表。<br>除了<code>mFinishedStarting</code>，还有类似的<code>mFinishedEarlyAnim</code>和<code>mWindowReplacementTimeouts</code>，其中<code>mFinishedEarlyAnim</code>用于存储已经完成绘制并且不需要任何已保存<code>surface</code>的应用程序窗口的<code>AppWindowToken</code>。<code>mWindowReplacementTimeouts</code>存储了等待更换的应用程序窗口的<code>AppWindowToken</code>，如果更换不及时，旧窗口就需要被处理。</p></li></ul></li><li><p><code>ArrayList mResizingWindows</code>：类型为<code>WindowState</code>。用来存储正在调整大小的窗口的列表。与<code>mResizingWindows</code>类似的还有<code>mPendingRemove</code>、<code>mDestoryPreservedSurface</code>等等。其中<code>mPendingRemove</code>是在内存耗尽时设置的，里面存着需要强制删除的窗口。<code>mDestorySurface</code>里面存有需要被<code>Destory</code>的<code>Surface</code>。<code>mDestoryPreservedSurface</code>里面存着窗口需要保存的等待销毁的<code>Surface</code>，因为当窗口经历<code>Surface</code>变化时，窗口需要一直保持旧<code>Surface</code>，直到新<code>Surface</code>的第一帧绘制完成。</p></li><li><p><code>WindowAnimator mAnimator</code>：用于管理窗口的动画以及特效动画。</p></li><li><p><code>H mH</code>：系统的<code>Handler</code>类，用于将任务加入到主线程的消息队列中，这样代码逻辑就会在主线程中执行。</p></li><li><p><code>InputManagerService mInputManager</code>：输入系统管理者。IMS会对触摸事件进行处理，它会寻找一个最合适的窗口来处理触摸反馈信息，WMS是窗口管理者，因此WMS就是输入系统的中转站，WMS包含IMS的引用。</p></li></ul><h1 id="2-Window的添加过程（WMS部分）"><a href="#2-Window的添加过程（WMS部分）" class="headerlink" title="2. Window的添加过程（WMS部分）"></a>2. Window的添加过程（WMS部分）</h1><p>Window的操作分为两大部分，WindowManager处理部分和WMS处理部分。</p><p>在<a href="https://tylerliu.top/2019/10/24/Android解析WindowManager-03%EF%BC%9AWindow的添加过程/">Android解析WindowManager 03：Window的添加过程</a>中，讲解了<code>Window</code>的添加过程的<code>WindowManager</code>处理部分，这里再来看看WMS部分。<br>无论是系统窗口还是Activity，它们的<code>Window</code>的添加过程都会调用WMS的<code>addWindow()</code>方法。frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java这段代码分成三个部分来看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addWindow</span><span class="params">(Session session, IWindow client, <span class="keyword">int</span> seq,</span></span></span><br><span class="line"><span class="function"><span class="params">        WindowManager.LayoutParams attrs, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> displayId,</span></span></span><br><span class="line"><span class="function"><span class="params">        Rect outContentInsets, Rect outStableInsets, Rect outOutsets,</span></span></span><br><span class="line"><span class="function"><span class="params">        InputChannel outInputChannel)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] appOp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> res = mPolicy.checkAddPermission(attrs, appOp); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> (res != WindowManagerGlobal.ADD_OKAY) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">synchronized</span>(mWindowMap) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mDisplayReady) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Display has not been initialialized"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> DisplayContent displayContent = mRoot.getDisplayContentOrCreate(displayId); <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">if</span> (displayContent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">return</span> WindowManagerGlobal.ADD_INVALID_DISPLAY;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (type &gt;= FIRST_SUB_WINDOW &amp;&amp; type &lt;= LAST_SUB_WINDOW) &#123; <span class="comment">// 3</span></span><br><span class="line">            parentWindow = windowForClientLocked(<span class="keyword">null</span>, attrs.token, <span class="keyword">false</span>); <span class="comment">// 4</span></span><br><span class="line">            <span class="keyword">if</span> (parentWindow == <span class="keyword">null</span>) &#123;</span><br><span class="line">               ......</span><br><span class="line">                <span class="keyword">return</span> WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (parentWindow.mAttrs.type &gt;= FIRST_SUB_WINDOW &amp;&amp; parentWindow.mAttrs.type &lt;= LAST_SUB_WINDOW) &#123;</span><br><span class="line">                ......</span><br><span class="line">                <span class="keyword">return</span> WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WMS的<code>addWindow()</code>方法返回的是各种状态值，比如，添加<code>Window</code>成功，无效的<code>display</code>等，这些状态被定义在<code>WindowManagerGlobal</code>中。<br>注释1，根据<code>Window</code>的属性，调用WMP的<code>checkAddPermission()</code>方法来检查权限，具体的实现在<code>PhoneWindowManager</code>的<code>checkAddPermission()</code>中，如果没有权限则不会执行后面的代码。<br>注释2，通过<code>display</code>来获得窗口要添加到哪个<code>DisplayContent</code>上，如果没没有找到<code>DisplayContent</code>，则返回<code>WindowManagerGlobal.ADD_INVALID_DISPLAY</code>状态，其中<code>DisplayContent</code>是用来描述一块屏幕的。<br>注释3，<code>type</code>表示窗口的类型，其数值介于<code>FIRST_SUB_WINDOW</code>和<code>LAST_SUB_WINDOW</code>（1000-1999），该数值定义在<code>WindowManager</code>中，说明这个窗口是一个子窗口。<br>注释4，<code>attrs.token</code>是<code>IBinder</code>类型的对象，<code>windowForClientLocked()</code>方法内部会根据<code>attrs.token</code>作为key值，从<code>mWindowMap</code>中得到该子窗口的父窗口。接着对父窗口进行判断，如果父窗口为空或者<code>type</code>的取值范围不正确，就返回错误的状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">AppWindowToken atoken = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> hasParent = parentWindow != <span class="keyword">null</span>;</span><br><span class="line">WindowToken token = displayContent.getWindowToken(hasParent ? parentWindow.mAttrs.token : attrs.token); <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> rootType = hasParent ? parentWindow.mAttrs.type : type; <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">boolean</span> addToastWindowRequiresToken = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (token == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (rootType &gt;= FIRST_APPLICATION_WINDOW &amp;&amp; rootType &lt;= LAST_APPLICATION_WINDOW) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> WindowManagerGlobal.ADD_BAD_APP_TOKEN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rootType == TYPE_INPUT_METHOD) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> WindowManagerGlobal.ADD_BAD_APP_TOKEN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rootType == TYPE_VOICE_INTERACTION) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> WindowManagerGlobal.ADD_BAD_APP_TOKEN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rootType == TYPE_WALLPAPER) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> WindowManagerGlobal.ADD_BAD_APP_TOKEN;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (type == TYPE_TOAST) &#123;</span><br><span class="line">        <span class="comment">// Apps targeting SDK above N MR1 cannot arbitrary add toast windows.</span></span><br><span class="line">        <span class="keyword">if</span> (doesAddToastWindowRequireToken(attrs.packageName, callingUid, parentWindow)) &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">return</span> WindowManagerGlobal.ADD_BAD_APP_TOKEN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> IBinder binder = attrs.token != <span class="keyword">null</span> ? attrs.token : client.asBinder();</span><br><span class="line">    token = <span class="keyword">new</span> WindowToken(<span class="keyword">this</span>, binder, type, <span class="keyword">false</span>, displayContent, session.mCanAddInternalSystemWindow); <span class="comment">// 3</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rootType &gt;= FIRST_APPLICATION_WINDOW &amp;&amp; rootType &lt;= LAST_APPLICATION_WINDOW) &#123; <span class="comment">// 4</span></span><br><span class="line">    atoken = token.asAppWindowToken(); <span class="comment">// 5</span></span><br><span class="line">    <span class="keyword">if</span> (atoken == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> WindowManagerGlobal.ADD_NOT_APP_TOKEN;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (atoken.removed) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> WindowManagerGlobal.ADD_APP_EXITING;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rootType == TYPE_INPUT_METHOD) &#123;</span><br><span class="line">    <span class="keyword">if</span> (token.windowType != TYPE_INPUT_METHOD) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> WindowManagerGlobal.ADD_BAD_APP_TOKEN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>注释1，通过<code>displayContent</code>的<code>getWindowToken()</code>得到<code>WindowToken</code>。<br>注释2，如果有父窗口就将父窗口的<code>type</code>值赋值给<code>rootType</code>，如果没有就将当前窗口的<code>type</code>值赋值给<code>rootType</code>。如果<code>WindowToken</code>为空，则根据<code>rootType</code>或者<code>type</code>的值进行区分判断，如果<code>rootType</code>值等于<code>TYPE_INPUT_METHOD</code>、<code>TYPE_WALLPAPER</code>等值时，则返回状态值<code>WindowManagerGlobal.ADD_BAD_APP_TOKEN</code>，说明<code>rootType</code>值等于<code>TYPE_INPUT_METHOD</code>、<code>TYPE_WALLPAPER</code>等值时不允许<code>WindowToken</code>为空。<br>注释3，隐式创建<code>WindowToken</code>，说明当添加窗口时可以不向WMS提供<code>WindowToken</code>，前提是<code>rootTtpe</code>或<code>type</code>的值不为前面条件筛选的值。<code>WindowToken</code>隐式和显示的创建需要加以区分，注释3的第4个参数为<code>false</code>就表示是隐式创建。<br>下面就是<code>WindowToken</code>不为空的情况，根据<code>rootType</code>和<code>type</code>的值进行判断，如在注释4，如果窗口为应用程序窗口，在注释5会将<code>WindowToken</code>转换为专门针对应用程序窗口的<code>AppWindowToken</code>，然后根据<code>AppWindowToken</code>的值进行后续的判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="keyword">final</span> WindowState win = <span class="keyword">new</span> WindowState(<span class="keyword">this</span>, session, client, token, parentWindow, appOp[<span class="number">0</span>], seq, attrs, viewVisibility, session.mUid, session.mCanAddInternalSystemWindow); <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">if</span> (win.mDeathRecipient == <span class="keyword">null</span>) &#123; <span class="comment">// 2</span></span><br><span class="line">      ......</span><br><span class="line">      <span class="keyword">return</span> WindowManagerGlobal.ADD_APP_EXITING;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (win.getDisplayContent() == <span class="keyword">null</span>) &#123; <span class="comment">// 3</span></span><br><span class="line">      ......</span><br><span class="line">      <span class="keyword">return</span> WindowManagerGlobal.ADD_INVALID_DISPLAY;</span><br><span class="line">&#125;</span><br><span class="line">mPolicy.adjustWindowParamsLw(win.mAttrs); <span class="comment">// 4</span></span><br><span class="line">win.setShowToOwnerOnlyLocked(mPolicy.checkShowToOwnerOnly(attrs));</span><br><span class="line">res = mPolicy.prepareAddWindowLw(win, attrs); <span class="comment">// 5</span></span><br><span class="line">......</span><br><span class="line">win.attach();</span><br><span class="line">mWindowMap.put(client.asBinder(), win); <span class="comment">// 6</span></span><br><span class="line"><span class="keyword">if</span> (win.mAppOp != AppOpsManager.OP_NONE) &#123;</span><br><span class="line">    <span class="keyword">int</span> startOpResult = mAppOps.startOpNoThrow(win.mAppOp, win.getOwningUid(), win.getOwningPackage());</span><br><span class="line">    <span class="keyword">if</span> ((startOpResult != AppOpsManager.MODE_ALLOWED) &amp;&amp; (startOpResult != AppOpsManager.MODE_DEFAULT)) &#123;</span><br><span class="line">        win.setAppOpVisibilityLw(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> AppWindowToken aToken = token.asAppWindowToken();</span><br><span class="line"><span class="keyword">if</span> (type == TYPE_APPLICATION_STARTING &amp;&amp; aToken != <span class="keyword">null</span>) &#123;</span><br><span class="line">    aToken.startingWindow = win;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">boolean</span> imMayMove = <span class="keyword">true</span>;</span><br><span class="line">win.mToken.addWindow(win); <span class="comment">// 7</span></span><br><span class="line"><span class="keyword">if</span> (type == TYPE_INPUT_METHOD) &#123;</span><br><span class="line">    win.mGivenInsetsPending = <span class="keyword">true</span>;</span><br><span class="line">    setInputMethodWindowLocked(win);</span><br><span class="line">    imMayMove = <span class="keyword">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == TYPE_INPUT_METHOD_DIALOG) &#123;</span><br><span class="line">    displayContent.computeImeTarget(<span class="keyword">true</span> <span class="comment">/* updateImeTarget */</span>);</span><br><span class="line">    imMayMove = <span class="keyword">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (type == TYPE_WALLPAPER) &#123;</span><br><span class="line">        displayContent.mWallpaperController.clearLastWallpaperTimeoutTime();</span><br><span class="line">        displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((attrs.flags&amp;FLAG_SHOW_WALLPAPER) != <span class="number">0</span>) &#123;</span><br><span class="line">        displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (displayContent.mWallpaperController.isBelowWallpaperTarget(win)) &#123;</span><br><span class="line">        displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>注释1，创建<code>WindowState</code>，它存有窗口的所有的状态信息，在WMS中它代表一个窗口。从<code>WindowState</code>传入的参数，可以发现<code>WindowState</code>中包含了WMS、<code>Session</code>、<code>WindowToken</code>、父类的<code>WindowState</code>、<code>LayoutParams</code>等信息。<br>注释2、3，分别判断请求添加窗口的客户端是否已经死亡、窗口的<code>DisplayContent</code>是否为空，如果是，则不会再执行后面的代码。<br>注释4，调用WMP的<code>adjustWindowParamsLw()</code>方法，该方法的实现在<code>PhoneWindowManager</code>中，会根据窗口的<code>type</code>对窗口的<code>LayoutParams</code>的一些成员变量进行修改。<br>注释5，调用WMP的<code>prepareAddWindowLw()</code>方法，用于准备将窗口添加到系统中。<br>注释6，将<code>WindowState</code>添加到<code>mWindowMap</code>中。<br>注释7，将<code>WindowState</code>添加到该<code>WindowState</code>对应的<code>WindowToken</code>中（实际是保存在<code>WindowToken</code>的父类<code>WindowContainer</code>中），这样<code>WindowToken</code>就包含了相同组件的<code>WindowToken</code>。</p><p><strong><code>addWindow()</code>方法总结：</strong>主要做了下面4件事</p><ol><li>对所要添加的窗口进行检查，如果窗口不满足一些条件，就不会再执行后面的代码；</li><li><code>WindowToken</code>相关的处理，比如有的窗口类型需要提供<code>WindowToken</code>，没有提供的话就不会执行后面的代码，有的窗口类型则需要由WMS隐式创建<code>WindowToken</code>；</li><li><code>WindowState</code>的创建和相关处理，将<code>WindowToken</code>与<code>WindowState</code>相关联；</li><li>创建和配置<code>DisplayContent</code>，完成窗口添加到系统前的准备工作。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;WMS在创建之后，它的重要成员有哪些？Window添加过程的WMS部分做了什么？&lt;/p&gt;
&lt;h1 id=&quot;1-WMS的重要成员&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="Android进阶" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
      <category term="框架层" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/"/>
    
      <category term="解析WindowManagerService" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/%E8%A7%A3%E6%9E%90WindowManagerService/"/>
    
    
      <category term="WindowManagerService" scheme="https://tylerLiu.top/tags/WindowManagerService/"/>
    
  </entry>
  
  <entry>
    <title>Android解析WindowManagerService 01：WMS的概述（基于Android 8.0）</title>
    <link href="https://tylerLiu.top/2019/10/26/Android%E8%A7%A3%E6%9E%90WindowManagerService-01%EF%BC%9AWMS%E7%9A%84%E6%A6%82%E8%BF%B0/"/>
    <id>https://tylerLiu.top/2019/10/26/Android解析WindowManagerService-01：WMS的概述/</id>
    <published>2019-10-26T05:51:30.000Z</published>
    <updated>2019-10-30T00:29:34.580Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>WMS属于系统服务中的其他服务，其主要职责：</p><ul><li><strong>窗口管理</strong>：WMS是窗口管理者，负责窗口的启动、添加和删除，另外窗口的大小和层级也是由WMS进行管理的。窗口管理的核心成员由<code>DisplayContent</code>、<code>WindowToken</code>和<code>WindowState</code>。</li><li><strong>窗口动画</strong>：窗口间进行切换时，可以使用窗口动画，窗口动画由WMS的动画子系统来负责，动画子系统的管理者为<code>WindowAnimator</code>。</li><li><strong>输入系统的中转站</strong>：通过对窗口的触摸从而产生触摸事件，<code>InputManagerService</code>(IMS)会对触摸事件进行处理，它会寻找一个最合适的窗口来处理触摸反馈信息，WMS是窗口的管理者，因此，WMS就成为输入系统的中转站。</li><li><strong><code>Surface</code>管理</strong>：窗口并不具备有绘制的功能，因此每个窗口都需要一块<code>Surface</code>来供自己绘制。为每个窗口分配<code>Surface</code>是由WMS来完成的。</li></ul><p>WMS的职责：</p><img src="/2019/10/26/Android解析WindowManagerService-01：WMS的概述/1572072703.jpg"><h1 id="2-WMS的诞生"><a href="#2-WMS的诞生" class="headerlink" title="2. WMS的诞生"></a>2. WMS的诞生</h1><p>WMS是在<code>SystemServer</code>进程中启动的。先看看<code>SystemServer</code>的<code>main()</code>方法：frameworks/base/services/java/com/android/server/SystemServer.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> SystemServer().run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面只调用了<code>SystemServer</code>的<code>run()</code>：frameworks/base/services/java/com/android/server/SystemServer.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// Initialize native services.</span></span><br><span class="line">        System.loadLibrary(<span class="string">"android_servers"</span>); <span class="comment">// 1</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// Create the system service manager.</span></span><br><span class="line">        mSystemServiceManager = <span class="keyword">new</span> SystemServiceManager(mSystemContext); <span class="comment">// 2</span></span><br><span class="line">        mSystemServiceManager.setStartInfo(mRuntimeRestart, mRuntimeStartElapsedTime, mRuntimeStartUptime);</span><br><span class="line">        LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);</span><br><span class="line">        <span class="comment">// Prepare the thread pool for init tasks that can be parallelized</span></span><br><span class="line">        SystemServerInitThreadPool.get();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        traceEnd();  <span class="comment">// InitBeforeStartServices</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start services.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        traceBeginAndSlog(<span class="string">"StartServices"</span>);</span><br><span class="line">        startBootstrapServices();</span><br><span class="line">        startCoreServices();</span><br><span class="line">        startOtherServices();</span><br><span class="line">        SystemServerInitThreadPool.shutdown();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        traceEnd();</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，加载了<code>android_servers.so</code>库。</p><p>注释2，创建<code>SystemServiceManager</code>，它会对系统的服务进行创建、启动和生命周期管理。</p><p>接下来会启动系统的各种服务。WMS是其他服务的一种。下面查看<code>startOtherServices()</code>。frameworks/base/services/java/com/android/server/SystemServer.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startOtherServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    traceBeginAndSlog(<span class="string">"InitWatchdog"</span>);</span><br><span class="line">    <span class="keyword">final</span> Watchdog watchdog = Watchdog.getInstance(); <span class="comment">// 1</span></span><br><span class="line">    watchdog.init(context, mActivityManagerService); <span class="comment">// 2</span></span><br><span class="line">    traceEnd();</span><br><span class="line">    traceBeginAndSlog(<span class="string">"StartInputManagerService"</span>);</span><br><span class="line">    inputManager = <span class="keyword">new</span> InputManagerService(context); <span class="comment">// 3</span></span><br><span class="line">    traceEnd();</span><br><span class="line">    traceBeginAndSlog(<span class="string">"StartWindowManagerService"</span>);</span><br><span class="line">    ConcurrentUtils.waitForFutureNoInterrupt(mSensorServiceStart, START_SENSOR_SERVICE);</span><br><span class="line">    mSensorServiceStart = <span class="keyword">null</span>;</span><br><span class="line">    wm = WindowManagerService.main(context, inputManager, mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL, !mFirstBoot, mOnlyCore, <span class="keyword">new</span> PhoneWindowManager()); <span class="comment">// 4</span></span><br><span class="line">    ServiceManager.addService(Context.WINDOW_SERVICE, wm); <span class="comment">// 5</span></span><br><span class="line">    ServiceManager.addService(Context.INPUT_SERVICE, inputManager); <span class="comment">// 6</span></span><br><span class="line">    traceEnd();   </span><br><span class="line">    ...... </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        wm.displayReady(); <span class="comment">// 7</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        reportWtf(<span class="string">"making display ready"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        wm.systemReady(); <span class="comment">// 8</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        reportWtf(<span class="string">"making Window Manager Service ready"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    ......      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只保留和WMS启动相关的代码。</p><p>注释1、2，获得<code>WatchDog</code>实例并对其进行初始化，<code>WatchDog</code>是用来监控系统的一些关键服务的运行状况。</p><p>注释3，创建IMS，并赋值给IMS类型的<code>inputManager</code>对象。</p><p>注释4，执行WMS的<code>main()</code>方法，其内部会创建WMS，<code>main()</code>方法其中一个传入的参数就是注释1创建的IMS，WMS是输入事件的中转站，其内部包含了IMS的引用。结合上文，可以得知WMS的<code>main()</code>方法是运行在<code>SystemServer</code>的<code>run()</code>方法中，即是运行在”system_server”线程中。</p><p>注释5、6分别将WMS和IMS注册到<code>ServiceManager</code>中，这样如果某个客户端想要使用WMS，就需要先去<code>ServiceManager</code>中查询信息，然后根据信息与WMS所在的进程建立通信通路，客户端就可以使用WMS了。</p><p>注释7，用来处理初始化显示信息。</p><p>注释8，通知WMS，系统的初始化工作已经完成，其内部调用了<code>WindowManagerPolicy</code>的<code>systemReady()</code>方法。</p><p>下面来看看注释4的<code>main()</code>方法。frameworks/base/services/core/java/com/android/server/wm/WindowManagerService .java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> WindowManagerService <span class="title">main</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> InputManagerService im,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> <span class="keyword">boolean</span> haveInputMethods, <span class="keyword">final</span> <span class="keyword">boolean</span> showBootMsgs, <span class="keyword">final</span> <span class="keyword">boolean</span> onlyCore, WindowManagerPolicy policy)</span> </span>&#123;</span><br><span class="line">        DisplayThread.getHandler().runWithScissors(() -&gt; <span class="comment">// 1</span></span><br><span class="line">            sInstance = <span class="keyword">new</span> WindowManagerService(context, im, haveInputMethods, showBootMsgs, onlyCore, policy), <span class="number">0</span>); <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> sInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，调用了<code>DisplayThread</code>的<code>getHandler()</code>方法，获取<code>DisplayThread</code>的实例。<code>DisplayThread</code>是一个单例的前台线程，这个线程用来处理需要低延时显示的相关操作，并只能由<code>WindowManager</code>、<code>DisplayManager</code>和<code>InputManager</code>实时执行快速操作。</p><p>注释2，创建WMS实例，该过程是运行在<code>Runnable</code>的<code>run()</code>方法中，<code>Runnable</code>会传入到<code>DisplayThread</code>对应<code>Handler</code>的<code>runWithScissors()</code>中，说明WMS的创建是运行在”android.display”中的。需要注意，<code>runWithScissors()</code>的第二个参数传入的是0。来看看<code>Handle</code>的<code>runWithScissors()</code>：frameworks/base/core/java/android/os/Handler.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">runWithScissors</span><span class="params">(<span class="keyword">final</span> Runnable r, <span class="keyword">long</span> timeout)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"runnable must not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout must be non-negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Looper.myLooper() == mLooper) &#123; <span class="comment">// 1</span></span><br><span class="line">        r.run();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BlockingRunnable br = <span class="keyword">new</span> BlockingRunnable(r);</span><br><span class="line">    <span class="keyword">return</span> br.postAndWait(<span class="keyword">this</span>, timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开头对传入的<code>Runable</code>和<code>timeout</code>进行判断，如果<code>Runable</code>为<code>null</code>或<code>timeout</code>小于0，则抛出异常。</p><p>注释1，根据每个线程只有一个<code>Looper</code>的原理来判断当前的线程（”system_server”线程）是否是<code>Handler</code>所指向的线程（”android.display”线程），如果是则直接执行<code>Runnable</code>的<code>run()</code>方法，如果不是则调用<code>BlobkingRunnable</code>的<code>postAndWait()</code>方法，并将当前线程的<code>Runnable</code>作为参数传进去，<code>BlockingRunnable</code>是<code>Handler</code>的内部类，代码如下所示。frameworks/base/core/java/android/os/Handler.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable mTask;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mDone;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlockingRunnable</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        mTask = task;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mTask.run(); <span class="comment">// 1</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                mDone = <span class="keyword">true</span>;</span><br><span class="line">                notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">postAndWait</span><span class="params">(Handler handler, <span class="keyword">long</span> timeout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!handler.post(<span class="keyword">this</span>)) &#123; <span class="comment">// 2</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> expirationTime = SystemClock.uptimeMillis() + timeout;</span><br><span class="line">                <span class="keyword">while</span> (!mDone) &#123;</span><br><span class="line">                    <span class="keyword">long</span> delay = expirationTime - SystemClock.uptimeMillis();</span><br><span class="line">                    <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// timeout</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        wait(delay);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!mDone) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        wait(); <span class="comment">// 3</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释2，将当前的<code>BlockingRunnable</code>添加到<code>Handler</code>的任务队列中。前面<code>runWithScissors()</code>第二个参数是0，因此<code>timeout</code>等于0，这样如果<code>mDone</code>为<code>false</code>的话会一直调用注释3的<code>wait()</code>方法，是当前线程（”system_server”线程）进入等待状态，那么等待的是哪个线程呢？往上看，注释1，执行了传入的<code>Runnable</code>的<code>run()</code>方法（运行在”andorid.display”线程），执行完毕后在<code>finally</code>代码块中将<code>mDone</code>设为<code>true</code>，并调用<code>notifyAll()</code>方法唤醒处于等待状态的线程，这样就不会继续调用注释3的代码。所以，system_server”线程线程等待的就是”android.display”线程，一直到”android.display”线程执行完毕，再执行”system_server”线程，因为”android.display”线程内部执行了WMS的创建，显然WMS的创建优先级更高。</p><p>WMS的构造方法：frameworks/base/services/core/java/com/android/server/wm/WindowManagerService .java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">WindowManagerService</span><span class="params">(Context context, InputManagerService inputManager, <span class="keyword">boolean</span> haveInputMethods, <span class="keyword">boolean</span> showBootMsgs, <span class="keyword">boolean</span> onlyCore, WindowManagerPolicy policy)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    mInputManager = inputManager; <span class="comment">// 1  Must be before createDisplayContentLocked.</span></span><br><span class="line">    ......</span><br><span class="line">    mDisplayManager = (DisplayManager)context.getSystemService(Context.DISPLAY_SERVICE);</span><br><span class="line">    mDisplays = mDisplayManager.getDisplays(); <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">for</span> (Display display : mDisplays) &#123;</span><br><span class="line">        createDisplayContentLocked(display); <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    mActivityManager = ActivityManager.getService(); <span class="comment">// 4</span></span><br><span class="line">    ......</span><br><span class="line">    mAnimator = <span class="keyword">new</span> WindowAnimator(<span class="keyword">this</span>); <span class="comment">// 5</span></span><br><span class="line">    mAllowTheaterModeWakeFromLayout = context.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromWindowLayout);</span><br><span class="line">    LocalServices.addService(WindowManagerInternal.class, <span class="keyword">new</span> LocalService());</span><br><span class="line">    initPolicy(); <span class="comment">// 6</span></span><br><span class="line">    <span class="comment">// Add ourself to the Watchdog monitors.</span></span><br><span class="line">    Watchdog.getInstance().addMonitor(<span class="keyword">this</span>); <span class="comment">// 7</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，保存传进来的IMS，这样WMS就持有IMS的引用。</p><p>注释2，通过<code>DisplayManager</code>的<code>getDisplays()</code>方法，获取<code>Display</code>数组（每个显示设备都有一个<code>Display</code>实例），然后遍历<code>Display</code>数组。</p><p>注释3，<code>createDisplayContentLocked()</code>方法会将<code>Display</code>封装成<code>DisplayContent</code>（用于描述一块屏幕）。</p><p>注释4，得到AMS实例，并赋值给<code>ActivityManager</code>，这样WMS就持有AMS的引用。</p><p>注释5，创建<code>WindowAnimator</code>，用于管理所有的窗口动画。</p><p>注释6，初始化窗口管理策略的接口类<code>WindowManagerPolicy</code>(WMP)，它是用来定义一个窗口策略所要遵循的通用规范。</p><p>注释7，将自身，即WMS，通过<code>addMonitor()</code>方法添加到<code>Watchdog</code>中，<code>Watchdog</code>是用来监控系统的一些关键服务的运行状况（比如传入的WMS的运行状况），这些被监控的服务都会实现<code>Watchdog.Monitor</code>接口。<code>Watchdog</code>每分钟都会对被监控的系统服务进行检查，如果被监控的系统服务出现死锁，就会杀死<code>Watchdog</code>所在的进程，即<code>SystemServer</code>进程。</p><p>注释6，<code>initPolicy()</code>方法。frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initPolicy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UiThread.getHandler().runWithScissors(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            WindowManagerPolicyThread.set(Thread.currentThread(), Looper.myLooper());</span><br><span class="line">            mPolicy.init(mContext, WindowManagerService.<span class="keyword">this</span>, WindowManagerService.<span class="keyword">this</span>); <span class="comment">// 1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>initPolicy()</code>方法和此前WMS的<code>main()</code>方法的实现类似，注释1处执行了WMP的<code>init()</code>方法，WMP是一个接口，<code>init()</code>方法的具体实现在<code>PhoneWindowManager</code>(PWM)中。PWM的<code>init()</code>方法是运行在”android.ui”线程中，它的优先级高于<code>initPolicy()</code>方法所在的”android.display”线程，因此”android.display”线程要等PWM的<code>init()</code>方法执行完毕后，处于等待状态的”android.display”线程才会被唤醒从而继续执行下面的代码。</p><p>本文共提及三个线程，”system_server”、”android.display”、”android.ui”，三者关系如下。</p><img src="/2019/10/26/Android解析WindowManagerService-01：WMS的概述/1572319428.jpg"><p>“system_server”线程中会调用WMS的<code>main()</code>方法，<code>main()</code>方法中会创建WMS，创建WMS的过程运行在”android.display”线程中，它的优先级更高，因此要等创建WMS完毕后才会唤醒处于等待状态的”system_server”线程。</p><p>WMS初始化时会执行<code>initPolicy()</code>方法，<code>initPolicy()</code>方法会调用PWM的<code>init()</code>方法，这个<code>init()</code>方法运行在”android.ui”线程，并且优先级更高，因此要先执行完PWM的<code>init()</code>方法之后，才会唤醒处于等待状态的”andorid.display”线程。</p><p>PWM的<code>init()</code>方法执行完毕后会接着执行运行在”system_server”线程的代码，比如WMS的<code>systemReady()</code>方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h1&gt;&lt;p&gt;WMS属于系统服务中的其他服务，其主要职责：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;窗口管理&lt;/strong&gt;：WM
      
    
    </summary>
    
      <category term="Android进阶" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
      <category term="框架层" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/"/>
    
      <category term="解析WindowManagerService" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/%E8%A7%A3%E6%9E%90WindowManagerService/"/>
    
    
      <category term="WindowManagerService" scheme="https://tylerLiu.top/tags/WindowManagerService/"/>
    
  </entry>
  
  <entry>
    <title>Android解析WindowManager 03：Window的添加过程</title>
    <link href="https://tylerLiu.top/2019/10/24/Android%E8%A7%A3%E6%9E%90WindowManager-03%EF%BC%9AWindow%E7%9A%84%E6%B7%BB%E5%8A%A0%E8%BF%87%E7%A8%8B/"/>
    <id>https://tylerLiu.top/2019/10/24/Android解析WindowManager-03：Window的添加过程/</id>
    <published>2019-10-24T08:56:00.000Z</published>
    <updated>2019-10-26T05:45:06.159Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p><code>WindowManager</code>对<code>Window</code>进行管理，包括对<code>Window</code>的添加、删除和更新的操作，这里统称为对<code>Window</code>的操作。对于<code>Window</code>的操作，最终都交由WMS进行处理。</p><p>窗口的操作分为两个部分：<code>WindowManager</code>处理部分和WMS处理部分。而<code>Window</code>分为三大类：Application Window（应用程序窗口）、Sub Window（子窗口）、System Window（系统窗口），不同类型的窗口添加过程会有所不同，但是对于WMS处理部分，添加的过程基本上是一样的。这里主要讲解对<code>Window</code>的操作的<code>WindowManager</code>部分。</p><h1 id="2-系统窗口的添加过程"><a href="#2-系统窗口的添加过程" class="headerlink" title="2. 系统窗口的添加过程"></a>2. 系统窗口的添加过程</h1><p>三大类窗口的添加过程有所不同，这里以系统窗口<code>StatusBar</code>为例，<code>StatusBar</code>是SystemUI的重要组成部分，具体就是指系统状态栏，用于显示时间、电量和信号等信息。来看看<code>StatusBar</code>的实现类<code>PhoneStatusBar</code>的<code>addStatusBarWindow()</code>方法，这个方法负责为<code>StatusBar</code>添加<code>Window</code>，如下。frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBar.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addStatusBarWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    makeStatusBarView(); <span class="comment">// 1</span></span><br><span class="line">    mStatusBarWindowManager = <span class="keyword">new</span> StatusBarWindowManager(mContext);</span><br><span class="line">    mRemoteInputController = <span class="keyword">new</span> RemoteInputController(mStatusBarWindowManager, mHeadsUpManager);</span><br><span class="line">    mStatusBarWindowManager.add(mStatusBarWindow, getStatusBarHeight()); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，构建<code>StatusBar</code>的视图。注释2，调用<code>StatusBarWindowManager</code>的<code>add()</code>方法，并传入<code>StatusBar</code>的视图（<code>StatusBarWindowView</code>）和<code>StatusBar</code>。</p><p>frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarWindowManager.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(View statusBarView, <span class="keyword">int</span> barHeight)</span> </span>&#123;</span><br><span class="line">    mLp = <span class="keyword">new</span> WindowManager.LayoutParams(</span><br><span class="line">            ViewGroup.LayoutParams.MATCH_PARENT,</span><br><span class="line">            barHeight,</span><br><span class="line">            WindowManager.LayoutParams.TYPE_STATUS_BAR, <span class="comment">// 1</span></span><br><span class="line">            WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE</span><br><span class="line">                    | WindowManager.LayoutParams.FLAG_TOUCHABLE_WHEN_WAKING</span><br><span class="line">                    | WindowManager.LayoutParams.FLAG_SPLIT_TOUCH</span><br><span class="line">                    | WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH</span><br><span class="line">                    | WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS,</span><br><span class="line">            PixelFormat.TRANSLUCENT);</span><br><span class="line">    mLp.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;</span><br><span class="line">    mLp.gravity = Gravity.TOP;</span><br><span class="line">    mLp.softInputMode = WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;</span><br><span class="line">    mLp.setTitle(<span class="string">"StatusBar"</span>);</span><br><span class="line">    mLp.packageName = mContext.getPackageName();</span><br><span class="line">    mStatusBarView = statusBarView;</span><br><span class="line">    mBarHeight = barHeight;</span><br><span class="line">    mWindowManager.addView(mStatusBarView, mLp); <span class="comment">// 2</span></span><br><span class="line">    mLpChanged = <span class="keyword">new</span> WindowManager.LayoutParams();</span><br><span class="line">    mLpChanged.copyFrom(mLp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过创建<code>LayoutParams</code>来配置<code>StatusBar</code>视图的属性，包括<code>width</code>、<code>height</code>、<code>type</code>、<code>flag</code>、<code>gravity</code>、<code>softInputMode</code>等。</p><p>注释1，设置<code>TYPE_STATUSS_BAR</code>，表示<code>StatusBar</code>视图的窗口类型是状态栏。注释2，调用了<code>WindowManager</code>的<code>addView()</code>方法，该方法定义在<code>WindowManager</code>的父类接口<code>ViewManager</code>中，而实现<code>addView()</code>的则是<code>WindowManagerImpl</code>。frameworks/base/core/java/android/WindowManagerImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(@NonNull View view, @NonNull ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">    applyDefaultToken(params);</span><br><span class="line">    mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面会调用<code>WindowManagerGlobal</code>的<code>addView()</code>：frameworks/base/core/java/android/view/WindowManagerGlobal.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line">    .....</span><br><span class="line">    <span class="comment">//参数检查</span></span><br><span class="line">    <span class="keyword">final</span> WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;</span><br><span class="line">    <span class="keyword">if</span> (parentWindow != <span class="keyword">null</span>) &#123;</span><br><span class="line">        parentWindow.adjustLayoutParamsForSubWindow(wparams); <span class="comment">// 1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br><span class="line">    ViewRootImpl root;</span><br><span class="line">    View panelParentView = <span class="keyword">null</span>;</span><br><span class="line">    ......</span><br><span class="line">    root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display); <span class="comment">// 2</span></span><br><span class="line">    view.setLayoutParams(wparams);</span><br><span class="line">    mViews.add(view);</span><br><span class="line">    mRoots.add(root); <span class="comment">// 3</span></span><br><span class="line">    mParams.add(wparams);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        root.setView(view, wparams, panelParentView); <span class="comment">// 4</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先会对参数<code>view</code>、<code>params</code>和<code>display</code>进行检查。</p><p>注释1，如果当前窗口要作为子窗口，就会根据父窗口对子窗口的<code>WindowManager.LayoutParams</code>类型的<code>wparams</code>对象进行相应的调整。</p><p>注释2，创建<code>ViewRootImpl</code>并赋值给<code>root</code>，紧接着在注释3将<code>root</code>存入到<code>ArrayList&lt;ViewRootImpl&gt;</code>类型的<code>mRoots</code>中，除了<code>mRoots</code>，<code>mViews</code>和<code>mParams</code>也是<code>ArrayList</code>类型的，分别用于存储窗口的<code>view</code>对象和<code>WindowManager.LayoutParams</code>类型的<code>wparams</code>对象。</p><p>注释4，调用<code>ViewRootImpl</code>的<code>setView()</code>方法。</p><p><code>ViewRootImpl</code>的职责：</p><ul><li><code>View</code>树的根并管理<code>View</code>树</li><li>触发<code>View</code>的测量、布局和绘制</li><li>输入事件的中转站</li><li>管理<code>Surface</code></li><li>负责与WMS进行进程间通信</li></ul><p>frameworks/base/core/java/android/view/ViewRootImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mOrigWindowType = mWindowAttributes.type;</span><br><span class="line">            mAttachInfo.mRecomputeGlobalAttributes = <span class="keyword">true</span>;</span><br><span class="line">            collectViewAttributes();</span><br><span class="line">            res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), mAttachInfo.mContentInsets, mAttachInfo.mStableInsets, mAttachInfo.mOutsets, mInputChannel);</span><br><span class="line">        &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里截取的部分，主要是调用<code>mWindowSession</code>的<code>addToDisplay()</code>方法。<code>mWindowSession</code>是<code>IWindowSession</code>类型的，它是一个<code>Binder</code>对象，用于进程间通信，<code>IWindowSession</code>是Client端的代理，它的Server端的实现为<code>Session</code>，此前包含<code>ViewRootImpl</code>在内的代码逻辑都是运行在本地进程的，而<code>Session</code>的<code>addToDisplay()</code>方法则运行在WMS所在的进程。frameworks/base/services/core/java/com/android/server/wm/Session.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addToDisplay</span><span class="params">(IWindow window, <span class="keyword">int</span> seq, WindowManager.LayoutParams attrs, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> displayId, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, InputChannel outInputChannel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mService.addWindow(<span class="keyword">this</span>, window, seq, attrs, viewVisibility, displayId, outContentInsets, outStableInsets, outOutsets, outInputChannel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法中调用WMS的<code>addWindow()</code>方法，并将自身即<code>Session</code>作为参数传入，每个应用程序进程都会对应一个<code>Session</code>，WMS会用<code>ArrayList</code>来保存这些<code>Session</code>。这样剩下的工作就交由WMS来处理，在WMS中会为这个添加的窗口分配<code>Surface</code>，并确定窗口显示次序，负责显示界面的是画布<code>Surface</code>，而不是窗口本身。WMS会将它管理的<code>Surfece</code>交给<code>SurfaceFlinger</code>处理，<code>SurfaceFlinger</code>会将这些混合并绘制到屏幕上。</p><p>窗口添加的WMS处理部分会在WMS中介绍，系统窗口的添加过程的时序图如下。</p><img src="/2019/10/24/Android解析WindowManager-03：Window的添加过程/Vez5wT.png"><h1 id="3-Activity的添加过程"><a href="#3-Activity的添加过程" class="headerlink" title="3. Activity的添加过程"></a>3. Activity的添加过程</h1><p>任何窗口的添加过程在WMS处理部分基本类似，不过在权限和窗口显示次序等方面会有不同。在<code>WindowManager</code>中的处理会不同，最典型的就是应用程序窗口Activity，Activity在启动过程中，如果Activity所在的进程不存在，则会先创建新的进程，接着会运行代表主线程的<code>ActivityThread</code>实例。<code>ActivityThread</code>管理当前应用程序进程的线程。当界面与用户进行交互时，会调用<code>ActivityThread</code>的<code>handleResumeActivity()</code>，如下。frameworks/base/core/java/android/app/ActivityThread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finalStateRequest, <span class="keyword">boolean</span> isForward, String reason)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// TODO Push resumeArgs into the activity for consideration</span></span><br><span class="line">    <span class="keyword">final</span> ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason); <span class="comment">// 1</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (r.window == <span class="keyword">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">        r.window = r.activity.getWindow();</span><br><span class="line">        View decor = r.window.getDecorView();</span><br><span class="line">        decor.setVisibility(View.INVISIBLE);</span><br><span class="line">        ViewManager wm = a.getWindowManager(); <span class="comment">// 2</span></span><br><span class="line">        WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">        a.mDecor = decor;</span><br><span class="line">        l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">        l.softInputMode |= forwardBit;</span><br><span class="line">        <span class="keyword">if</span> (r.mPreserveWindow) &#123;</span><br><span class="line">            a.mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">            r.mPreserveWindow = <span class="keyword">false</span>;</span><br><span class="line">            ViewRootImpl impl = decor.getViewRootImpl();</span><br><span class="line">            <span class="keyword">if</span> (impl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                impl.notifyChildRebuilt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a.mVisibleFromClient) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!a.mWindowAdded) &#123;</span><br><span class="line">                a.mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">                wm.addView(decor, l); <span class="comment">// 3</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                a.onWindowAttributesChanged(l);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，<code>performResumeActivity()</code>最终会调用Activity的<code>onResume()</code>。</p><p>注释2，得到<code>ViewManager</code>类型的对象<code>vm</code>，并在注释3调用<code>vm</code>的<code>addView()</code>方法，该方法的实现在<code>WindowManagerImpl</code>中，后面的过程在系统窗口添加过程中已经介绍过。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h1&gt;&lt;p&gt;&lt;code&gt;WindowManager&lt;/code&gt;对&lt;code&gt;Window&lt;/code&gt;进行管理，包括对&lt;code&gt;
      
    
    </summary>
    
      <category term="Android进阶" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
      <category term="框架层" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/"/>
    
      <category term="解析WindowManager" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/%E8%A7%A3%E6%9E%90WindowManager/"/>
    
    
      <category term="WindowManager" scheme="https://tylerLiu.top/tags/WindowManager/"/>
    
  </entry>
  
  <entry>
    <title>Android解析WindowManager 02：Window属性</title>
    <link href="https://tylerLiu.top/2019/10/24/Android%E8%A7%A3%E6%9E%90WindowManager-02%EF%BC%9AWindow%E5%B1%9E%E6%80%A7/"/>
    <id>https://tylerLiu.top/2019/10/24/Android解析WindowManager-02：Window属性/</id>
    <published>2019-10-24T01:04:25.000Z</published>
    <updated>2019-10-24T08:49:36.272Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>前面讲过了<code>Window</code>、<code>WindowManager</code>、WMS之间的关系，WMS是<code>Window</code>的最终管理者，<code>Window</code>如果是员工， WMS就是老板，为了方便老板管理员工，会定义一些“协议”，这些“协议”就是<code>Window</code>属性，被定义在<code>WindowManager</code>的内部类<code>LayoutParams</code>中。</p><p><code>Window</code>的属性有很多种，最常用的有三种，<code>Type</code>（<code>Window</code>的类型）、<code>Flag</code>（<code>Window</code>的标志）、<code>SoftInputMode</code>（软键盘相关模式）。</p><h1 id="2-Window的类型和显示次序"><a href="#2-Window的类型和显示次序" class="headerlink" title="2. Window的类型和显示次序"></a>2. Window的类型和显示次序</h1><p><code>Window</code>的类型有很多种，如应用程序窗口、系统错误窗口、输入法窗口、<code>PopupWindow</code>、<code>Toast</code>、<code>Dialog</code>等。总的来说分成三大类：Application Window（应用程序窗口）、Sub Window（子窗口）、Syste Window（系统窗口），每个大类下面有很多种类型，它们都定义在<code>WindowManager</code>的静态内部类<code>LayoutParams</code>中。</p><h2 id="2-1-应用程序窗口"><a href="#2-1-应用程序窗口" class="headerlink" title="2.1 应用程序窗口"></a>2.1 应用程序窗口</h2><p>Activity就是一个典型的应用程序窗口，应用程序窗口包含的类型如下：frameworks/base/core/java/android/view/WindowManager.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FIRST_APPLICATION_WINDOW = <span class="number">1</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_BASE_APPLICATION   = <span class="number">1</span>; <span class="comment">// 窗口的基础值，其他的窗口值要大于这个值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_APPLICATION        = <span class="number">2</span>; <span class="comment">// 普通的应用程序窗口类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_APPLICATION_STARTING = <span class="number">3</span>; <span class="comment">// 应用程序启动窗口类型，用于系统在应用程序窗口启动前显示的窗口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_DRAWN_APPLICATION = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LAST_APPLICATION_WINDOW = <span class="number">99</span>; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>注释1，表示应用程序类型初始值，注释2，表示应用程序窗口结束值，即应用程序窗口的Type值范围是1-99，这个数值的大小涉及到窗口的层级。</p><h2 id="2-2-子窗口"><a href="#2-2-子窗口" class="headerlink" title="2.2 子窗口"></a>2.2 子窗口</h2><p>不能独立存在，需要依附在其他窗口之上，<code>PopupWindow</code>就是子窗口，子窗口的类型如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FIRST_SUB_WINDOW = <span class="number">1000</span>; <span class="comment">// 子窗口类型初始值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_APPLICATION_PANEL = FIRST_SUB_WINDOW;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_APPLICATION_MEDIA = FIRST_SUB_WINDOW + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_APPLICATION_SUB_PANEL = FIRST_SUB_WINDOW + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_APPLICATION_ATTACHED_DIALOG = FIRST_SUB_WINDOW + <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_APPLICATION_MEDIA_OVERLAY  = FIRST_SUB_WINDOW + <span class="number">4</span>; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_APPLICATION_ABOVE_SUB_PANEL = FIRST_SUB_WINDOW + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LAST_SUB_WINDOW = <span class="number">1999</span>; <span class="comment">// 子窗口类型结束值</span></span><br></pre></td></tr></table></figure><p>子窗口的<code>Type</code>值为1000-1999。</p><h2 id="2-3-系统窗口"><a href="#2-3-系统窗口" class="headerlink" title="2.3 系统窗口"></a>2.3 系统窗口</h2><p><code>Toast</code>、输入法窗口、系统音量条窗口、系统错误窗口都属于系统窗口。系统窗口的类型定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FIRST_SYSTEM_WINDOW     = <span class="number">2000</span>; <span class="comment">// 系统窗口类型初始值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_STATUS_BAR         = FIRST_SYSTEM_WINDOW; <span class="comment">// 系统状态栏窗口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_SEARCH_BAR         = FIRST_SYSTEM_WINDOW+<span class="number">1</span>; <span class="comment">// 搜索条窗口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_PHONE              = FIRST_SYSTEM_WINDOW+<span class="number">2</span>; <span class="comment">// 通话窗口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_SYSTEM_ALERT       = FIRST_SYSTEM_WINDOW+<span class="number">3</span>; <span class="comment">// 系统ALERT窗口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_KEYGUARD           = FIRST_SYSTEM_WINDOW+<span class="number">4</span>; <span class="comment">// 锁屏窗口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_TOAST              = FIRST_SYSTEM_WINDOW+<span class="number">5</span>; <span class="comment">// TOAST窗口</span></span><br><span class="line">......</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LAST_SYSTEM_WINDOW      = <span class="number">2999</span>; <span class="comment">// 系统窗口类型结束值</span></span><br></pre></td></tr></table></figure><h2 id="2-4-窗口显示次序"><a href="#2-4-窗口显示次序" class="headerlink" title="2.4 窗口显示次序"></a>2.4 窗口显示次序</h2><p>当一个进程向WMS申请一个窗口时，WMS会为窗口确定显示次序。为了方便窗口显示次序的管理，手机屏幕可以虚拟的用x、y、z轴来表示，其中z轴垂直于屏幕，从屏幕内指向屏幕外，这样确定窗口显示次序就是确定窗口在z轴上的次序，这个次序称为Z-Oder。Type值是Z-Oder排序的依据。一般情况下，Type值越大，Z-Oder排序越靠前，就越靠近用户。</p><h1 id="3-Window标志"><a href="#3-Window标志" class="headerlink" title="3. Window标志"></a>3. Window标志</h1><p>即<code>Flag</code>，用于控制<code>Window</code>的显示，也是被定义在<code>WindowManager</code>的内部类<code>LayoutParams</code>中，下面是常用的<code>Flag</code>：</p><table><thead><tr><th align="left">Flag</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">FLAG_ALLOW_LOCK_WHILE_SCREEN_ON</td><td align="left">只要窗口可见，就允许在开启状态的屏幕上锁屏</td></tr><tr><td align="left">FLAG_NOT_FOCUSABLE</td><td align="left">窗口不能获得输入焦点，设置该标志的同时，FLAG_NOT_TOUCH_MODAL也会被设置</td></tr><tr><td align="left">FLAG_NOT_TOUCHABLE</td><td align="left">窗口不接收任何触摸事件</td></tr><tr><td align="left">FLAG_NOT_TOUCH_MODAL</td><td align="left">在该窗口区域外的触摸事件会传递给其他的Window，而自己只会处理窗口区域内的触摸事件</td></tr><tr><td align="left">FLAG_KEEP_SCREEN_ON</td><td align="left">只要窗口可见，屏幕就一直亮着</td></tr><tr><td align="left">FLAG_LAYOUT_NO_LIMITS</td><td align="left">允许窗口超过屏幕外</td></tr><tr><td align="left">FLAG_FULLSCREEN</td><td align="left">隐藏所有的屏幕装饰窗口，比如在游戏、播放器中全屏显示</td></tr><tr><td align="left">FLAG_SHOW_WHEN_LOCKED</td><td align="left">窗口可以在锁屏的窗口之上显示</td></tr><tr><td align="left">FLAG_IGNORE_CHEEK_PRESSES</td><td align="left">当用户的脸贴近屏幕时（如打电话），不会去响应此事件</td></tr><tr><td align="left">FLAG_TURN_SCREEN_ON</td><td align="left">窗口显示时将屏幕点亮</td></tr></tbody></table><p>设置<code>Window</code>的<code>Flag</code>有三种方式，一是通过<code>Window</code>的<code>addFlag()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Window mWindow = getWindow(); </span><br><span class="line">mWindow.addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);</span><br></pre></td></tr></table></figure><p>二是通过<code>Window</code>的<code>setFlag()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Window mWindow =getWindow();</span><br><span class="line">mWindow.setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN , WindowManager.LayoutParams.FLAG_FULLSCREEN);</span><br></pre></td></tr></table></figure><p><code>addFlag()</code>内部会调用<code>setFlag()</code>，因此二者区别不大。</p><p>第三种是给<code>LayoutParams</code>设置<code>Flag</code>，并通过<code>WindowManager</code>的<code>addView()</code>方法进行添加。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WindowManager.LayoutParams mWindowLayoutParams = <span class="keyword">new</span> WindowManager.LayoutParams();</span><br><span class="line">mWindowLayoutParams.flags=WindowManager.LayoutParams.FLAG_FULLSCREEN;</span><br><span class="line">WindowManager mWindowManager =(WindowManager) getSystemService(Context.WINDOW_SERVICE);  </span><br><span class="line">TextView mTextView=<span class="keyword">new</span> TextView(<span class="keyword">this</span>);</span><br><span class="line">mWindowManager.addView(mTextView,mWindowLayoutParams);</span><br></pre></td></tr></table></figure><h1 id="4-软键盘相关模式"><a href="#4-软键盘相关模式" class="headerlink" title="4. 软键盘相关模式"></a>4. 软键盘相关模式</h1><p>一般默认情况下，弹出的软键盘窗口可能会盖住输入框下面的按钮，这样用户体验不好。</p><p>为了使软键盘窗口能按照期望来显示，<code>WindowManager</code>的静态内部类<code>LayoutParams</code>中定义了软键盘相关模式，这里列举常用的几个：</p><table><thead><tr><th align="left">SoftInputMode</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">SOFT_INPUT_STATE_UNSPECIFIED</td><td align="left">没有指定状态，系统会选择一个合适的状态或依赖于主题的设置</td></tr><tr><td align="left">SOFT_INPUT_STATE_UNCHANGED</td><td align="left">不会改变软甲盘的状态</td></tr><tr><td align="left">SOFT_INPUT_STATE_HIDDEN</td><td align="left">当用户进入该窗口时，软键盘默认隐藏</td></tr><tr><td align="left">SOFT_INPUT_STATE_ALWAYS_HIDDEN</td><td align="left">当窗口获取焦点时，软键盘总是被隐藏</td></tr><tr><td align="left">SOFT_INPUT_ADJUST_RESIZE</td><td align="left">当软键盘弹出时，窗口会调整大小</td></tr><tr><td align="left">SOFT_INPUT_ADJUST_PAN</td><td align="left">当软键盘弹出时，窗口不需要调整大小，要确保输入焦点是可见的</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h1&gt;&lt;p&gt;前面讲过了&lt;code&gt;Window&lt;/code&gt;、&lt;code&gt;WindowManager&lt;/code&gt;、WMS之间的关系
      
    
    </summary>
    
      <category term="Android进阶" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
      <category term="框架层" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/"/>
    
      <category term="解析WindowManager" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/%E8%A7%A3%E6%9E%90WindowManager/"/>
    
    
      <category term="WindowManager" scheme="https://tylerLiu.top/tags/WindowManager/"/>
    
  </entry>
  
  <entry>
    <title>Android解析WindowManager 01：WindowManager体系</title>
    <link href="https://tylerLiu.top/2019/10/18/Android%E8%A7%A3%E6%9E%90WindowManager-01%EF%BC%9AWindowManager%E4%BD%93%E7%B3%BB/"/>
    <id>https://tylerLiu.top/2019/10/18/Android解析WindowManager-01：WindowManager体系/</id>
    <published>2019-10-18T02:59:10.000Z</published>
    <updated>2019-10-24T01:01:44.047Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Window、WindowManager和WMS"><a href="#1-Window、WindowManager和WMS" class="headerlink" title="1. Window、WindowManager和WMS"></a>1. Window、WindowManager和WMS</h1><p><code>Window</code>，一个抽象类，其具体的实现是<code>PhoneWindow</code>，它对<code>View</code>进行管理。<code>WindowManager</code>是一个接口类，继承自接口<code>ViewManager</code>，用来管理<code>Window</code>，其实现类是<code>WindowManagerImpl</code>。如果要对<code>Window</code>进行添加和删除就可以使用<code>WindowManager</code>，具体的工作会由WMS来完成，<code>WindowManager</code>和WMS通过<code>Binder</code>进行跨进程通信，WMS作为系统服务，有很多API是不会暴露给<code>WindowManager</code>的，这点与AMS和<code>ActivityManager</code>类似。</p><p>这里主要介绍<code>Window</code>管理和输入系统。</p><img src="/2019/10/18/Android解析WindowManager-01：WindowManager体系/1571368891.jpg"><p><code>Window</code>包含了<code>View</code>，并对<code>View</code>进行管理，<code>Window</code>是一个抽象的概念，并不是真实存在的，<code>Window</code>的实体就是<code>View</code>。<code>WindowManager</code>用来管理<code>Window</code>，而<code>WindowManager</code>所提供的功能最终会由WMS进行处理。</p><h1 id="2-WindowManager体系"><a href="#2-WindowManager体系" class="headerlink" title="2. WindowManager体系"></a>2. WindowManager体系</h1><p><code>WindowManager</code>是一个接口，继承<code>ViewManager</code>，<code>ViewManager</code>中定义了三个方法，分别用来添加、更新和删除<code>View</code>：frameworks/base/core/java/android/view/ViewManager.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Interface to let you add and remove child views to an Activity. To get an instance</span></span><br><span class="line"><span class="comment">  * of this class, call &#123;<span class="doctag">@link</span> android.content.Context#getSystemService(java.lang.String) Context.getSystemService()&#125;.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ViewManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Assign the passed LayoutParams to the passed View and add the view to the window.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Throws &#123;<span class="doctag">@link</span> android.view.WindowManager.BadTokenException&#125; for certain programming</span></span><br><span class="line"><span class="comment">     * errors, such as adding a second view to a window without removing the first view.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Throws &#123;<span class="doctag">@link</span> android.view.WindowManager.InvalidDisplayException&#125; if the window is on a</span></span><br><span class="line"><span class="comment">     * secondary &#123;<span class="doctag">@link</span> Display&#125; and the specified display can't be found</span></span><br><span class="line"><span class="comment">     * (see &#123;<span class="doctag">@link</span> android.app.Presentation&#125;).</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> view The view to be added to this window.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> params The LayoutParams to assign to view.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateViewLayout</span><span class="params">(View view, ViewGroup.LayoutParams params)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeView</span><span class="params">(View view)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>WindowManager</code>也继承了这些方法。可以看到里面传入的参数都是<code>View</code>，说明<code>WindowManager</code>具体管理的是以<code>View</code>形式存在的<code>Window</code>。<code>WindowManager</code>在继承<code>ViewManager</code>的同时，加入了其他功能，包括<code>Window</code>的类型和层级相关的常量、内部类以及一些方法，其中有两个方法是根据<code>Window</code>的特性加入的，如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Display <span class="title">getDefaultDisplay</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeViewImmediate</span><span class="params">(View view)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>getDefaultDisplay()</code>：获取<code>WindowManager</code>实例将<code>Window</code>添加到哪个屏幕上，即得到<code>WindowManager</code>所管理的屏幕（Display）。</li><li><code>removeViewImmediate()</code>：规定在这个方法返回前要立即执行<code>View.onDetachedFromWindow()</code>，来完成传入的<code>View</code>相关的销毁工作。</li></ul><p><code>Window</code>是一个抽象类，其具体实现是<code>PhoneWindow</code>。在Activity启动过程中会调用<code>ActivityThread</code>的<code>performLaunchActivity()</code>，<code>performLaunchActivity()</code>中又会调用<code>Activity</code>的<code>attach()</code>：frameworks/base/core/java/android/app/Activity.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context, ActivityThread aThread,</span></span></span><br><span class="line"><span class="function"><span class="params">        Instrumentation instr, IBinder token, <span class="keyword">int</span> ident,</span></span></span><br><span class="line"><span class="function"><span class="params">        Application application, Intent intent, ActivityInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">        CharSequence title, Activity parent, String id,</span></span></span><br><span class="line"><span class="function"><span class="params">        NonConfigurationInstances lastNonConfigurationInstances,</span></span></span><br><span class="line"><span class="function"><span class="params">        Configuration config, String referrer, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">        Window window, ActivityConfigCallback activityConfigCallback)</span> </span>&#123;</span><br><span class="line">    attachBaseContext(context);</span><br><span class="line"></span><br><span class="line">    mFragments.attachHost(<span class="keyword">null</span> <span class="comment">/*parent*/</span>);</span><br><span class="line"></span><br><span class="line">    mWindow = <span class="keyword">new</span> PhoneWindow(<span class="keyword">this</span>, window, activityConfigCallback); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    mWindow.setWindowManager(</span><br><span class="line">            (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">            mToken, mComponent.flattenToString(),</span><br><span class="line">            (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，创建<code>PhoneWindow</code>；注释2，调用<code>PhoneWindow</code>的<code>setWindowManager()</code>，它的具体实现在<code>PhoneWindow</code>的父类<code>Window</code>中。frameworks/base/core/java/android/view/Window.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWindowManager</span><span class="params">(WindowManager wm, IBinder appToken, String appName, <span class="keyword">boolean</span> hardwareAccelerated)</span> </span>&#123;</span><br><span class="line">    mAppToken = appToken;</span><br><span class="line">    mAppName = appName;</span><br><span class="line">    mHardwareAccelerated = hardwareAccelerated || SystemProperties.getBoolean(PROPERTY_HARDWARE_UI, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (wm == <span class="keyword">null</span>) &#123;</span><br><span class="line">        wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE); <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(<span class="keyword">this</span>); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果传入的<code>WindowManager</code>为空，就会在注释1调用<code>context</code>的<code>getSystemService()</code>并传入服务的名称<code>Context.WINDOW_SERVER</code>，具体的实现在<code>ContextImpl</code>中，如下。frameworks/base/core/java/android/app/ContextImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSystemService</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SystemServiceRegistry.getSystemService(<span class="keyword">this</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getSystemServiceName</span><span class="params">(Class&lt;?&gt; serviceClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SystemServiceRegistry.getSystemServiceName(serviceClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终会调用<code>SystemServiceRegistry</code>的<code>getSystemSeviceName()</code>。frameworks/base/core/java/android/app/SystemServiceRegistry.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSystemServiceName</span><span class="params">(Class&lt;?&gt; serviceClass)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> SYSTEM_SERVICE_NAMES.get(serviceClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SYSTEM_SERVICE_NAMES</code>是一个<code>HashMap</code>，用来存储服务的名称。传入<code>Context.WINDOW_SERVER</code>对应的是什么呢？frameworks/base/core/java/android/app/SystemServiceRegistry.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemServiceRegistry</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SystemServiceRegistry</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    registerService(Context.WINDOW_SERVICE, WindowManager.class, <span class="keyword">new</span> CachedServiceFetcher&lt;WindowManager&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> WindowManager <span class="title">createService</span><span class="params">(ContextImpl ctx)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> WindowManagerImpl(ctx);</span><br><span class="line">        &#125;&#125;);</span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>SystemServiceRegistry</code>的静态代码块中会调用多个<code>registerService()</code>方法，这里只看<code>Context.WINDOW_SERVICE</code>。<code>registerService()</code>会将传入的服务的名称存入到<code>SYSTEM_SERVICE_NAMES</code>中。从上面的代码可以看出，传入的<code>Context.WINDOW_SERVICE</code>对应的就是<code>WindowManagerImpl</code>的实例，因此<code>Context</code>的<code>getSystemService()</code>得到的是<code>WindowManagerImpl</code>实例。再回到<code>Window</code>的<code>setWindowManager()</code>中，得到<code>WindowManagerImpl</code>实例后转为<code>WindowManger</code>类型，在注释2处调用<code>WindowManagerImpl</code>的<code>createLocalWindowManager()</code>：frameworks/base/core/java/android/view/WindowManagerImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> WindowManagerImpl <span class="title">createLocalWindowManager</span><span class="params">(Window parentWindow)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> WindowManagerImpl(mContext, parentWindow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在里面也创建了<code>WindowManagerImpl</code>，不过在创建的同时，将创建它的<code>Window</code>作为参数传了进来，这样<code>WindowManagerImpl</code>就持有<code>Window</code>的引用了，就可以对<code>Window</code>进行操作，比如，在<code>Window</code>中添加<code>View</code>，来看看<code>WindowManagerImpl</code>的<code>addView()</code>：frameworks/base/core/java/android/view/WindowManagerImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(@NonNull View view, @NonNull ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">    applyDefaultToken(params);</span><br><span class="line">    mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，调用了<code>WindowManagerGlobal</code>的<code>addView()</code>方法，其中最后一个参数<code>mParentWindow</code>就是<code>Window</code>，<code>WindowManagerImpl</code>虽然是<code>WindowManager</code>的实现类，但是没有实现任何功能，而是将功能的实现委托给了<code>WindowManagerGlobal</code>，这是桥接模式。</p><p>再来看看<code>WindowManagerImpl</code>中是如何定义<code>WindowManagerGlobal</code>的：frameworks/base/core/java/android/view/WindowManagerImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowManagerImpl</span> <span class="keyword">implements</span> <span class="title">WindowManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Context mContext;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Window mParentWindow; <span class="comment">// 1</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">WindowManagerImpl</span><span class="params">(Context context, Window parentWindow)</span> </span>&#123;</span><br><span class="line">        mContext = context;</span><br><span class="line">        mParentWindow = parentWindow;</span><br><span class="line">    &#125;</span><br><span class="line">    ......   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>WindowManagerGlobal</code>是一个单例，说明在一个进程中只有一个<code>WindowManagerGlobal</code>实例。注释1，说明一个<code>WindowManagerImpl</code>可能会实现多个<code>Window</code>，即一个进程中可能会有多个<code>WindowManagerImpl</code>实例。 </p><p>Window和WindowManager关系图：</p><img src="/2019/10/18/Android解析WindowManager-01：WindowManager体系/1571878481.jpg"><p><code>PhoneWindow</code>继承自<code>Window</code>，<code>Window</code>通过<code>setWindowManager()</code>方法与<code>WindowManager</code>发生联系。<code>WindowManager</code>继承自接口<code>ViewManager</code>，<code>WindowManagerImpl</code>是<code>WindowManager</code>接口的实现类，但是具体的功能都会委托给<code>WindowManagerGlobal</code>来实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Window、WindowManager和WMS&quot;&gt;&lt;a href=&quot;#1-Window、WindowManager和WMS&quot; class=&quot;headerlink&quot; title=&quot;1. Window、WindowManager和WMS&quot;&gt;&lt;/a&gt;1. Wind
      
    
    </summary>
    
      <category term="Android进阶" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
      <category term="框架层" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/"/>
    
      <category term="解析WindowManager" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/%E8%A7%A3%E6%9E%90WindowManager/"/>
    
    
      <category term="WindowManager" scheme="https://tylerLiu.top/tags/WindowManager/"/>
    
  </entry>
  
  <entry>
    <title>九、深入理解绘制原理</title>
    <link href="https://tylerLiu.top/2019/09/25/%E4%B9%9D%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BB%98%E5%88%B6%E5%8E%9F%E7%90%86/"/>
    <id>https://tylerLiu.top/2019/09/25/九、深入理解绘制原理/</id>
    <published>2019-09-25T07:33:53.000Z</published>
    <updated>2019-09-25T09:12:54.525Z</updated>
    
    <content type="html"><![CDATA[<p>通过前面知道了<code>Widget</code>、<code>Element</code>、<code>RenderObject</code>的关系，也知道<code>Widget</code>的布局逻辑，最终所有<code>Widget</code>都转化为<code>RenderObject</code>对象，它们堆叠出所需的画面。</p><p>所以在Flutter中，最终页面的<code>Layout</code>、<code>Paint</code>等都会发生在<code>Widget</code>所对应的<code>RenderObject</code>子类中，而<code>RenderObject</code>也是Flutter跨平台最大的特点之一：<strong>所有的控件都与平台无关</strong>。简而言之，<strong>Flutter只要求系统提供<code>Canvas</code>，然后开发者通过<code>Widget</code>生成<code>RenderObject</code>“直接”通过引擎绘制到屏幕上</strong>。</p><h1 id="1-绘制过程"><a href="#1-绘制过程" class="headerlink" title="1. 绘制过程"></a>1. 绘制过程</h1><p><code>Widget</code>最终都会转化为<code>RenderObject</code>，所以要了解绘制过程，要先看<code>RenderObject</code>的<code>paint()</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/// Paint this render object into </span>the<span class="markdown"> given context at </span>the<span class="markdown"> given offset.</span></span></span><br><span class="line"><span class="comment"><span class="markdown">///</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// Subclasses </span>should<span class="markdown"> override this method to provide </span>a<span class="markdown"> visual appearance</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// for themselves. The render object's local coordinate system is</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// axis-aligned with </span>the<span class="markdown"> coordinate system of </span>the<span class="markdown"> context's canvas and </span>the<span class="markdown"></span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// render object's local origin (i.e, x=0 and y=0) is placed at </span>the<span class="markdown"> given</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// offset in </span>the<span class="markdown"> context's canvas.</span></span></span><br><span class="line"><span class="comment"><span class="markdown">///</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// Do not call this function directly. If </span>you<span class="markdown"> wish to paint yourself, call</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// [markNeedsPaint] instead to schedule </span>a<span class="markdown"> call to this function. If </span>you<span class="markdown"> wish</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// to paint one of </span>your<span class="markdown"> children, call [PaintingContext.paintChild] on </span>the<span class="markdown"></span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// given <span class="code">`context`</span>.</span></span></span><br><span class="line"><span class="comment"><span class="markdown">///</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// When painting one of </span>your<span class="markdown"> children (via </span>a<span class="markdown"> paint child function on </span>the<span class="markdown"></span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// given context), </span>the<span class="markdown"> current canvas held by </span>the<span class="markdown"> context might change</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// because draw operations before and after painting children might need to</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// be recorded on separate compositing layers.</span></span></span><br><span class="line"><span class="keyword">void</span> paint(PaintingContext context, Offset offset) &#123; &#125;</span><br></pre></td></tr></table></figure><p>所有的<code>RenderObject</code>子类都必须实现<code>paint()</code>方法，并且该方法并不是给用户直接调用，需要更新绘制时，可以通过<code>markNeddsPaint()</code>方法去触发界面绘制。按照正常流程，在经历大小和布局等位置计算之后，最终<code>paint()</code>方法就会被调用，该方法有两个参数，它们是完成绘制的关键。</p><ul><li><code>PaintingContext</code>的关键是<strong>A place to paint</strong>，同时它在父类<code>ClipContext</code>是包含有<code>Canvas</code>，并且<code>PaintingContext</code>的构造方法是<code>@protected</code>，只在<code>PaintingContext.repaintCompositedChild</code>和<code>pushLayer</code>时自动创建。</li><li><code>Offset</code>在<code>paint()</code>中主要是提供当前控件在屏幕的相对偏移值，提供绘制时确定绘制的坐标。</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/// A place to paint.</span></span></span><br><span class="line"><span class="comment"><span class="markdown">///</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// Rather than holding </span>a<span class="markdown"> canvas directly, [RenderObject]s paint using </span>a<span class="markdown"> painting</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// context. The painting context has </span>a<span class="markdown"> [Canvas], which receives </span>the<span class="markdown"></span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// individual draw operations, and also has functions for painting child</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// render objects.</span></span></span><br><span class="line"><span class="comment"><span class="markdown">///</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// When painting </span>a<span class="markdown"> child render object, </span>the<span class="markdown"> canvas held by </span>the<span class="markdown"> painting context</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// can change because </span>the<span class="markdown"> draw operations issued before and after painting </span>the<span class="markdown"></span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// child might be recorded in separate compositing layers. For this reason, do</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// not hold </span>a<span class="markdown"> reference to </span>the<span class="markdown"> canvas across operations that might paint</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// child render objects.</span></span></span><br><span class="line"><span class="comment"><span class="markdown">///</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// New [PaintingContext] objects </span>are<span class="markdown"> created automatically when using</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// [PaintingContext.repaintCompositedChild] and [pushLayer].</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaintingContext</span> <span class="keyword">extends</span> <span class="title">ClipContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment"><span class="markdown">/// Creates </span>a<span class="markdown"> painting context.</span></span></span><br><span class="line">  <span class="comment"><span class="markdown">///</span></span></span><br><span class="line">  <span class="comment"><span class="markdown">/// Typically only called by [PaintingContext.repaintCompositedChild]</span></span></span><br><span class="line">  <span class="comment"><span class="markdown">/// and [pushLayer].</span></span></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  PaintingContext(<span class="keyword">this</span>._containerLayer, <span class="keyword">this</span>.estimatedBounds)</span><br><span class="line">    : <span class="keyword">assert</span>(_containerLayer != <span class="keyword">null</span>),</span><br><span class="line">      <span class="keyword">assert</span>(estimatedBounds != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> ContainerLayer _containerLayer;</span><br></pre></td></tr></table></figure><p><code>PaintingContext</code>，从字面上可以看出来它是存在上下文关系，它是在哪开始创建的呢？</p><p>通过源码可以知道，项目在<code>runApp()</code>时，通过<code>WidgetsFlutterBinding</code>启动，而<code>WidgetsFlutterBinding</code>是一个“胶水类”，它会触发Mixins的<code>RenderBinding</code>，如下，创建根node的<code>PaintingContext</code>。</p><img src="/2019/09/25/九、深入理解绘制原理/1569401737(1).jpg"><p>那么<code>Offset</code>呢？在<code>RenderBoxContainerDefaultsMixin</code>可以看到：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/// Paints each child by walking </span>the<span class="markdown"> child list forwards.</span></span></span><br><span class="line"><span class="comment"><span class="markdown">///</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// See also:</span></span></span><br><span class="line"><span class="comment"><span class="markdown">///</span></span></span><br><span class="line"><span class="comment"><span class="markdown">///  * [defaultHitTestChildren], which implements hit-testing of </span>the<span class="markdown"> children</span></span></span><br><span class="line"><span class="comment"><span class="markdown">///    in </span>a<span class="markdown"> manner appropriate for this painting strategy.</span></span></span><br><span class="line"><span class="keyword">void</span> defaultPaint(PaintingContext context, Offset offset) &#123;</span><br><span class="line">  ChildType child = firstChild;</span><br><span class="line">  <span class="keyword">while</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> ParentDataType childParentData = child.parentData;</span><br><span class="line">    context.paintChild(child, childParentData.offset + offset);</span><br><span class="line">    child = childParentData.nextSibling;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<code>Offset</code>的传递，是通过父控件和子控件的<code>offset</code>相加之后，一级一级的将需要绘制的坐标结合去传递的。</p><p>简单来说，<strong>通过<code>PaintingContext</code>和<code>Offset</code>，在布局之后九可以在屏幕上准确绘制绘制需要的画面</strong>。</p><h2 id="1-1-测试绘制"><a href="#1-1-测试绘制" class="headerlink" title="1.1 测试绘制"></a>1.1 测试绘制</h2><p>来做一个简单测试。</p><p>在屏幕上通过<code>Container</code>限制一个高为60的绿色容器，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通过前面知道了&lt;code&gt;Widget&lt;/code&gt;、&lt;code&gt;Element&lt;/code&gt;、&lt;code&gt;RenderObject&lt;/code&gt;的关系，也知道&lt;code&gt;Widget&lt;/code&gt;的布局逻辑，最终所有&lt;code&gt;Widget&lt;/code&gt;都转化为&lt;code
      
    
    </summary>
    
      <category term="Flutter" scheme="https://tylerLiu.top/categories/Flutter/"/>
    
      <category term="学习" scheme="https://tylerLiu.top/categories/Flutter/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Flutter" scheme="https://tylerLiu.top/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>八、实用技巧与填坑</title>
    <link href="https://tylerLiu.top/2019/09/25/%E5%85%AB%E3%80%81%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7%E4%B8%8E%E5%A1%AB%E5%9D%91/"/>
    <id>https://tylerLiu.top/2019/09/25/八、实用技巧与填坑/</id>
    <published>2019-09-25T03:03:25.000Z</published>
    <updated>2019-09-25T07:36:12.005Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Text的TextOverflow-ellipsis不生效"><a href="#1-Text的TextOverflow-ellipsis不生效" class="headerlink" title="1. Text的TextOverflow.ellipsis不生效"></a>1. Text的TextOverflow.ellipsis不生效</h1><p>设置没有生效，提示如下<code>overflow</code>的警告。大部分时候，这是<code>Text</code>内部的<code>RenderParagraph</code>在判断<code>final bool didOverflowWidth = size.with &lt; textSize.width;</code>时，<code>size.width</code>和<code>textSize.width</code>相等导致。</p><p>这需要给<code>Text</code>设置一个<code>Container</code>之类的去约束它的大小，或者是<code>Row</code>中通过<code>Expanded</code> + <code>Container</code>去约束<code>Text</code>。</p><h1 id="2-获取控件的大小和位置"><a href="#2-获取控件的大小和位置" class="headerlink" title="2. 获取控件的大小和位置"></a>2. 获取控件的大小和位置</h1><p>前面有介绍过，可以用<code>GlobalKey</code>，通过<code>key</code>去获取到控件对象的<code>buildContext</code>，而前面也说过<code>BuildContext</code>的实现其实是<code>Element</code>，而<code>Element</code>持有<code>RenderObject</code>。所以，<code>RenderObject</code>实际上就是<code>RenderBox</code>，那么通过<code>RenderBox</code>就可以获取控件的大小和位置了：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">showSizes() &#123;</span><br><span class="line">  RenderBox renderBoxRed = fileListKey.currentContext.findRenderObject();</span><br><span class="line">  <span class="built_in">print</span>(renderBoxRed.size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showPositions() &#123;</span><br><span class="line">  RenderBox renderBoxRed = fileListKey.currentContext.findRenderObject();</span><br><span class="line">  <span class="built_in">print</span>(renderBoxRed.localToGlobal(Offset.zero));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-获取状态栏高度和安全布局"><a href="#3-获取状态栏高度和安全布局" class="headerlink" title="3. 获取状态栏高度和安全布局"></a>3. 获取状态栏高度和安全布局</h1><p><code>MaterialApp</code>源码内部是一个<code>WidgetApp</code>，而<code>WidgetApp</code>内有一个<code>MediaQuery</code>，所以可以通过<code>MediaQuery.of(context).size</code>去获取屏幕的大小。</p><p><code>MediaQuery</code>其实是一个<code>InheritedWidget</code>，里面有一个<code>MediaQueryData</code>参数，该参数是通过下面的代码设置的，在通过源码可以知道，一般情况下<code>MediaQueryData</code>的<code>padding</code>的<code>top</code>就是状态栏的高度。所以，可以通过<code>MediaQueryData.fromWindow(WidgetsBinding.instance.window).padding.top</code>获取到状态栏高度，有时可能需要考虑<code>viewInsets</code>参数。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoWindow</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MediaQuery(</span><br><span class="line">      data: MediaQueryData.fromWindow(WidgetsBinding.instance.<span class="built_in">window</span>),</span><br><span class="line">      child: Localizations(locale: <span class="keyword">null</span>, delegates: <span class="keyword">null</span>),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于<code>AppBar</code>的高度，默认是<code>Size.fromHeight(kToolBarHeight + (bottom?.perferredSize?.height ?? 0.0)),</code>，<code>kToolBarHeight</code>是一个固定的数值，可以通过实现<code>PerferredSizeWidget</code>去自定义<code>AppBar</code>。</p><p>有时布局位置是从状态栏开始计算的，这时需要用<code>SafeArea</code>嵌套下，原因是因为<code>MediaQueryData</code>的存在，具体需要查看源码。</p><h1 id="4-设置状态栏颜色和图标颜色"><a href="#4-设置状态栏颜色和图标颜色" class="headerlink" title="4. 设置状态栏颜色和图标颜色"></a>4. 设置状态栏颜色和图标颜色</h1><p>可以通过<code>AppBar</code>的<code>brightness</code>或者<code>ThemeData</code>去设置状态栏颜色。</p><p>如果不想用<code>AppBar</code>，可以嵌套<code>AnnotateRegion&lt;SystemUiOverlayStyle&gt;</code>去设置状态栏样式，通过<code>SystemUiOverlayStyle</code>就可以快速设置状态栏和底部导航栏的样式。</p><p>同时还可以通过<code>SystemChrome.setSystemUIOverlayStyle</code>去设置，前提是，没有使用<code>AppBar</code>。<strong>注意，所有状态栏设置都是全局的</strong>。如果在A页面设置之后，在B页面没有手动设置或者使用<code>AppBar</code>，那么设置的状态栏就会显示在B页面。</p><h1 id="5-系统字体缩放"><a href="#5-系统字体缩放" class="headerlink" title="5. 系统字体缩放"></a>5. 系统字体缩放</h1><p>现在一般手机都有字体缩放，大多时候，会选择禁止应用字体跟随系统字体缩放。</p><p>Flutter中的字体缩放和<code>MediaQueryData</code>和<code>textScaleFactor</code>有关。可以在需要的页面，通过最外层嵌套如下代码设置，将字体设置为默认不允许缩放。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MediaQuery(</span><br><span class="line">    data: MediaQueryData.fromWindow(WidgetsBinding.instance.<span class="built_in">window</span>).copyWith(textScaleFactor: <span class="number">1</span>),</span><br><span class="line">    child: <span class="keyword">new</span> Container(),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h1 id="6-Margin和Padding"><a href="#6-Margin和Padding" class="headerlink" title="6. Margin和Padding"></a>6. Margin和Padding</h1><p>在使用<code>Container</code>时，经常会使用<code>margin</code>和<code>padding</code>，<code>Container</code>其实只是对各种布局的封装，内部的<code>margin</code>和<code>padding</code>其实是通过<code>Padding</code>实现的，而<code>Padding</code>不支持负数，如果需要使用负数，可以使用<code>Transform</code>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Transform(</span><br><span class="line">  transform: Matrix4.translationValues(<span class="number">10</span>, <span class="number">-10</span>, <span class="number">0</span>),</span><br><span class="line">  child: <span class="keyword">new</span> Container(),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h1 id="7-控件圆角剪切"><a href="#7-控件圆角剪切" class="headerlink" title="7. 控件圆角剪切"></a>7. 控件圆角剪切</h1><p>日常开发中大致会用到两种圆角方案：</p><ul><li>通过<code>Decoration</code>的实现类<code>BoxDecoration</code>去实现。</li><li>通过<code>ClipRRect</code>去实现。</li></ul><p>其中<code>BoxDecoration</code>一般用在<code>DecoratedBox</code>、<code>Container</code>等控件，这种实现一般都是直接<code>Canvas</code>绘制时，针对当前控件进行背景圆角化，并不会影响其child。意味着如果child也是图片或者也有背景色，圆角效果就有可能消失。</p><p>而<code>ClipRRect</code>的效果就会影响child，如下<code>RenderObject</code>源码可知：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/// Clip further painting using </span>a<span class="markdown"> rounded rectangle.</span></span></span><br><span class="line"><span class="comment"><span class="markdown">///</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// &#123;@macro flutter.rendering.object.needsCompositing&#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// * <span class="code">`offset`</span> is </span>the<span class="markdown"> offset from </span>the<span class="markdown"> origin of </span>the<span class="markdown"> canvas' coordinate system</span></span></span><br><span class="line"><span class="comment"><span class="markdown">///   to </span>the<span class="markdown"> origin of </span>the<span class="markdown"> caller's coordinate system.</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// * <span class="code">`bounds`</span> is </span>the<span class="markdown"> region of </span>the<span class="markdown"> canvas (in </span>the<span class="markdown"> caller's coordinate system)</span></span></span><br><span class="line"><span class="comment"><span class="markdown">///   into which <span class="code">`painter`</span> </span>will<span class="markdown"> paint in.</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// * <span class="code">`clipRRect`</span> is </span>the<span class="markdown"> rounded-rectangle (in </span>the<span class="markdown"> caller's coordinate system)</span></span></span><br><span class="line"><span class="comment"><span class="markdown">///   to use to clip </span>the<span class="markdown"> painting done by <span class="code">`painter`</span>.</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// * <span class="code">`painter`</span> is </span>a<span class="markdown"> callback that </span>will<span class="markdown"> paint with </span>the<span class="markdown"> <span class="code">`clipRRect`</span> applied. This</span></span></span><br><span class="line"><span class="comment"><span class="markdown">///   function calls </span>the<span class="markdown"> <span class="code">`painter`</span> synchronously.</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// * <span class="code">`clipBehavior`</span> controls how </span>the<span class="markdown"> path is clipped.</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// &#123;@macro flutter.rendering.object.oldLayer&#125;</span></span></span><br><span class="line">ClipRRectLayer pushClipRRect(<span class="built_in">bool</span> needsCompositing, Offset offset, Rect bounds, RRect clipRRect, PaintingContextCallback painter, &#123; Clip clipBehavior = Clip.antiAlias, ClipRRectLayer oldLayer &#125;) &#123;</span><br><span class="line">  <span class="keyword">assert</span>(clipBehavior != <span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">final</span> Rect offsetBounds = bounds.shift(offset);</span><br><span class="line">  <span class="keyword">final</span> RRect offsetClipRRect = clipRRect.shift(offset);</span><br><span class="line">  <span class="keyword">if</span> (needsCompositing) &#123;</span><br><span class="line">    <span class="keyword">final</span> ClipRRectLayer layer = oldLayer ?? ClipRRectLayer();</span><br><span class="line">    layer</span><br><span class="line">      ..clipRRect = offsetClipRRect</span><br><span class="line">      ..clipBehavior = clipBehavior;</span><br><span class="line">    pushLayer(layer, painter, offset, childPaintBounds: offsetBounds);</span><br><span class="line">    <span class="keyword">return</span> layer;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    clipRRectAndPaint(offsetClipRRect, clipBehavior, offsetBounds, () =&gt; painter(<span class="keyword">this</span>, offset));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8-PageView"><a href="#8-PageView" class="headerlink" title="8. PageView"></a>8. PageView</h1><p>如果在使用<code>TarBarView</code>，并且使用<code>KeepAlive</code>的话，推荐使用<code>PageView</code>。因为在1.2版本中，在<code>KeepAlive</code>的状态下，跨两个页面以上的Tab直接切换，<code>TabBarView</code>会导致页面的<code>dispose()</code>，再重新<code>initState()</code>。尽管<code>TarBarView</code>内部封装了<code>PageView</code> + <code>TabBar</code>。</p><p>可以直接使用<code>PageView</code> + <code>TabBar</code>去实现，在tab切换时，使用<code>_pageController.jumpTo(MediaQuery.of(context).size.with * index);</code>可以避免一些问题。当然，这时损失的就是动画效果。事实上，<code>TarBarView</code>只是针对<code>PageView</code> + <code>TabBar</code>进行了封装。</p><p>除了这个，还有第二个方法，使用如下<code>PageStorageKey</code>保持页面数状态，因为它是<strong>save and restore values</strong>，所以页面的<code>dispose()</code>再重新<code>initState()</code>方法，每次都会被调用。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Scaffold(</span><br><span class="line">  key: <span class="keyword">new</span> PageStorageKey&lt;your value type&gt;(your value)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="9-懒加载"><a href="#9-懒加载" class="headerlink" title="9. 懒加载"></a>9. 懒加载</h1><p>Flutter中通过<code>FutureBuilder</code>或者<code>StreamBuilder</code>可以简单的实现懒加载，通过<code>future</code>或者<code>stream</code>“异步”获取数据，之后通过<code>AsyncSnapshot</code>的<code>data</code>再去加载数据，至于流和异步的概念，后面再展开讲解。</p><h1 id="10-Android返回键回到桌面"><a href="#10-Android返回键回到桌面" class="headerlink" title="10. Android返回键回到桌面"></a>10. Android返回键回到桌面</h1><p>Flutter官方提供了<a href="https://github.com/flutter/plugins/tree/master/packages/android_intent" target="_blank" rel="noopener">android_intent</a>插件，实现回到桌面可以按照如下实现：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  Future&lt;<span class="built_in">bool</span>&gt; _dialogExitApp(BuildContext context) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Platform.isAndroid) &#123;</span><br><span class="line">      AndroidIntent intent = AndroidIntent(</span><br><span class="line">        action: <span class="string">'android.intent.action.MAIN'</span>,</span><br><span class="line">        category: <span class="string">"android.intent.category.HOME"</span>,</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">await</span> intent.launch();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Future.value(<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">·····</span><br><span class="line"> <span class="keyword">return</span> WillPopScope(</span><br><span class="line">      onWillPop: () &#123;</span><br><span class="line">        <span class="keyword">return</span> _dialogExitApp(context);</span><br><span class="line">      &#125;,</span><br><span class="line">      child:xxx);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Text的TextOverflow-ellipsis不生效&quot;&gt;&lt;a href=&quot;#1-Text的TextOverflow-ellipsis不生效&quot; class=&quot;headerlink&quot; title=&quot;1. Text的TextOverflow.ellipsis不
      
    
    </summary>
    
      <category term="Flutter" scheme="https://tylerLiu.top/categories/Flutter/"/>
    
      <category term="学习" scheme="https://tylerLiu.top/categories/Flutter/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Flutter" scheme="https://tylerLiu.top/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>七、深入布局原理</title>
    <link href="https://tylerLiu.top/2019/09/24/%E4%B8%83%E3%80%81%E6%B7%B1%E5%85%A5%E5%B8%83%E5%B1%80%E5%8E%9F%E7%90%86/"/>
    <id>https://tylerLiu.top/2019/09/24/七、深入布局原理/</id>
    <published>2019-09-24T08:36:59.000Z</published>
    <updated>2019-09-25T03:02:35.852Z</updated>
    
    <content type="html"><![CDATA[<p>前面了解了<code>Widget</code>、<code>Element</code>、<code>RenderObject</code>三者之间的关系，<code>Widget</code>是作为“配置文件”存在的，在Flutter中，其功能比较单一。</p><h1 id="1-单子元素布局"><a href="#1-单子元素布局" class="headerlink" title="1. 单子元素布局"></a>1. 单子元素布局</h1><p>在Flutter单子元素的布局<code>Widget</code>中，<code>Container</code>使用广泛，因为它在功能上并不会像<code>Padding</code>等<code>Widget</code>那样功能单一，为什么呢？</p><p><code>Container</code>的<code>build()</code>的实现：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  Widget current = child;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (child == <span class="keyword">null</span> &amp;&amp; (constraints == <span class="keyword">null</span> || !constraints.isTight)) &#123;</span><br><span class="line">    current = LimitedBox(</span><br><span class="line">      maxWidth: <span class="number">0.0</span>,</span><br><span class="line">      maxHeight: <span class="number">0.0</span>,</span><br><span class="line">      child: ConstrainedBox(constraints: <span class="keyword">const</span> BoxConstraints.expand()),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (alignment != <span class="keyword">null</span>)</span><br><span class="line">    current = Align(alignment: alignment, child: current);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> EdgeInsetsGeometry effectivePadding = _paddingIncludingDecoration;</span><br><span class="line">  <span class="keyword">if</span> (effectivePadding != <span class="keyword">null</span>)</span><br><span class="line">    current = Padding(padding: effectivePadding, child: current);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (decoration != <span class="keyword">null</span>)</span><br><span class="line">    current = DecoratedBox(decoration: decoration, child: current);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (foregroundDecoration != <span class="keyword">null</span>) &#123;</span><br><span class="line">    current = DecoratedBox(</span><br><span class="line">      decoration: foregroundDecoration,</span><br><span class="line">      position: DecorationPosition.foreground,</span><br><span class="line">      child: current,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (constraints != <span class="keyword">null</span>)</span><br><span class="line">    current = ConstrainedBox(constraints: constraints, child: current);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (margin != <span class="keyword">null</span>)</span><br><span class="line">    current = Padding(padding: margin, child: current);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (transform != <span class="keyword">null</span>)</span><br><span class="line">    current = Transform(transform: transform, child: current);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码可以看出，<code>Container</code>其实也只是把其他“单一”的<code>Widget</code>进行了二次封装，然后通过配置来达到“多功能”的效果。</p><p>接着查看<code>ContainerBox</code>的源码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConstrainedBox</span> <span class="keyword">extends</span> <span class="title">SingleChildRenderObjectWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment"><span class="markdown">/// Creates </span>a<span class="markdown"> widget that imposes additional constraints on its child.</span></span></span><br><span class="line">  <span class="comment"><span class="markdown">///</span></span></span><br><span class="line">  <span class="comment"><span class="markdown">/// The [constraints] argument must not be null.</span></span></span><br><span class="line">  ConstrainedBox(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.constraints,</span><br><span class="line">    Widget child,</span><br><span class="line">  &#125;) : <span class="keyword">assert</span>(constraints != <span class="keyword">null</span>),</span><br><span class="line">       <span class="keyword">assert</span>(constraints.debugAssertIsValid()),</span><br><span class="line">       <span class="keyword">super</span>(key: key, child: child);</span><br><span class="line"></span><br><span class="line">  <span class="comment"><span class="markdown">/// The additional constraints to impose on </span>the<span class="markdown"> child.</span></span></span><br><span class="line">  <span class="keyword">final</span> BoxConstraints constraints;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  RenderConstrainedBox createRenderObject(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> RenderConstrainedBox(additionalConstraints: constraints);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> updateRenderObject(BuildContext context, RenderConstrainedBox renderObject) &#123;</span><br><span class="line">    renderObject.additionalConstraints = constraints;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> debugFillProperties(DiagnosticPropertiesBuilder properties) &#123;</span><br><span class="line">    <span class="keyword">super</span>.debugFillProperties(properties);</span><br><span class="line">    properties.add(DiagnosticsProperty&lt;BoxConstraints&gt;(<span class="string">'constraints'</span>, constraints, showName: <span class="keyword">false</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码可以看出，它继承了<code>SingleChildRenderObjectWidget</code>，重写了<code>createRenderObject()</code>，返回<code>RenderConstrainedBox</code>。<code>RenderConstrainedBox</code>继承自<code>RenderBox</code>，从而实现了<code>RenderObject</code>布局，关系是：</p><table><thead><tr><th align="center">Widget</th><th align="center">RenderBox（RenderObject）</th></tr></thead><tbody><tr><td align="center">ConstrainedBox</td><td align="center">RenderConstrainedBox</td></tr></tbody></table><p>再来看看其他<code>Widget</code>，可以看到它们都是继承<code>SingleChildRenderObjectWidget</code>，简单来说，它们的不同之处就是<code>RenderObject</code>的实现：</p><table><thead><tr><th align="center">Widget</th><th align="center">RenderBox（RenderObject）</th></tr></thead><tbody><tr><td align="center">Align</td><td align="center">RenderPositionBox</td></tr><tr><td align="center">Padding</td><td align="center">RenderPadding</td></tr><tr><td align="center">Transform</td><td align="center">RenderTransform</td></tr><tr><td align="center">Offstage</td><td align="center">RenderOffstage</td></tr></tbody></table><p>总结：<strong>真正的布局和大小计算等行为，都是在<code>RenderBox</code>上实现的</strong>。不同<code>Widget</code>通过各自<code>RenderBox</code>实现不同的布局效果。<strong>所以找每个<code>Widget</code>的实现，找它们的<code>RenderBox</code>即可</strong>。</p><p>这里以<code>Offstage</code>为例，<code>Offstage</code>是通过<code>offstage</code>标志控制<code>child</code>是否显示的效果，它也有一个<code>RenderOffstage</code>，如下，通过<code>RenderOffstage</code>的源码可以看到<code>offstage</code>标志位的作用：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="built_in">double</span> computeMinIntrinsicWidth(<span class="built_in">double</span> height) &#123;</span><br><span class="line">  <span class="keyword">if</span> (offstage)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">super</span>.computeMinIntrinsicWidth(height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="built_in">double</span> computeMaxIntrinsicWidth(<span class="built_in">double</span> height) &#123;</span><br><span class="line">  <span class="keyword">if</span> (offstage)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">super</span>.computeMaxIntrinsicWidth(height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="built_in">double</span> computeMinIntrinsicHeight(<span class="built_in">double</span> width) &#123;</span><br><span class="line">  <span class="keyword">if</span> (offstage)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">super</span>.computeMinIntrinsicHeight(width);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="built_in">double</span> computeMaxIntrinsicHeight(<span class="built_in">double</span> width) &#123;</span><br><span class="line">  <span class="keyword">if</span> (offstage)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">super</span>.computeMaxIntrinsicHeight(width);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以大部分时候，<code>Widget</code>都是通过实现<code>RenderBox</code>实现布局的，<strong>因此可以直接使用<code>RenderBox</code>，而不使用<code>Widget</code></strong>。</p><p>Flutter官方提供了一个<code>CustomSingleChildLayout</code>的类，它抽象了<code>SingleChildLayoutDelegate</code>的对象，使开发者可以方便的使用<code>RenderBox</code>来自定义效果。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomSingleChildLayout</span> <span class="keyword">extends</span> <span class="title">SingleChildRenderObjectWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment"><span class="markdown">/// Creates </span>a<span class="markdown"> custom single child layout.</span></span></span><br><span class="line">  <span class="comment"><span class="markdown">///</span></span></span><br><span class="line">  <span class="comment"><span class="markdown">/// The [delegate] argument must not be null.</span></span></span><br><span class="line">  <span class="keyword">const</span> CustomSingleChildLayout(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.delegate,</span><br><span class="line">    Widget child,</span><br><span class="line">  &#125;) : <span class="keyword">assert</span>(delegate != <span class="keyword">null</span>),</span><br><span class="line">       <span class="keyword">super</span>(key: key, child: child);</span><br><span class="line"></span><br><span class="line">  <span class="comment"><span class="markdown">/// The delegate that controls </span>the<span class="markdown"> layout of </span>the<span class="markdown"> child.</span></span></span><br><span class="line">  <span class="keyword">final</span> SingleChildLayoutDelegate delegate;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  RenderCustomSingleChildLayoutBox createRenderObject(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> RenderCustomSingleChildLayoutBox(delegate: delegate);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> updateRenderObject(BuildContext context, RenderCustomSingleChildLayoutBox renderObject) &#123;</span><br><span class="line">    renderObject.delegate = delegate;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看看<code>SingleChildLayoutDelegate</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleChildLayoutDelegate</span> </span>&#123;</span><br><span class="line">  <span class="comment"><span class="markdown">/// Creates </span>a<span class="markdown"> layout delegate.</span></span></span><br><span class="line">  <span class="comment"><span class="markdown">///</span></span></span><br><span class="line">  <span class="comment"><span class="markdown">/// The layout </span>will<span class="markdown"> update whenever [relayout] notifies its listeners.</span></span></span><br><span class="line">  <span class="keyword">const</span> SingleChildLayoutDelegate(&#123; Listenable relayout &#125;) : _relayout = relayout;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Listenable _relayout;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下面前三个方法是按照顺序执行的</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 给定大小</span></span><br><span class="line">  Size getSize(BoxConstraints constraints) =&gt; constraints.biggest;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 约束限制子控件的大小</span></span><br><span class="line">  BoxConstraints getConstraintsForChild(BoxConstraints constraints) =&gt; constraints;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 确定位置</span></span><br><span class="line">  Offset getPositionForChild(Size size, Size childSize) =&gt; Offset.zero;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否需要重新布局</span></span><br><span class="line">  <span class="built_in">bool</span> shouldRelayout(covariant SingleChildLayoutDelegate oldDelegate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再在<code>RenderCustomSingleChildLayoutBox</code>中使用：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/// A delegate that controls this object's layout.</span></span></span><br><span class="line">SingleChildLayoutDelegate <span class="keyword">get</span> delegate =&gt; _delegate;</span><br><span class="line">SingleChildLayoutDelegate _delegate;</span><br><span class="line"><span class="keyword">set</span> delegate(SingleChildLayoutDelegate newDelegate) &#123;</span><br><span class="line">  <span class="keyword">assert</span>(newDelegate != <span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">if</span> (_delegate == newDelegate)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">final</span> SingleChildLayoutDelegate oldDelegate = _delegate;</span><br><span class="line">  <span class="keyword">if</span> (newDelegate.runtimeType != oldDelegate.runtimeType || newDelegate.shouldRelayout(oldDelegate))</span><br><span class="line">    markNeedsLayout();</span><br><span class="line">  _delegate = newDelegate;</span><br><span class="line">  <span class="keyword">if</span> (attached) &#123;</span><br><span class="line">    oldDelegate?._relayout?.removeListener(markNeedsLayout);</span><br><span class="line">    newDelegate?._relayout?.addListener(markNeedsLayout);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> performLayout() &#123;</span><br><span class="line">  size = _getSize(constraints);</span><br><span class="line">  <span class="keyword">if</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> BoxConstraints childConstraints = delegate.getConstraintsForChild(constraints);</span><br><span class="line">    <span class="keyword">assert</span>(childConstraints.debugAssertIsValid(isAppliedConstraint: <span class="keyword">true</span>));</span><br><span class="line">    child.layout(childConstraints, parentUsesSize: !childConstraints.isTight);</span><br><span class="line">    <span class="keyword">final</span> BoxParentData childParentData = child.parentData;</span><br><span class="line">    childParentData.offset = delegate.getPositionForChild(size, childConstraints.isTight ? childConstraints.smallest : child.size);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从而控制<code>RenderBox</code>的布局位置、大小等。</p><h1 id="2-多子元素布局"><a href="#2-多子元素布局" class="headerlink" title="2. 多子元素布局"></a>2. 多子元素布局</h1><p>多子元素布局和单子元素布局类似，比如：</p><ul><li><code>Row</code>、<code>Colum</code>都继承了<code>Flex</code>，而<code>Flex</code>继承了<code>MultiChildRenderObjectWidget</code>，并通过<code>RenderFlex</code>创建<code>RenderBox</code>；</li><li><code>Stack</code>同样继承了<code>MultiChildRenderObjectWidget</code>，并通过<code>RenderStack</code>创建<code>RenderBox</code>。</li></ul><table><thead><tr><th align="center">Widget</th><th align="center">RenderBox（RenderObject）</th></tr></thead><tbody><tr><td align="center">Row/Colum/Flex</td><td align="center">RenderFlex</td></tr><tr><td align="center">Stack</td><td align="center">RenderStack</td></tr><tr><td align="center">Flow</td><td align="center">RenderFlow</td></tr><tr><td align="center">Wrap</td><td align="center">RenderWrap</td></tr></tbody></table><p>同样，多子元素布局也提供了<code>CustomMultiChildLayout</code>和<code>MultiChildLayoutDelegate</code>来满足不同的需求。</p><h1 id="3-多子元素滑动布局"><a href="#3-多子元素滑动布局" class="headerlink" title="3. 多子元素滑动布局"></a>3. 多子元素滑动布局</h1><p>滑动布局作为多子元素的一个分支，如<code>ListView</code>、<code>GridView</code>、<code>PageView</code>，它们在实现上要复杂的多，下面是它们的关系图：</p><img src="/2019/09/24/七、深入布局原理/1569376398.jpg"><p>从上图可知，最终会产生两个<code>RenderObject</code>：</p><ul><li><code>RenderSliver</code>：Base class for the render objects that implement scroll effects in viewports.</li><li><code>RenderViewpotr</code>：A render object that is bigger on the inside.</li></ul><p><code>RenderViewport</code>的部分注释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/// [RenderViewport] cannot contain [RenderBox] children directly. Instead, use</span><br><span class="line">/// a [RenderSliverList], [RenderSliverFixedExtentList], [RenderSliverGrid], or</span><br><span class="line">/// a [RenderSliverToBoxAdapter], for example.</span><br></pre></td></tr></table></figure><p>从这部分的注释可以看出，<code>RenderViewport</code>内部不能直接放置<code>RenderBox</code>，需要通过<code>RenderSliver</code>及其相关的类来完成布局。从源码可知：<strong><code>RenderViewport</code>对应的<code>Widget</code> <code>Viewpoer</code>就是一个<code>MultiChildRenderObjectWidget</code></strong>。这就又回到了<code>MultiChildRenderObjectWidget</code>。</p><p>再简单说明上面的流程图：</p><ul><li><code>ListView</code>、<code>GridView</code>、<code>PageView</code>等都是通过<code>Scrollable</code>、<code>Viewport</code>、<code>Sliver</code>家族实现的效果。这里可以简单理解为：一个“可滑动”控件，嵌套了一个“视觉窗口”，内部通过“碎片”展示children。</li><li>不同的是<code>PageView</code>没有继承<code>ScrollView</code>，而是直接通过<code>NotificationListener</code>和<code>ScrollNotification</code>嵌套实现。</li></ul><blockquote><p><code>TabBarView</code>内部就是<code>NotificationListener</code> + <code>PageView</code>。</p></blockquote><p>官方提供了自定义滑动<code>CustomScrollView</code>，它继承了<code>ScrollView</code>，可以通过<code>slivers</code>参数实现布局，这些<code>slivers</code>最终通过<code>Scrollable</code>的<code>buildViewport</code>添加到<code>Viewport</code>中，代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomScrollViewDemo</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> CustomScrollView(</span><br><span class="line">      slivers: &lt;Widget&gt;[</span><br><span class="line">        <span class="keyword">const</span> SliverAppBar(</span><br><span class="line">          pinned: <span class="keyword">true</span>,</span><br><span class="line">          expandedHeight: <span class="number">250.0</span>,</span><br><span class="line">          flexibleSpace: FlexibleSpaceBar(</span><br><span class="line">            title: Text(<span class="string">"CustomScrollViewDemo"</span>),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">        SliverGrid(</span><br><span class="line">          gridDelegate: SliverGridDelegateWithMaxCrossAxisExtent(</span><br><span class="line">            maxCrossAxisExtent: <span class="number">200.0</span>,</span><br><span class="line">            mainAxisSpacing: <span class="number">10.0</span>,</span><br><span class="line">            crossAxisSpacing: <span class="number">10.0</span>,</span><br><span class="line">            childAspectRatio: <span class="number">4.0</span>,</span><br><span class="line">          ),</span><br><span class="line">          delegate: SliverChildBuilderDelegate(</span><br><span class="line">            (BuildContext context, <span class="built_in">int</span> index) &#123;</span><br><span class="line">              <span class="keyword">return</span> Container(</span><br><span class="line">                alignment: Alignment.center,</span><br><span class="line">                color: Colors.teal[<span class="number">100</span> * (index % <span class="number">9</span>)],</span><br><span class="line">                child: Text(<span class="string">'girid item <span class="subst">$index</span>'</span>),</span><br><span class="line">              );</span><br><span class="line">            &#125;,</span><br><span class="line">            childCount: <span class="number">20</span>,</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">        SliverFixedExtentList(</span><br><span class="line">          itemExtent: <span class="number">50.0</span>,</span><br><span class="line">          delegate: SliverChildBuilderDelegate((BuildContext context, <span class="built_in">int</span> index) &#123;</span><br><span class="line">            <span class="keyword">return</span> Container(</span><br><span class="line">              alignment: Alignment.center,</span><br><span class="line">              color: Colors.lightBlue[<span class="number">100</span> * (index % <span class="number">9</span>)],</span><br><span class="line">              child: Text(<span class="string">'list item <span class="subst">$index</span>'</span>),</span><br><span class="line">            );</span><br><span class="line">          &#125;),</span><br><span class="line">        ),</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面了解了&lt;code&gt;Widget&lt;/code&gt;、&lt;code&gt;Element&lt;/code&gt;、&lt;code&gt;RenderObject&lt;/code&gt;三者之间的关系，&lt;code&gt;Widget&lt;/code&gt;是作为“配置文件”存在的，在Flutter中，其功能比较单一。&lt;/p&gt;
&lt;h1
      
    
    </summary>
    
      <category term="Flutter" scheme="https://tylerLiu.top/categories/Flutter/"/>
    
      <category term="学习" scheme="https://tylerLiu.top/categories/Flutter/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Flutter" scheme="https://tylerLiu.top/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>六、深入Widget原理</title>
    <link href="https://tylerLiu.top/2019/09/24/%E5%85%AD%E3%80%81%E6%B7%B1%E5%85%A5Widget%E5%8E%9F%E7%90%86/"/>
    <id>https://tylerLiu.top/2019/09/24/六、深入Widget原理/</id>
    <published>2019-09-24T06:43:27.000Z</published>
    <updated>2019-09-24T08:34:46.228Z</updated>
    
    <content type="html"><![CDATA[<p><code>Widget</code>：<strong>并不是真正渲染的对象</strong>。事实上，在Flutter渲染是经历了从<code>Widget</code>到<code>Element</code>再到<code>RenderObject</code>的过程。</p><p><code>Widget</code>是不可变的，那么<code>Widget</code>是如何在不可变中去构建画面的？从前面知道，<code>Widget</code>是需要转换为<code>Element</code>去渲染的，从下面的注释可以知道，事实上<strong><code>Widget</code>只是<code>Element</code>的一个配置描述</strong>，告诉<code>Element</code>这个实例如何去渲染。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@immutable</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Widget</span> <span class="keyword">extends</span> <span class="title">DiagnosticableTree</span> </span>&#123;</span><br><span class="line">    <span class="comment"><span class="markdown">/// Inflates this configuration to </span>a<span class="markdown"> concrete instance.</span></span></span><br><span class="line">    <span class="comment"><span class="markdown">///</span></span></span><br><span class="line">    <span class="comment"><span class="markdown">/// A given widget can be included in </span>the<span class="markdown"> tree zero or </span>more<span class="markdown"> times. In particular</span></span></span><br><span class="line">    <span class="comment"><span class="markdown">/// </span>a<span class="markdown"> given widget can be placed in </span>the<span class="markdown"> tree multiple times. Each time </span>a<span class="markdown"> widget</span></span></span><br><span class="line">    <span class="comment"><span class="markdown">/// is placed in </span>the<span class="markdown"> tree, it is inflated into </span>an<span class="markdown"> [Element], which means </span>a<span class="markdown"></span></span></span><br><span class="line">    <span class="comment"><span class="markdown">/// widget that is incorporated into </span>the<span class="markdown"> tree multiple times </span>will<span class="markdown"> be inflated</span></span></span><br><span class="line">    <span class="comment"><span class="markdown">/// multiple times.</span></span></span><br><span class="line">    <span class="meta">@protected</span></span><br><span class="line">    <span class="built_in">Element</span> createElement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Widget</code>和<code>Element</code>之间是怎样的对应关系呢？从上面的注释可以知道：<strong><code>Widget</code>和<code>Element</code>之间是一对多的关系</strong>。实际上渲染树是由<code>Element</code>实例的节点构成的，而作为配置文件的<code>Widget</code>可能被复制到树的多个部分，对应产生多个<code>Element</code>对象。</p><p><code>RenderObject</code>又是什么呢？它和<code>Widget</code>、<code>Element</code>有什么关系？源码注释写道：<code>An object in the render tree</code>，可以看出，<code>RenderObject</code>才是实际的渲染对象，通过<code>Element</code>的源码可以看到：<strong><code>Element</code>持有<code>RenderObject</code>和<code>Widget</code></strong>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/// The configuration for this element.</span></span></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget <span class="keyword">get</span> widget =&gt; _widget;</span><br><span class="line">Widget _widget;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">/// The render object at (or below) this location in </span>the<span class="markdown"> tree.</span></span></span><br><span class="line"><span class="comment"><span class="markdown">///</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// If this object is </span>a<span class="markdown"> [RenderObjectElement], </span>the<span class="markdown"> render object is </span>the<span class="markdown"> one at</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// this location in </span>the<span class="markdown"> tree. Otherwise, this getter </span>will<span class="markdown"> walk down </span>the<span class="markdown"> tree</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// until it finds </span>a<span class="markdown"> [RenderObjectElement].</span></span></span><br><span class="line">RenderObject <span class="keyword">get</span> renderObject &#123;</span><br><span class="line">    RenderObject result;</span><br><span class="line">    <span class="keyword">void</span> visit(<span class="built_in">Element</span> element) &#123;</span><br><span class="line">      <span class="keyword">assert</span>(result == <span class="keyword">null</span>); <span class="comment">// this verifies that there's only one child</span></span><br><span class="line">      <span class="keyword">if</span> (element <span class="keyword">is</span> RenderObjectElement)</span><br><span class="line">        result = element.renderObject;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        element.visitChildren(visit);</span><br><span class="line">    &#125;</span><br><span class="line">    visit(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再结合：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/// Creates </span>an<span class="markdown"> instance of </span>the<span class="markdown"> [RenderObject] class that this</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// [RenderObjectWidget] represents, using </span>the<span class="markdown"> configuration described by this</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// [RenderObjectWidget].</span></span></span><br><span class="line"><span class="comment"><span class="markdown">///</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// This method </span>should<span class="markdown"> not do anything with </span>the<span class="markdown"> children of </span>the<span class="markdown"> render object.</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// That </span>should<span class="markdown"> instead be handled by </span>the<span class="markdown"> method that overrides</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// [RenderObjectElement.mount] in </span>the<span class="markdown"> object rendered by this object's</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// [createElement] method. See, for example,</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// [SingleChildRenderObjectElement.mount].</span></span></span><br><span class="line"><span class="meta">@protected</span></span><br><span class="line">RenderObject createRenderObject(BuildContext context);</span><br></pre></td></tr></table></figure><p>可以得出三者的关系：<strong>配置文件<code>Widget</code>生成了<code>Element</code>，而后创建<code>RenderObject</code>关联到<code>Element</code>的内部<code>renderObject</code>对象上，最后Flutter通过<code>RenderObject</code>数据来布局和绘制</strong>。理论上可以认为<code>RenderObject</code>是最终给Flutter的渲染数据，它保存了大小和位置等信息，Flutter通过它去绘制画面。</p><p>说到<code>RenderObject</code>，就需要说说<code>RenderBox</code>：<code>A render object in a 2D Cartesian coordinate system</code>，从注释可以看出，它是在继承<code>RenderObject</code>基础的布局和绘制功能上，实现了“笛卡尔坐标系”：以Top、Left为基点，通过宽高两个轴实现布局和嵌套的。</p><p><code>RenderBox</code>避免了直接使用<code>RenderObject</code>的麻烦场景，其中<code>RenderBox</code>的布局和计算大小是在<code>performLayout()</code>和<code>performSize()</code>两个方法中实现的，很多时候更多的是选择继承<code>RenderBox</code>去实现自定义。</p><p>综上情况：</p><ul><li><code>Widget</code>只是显示数据配置，所以相对而言是轻量级的存在，而Flutter中对<code>Widget</code>也做了一定的优化，所以每次改变状态导致的<code>Widget</code>重构并不会有太大的问题。</li><li><code>RenderObject</code>就不同了，<code>RenderObject</code>涉及到布局、计算、绘制等流程，要是每次都全部重新创建，开销就比较大。</li></ul><p>所以对于是否每次都创建新的<code>Element</code>和<code>RenderObject</code>对象，<code>Widget</code>都做了对应的判断以便于复用，比如：在<code>newWidget</code>与<code>oldWidget</code>的<code>runtimeType</code>和<code>key</code>相等时，会选择使用<code>newWidget</code>去更新已经存在的<code>Element</code>对象，否则就选择重新创建新的<code>Element</code>。</p><p>由此可知：<code>Widget</code>重新创建，<code>Element</code>树和<code>RenderObject</code>树并不会完全重新创建。</p><p>如何获取布局的大小和位置呢？</p><p>首先需要用到前面提过的<code>GlobalKey</code>，通过<code>key</code>获取控件对象的<code>BuildContext</code>，而<code>BuildContext</code>的实现其实是<code>Element</code>，而<code>Element</code>持有<code>RenderObject</code>，所以，<code>RenderObject</code>实际上获取的是<code>RenderBox</code>，那么通过<code>RenderBox</code>就能知道布局的大小和位置了。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">showSizes() &#123;</span><br><span class="line">    RenderBox renderBoxRed = fileListKey.currentContext.findRenderObject();</span><br><span class="line">    <span class="built_in">print</span>(renderBoxRed.size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showPositions() &#123;</span><br><span class="line">    RenderBox renderBoxRed = fileListKey.currentContext.findRenderObject();</span><br><span class="line">    <span class="built_in">print</span>(renderBoxRed.localToGlobal(Offset.zero));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;Widget&lt;/code&gt;：&lt;strong&gt;并不是真正渲染的对象&lt;/strong&gt;。事实上，在Flutter渲染是经历了从&lt;code&gt;Widget&lt;/code&gt;到&lt;code&gt;Element&lt;/code&gt;再到&lt;code&gt;RenderObject&lt;/code&gt;的过程
      
    
    </summary>
    
      <category term="Flutter" scheme="https://tylerLiu.top/categories/Flutter/"/>
    
      <category term="学习" scheme="https://tylerLiu.top/categories/Flutter/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Flutter" scheme="https://tylerLiu.top/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>五、深入探究</title>
    <link href="https://tylerLiu.top/2019/09/19/%E4%BA%94%E3%80%81%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6/"/>
    <id>https://tylerLiu.top/2019/09/19/五、深入探究/</id>
    <published>2019-09-19T09:15:45.000Z</published>
    <updated>2019-09-24T06:42:33.545Z</updated>
    
    <content type="html"><![CDATA[<p>Demo地址：<a href="https://gitee.com/QingFengBaiYu/tyler_flutter_app" target="_blank" rel="noopener">tyler_flutter_app</a></p><h1 id="1-WidgetsFlutterBinding"><a href="#1-WidgetsFlutterBinding" class="headerlink" title="1. WidgetsFlutterBinding"></a>1. WidgetsFlutterBinding</h1><p>胶水类。</p><h2 id="1-1-Mixins"><a href="#1-1-Mixins" class="headerlink" title="1.1 Mixins"></a>1.1 Mixins</h2><p>直译：混入。</p><p>Flutter使用的Dart支持Mixins，Mixins能更好的解决多继承中出现的问题，如：方法优先顺序混乱、参数冲突、类结构复杂化等。</p><p>示例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  a() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"A.a()"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  b() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"A.b()"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A2</span> </span>&#123;</span><br><span class="line">  a() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"A2.a()"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">  a() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"B.a()"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  b() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"B.b()"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  c() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"B.c()"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">G</span> <span class="keyword">extends</span> <span class="title">B</span> <span class="title">with</span> <span class="title">A</span>, <span class="title">A2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">testMixins() &#123;</span><br><span class="line">  G t = <span class="keyword">new</span> G();</span><br><span class="line">  t.a();</span><br><span class="line">  t.b();</span><br><span class="line">  t.c();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I/flutter (13627): A2.a()</span><br><span class="line">I/flutter (13627): A.b()</span><br><span class="line">I/flutter (13627): B.c()</span><br></pre></td></tr></table></figure><p>Dart中，<code>with</code>就是用于Mixins。<code>class G extends B with A, A2</code>，在执行<code>G</code>的<code>a()</code>、<code>b()</code>、<code>c()</code>方法之后，输出<code>A2.a()</code>、<code>A.b()</code>、<code>B.c()</code>。</p><p>结论：<strong>相同方法被覆盖了，并且<code>with</code>后面的会覆盖前面的。</strong></p><p>下面继续修改代码。定义一个<code>Base</code>抽象类，<code>A</code>、<code>A2</code>、<code>B</code>都继承它，同时<code>print()</code>执行之后，执行<code>super()</code>操作。</p><p>从输出可以看出，<code>A</code>、<code>A2</code>、<code>B</code>中的<strong>所有方法都被执行，且只执行一次，同时执行顺序和<code>with</code>顺序有关</strong>。如果把<code>class A.a()</code>方法的<code>super</code>去掉，就不会有<code>B.a()</code>和<code>base a()</code>的输出。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">  a() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"base a()"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  b() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"base b()"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  c() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"base c()"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">  a() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"A.a()"</span>);</span><br><span class="line">    <span class="keyword">super</span>.a();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  b() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"A.b()"</span>);</span><br><span class="line">    <span class="keyword">super</span>.b();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A2</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">  a() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"A2.a()"</span>);</span><br><span class="line">    <span class="keyword">super</span>.a();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">  a() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"B.a()"</span>);</span><br><span class="line">    <span class="keyword">super</span>.a();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  b() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"B.b()"</span>);</span><br><span class="line">    <span class="keyword">super</span>.b();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  c() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"B.c()"</span>);</span><br><span class="line">    <span class="keyword">super</span>.c();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">G</span> <span class="keyword">extends</span> <span class="title">B</span> <span class="title">with</span> <span class="title">A</span>, <span class="title">A2</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">testMixins() &#123;</span><br><span class="line">  G t = <span class="keyword">new</span> G();</span><br><span class="line">  t.a();</span><br><span class="line">  t.b();</span><br><span class="line">  t.c();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A2.a()</span><br><span class="line">A.a()</span><br><span class="line">B.a()</span><br><span class="line">base a()</span><br><span class="line">A.b()</span><br><span class="line">B.b()</span><br><span class="line">base b()</span><br><span class="line">B.c()</span><br><span class="line">base c()</span><br></pre></td></tr></table></figure><h2 id="1-2-WidgetsFlutteBinding"><a href="#1-2-WidgetsFlutteBinding" class="headerlink" title="1.2 WidgetsFlutteBinding"></a>1.2 WidgetsFlutteBinding</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/// A concrete binding for applications based on </span>the<span class="markdown"> Widgets framework.</span></span></span><br><span class="line"><span class="comment"><span class="markdown">///</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// This is </span>the<span class="markdown"> glue that binds </span>the<span class="markdown"> framework to </span>the<span class="markdown"> Flutter engine.</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetsFlutterBinding</span> <span class="keyword">extends</span> <span class="title">BindingBase</span> <span class="title">with</span> <span class="title">GestureBinding</span>, <span class="title">ServicesBinding</span>, <span class="title">SchedulerBinding</span>, <span class="title">PaintingBinding</span>, <span class="title">SemanticsBinding</span>, <span class="title">RendererBinding</span>, <span class="title">WidgetsBinding</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment"><span class="markdown">/// Returns </span>an<span class="markdown"> instance of </span>the<span class="markdown"> [WidgetsBinding], creating and</span></span></span><br><span class="line">  <span class="comment"><span class="markdown">/// initializing it if necessary. If one is created, it </span>will<span class="markdown"> be </span>a<span class="markdown"></span></span></span><br><span class="line">  <span class="comment"><span class="markdown">/// [WidgetsFlutterBinding]. If one was previously initialized, then</span></span></span><br><span class="line">  <span class="comment"><span class="markdown">/// it </span>will<span class="markdown"> at least implement [WidgetsBinding].</span></span></span><br><span class="line">  <span class="comment"><span class="markdown">///</span></span></span><br><span class="line">  <span class="comment"><span class="markdown">/// You only need to call this method if </span>you<span class="markdown"> need </span>the<span class="markdown"> binding to be</span></span></span><br><span class="line">  <span class="comment"><span class="markdown">/// initialized before calling [runApp].</span></span></span><br><span class="line">  <span class="comment"><span class="markdown">///</span></span></span><br><span class="line">  <span class="comment"><span class="markdown">/// In </span>the<span class="markdown"> <span class="code">`flutter_test`</span> framework, [testWidgets] initializes </span>the<span class="markdown"></span></span></span><br><span class="line">  <span class="comment"><span class="markdown">/// binding instance to </span>a<span class="markdown"> [TestWidgetsFlutterBinding], not </span>a<span class="markdown"></span></span></span><br><span class="line">  <span class="comment"><span class="markdown">/// [WidgetsFlutterBinding].</span></span></span><br><span class="line">  <span class="keyword">static</span> WidgetsBinding ensureInitialized() &#123;</span><br><span class="line">    <span class="keyword">if</span> (WidgetsBinding.instance == <span class="keyword">null</span>)</span><br><span class="line">      WidgetsFlutterBinding();</span><br><span class="line">    <span class="keyword">return</span> WidgetsBinding.instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>WidgetsFlutterBinding</code>在Flutter启动时，<code>runApp()</code>会被调用，作为App的入口，需要承担类的初始化以及功能配置，这时，<code>Mixins</code>的作用就体现出来了。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/// The glue between </span>the<span class="markdown"> widgets layer and </span>the<span class="markdown"> Flutter engine.</span></span></span><br><span class="line">mixin WidgetsBinding on BindingBase, SchedulerBinding, GestureBinding, RendererBinding, SemanticsBinding &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">/// The glue between </span>the<span class="markdown"> render tree and </span>the<span class="markdown"> Flutter engine.</span></span></span><br><span class="line">mixin RendererBinding on BindingBase, ServicesBinding, SchedulerBinding, GestureBinding, SemanticsBinding, HitTestable &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">/// The glue between </span>the<span class="markdown"> semantics layer and </span>the<span class="markdown"> Flutter engine.</span></span></span><br><span class="line">mixin SemanticsBinding on BindingBase &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">/// Binding for </span>the<span class="markdown"> painting library.</span></span></span><br><span class="line"><span class="comment"><span class="markdown">///</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// Hooks into </span>the<span class="markdown"> cache eviction logic to clear </span>the<span class="markdown"> image cache.</span></span></span><br><span class="line"><span class="comment"><span class="markdown">///</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// Requires </span>the<span class="markdown"> [ServicesBinding] to be mixed in earlier.</span></span></span><br><span class="line">mixin PaintingBinding on BindingBase, ServicesBinding &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">/// Scheduler for running </span>the<span class="markdown"> following:</span></span></span><br><span class="line"><span class="comment"><span class="markdown">///</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// * <span class="emphasis">_Transient callbacks_</span>, triggered by </span>the<span class="markdown"> system's [Window.onBeginFrame]</span></span></span><br><span class="line"><span class="comment"><span class="markdown">///   callback, for synchronizing </span>the<span class="markdown"> application's behavior to </span>the<span class="markdown"> system's</span></span></span><br><span class="line"><span class="comment"><span class="markdown">///   display. For example, [Ticker]s and [AnimationController]s trigger from</span></span></span><br><span class="line"><span class="comment"><span class="markdown">///   these.</span></span></span><br><span class="line"><span class="comment"><span class="markdown">///</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// * <span class="emphasis">_Persistent callbacks_</span>, triggered by </span>the<span class="markdown"> system's [Window.onDrawFrame]</span></span></span><br><span class="line"><span class="comment"><span class="markdown">///   callback, for updating </span>the<span class="markdown"> system's display after transient callbacks have</span></span></span><br><span class="line"><span class="comment"><span class="markdown">///   executed. For example, </span>the<span class="markdown"> rendering layer uses this to drive its</span></span></span><br><span class="line"><span class="comment"><span class="markdown">///   rendering pipeline.</span></span></span><br><span class="line"><span class="comment"><span class="markdown">///</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// * <span class="emphasis">_Post-frame callbacks_</span>, which </span>are<span class="markdown"> run after persistent callbacks, </span>just<span class="markdown"></span></span></span><br><span class="line"><span class="comment"><span class="markdown">///   before returning from </span>the<span class="markdown"> [Window.onDrawFrame] callback.</span></span></span><br><span class="line"><span class="comment"><span class="markdown">///</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// * Non-rendering tasks, to be run between frames. These </span>are<span class="markdown"> given </span>a<span class="markdown"></span></span></span><br><span class="line"><span class="comment"><span class="markdown">///   priority and </span>are<span class="markdown"> executed in priority order according to </span>a<span class="markdown"></span></span></span><br><span class="line"><span class="comment"><span class="markdown">///   [schedulingStrategy].</span></span></span><br><span class="line">mixin SchedulerBinding on BindingBase, ServicesBinding &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">/// Listens for platform messages and directs them to </span>the<span class="markdown"> [defaultBinaryMessenger]</span></span></span><br><span class="line">mixin ServicesBinding on BindingBase &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">/// A binding for </span>the<span class="markdown"> gesture subsystem.</span></span></span><br><span class="line">mixin GestureBinding on BindingBase <span class="keyword">implements</span> HitTestable, HitTestDispatcher, HitTestTarget &#123;&#125;</span><br></pre></td></tr></table></figure><p><code>WidgetsFlutterBinding</code>本身没有什么代码，主要继承了<code>BindingBase</code>，之后通过<code>with</code>黏上各类<strong>Binding</strong>，这些<strong>Binding</strong>也继承了<code>BindingBase</code>。</p><p>这些<strong>Binding</strong>都可以被单独使用，也可以被“黏”到 <strong><code>WidgetsFlutterBinding</code></strong>中使用，这样的结构比一层一层继承的结构更加清晰。</p><p>下面是执行顺序：</p><img src="/2019/09/19/五、深入探究/YRY[OO5%7DM9S~FDM[O5%6070OQ.png"><h1 id="2-InheritedWidget"><a href="#2-InheritedWidget" class="headerlink" title="2. InheritedWidget"></a>2. InheritedWidget</h1><p><code>InheritedWidget</code>是一个抽象类。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritedWidget</span> <span class="keyword">extends</span> <span class="title">ProxyWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment"><span class="markdown">/// Abstract const constructor. This constructor enables subclasses to provide</span></span></span><br><span class="line">  <span class="comment"><span class="markdown">/// const constructors </span>so<span class="markdown"> that </span>they<span class="markdown"> can be used in const expressions.</span></span></span><br><span class="line">  <span class="keyword">const</span> InheritedWidget(&#123; Key key, Widget child &#125;)</span><br><span class="line">    : <span class="keyword">super</span>(key: key, child: child);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  InheritedElement createElement() =&gt; InheritedElement(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment"><span class="markdown">/// Whether </span>the<span class="markdown"> framework </span>should<span class="markdown"> notify widgets that inherit from this widget.</span></span></span><br><span class="line">  <span class="comment"><span class="markdown">///</span></span></span><br><span class="line">  <span class="comment"><span class="markdown">/// When this widget is rebuilt, sometimes we need to rebuild </span>the<span class="markdown"> widgets that</span></span></span><br><span class="line">  <span class="comment"><span class="markdown">/// inherit from this widget </span>but<span class="markdown"> sometimes we do not. For example, if </span>the<span class="markdown"> data</span></span></span><br><span class="line">  <span class="comment"><span class="markdown">/// held by this widget is </span>the<span class="markdown"> same as </span>the<span class="markdown"> data held by <span class="code">`oldWidget`</span>, then we</span></span></span><br><span class="line">  <span class="comment"><span class="markdown">/// do not need to rebuild </span>the<span class="markdown"> widgets that inherited </span>the<span class="markdown"> data held by</span></span></span><br><span class="line">  <span class="comment"><span class="markdown">/// <span class="code">`oldWidget`</span>.</span></span></span><br><span class="line">  <span class="comment"><span class="markdown">///</span></span></span><br><span class="line">  <span class="comment"><span class="markdown">/// The framework distinguishes these cases by calling this function with </span>the<span class="markdown"></span></span></span><br><span class="line">  <span class="comment"><span class="markdown">/// widget that previously occupied this location in </span>the<span class="markdown"> tree as </span>an<span class="markdown"> argument.</span></span></span><br><span class="line">  <span class="comment"><span class="markdown">/// The given widget is guaranteed to have </span>the<span class="markdown"> same [runtimeType] as this</span></span></span><br><span class="line">  <span class="comment"><span class="markdown">/// object.</span></span></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="built_in">bool</span> updateShouldNotify(covariant InheritedWidget oldWidget);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面主要实现了两个方法：</p><ul><li>创建了<code>InheritedElement</code>，该<strong>Element</strong>属于特殊Element，主要增加了将自身也添加到映射关系表<code>_inheritedWidgets</code>，方便子element获取；同时通过<code>notifyClients()</code>来更新依赖。</li><li>增加<code>updateShouldNotify()</code>方法，当方法返回<code>true</code>时，依赖该Widget的示例就会更新。</li></ul><p>可以简单理解为：<code>InheritedWidget</code>通过<code>InheritedElement</code>实现了由下往上查找的支持（因为自身添加到<code>_inheritedWidgets</code>），同时具备更新其子类的功能。</p><blockquote><p>注：每个Element都有一个<code>_inheriteWidgets</code>，它是一个<code>HashMap&lt;Type, InheritedElement&gt;</code>，它保存了上层节点出现的<code>InherotedWidget</code>与其对应element的映射关系。</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Element</span> <span class="keyword">extends</span> <span class="title">DiagnosticableTree</span> <span class="keyword">implements</span> <span class="title">BuildContext</span> </span>&#123;</span><br><span class="line">  <span class="comment"><span class="markdown">/// Creates </span>an<span class="markdown"> element that uses </span>the<span class="markdown"> given widget as its configuration.</span></span></span><br><span class="line">  <span class="comment"><span class="markdown">///</span></span></span><br><span class="line">  <span class="comment"><span class="markdown">/// Typically called by </span>an<span class="markdown"> override of [Widget.createElement].</span></span></span><br><span class="line">  <span class="built_in">Element</span>(Widget widget)</span><br><span class="line">    : <span class="keyword">assert</span>(widget != <span class="keyword">null</span>),</span><br><span class="line">      _widget = widget;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Element</span> _parent;</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在看<code>BuildContext</code>，<code>BuildContext</code>是一个接口，<code>Element</code>实现了它。<code>InheritedElement</code>是<code>Element</code>的子类，所以每个<code>InheritedElement</code>实例就是一个<code>BuildContext</code>实例。日常传递的<code>BuildContext</code>也是一个<code>Element</code>。</p><p>所以，当需要共享<code>State</code>时，如果逐层去传递，实现共享，就会很麻烦，这时，可以使用<code>InheritedWidgets</code>。<strong>将需要共享的<code>State</code>放在一个<code>inheritedWidgets</code>中，然后在使用的<code>Widget</code>中直接取用</strong>。如下：通常如焦点、主题色、多语言、用户信息等都属于App内的全局共享数据，它们都会通过<code>BuildContext</code>（<code>InheritedElement</code>）获取。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 收起键盘</span></span><br><span class="line">FocusScope.of(context).requestFocus(<span class="keyword">new</span> FocusNode());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主题色</span></span><br><span class="line">Theme.of(context).primaryColor</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多语言</span></span><br><span class="line">Localizations.of(context, GSYLocalizations)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 Redux 获取用户信息</span></span><br><span class="line">StoreProvider.of(context).userInfo</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 Redux 获取用户信息</span></span><br><span class="line">StoreProvider.of(context).userInfo</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 Scope Model 获取用户信息</span></span><br><span class="line">ScopedModel.of&lt;UserInfo&gt;(context).userInfo</span><br></pre></td></tr></table></figure><p>先来看看<code>Theme</code>。</p><p>如下代码，通过给<code>MaterialApp</code>设置主题数据，通过<code>Theme.of(context)</code>就可以获取到主题数据并绑定使用。当<code>MaterialApp</code>的主题数据变化时，对应的<code>Widget</code>颜色就会变化。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加主题</span></span><br><span class="line"><span class="keyword">new</span> MaterialApp(</span><br><span class="line">    theme: ThemeData.dark()</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用主题色</span></span><br><span class="line"><span class="keyword">new</span> Container( color: Theme.of(context).primaryColor,</span><br></pre></td></tr></table></figure><p>代码嵌套：<code>MaterialApp</code> -&gt; <code>AnimatedTheme</code> -&gt; <code>Theme</code> -&gt; <code>_InheritedTheme extends InheritedWidget</code>，所以通过<code>MaterialApp</code>为入口，最终嵌套在<code>InheritedWidget</code>下。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ThemeData of(BuildContext context, &#123; <span class="built_in">bool</span> shadowThemeOnly = <span class="keyword">false</span> &#125;) &#123;</span><br><span class="line">    <span class="keyword">final</span> _InheritedTheme inheritedTheme = context.inheritFromWidgetOfExactType(_InheritedTheme);</span><br><span class="line">    <span class="keyword">if</span> (shadowThemeOnly) &#123;</span><br><span class="line">      <span class="keyword">if</span> (inheritedTheme == <span class="keyword">null</span> || inheritedTheme.theme.isMaterialAppTheme)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">return</span> inheritedTheme.theme.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> MaterialLocalizations localizations = MaterialLocalizations.of(context);</span><br><span class="line">    <span class="keyword">final</span> ScriptCategory category = localizations?.scriptCategory ?? ScriptCategory.englishLike;</span><br><span class="line">    <span class="keyword">final</span> ThemeData theme = inheritedTheme?.theme?.data ?? _kFallbackTheme;</span><br><span class="line">    <span class="keyword">return</span> ThemeData.localize(theme, theme.typography.geometryThemeFor(category));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>Theme.of(context)</code>获取主题数据，内部是通过<code>context.inheritFromWidgetOfExactType()</code>去获取的，而<code>Element</code>中实现了<code>BuildContext</code>的<code>inheritFromWidgetOfExactType()</code>方法，如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">InheritedWidget inheritFromWidgetOfExactType(<span class="built_in">Type</span> targetType, &#123; <span class="built_in">Object</span> aspect &#125;) &#123;</span><br><span class="line">  <span class="keyword">assert</span>(_debugCheckStateIsActiveForAncestorLookup());</span><br><span class="line">  <span class="keyword">final</span> InheritedElement ancestor = _inheritedWidgets == <span class="keyword">null</span> ? <span class="keyword">null</span> : _inheritedWidgets[targetType];</span><br><span class="line">  <span class="keyword">if</span> (ancestor != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(ancestor <span class="keyword">is</span> InheritedElement);</span><br><span class="line">    <span class="keyword">return</span> inheritFromElement(ancestor, aspect: aspect);</span><br><span class="line">  &#125;</span><br><span class="line">  _hadUnsatisfiedDependencies = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然<code>InheritedElement</code>已经存在于<code>_inheritedWidgets</code>中，就可以直接拿出来。</p><blockquote><p>前文：<code>InteritedWidget</code>内的<code>InheritedElement</code>，该<code>Element</code>属于特殊<code>Element</code>，主要增加了将自身也添加到映射关系表<code>_inheritedWidgets</code>。</p></blockquote><p><strong>该处逻辑有变动</strong></p><p>最后，如下，在<code>InheritedElement</code>中，<code>notifyClents</code>通过<code>InheritedWidget</code>的<code>updateShouldNotofy()</code>方法判断是否更新，比如在<code>Theme</code>的<code>_InheritedTheme</code>是：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逻辑有变动，需要重新查看源码</span></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> notifyClients(InheritedWidget oldWidget) &#123;</span><br><span class="line">  <span class="keyword">assert</span>(_debugCheckOwnerBuildTargetExists(<span class="string">'notifyClients'</span>));</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">Element</span> dependent <span class="keyword">in</span> _dependents.keys) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(() &#123;</span><br><span class="line">      <span class="comment">// check that it really is our descendant</span></span><br><span class="line">      <span class="built_in">Element</span> ancestor = dependent._parent;</span><br><span class="line">      <span class="keyword">while</span> (ancestor != <span class="keyword">this</span> &amp;&amp; ancestor != <span class="keyword">null</span>)</span><br><span class="line">        ancestor = ancestor._parent;</span><br><span class="line">      <span class="keyword">return</span> ancestor == <span class="keyword">this</span>;</span><br><span class="line">    &#125;());</span><br><span class="line">    <span class="comment">// check that it really depends on us</span></span><br><span class="line">    <span class="keyword">assert</span>(dependent._dependencies.contains(<span class="keyword">this</span>));</span><br><span class="line">    notifyDependent(oldWidget, dependent);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>本质上，<code>Theme</code>、<code>Redux</code>、<code>Scope Model</code>、<code>Localizations</code>的核心都是<code>InheritedWidget</code>。</strong></p><h1 id="3-内存"><a href="#3-内存" class="headerlink" title="3. 内存"></a>3. 内存</h1><p>咸鱼有发布了关于内存的文章<a href="https://yq.aliyun.com/articles/651005" target="_blank" rel="noopener">Flutter之禅 内存优化篇</a>，里面有介绍到：</p><ul><li>Flutter中<code>InmageCache</code>缓存的是<code>ImageStream</code>对象，也就是缓存的是一个异步加载的图片的对象。</li><li>在图片加载解码完成前，无法知道需要消耗多少内存。</li><li>所以容易产生大量的IO操作，导致内存峰值过高。</li></ul><img src="/2019/09/19/五、深入探究/TB19pDEehnaK1RjSZFtXXbC2VXa-1348-723.png"><p>如图，是图片缓存相关的流程，目前的拮据处理是通过的：</p><ul><li>在页面不可见时，没有必要发出多余的图片</li><li>限制缓存图片的数量</li><li>在适当的时候CG</li></ul><p>这里主要讲讲<strong>限制缓存图片的数量</strong>。</p><p>在之前有说过<code>WidgetFlutterBinding</code>这个胶水类，其中<code>Mixins</code>了<code>PaintingBinding</code>如下，被黏上去的这个Binding就是负责图片的缓存。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/// Binding for </span>the<span class="markdown"> painting library.</span></span></span><br><span class="line"><span class="comment"><span class="markdown">///</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// Hooks into </span>the<span class="markdown"> cache eviction logic to clear </span>the<span class="markdown"> image cache.</span></span></span><br><span class="line"><span class="comment"><span class="markdown">///</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/// Requires </span>the<span class="markdown"> [ServicesBinding] to be mixed in earlier.</span></span></span><br><span class="line">mixin PaintingBinding on BindingBase, ServicesBinding &#123;&#125;</span><br></pre></td></tr></table></figure><p>里面注释有说到Hooks into the cache eviction logic to clear the image cache.</p><p>直译为：挂钩到缓存回收逻辑以清除映像缓存。</p><p>在<code>PaintingBinding</code>内有一个<code>ImageCache</code>对象，该对象全局一个单例，同时在图片加载时的<code>ImageProvider</code>所使用，所以设置缓存图片大小如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓存个数 100</span></span><br><span class="line">PaintingBinding.instance.imageCache.maximumSize=<span class="number">100</span>;</span><br><span class="line"><span class="comment">// 缓存大小 50m</span></span><br><span class="line">PaintingBinding.instance.imageCache.maximumSizeBytes= <span class="number">50</span> &lt;&lt; <span class="number">20</span>;</span><br></pre></td></tr></table></figure><h1 id="4-线程"><a href="#4-线程" class="headerlink" title="4. 线程"></a>4. 线程</h1><p>在咸鱼技术的<a href="https://www.jianshu.com/p/39575a90e820" target="_blank" rel="noopener">深入理解Flutter Platform Channel</a>中有讲到：Flutter四大线程，<code>Platform Task Runner</code>、<code>UI Task Runner</code>、<code>GPU Task Runner</code>和<code>IO Task Runner</code>。<br>其中，<code>Platform Task Runner</code>就是Android和iOS的主线程，<code>UI Task Runner</code>是Flutter的UI线程。</p><p>如下图，通过<code>Platform Channel</code>通信的两端就是<code>Platform Task Runner</code>和<code>UI Task Runner</code>，这里总结起来是：</p><ul><li>因为<code>Platform Task Runner</code>本来是原生的的主线程，所以尽量不要在<code>Platform</code>端执行耗时操作。</li><li>因为<code>Platform Channel</code>不是线程安全的，所以消息处理结果回传到Flutter端时，需要确保回调函数是在<code>Platform Thread</code>（也就是Andorid和iOS的主线程）中执行。</li></ul><img src="/2019/09/19/五、深入探究/1569306927.jpg"><h1 id="5-热更新"><a href="#5-热更新" class="headerlink" title="5. 热更新"></a>5. 热更新</h1><ol><li>Flutter依然是Android和iOS工程。</li><li>Flutter通过BuildPhase中添加shell（xcode_backend.sh）来生成和嵌入<strong>App.framework</strong>和<em>Flutter.framework*</em>到iOS。</li><li>Flutter通过Gradle引入<strong>flutter.jar</strong>和把编译完成的<strong>二进制文件</strong>添加到Android中。</li></ol><p>其中Andorid的编译后二进制文件存在于data/data/包名/app_flutter/flutter_assets/下。</p><blockquote><p>注意，1.7.8版本后，Android下生成的Flutter已经编译为纯so文件。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Demo地址：&lt;a href=&quot;https://gitee.com/QingFengBaiYu/tyler_flutter_app&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;tyler_flutter_app&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;1-Wid
      
    
    </summary>
    
      <category term="Flutter" scheme="https://tylerLiu.top/categories/Flutter/"/>
    
      <category term="学习" scheme="https://tylerLiu.top/categories/Flutter/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Flutter" scheme="https://tylerLiu.top/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>四、Redux、主题、国际化</title>
    <link href="https://tylerLiu.top/2019/09/19/%E5%9B%9B%E3%80%81Redux%E3%80%81%E4%B8%BB%E9%A2%98%E3%80%81%E5%9B%BD%E9%99%85%E5%8C%96/"/>
    <id>https://tylerLiu.top/2019/09/19/四、Redux、主题、国际化/</id>
    <published>2019-09-19T03:07:36.000Z</published>
    <updated>2019-09-19T09:15:07.648Z</updated>
    
    <content type="html"><![CDATA[<p>Demo地址：<a href="https://gitee.com/QingFengBaiYu/tyler_flutter_app" target="_blank" rel="noopener">tyler_flutter_app</a></p><p>本文主要是使用Redux实现主题切换和多语言切换的功能。</p><p>Flutter作为响应式框架，通过<code>state</code>实现跨帧渲染的逻辑。Flutter中使用的Redux库，是<a href="https://pub.flutter-io.cn/packages/flutter_redux" target="_blank" rel="noopener">flutter_redux</a>。</p><img src="/2019/09/19/四、Redux、主题、国际化/1568863166.jpg"><h1 id="1-Redux"><a href="#1-Redux" class="headerlink" title="1. Redux"></a>1. Redux</h1><p>Redux是<strong>状态管理</strong>，在已有<code>state</code>基础上，为什么还要用Redux？Redux好处：<strong>共享状态</strong>和<strong>单一数据</strong>。</p><p>假设，App内有多个使用到了登录用户的数据，这时如果某处对用户数据进行了修改，各个页面的同步更新就会很麻烦。使用Redux后，某个页面修改了用户信息，所有绑定了Redux的控件，将由Redux自动同步刷新。同理，主题和语言的切换也是如此。</p><img src="/2019/09/19/四、Redux、主题、国际化/1568870008.jpg"><p>如上图，Redux主要组成部分为：</p><ul><li>Store：用于存储和管理State</li><li>Action：用于定义一个数据变化的请求行为</li><li>Reducer：用于根据Action产生新状态，一般是一个方法</li></ul><p>所以一般流程为：</p><ol><li>Widget绑定Store中的State数据；</li><li>Widget通过Action发布一个新的动作；</li><li>Reducer根据Action更新State；</li><li>更新Store中State绑定的Widget。</li></ol><p>首先，要创建一个Store。创建<code>Store</code>，需要<code>reducer</code>，而<code>reducer</code>实际上是一个带有<code>action</code>和<code>state</code>的方法，并返回新的<code>State</code>。所以需要先创建一个State对象<code>TylerState</code>类，用于存储需要共享的数据，如：用户信息、主题、语言等。</p><p>然后定义一个<code>Reducer</code>方法<code>appReducer()</code>：将<code>TylerState</code>内的每个参数和对应的<code>action</code>绑定起来，返回完整的<code>TylerState</code>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TylerState</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 用户信息</span></span><br><span class="line">  User userInfo;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 主题数据</span></span><br><span class="line">  ThemeData themeData;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 语言</span></span><br><span class="line">  Locale locale;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造方法</span></span><br><span class="line">  TylerState(&#123;<span class="keyword">this</span>.userInfo, <span class="keyword">this</span>.themeData, <span class="keyword">this</span>.locale&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">创建 Reducer</span></span><br><span class="line"><span class="comment">源码中 Reducer 是一个方法 typedef State Reducer&lt;State&gt;(State state, dynamic action);</span></span><br><span class="line"><span class="comment">这里自定义 appReducer 用于创建 store</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">TylerState appReducer(TylerState state, action) &#123;</span><br><span class="line">  <span class="keyword">return</span> TylerState(</span><br><span class="line">    <span class="comment">// 通过 UserReducer 将 TylerState 内的 userInfo 和 action 关联在一起</span></span><br><span class="line">    userInfo: UserReducer(state.userInfo, action),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 ThemeDataReducer 将 TylerState 内的 themeData 和 action 关联在一起</span></span><br><span class="line">    themeData: ThemeDataReducer(state.themeData, action),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 LocaleReducer 将 TylerState 内的 locale 和 action 关联在一起</span></span><br><span class="line">    locale: LocaleReducer(state.locale, action),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TylerState</code>中的每个参数都是通过各自的<code>Recuder</code>返回的。比如，<code>themeData</code>是通过<code>ThemeDataReducer()</code>产生的，<code>ThemeDataReducer</code>是将<code>ThemeData</code>和一系列Theme相关的<code>Action</code>绑定起来。</p><p>然后通过<code>flutter_redux</code>的<code>combineReducers()</code>与<code>TypedReducer</code>，将<code>RefreshThemeDataAction</code>类和<code>_refresh()</code>方法绑定起来，最终返回一个<code>ThemeData</code>实例。即：用户每发出一个<code>RefreshThemeDataAction</code>，最终都会触发<code>_refresh()</code>，然后更新<code>TylerState</code>中的<code>themeData</code>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ThemeDataReducer = combineReducers&lt;ThemeData&gt;([TypedReducer&lt;ThemeData, RefreshThemeDataAction&gt;(_refresh)]);</span><br><span class="line"></span><br><span class="line">ThemeData _refresh(ThemeData themeData, action) &#123;</span><br><span class="line">  themeData = action.themeData;</span><br><span class="line">  <span class="keyword">return</span> themeData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefreshThemeDataAction</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ThemeData themeData;</span><br><span class="line"></span><br><span class="line">  RefreshThemeDataAction(<span class="keyword">this</span>.themeData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时，就可以创建<code>Store</code>了。在创建<code>Store</code>的同时，通过<code>initialState</code>对<code>TylerState</code>初始化，然后通过<code>StoreProvider</code>加载<code>Store</code>并包裹<code>MaterialApp</code>。这样就完成了Redux的构建。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlutterReduxApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> store = <span class="keyword">new</span> Store&lt;TylerState&gt;(appReducer,</span><br><span class="line">      initialState: <span class="keyword">new</span> TylerState(</span><br><span class="line">          themeData: <span class="keyword">new</span> ThemeData(</span><br><span class="line">            primarySwatch: TylerColor.primarySwatch,</span><br><span class="line">          ),</span><br><span class="line">          locale: Locale(<span class="string">'zh'</span>, <span class="string">'CH'</span>)));</span><br><span class="line"></span><br><span class="line">  FlutterReduxApp(&#123;Key key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// 通过 StoreProvider 应用 store</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StoreProvider(</span><br><span class="line">      store: store,</span><br><span class="line">      <span class="comment">// 通过 StoreBuilder 获取 themeData</span></span><br><span class="line">      child: <span class="keyword">new</span> StoreBuilder(builder: (context, store) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MaterialApp();</span><br><span class="line">      &#125;),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面就是使用，如下，通过在<code>build()</code>中使用<code>StoreConnector</code>，通过<code>converter</code>转换<code>store.state</code>的数据，最后通过<code>builder</code>返回实际需要渲染的控件，这样就完成了数据和控件的绑定。也可以使用<code>StoreBuilder</code>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoUserStorePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// 通过 StoreConnector 关联 TylerState 中的 User</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StoreConnector&lt;TylerState, User&gt;(</span><br><span class="line">      <span class="comment">// 通过 converter 将 TylerState 中的 userInfo 返回</span></span><br><span class="line">      converter: (store) =&gt; store.state.userInfo,</span><br><span class="line">      <span class="comment">// 在 userInfo 中返回实际渲染的控件</span></span><br><span class="line">      builder: (context, userInfo) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Text(</span><br><span class="line">          userInfo.name,</span><br><span class="line">          style: Theme.of(context).textTheme.display1,</span><br><span class="line">        );</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，当需要触发更新时，使用下面代码即可：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StoreProvider.of(context).dispatch(<span class="keyword">new</span> UpdateUserAction(newUserInfo));</span><br></pre></td></tr></table></figure><h1 id="2-主题"><a href="#2-主题" class="headerlink" title="2. 主题"></a>2. 主题</h1><p>Flutter默认支持主题设置，<code>MaterialApp</code>提供了<code>theme</code>参数设置主题，之后就可以通过<code>Theme.of(context)</code>获取到当前的<code>ThemeData</code>用于设置控件的颜色、字体等。</p><p><code>ThemeData</code>的创建提供很多参数，这里主要说<code>primarySwatch</code>参数。<code>primarySwatch</code>是一个<code>MaterialColor</code>对象，内部由10个不同深浅的颜色组成，可以用来做主题的颜色。</p><p>Flutter默认提供了很多主题颜色，同时也可以通过<code>MaterialColor</code>实现自定义的主题颜色：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> MaterialColor primarySwatch = <span class="keyword">const</span> MaterialColor(</span><br><span class="line">  primaryValue,</span><br><span class="line">  <span class="keyword">const</span> &lt;<span class="built_in">int</span>, Color&gt;&#123;</span><br><span class="line">    <span class="number">50</span>: <span class="keyword">const</span> Color(primaryLightValue),</span><br><span class="line">    <span class="number">100</span>: <span class="keyword">const</span> Color(primaryLightValue),</span><br><span class="line">    <span class="number">200</span>: <span class="keyword">const</span> Color(primaryLightValue),</span><br><span class="line">    <span class="number">300</span>: <span class="keyword">const</span> Color(primaryLightValue),</span><br><span class="line">    <span class="number">400</span>: <span class="keyword">const</span> Color(primaryLightValue),</span><br><span class="line">    <span class="number">500</span>: <span class="keyword">const</span> Color(primaryValue),</span><br><span class="line">    <span class="number">600</span>: <span class="keyword">const</span> Color(primaryDarkValue),</span><br><span class="line">    <span class="number">700</span>: <span class="keyword">const</span> Color(primaryDarkValue),</span><br><span class="line">    <span class="number">800</span>: <span class="keyword">const</span> Color(primaryDarkValue),</span><br><span class="line">    <span class="number">900</span>: <span class="keyword">const</span> Color(primaryDarkValue),</span><br><span class="line">  &#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>就可以通过Redux实现主题切换。</p><p>前面已经在<code>TylerState</code>中创建了<code>themeData</code>，此时将它设置给<code>MaterialApp</code>的<code>theme</code>参数，之后通过<code>dispatch()</code>改变<code>themeData</code>，即实现主题切换。</p><p><code>MaterialApp</code>也是一个<code>StatefulWidget</code>，如下，需要利用<code>StoreBuilder</code>包裹起来，之后就可以通过<code>dispatch()</code>修改主题，通过<code>Theme.of(context).primaryColor</code>获取主题颜色。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="comment">// 通过 StoreProvider 应用 store</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> StoreProvider(</span><br><span class="line">    store: store,</span><br><span class="line">    child: <span class="keyword">new</span> StoreBuilder&lt;GSYState&gt;(builder: (context, store) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> MaterialApp(</span><br><span class="line">          theme: store.state.themeData);</span><br><span class="line">    &#125;),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">ThemeData  themeData = <span class="keyword">new</span> ThemeData(primarySwatch: colors[index]);</span><br><span class="line">store.dispatch(<span class="keyword">new</span> RefreshThemeDataAction(themeData));</span><br></pre></td></tr></table></figure><h1 id="3-国际化"><a href="#3-国际化" class="headerlink" title="3. 国际化"></a>3. 国际化</h1><p>中文官网上有介绍，<a href="https://flutterchina.club/tutorials/internationalization/" target="_blank" rel="noopener">国际化Flutter App</a>，但是实现起来较为复杂，这里使用Redux可以很简便的实现。</p><img src="/2019/09/19/四、Redux、主题、国际化/1568876501.jpg"><p>通过默认的<code>MaterialApp</code>设置，自定义的多语言要实现<code>LocalizationsDelegate</code>和<code>Localizations</code>。最终流程会通过<code>Localizations</code>使用<code>Locale</code>加载<code>delegate</code>。</p><p>流程：</p><ul><li>实现<code>LocalizationsDelegate</code></li><li>实现<code>Localizations</code></li><li>通过<code>Store</code>的<code>Locale</code>切换语言</li></ul><p>代码如下，创建自定义<code>delegate</code>需要继承<code>LocalizationsDelegate</code>，实现里面的<code>load()</code>。通过<code>locale</code>，判断需要加载的语言，返回自定义语言实现类<code>TylerLocalizations</code>，最后通过静态<code>delegate</code>对外提供<code>LocalizationsDelegate</code>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多语言代理</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TylerLocalizationsDelegate</span> <span class="keyword">extends</span> <span class="title">LocalizationsDelegate</span>&lt;<span class="title">TylerLocalizations</span>&gt; </span>&#123;</span><br><span class="line">  TylerLocalizationsDelegate();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> isSupported(Locale locale) &#123;</span><br><span class="line">    <span class="comment">// 支持中文和英文</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="string">'en'</span>, <span class="string">'zh'</span>].contains(locale.languageCode);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据 locale，创建一个对象用于提供当前的 locale 下的文本显示</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Future&lt;TylerLocalizations&gt; load(Locale locale) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SynchronousFuture&lt;TylerLocalizations&gt;(<span class="keyword">new</span> TylerLocalizations(locale));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> shouldReload(LocalizationsDelegate&lt;TylerLocalizations&gt; old) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 全局静态代理</span></span><br><span class="line">  <span class="keyword">static</span> TylerLocalizationsDelegate delegate = <span class="keyword">new</span> TylerLocalizationsDelegate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>TylerLocalizations</code>是一个自定义对象，代码如下，它会根据创建时的<code>Locale</code>，通过<code>locale.languageCode</code>判断返回对应的语言实体。</p><p><code>TylerLocalizations</code>对象最后会通过<code>Localizations</code>加载，<code>Local</code>也是那时通过<code>delegate</code>赋予。同时，在该<code>context</code>下，可以通过<code>Loccalizations.of()</code>获取<code>TylerLocalizations</code>，比如：<code>TylerLocalizations.of(context).currentLocalized.app_name</code>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义多语言实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TylerLocalizations</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Locale locale;</span><br><span class="line"></span><br><span class="line">  TylerLocalizations(<span class="keyword">this</span>.locale);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据 locale.languageCode 加载对应的语言</span></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, StringBase&gt; _localizedValues = &#123;</span><br><span class="line">    <span class="string">'en'</span>: <span class="keyword">new</span> StringEn(),</span><br><span class="line">    <span class="string">'zh'</span>: <span class="keyword">new</span> StringZh(),</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  StringBase <span class="keyword">get</span> currentLocalized &#123;</span><br><span class="line">    <span class="keyword">if</span> (_localizedValues.containsKey(locale.languageCode)) &#123;</span><br><span class="line">      <span class="keyword">return</span> _localizedValues[locale.languageCode];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _localizedValues[<span class="string">"en"</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过 Localizations 加载当前的 TylerLocalizations，获取对应的 StringBase</span></span><br><span class="line">  <span class="keyword">static</span> TylerLocalizations of(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Localizations.of(context, Localizations);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>介绍完<code>delegate</code>，接下来是<code>Localizations</code>。从流程图可以看出，<code>Localizations</code>提供一个<code>override</code>方法构建<code>Localizations</code>，这个方法可以设置<code>locale</code>，而需要的正式实时动态切换语言显示。</p><p>代码如下，创建一个<code>TylerLocalizations</code>的<code>Widget</code>，通过<code>StoreBuilder</code>绑定<code>Store</code>，然后通过<code>Localizations.override</code>包裹需要构建的页面，将<code>Store</code>中的<code>locale</code>和<code>Localizations</code>的<code>locale</code>绑定起来。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TylerLocalizations</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Widget child;</span><br><span class="line"></span><br><span class="line">  TylerLocalizations(&#123;Key key, <span class="keyword">this</span>.child&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _TylerLocalizationsState createState() =&gt; _TylerLocalizationsState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_TylerLocalizationsState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">TylerLocalizations</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StoreBuilder&lt;TylerState&gt;(builder: (context, store) &#123;</span><br><span class="line">      <span class="comment">// 通过 StoreBuilder 和 Localizations 实现实时多语言切换</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Localizations.override(</span><br><span class="line">        context: context,</span><br><span class="line">        locale: store.state.locale,</span><br><span class="line">        child: widget.child,</span><br><span class="line">      );</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后将<code>TylerLocalizations</code>使用到<code>MaterialApp</code>中。通过<code>store.dispatch</code>切换<code>Locale</code>即可。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlutterReducerApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建Store，引用 TylerState 中的 appReducer() 创建的Reducer</span></span><br><span class="line">  <span class="keyword">final</span> store = <span class="keyword">new</span> Store&lt;TylerState&gt;(appReducer, initialState: <span class="keyword">new</span> TylerState(userInfo: User.empty()));</span><br><span class="line"></span><br><span class="line">  FlutterReducerApp(&#123;Key key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// 通过 StoreProvider 应用 store</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StoreProvider(</span><br><span class="line">        store: store,</span><br><span class="line">        child: <span class="keyword">new</span> StoreBuilder&lt;TylerState&gt;(builder: (context, store) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> MaterialApp(</span><br><span class="line">            <span class="comment">// 多语言实现代理</span></span><br><span class="line">            localizationsDelegates: [</span><br><span class="line">              GlobalMaterialLocalizations.delegate,</span><br><span class="line">              GlobalWidgetsLocalizations.delegate,</span><br><span class="line">              TylerLocalizationsDelegate.delegate,</span><br><span class="line">            ],</span><br><span class="line">            locale: store.state.locale,</span><br><span class="line">            supportedLocales: [store.state.locale],</span><br><span class="line">            routes: &#123;</span><br><span class="line">              HomePage.sName: (context) &#123;</span><br><span class="line">                <span class="comment">// 通过 Localizations.override 包裹这一层</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> TylerLocalizations(</span><br><span class="line">                  child: <span class="keyword">new</span> HomePage(),</span><br><span class="line">                );</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">          );</span><br><span class="line">        &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoUtils</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 切换主题</span></span><br><span class="line">  <span class="keyword">static</span> changeLocale(Store&lt;TylerState&gt; store, <span class="built_in">int</span> index) &#123;</span><br><span class="line">    Locale locale = store.state.platformLocale;</span><br><span class="line">    <span class="keyword">switch</span> (index) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        locale = Locale(<span class="string">'zh'</span>, <span class="string">'CH'</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        locale = Locale(<span class="string">'en'</span>, <span class="string">'US'</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    store.dispatch(RefreshLocaleAction(locale));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Demo地址：&lt;a href=&quot;https://gitee.com/QingFengBaiYu/tyler_flutter_app&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;tyler_flutter_app&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文主要是使用Red
      
    
    </summary>
    
      <category term="Flutter" scheme="https://tylerLiu.top/categories/Flutter/"/>
    
      <category term="学习" scheme="https://tylerLiu.top/categories/Flutter/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Flutter" scheme="https://tylerLiu.top/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>三、打包及问题处理</title>
    <link href="https://tylerLiu.top/2019/09/18/%E4%B8%89%E3%80%81%E6%89%93%E5%8C%85%E5%8F%8A%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/"/>
    <id>https://tylerLiu.top/2019/09/18/三、打包及问题处理/</id>
    <published>2019-09-18T07:46:21.000Z</published>
    <updated>2019-09-19T09:15:02.930Z</updated>
    
    <content type="html"><![CDATA[<p>Demo地址：<a href="https://gitee.com/QingFengBaiYu/tyler_flutter_app" target="_blank" rel="noopener">tyler_flutter_app</a></p><h1 id="1-打包"><a href="#1-打包" class="headerlink" title="1. 打包"></a>1. 打包</h1><h2 id="1-1-Andorid打包"><a href="#1-1-Andorid打包" class="headerlink" title="1.1 Andorid打包"></a>1.1 Andorid打包</h2><img src="/2019/09/18/三、打包及问题处理/32132132132221.png"><p>Android上和一般Android开发类似，在<code>andorid/app/build.gradle</code>下可以配置<code>applicationId</code>、<code>versionCode</code>、<code>versionName</code>和签名信息等，最后通过<code>flutter build apk</code>完成编译，编译完成的包在<code>build/app/outputs/apk/release</code>下。（截图里面签名有个小错误，注意。）</p><h2 id="1-2-IOS打包"><a href="#1-2-IOS打包" class="headerlink" title="1.2 IOS打包"></a>1.2 IOS打包</h2><p>关于IOS打包的部分暂时可以参考<a href="https://guoshuyu.cn/home/wx/Flutter-3.html" target="_blank" rel="noopener">https://guoshuyu.cn/home/wx/Flutter-3.html</a>。后面会实际操作看看里面可能出现的问题。</p><p>也可以参考<a href="https://flutterchina.club/ios-release/" target="_blank" rel="noopener">发布的IOS版APP</a>。</p><h1 id="2-细节点"><a href="#2-细节点" class="headerlink" title="2. 细节点"></a>2. 细节点</h1><h2 id="2-1-AppBar"><a href="#2-1-AppBar" class="headerlink" title="2.1 AppBar"></a>2.1 AppBar</h2><p>AppBar不仅可以作为标题栏，里面的<code>leading</code>和<code>bottom</code>也有相应的作用。</p><ul><li><code>bottom</code>：默认支持<code>TabBar</code>，即顶部Tab效果，因为<code>TabBar</code>实现了<code>PreferredSizeWidget</code>的<code>preferredSize</code>。所以自定义的控件只要实现了<code>preferredSize</code>，就可以放到<code>bottom</code>中。比如下面是的搜索栏。</li></ul><img src="/2019/09/18/三、打包及问题处理/1568796679.jpg"><ul><li><code>leading</code>：通常是左侧按键，不设置时，一般是<code>Drawer</code>的图标或者返回按钮。</li><li><code>flexibleSpace</code>：位于<code>bottom</code>和<code>leading</code>之间。</li></ul><h2 id="2-2-按键"><a href="#2-2-按键" class="headerlink" title="2.2 按键"></a>2.2 按键</h2><p>Flutter中的按键，如<code>Flatbutton</code>，默认是有边距和最小大小的。如果想取消这些默认设置，其中一种方式如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> RawMaterialButton(</span><br><span class="line">    materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,</span><br><span class="line">    padding: padding ?? <span class="keyword">const</span> EdgeInsets.all(<span class="number">0.0</span>),</span><br><span class="line">    constraints: <span class="keyword">const</span> BoxConstraints(minWidth: <span class="number">0.0</span>, minHeight: <span class="number">0.0</span>),</span><br><span class="line">    child: child,</span><br><span class="line">    onPressed: onPressed);</span><br></pre></td></tr></table></figure><p>如果在加上<code>Flex</code>，一个可控的填充按键就出来了：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> RawMaterialButton(</span><br><span class="line">    materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,</span><br><span class="line">    padding: padding ?? <span class="keyword">const</span> EdgeInsets.all(<span class="number">0.0</span>),</span><br><span class="line">        constraints: <span class="keyword">const</span> BoxConstraints(minWidth: <span class="number">0.0</span>, minHeight: <span class="number">0.0</span>),</span><br><span class="line">    <span class="comment">// flex</span></span><br><span class="line">    child: <span class="keyword">new</span> Flex(</span><br><span class="line">        mainAxisAlignment: mainAxisAlignment,</span><br><span class="line">        direction: Axis.horizontal,</span><br><span class="line">        children: &lt;Widget&gt;[],</span><br><span class="line">    ),</span><br><span class="line">    onPressed: onPressed);</span><br></pre></td></tr></table></figure><h2 id="2-3-StatefulWidget赋值"><a href="#2-3-StatefulWidget赋值" class="headerlink" title="2.3 StatefulWidget赋值"></a>2.3 StatefulWidget赋值</h2><p>这里以给<code>TextField</code>赋值为例，在Flutter中，给有状态的<code>Widget</code>传递状态和数据，一般都是使用<code>controller</code>。示例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoController</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _DemoControllerState createState() =&gt; _DemoControllerState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_DemoControllerState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">DemoController</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> TextEditingController _controller = <span class="keyword">new</span> TextEditingController();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> didChangeDependencies() &#123;</span><br><span class="line">    <span class="keyword">super</span>.didChangeDependencies();</span><br><span class="line">    <span class="comment">// 通过给 controller 的 value 新创建一个 TextEditingValue</span></span><br><span class="line">    _controller.value = <span class="keyword">new</span> TextEditingValue(text: <span class="string">"给输入框填入参数"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TextField(</span><br><span class="line">      <span class="comment">// controller</span></span><br><span class="line">      controller: _controller,</span><br><span class="line">      onChanged: onChanged,</span><br><span class="line">      obscureText: obscureText,</span><br><span class="line">      decoration: <span class="keyword">new</span> InputDecoration(</span><br><span class="line">          hintText: hintText,</span><br><span class="line">          icon: iconData == <span class="keyword">null</span> ? <span class="keyword">null</span> : <span class="keyword">new</span> Icon(iconData);</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TextEditingValue</code>实际上是<code>ValueNotifier</code>，其中<code>Value</code>的<code>setter</code>方法被重载，一旦改变就触发<code>notifyListeners()</code>方法。而<code>TextEditingController</code>中，通过调用<code>addListener()</code>监听数据改变，从而让UI更新。</p><p>赋值还有一个简单的方法：传递一个对象，如class A对象，在控件内部使用对象A.b 的变量绑定控件，外部通过<code>setState({A.b = b2})</code>进行更新。</p><h2 id="2-4-GlobalKey"><a href="#2-4-GlobalKey" class="headerlink" title="2.4 GlobalKey"></a>2.4 GlobalKey</h2><p>在Flutter，要主动改变子控件的状态，还可以使用<code>GlobalKey</code>。比如需要主动调用<code>RefreshIndicator</code>显示刷新状态，代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">GlobalKey&lt;RefreshIndicatorState&gt; refreshIndicatorKey;</span><br><span class="line"></span><br><span class="line">showForRefresh() &#123;</span><br><span class="line">  <span class="comment">// 显示刷新</span></span><br><span class="line">  refreshIndicatorKey.currentState.show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  refreshIndicatorKey =  <span class="keyword">new</span> GlobalKey&lt;RefreshIndicatorState&gt;();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RefreshIndicator(</span><br><span class="line">    key: refreshIndicatorKey,</span><br><span class="line">    onRefresh: onRefresh,</span><br><span class="line">    child: <span class="keyword">new</span> ListView.builder(</span><br><span class="line">      ......</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-Redux与主题"><a href="#2-5-Redux与主题" class="headerlink" title="2.5 Redux与主题"></a>2.5 Redux与主题</h2><p>Redux主要用作Flutter全局State的管理器，详细内容可以查看<a href="https://tylerliu.top/2019/09/16/二、快速开发实战/#more">二、快速开发实战</a>。这里主要是通过Redux来实现切换主题的效果。</p><p>代码如下，通过<code>StoreProvider</code>加载<code>store</code>，再通过<code>StoreBuilder</code>将<code>store</code>中的<code>themeData</code>绑定到<code>MaterialApp</code>的<code>theme</code>下，之后，在其他<code>Widget</code>中通过<code>Theme.of(context)</code>调用需要的颜色，最终在任意位置调用<code>store.dispatch</code>实现主题颜色修改。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlutterReduxApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> store = <span class="keyword">new</span> Store&lt;TylerState&gt;(appReducer,</span><br><span class="line">      initialState: <span class="keyword">new</span> TylerState(</span><br><span class="line">          themeData: <span class="keyword">new</span> ThemeData(</span><br><span class="line">        primarySwatch: TylerColor.primarySwatch,</span><br><span class="line">      )));</span><br><span class="line"></span><br><span class="line">  FlutterReduxApp(&#123;Key key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// 通过 StoreProvider 应用 store</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StoreProvider(</span><br><span class="line">      store: store,</span><br><span class="line">      <span class="comment">// 通过 StoreBuilder 获取 themeData</span></span><br><span class="line">      child: <span class="keyword">new</span> StoreBuilder(builder: (context, store) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MaterialApp(</span><br><span class="line">          theme: store.state.themeData,</span><br><span class="line">          routes: &#123;</span><br><span class="line">            HomePage.sName: (context) &#123;</span><br><span class="line">              <span class="keyword">return</span> HomePage();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">        );</span><br><span class="line">      &#125;),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-6-Hotload与Package"><a href="#2-6-Hotload与Package" class="headerlink" title="2.6 Hotload与Package"></a>2.6 Hotload与Package</h2><p>Flutter的Debug和Release下分别是JIT和AOT模式，而在Debug下，支持Hotload。但需要注意：如果开发过程中，安装的新的第三方库，新的第三方库中包含了原生代码，就需要停止后重新运行。</p><p><code>pubspec.yaml</code>文件就是包的依赖目录，其中<code>^</code>表示等于等于，一般<code>upgrade</code>和<code>get</code>都能达到下载包的作用。但是：<code>upgrade</code>会在包有更新的情况下，更新<code>pubspec.lock</code>文件下包的版本。</p><h1 id="3-问题处理"><a href="#3-问题处理" class="headerlink" title="3. 问题处理"></a>3. 问题处理</h1><ul><li><code>Waiting for another flutter command to release the startup lock</code>：<ol><li>打开flutter安装目录 /bin/cache/</li><li>删除 lockfile 文件</li><li>重启 AndroidStudio</li></ol></li><li>dialog下的黄色线<a href="https://stackoverflow.com/questions/47114639/yellow-lines-under-text-widgets-in-flutter" target="_blank" rel="noopener">yellow-lines-under-text-widgets-in-flutter</a>：<code>showDialog</code>中，默认是没使用<code>Scaffold</code>，这会导致文本有黄色溢出线提示，可以使用<code>Material</code>包一层处理。</li><li><code>TabBar</code> + <code>TabView</code> + <code>KeepAlive</code> 的问题，可以通过<code>TabBar</code> + <code>PageView</code>解决。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Demo地址：&lt;a href=&quot;https://gitee.com/QingFengBaiYu/tyler_flutter_app&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;tyler_flutter_app&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;1-打包&quot;
      
    
    </summary>
    
      <category term="Flutter" scheme="https://tylerLiu.top/categories/Flutter/"/>
    
      <category term="学习" scheme="https://tylerLiu.top/categories/Flutter/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Flutter" scheme="https://tylerLiu.top/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>二、快速开发实战</title>
    <link href="https://tylerLiu.top/2019/09/16/%E4%BA%8C%E3%80%81%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/"/>
    <id>https://tylerLiu.top/2019/09/16/二、快速开发实战/</id>
    <published>2019-09-16T09:29:33.000Z</published>
    <updated>2019-09-19T09:14:57.123Z</updated>
    
    <content type="html"><![CDATA[<p>Demo地址：<a href="https://gitee.com/QingFengBaiYu/tyler_flutter_app" target="_blank" rel="noopener">tyler_flutter_app</a></p><p>本文将介绍如何搭建一个通用的Flutter App常用功能脚手架，快速开发一个完整的Flutter应用。</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>内容结构：</p><img src="/2019/09/16/二、快速开发实战/1568699853.jpg"><h1 id="1-基础控件"><a href="#1-基础控件" class="headerlink" title="1. 基础控件"></a>1. 基础控件</h1><h2 id="1-1-TabBar控件实现"><a href="#1-1-TabBar控件实现" class="headerlink" title="1.1 TabBar控件实现"></a>1.1 TabBar控件实现</h2><p><code>TabBar</code>是常用的需求，而在Flutter中，<strong><code>Scaffold</code> + <code>AppBar</code> + <code>TabBar</code> + <code>TabBarView</code></strong>是<code>TabBar</code>页面最简单的实现，在加上<code>AutomaticKeepAliveClientMixin</code>用于页面KeepAlive之后，像<a href="https://github.com/flutter/flutter/issues/11895" target="_blank" rel="noopener">#11895</a>就会造成Crash。到flutter V0.5.7 SDK修复后，问题还是没有得到完全解决，所以修改实现方式。</p><p>目前是通过<strong><code>Scaffold</code> + <code>AppBar</code> + <code>TabBar</code> + <code>TabBarView</code></strong>来组合实现效果，从而解决上面的问题。地址：<a href="https://gitee.com/QingFengBaiYu/FlutterTabBar" target="_blank" rel="noopener">FlutterTabBar</a>。</p><p>作为一个<code>TabBar Widget</code>，肯定继承<code>StatefulWidget</code>，需要实现它的<code>State</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_TylerTabBarState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">TylerTabBar</span>&gt; <span class="title">with</span> <span class="title">SingleTickerProviderStateMixin</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> _type;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;Widget&gt; _tabItems;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;Widget&gt; _tabViews;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Color _backgroundColor;</span><br><span class="line">  <span class="keyword">final</span> Color _indicatorColor;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Widget _title;</span><br><span class="line">  <span class="keyword">final</span> Widget _drawer;</span><br><span class="line">  <span class="keyword">final</span> Widget _floatingActionButton;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> PageController _pageController;</span><br><span class="line"></span><br><span class="line">  _TylerTabBarState(<span class="keyword">this</span>._type, <span class="keyword">this</span>._tabItems, <span class="keyword">this</span>._tabViews, <span class="keyword">this</span>._backgroundColor, <span class="keyword">this</span>._indicatorColor,</span><br><span class="line">      <span class="keyword">this</span>._title, <span class="keyword">this</span>._drawer, <span class="keyword">this</span>._floatingActionButton, <span class="keyword">this</span>._pageController)</span><br><span class="line">      : <span class="keyword">super</span>();</span><br><span class="line"></span><br><span class="line">  TabController _tabController;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    <span class="comment">// 初始化时创建控制器</span></span><br><span class="line">    <span class="comment">// 通过with SingleTickerProviderStateMixin 实现动画效果</span></span><br><span class="line">    _tabController = <span class="keyword">new</span> TabController(length: _tabItems.length, vsync: <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// 顶部TabBar模式</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._type == TylerTabBar.TOP_TAB) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Scaffold(</span><br><span class="line">        <span class="comment">// 设置侧边滑出 drawer， 不需要可以不设置</span></span><br><span class="line">        drawer: _drawer,</span><br><span class="line">        <span class="comment">// 设置悬浮按钮，不需要可以不设置</span></span><br><span class="line">        floatingActionButton: _floatingActionButton,</span><br><span class="line">        <span class="comment">// 标题栏</span></span><br><span class="line">        appBar: <span class="keyword">new</span> AppBar(</span><br><span class="line">          backgroundColor: _backgroundColor,</span><br><span class="line">          title: _title,</span><br><span class="line">          <span class="comment">// TabBar控件</span></span><br><span class="line">          bottom: <span class="keyword">new</span> TabBar(</span><br><span class="line">            <span class="comment">//顶部时，tabBar为可以滑动模式</span></span><br><span class="line">            isScrollable: <span class="keyword">true</span>,</span><br><span class="line">            <span class="comment">// 必须有的控制器，与pageView的控制器同步</span></span><br><span class="line">            controller: _tabController,</span><br><span class="line">            <span class="comment">// 每一个tab item，是一个List&lt;Widget&gt;</span></span><br><span class="line">            tabs: _tabItems,</span><br><span class="line">            <span class="comment">// tab底部选中条颜色</span></span><br><span class="line">            indicatorColor: _indicatorColor,</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">        <span class="comment">// 页面主体，PageView，用于承载Tab对应的页面</span></span><br><span class="line">        body: <span class="keyword">new</span> PageView(</span><br><span class="line">          <span class="comment">// 必须有的控制器，与tabBar的控制器同步</span></span><br><span class="line">          controller: _pageController,</span><br><span class="line">          <span class="comment">// 每一个 tab 对应的页面主体，是一个List&lt;Widget&gt;</span></span><br><span class="line">          children: _tabViews,</span><br><span class="line">          <span class="comment">// 页面触摸作用滑动回调，用于同步 tab 选中状态</span></span><br><span class="line">          onPageChanged: (index) &#123;</span><br><span class="line">            _tabController.animateTo(index);</span><br><span class="line">          &#125;,</span><br><span class="line">        ),</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 底部TabBar模式</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Scaffold(</span><br><span class="line">      <span class="comment">// 设置侧边滑出 drawer， 不需要可以不设置</span></span><br><span class="line">      drawer: _drawer,</span><br><span class="line">      <span class="comment">// 设置悬浮按钮，不需要可以不设置</span></span><br><span class="line">      floatingActionButton: _floatingActionButton,</span><br><span class="line">      <span class="comment">// 标题栏</span></span><br><span class="line">      appBar: <span class="keyword">new</span> AppBar(</span><br><span class="line">        backgroundColor: _backgroundColor,</span><br><span class="line">        title: _title,</span><br><span class="line">      ),</span><br><span class="line">      <span class="comment">// 页面主体，PageView，用于承载Tab对应的页面</span></span><br><span class="line">      body: <span class="keyword">new</span> PageView(</span><br><span class="line">        <span class="comment">// 必须有的控制器，与tabBar的控制器同步</span></span><br><span class="line">        controller: _pageController,</span><br><span class="line">        <span class="comment">// 每一个 tab 对应的页面主体，是一个List&lt;Widget&gt;</span></span><br><span class="line">        children: _tabViews,</span><br><span class="line">        <span class="comment">// 页面触摸作用滑动回调，用于同步 tab 选中状态</span></span><br><span class="line">        onPageChanged: (index) &#123;</span><br><span class="line">          _tabController.animateTo(index);</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">      bottomNavigationBar: <span class="keyword">new</span> Material(</span><br><span class="line">        color: _backgroundColor,</span><br><span class="line">        <span class="comment">// tabBar控件</span></span><br><span class="line">        child: <span class="keyword">new</span> TabBar(</span><br><span class="line">          <span class="comment">// 必须有的控制器，与pageView的控制器同步</span></span><br><span class="line">          controller: _tabController,</span><br><span class="line">          <span class="comment">// 每一个tab item，是一个List&lt;Widget&gt;</span></span><br><span class="line">          tabs: _tabItems,</span><br><span class="line">          <span class="comment">// tab底部选中条颜色</span></span><br><span class="line">          indicatorColor: _indicatorColor,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    <span class="comment">// 页面销毁时，销毁控制器</span></span><br><span class="line">    _tabController.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个底部<code>TabBar</code>的页面效果。<code>TabBar</code>和<code>PageView</code>之间通过<code>_pageController</code>和<code>_tabController</code>实现Tab和页面的同步，通过<code>SingleTickerProvidersStateMixin</code>实现Tab的动画切换效果，如果需要多个嵌套动画效果，需要使用<code>TickerProvidersStateMixin</code>。代码中可以看到：</p><ul><li>手动左右滑动<code>PageView</code>时，通过<code>onPageChanged()</code>回调调用<code>_tabController.animateTo(index);</code>同步<code>TabBar</code>状态。</li><li><code>_tabItems</code>中，监听每个<code>TabBarItem</code>的点击，通过<code>_pageController</code>实现<code>PageView</code>的状态同步。</li></ul><p>上面的代码还缺少<code>TabBarItem</code>的点击，这块会被放到外部实现。也可以直接在内部封装好控件，直接传递配置数据显示。</p><p>外部调用如下：每个<code>TabBar</code>点击时，通过<code>pageController.jumoTo()</code>跳转页面，每个页面都需要跳转坐标为：<strong>当前屏幕大小乘以索引<code>index</code></strong>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter_tab_bar/tab_bar_page_first.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter_tab_bar/tab_bar_page_second.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter_tab_bar/tab_bar_page_three.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter_tab_bar/tyler_tab_bar.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TabBarBottomPageWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _TabBarBottomPageWidgetState createState() =&gt; _TabBarBottomPageWidgetState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_TabBarBottomPageWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">TabBarBottomPageWidget</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> PageController _topPageController = <span class="keyword">new</span> PageController();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; _tab = [<span class="string">"动态"</span>, <span class="string">"趋势"</span>, <span class="string">"我的"</span>];</span><br><span class="line"></span><br><span class="line">  _renderTab() &#123;</span><br><span class="line">    <span class="built_in">List</span>&lt;Widget&gt; list = <span class="keyword">new</span> <span class="built_in">List</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; _tab.length; i++) &#123;</span><br><span class="line">      list.add(<span class="keyword">new</span> FlatButton(</span><br><span class="line">          onPressed: () &#123;</span><br><span class="line">            _topPageController.jumpTo(MediaQuery.of(context).size.width * i);</span><br><span class="line">          &#125;,</span><br><span class="line">          child: <span class="keyword">new</span> Text(</span><br><span class="line">            _tab[i],</span><br><span class="line">            maxLines: <span class="number">1</span>,</span><br><span class="line">          )));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _renderPage() &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">      <span class="keyword">new</span> TabBarPageFirst(),</span><br><span class="line">      <span class="keyword">new</span> TabBarPageSecond(),</span><br><span class="line">      <span class="keyword">new</span> TabBarPageThree(),</span><br><span class="line">    ];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TylerTabBar(</span><br><span class="line">      type: TylerTabBar.BOTTOM_TAB,</span><br><span class="line">      <span class="comment">// 渲染 tab</span></span><br><span class="line">      tabItems: _renderTab(),</span><br><span class="line">      <span class="comment">// 渲染页面</span></span><br><span class="line">      tabViews: _renderPage(),</span><br><span class="line">      topPageController: _topPageController,</span><br><span class="line">      backgroundColor: Colors.black45,</span><br><span class="line">      indicatorColor: Colors.white,</span><br><span class="line">      title: <span class="keyword">new</span> Text(<span class="string">"Flutter的TabBar"</span>),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，会发现，当页面点击切换时，<code>StatefulWidget</code>的子页面每次都会重新调用<code>initState()</code>。无法实现页面同步跳转，这时就需要<code>AutomaticKeepAliveClentMixin</code>。</p><p>每个Taba对应的<code>StatefulWidget</code>的<code>State</code>，需要通过<code>with AutomaticKeepAliveClentMixin</code>，然后重写：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="built_in">bool</span> <span class="keyword">get</span> wantKeepAlive =&gt; <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><p>就可以实现不重新构建的效果了。</p><p>这样底部的Tab就实现了，再来看看顶部Tab的实现。顶部Tab和顶部Tab的区别如下：</p><ul><li>底部Tab是放在<code>Scaffold</code>的<code>bottomNavigation</code>中的。</li><li>顶部Tab是放在<code>AppBar</code>的<code>bottom</code>中的，即标题栏下方。</li></ul><p>同时在顶部Tab中增加了<code>isScrollable: true</code>属性，代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Scaffold(</span><br><span class="line">    <span class="comment">// 设置侧边滑出 drawer， 不需要可以不设置</span></span><br><span class="line">    drawer: _drawer,</span><br><span class="line">    <span class="comment">// 设置悬浮按钮，不需要可以不设置</span></span><br><span class="line">    floatingActionButton: _floatingActionButton,</span><br><span class="line">    <span class="comment">// 标题栏</span></span><br><span class="line">    appBar: <span class="keyword">new</span> AppBar(</span><br><span class="line">      backgroundColor: _backgroundColor,</span><br><span class="line">      title: _title,</span><br><span class="line">      <span class="comment">// TabBar控件</span></span><br><span class="line">      bottom: <span class="keyword">new</span> TabBar(</span><br><span class="line">        <span class="comment">//顶部时，tabBar为可以滑动模式</span></span><br><span class="line">        isScrollable: <span class="keyword">true</span>,</span><br><span class="line">        <span class="comment">// 必须有的控制器，与pageView的控制器同步</span></span><br><span class="line">        controller: _tabController,</span><br><span class="line">        <span class="comment">// 每一个tab item，是一个List&lt;Widget&gt;</span></span><br><span class="line">        tabs: _tabItems,</span><br><span class="line">        <span class="comment">// tab底部选中条颜色</span></span><br><span class="line">        indicatorColor: _indicatorColor,</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">    <span class="comment">// 页面主体，PageView，用于承载Tab对应的页面</span></span><br><span class="line">    body: <span class="keyword">new</span> PageView(</span><br><span class="line">      <span class="comment">// 必须有的控制器，与tabBar的控制器同步</span></span><br><span class="line">      controller: _pageController,</span><br><span class="line">      <span class="comment">// 每一个 tab 对应的页面主体，是一个List&lt;Widget&gt;</span></span><br><span class="line">      children: _tabViews,</span><br><span class="line">      <span class="comment">// 页面触摸作用滑动回调，用于同步 tab 选中状态</span></span><br><span class="line">      onPageChanged: (index) &#123;</span><br><span class="line">        _tabController.animateTo(index);</span><br><span class="line">      &#125;,</span><br><span class="line">    ),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><img src="/2019/09/16/二、快速开发实战/1568703307.jpg"><p>在<code>TabBar</code>页面中，一般还会出现：<strong>父页面需要控制<code>PageView</code>中子页面的需求</strong>。这时，就需要用到<code>GlobalKey</code>了。比如<code>GlobalKey&lt;PageOneState&gt; stateOne = new GlobalKet&lt;PageOneState&gt;();</code>，通过<code>globalkey.currentState</code>对象，就可以调用<code>PageOneState</code>中的方法。要注意，<code>GlobalKey</code>需要是全局唯一的，一般可以在<code>build()</code>中创建。</p><h2 id="1-2-上下刷新列表"><a href="#1-2-上下刷新列表" class="headerlink" title="1.2 上下刷新列表"></a>1.2 上下刷新列表</h2><p>Flutter提供了<code>RefreshIndicator</code>作为内置下拉刷新控件；同时通过给<code>ListView</code>添加<code>ScrollController</code>做滑动监听，在最后添加一个<code>item</code>，作为上滑加载更多的Loading显示。</p><p>代码如下，通过<code>RefreshIndicator</code>控件可以简单完成下拉刷新工作。注意：<strong>可以利用<code>GlobalKey&lt;RefreshIndicatorState&gt;</code>对外提供<code>RefreshIndicator</code>的<code>RefreshIndicatorState</code>，这样外部就可以通过<code>GlobalKey</code>调用<code>globalKey.currenState.show();</code>，主动显示刷新状态并触发<code>onRefresh()</code>。</strong></p><p><strong>上拉加载更多</strong>在代码中是通过<code>_getListCount()</code>方法，在原本的基础数据上，增加实际需要渲染的<code>item</code>数量给<code>ListView</code>实现的，最后通过<code>ScrollController</code>监听到底部，触发<code>onLoadMore()</code>。</p><p>代码如下，通过<code>_getListCount()</code>，还可以配置空白页面，头布局等效果。其实就是<strong>在内部通过改变实际<code>item</code>数量与渲染<code>item</code>，以实现更多配置的效果。</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter_spinkit/flutter_spinkit.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下拉刷新控件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PullLoadWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _PullLoadWidgetState createState() =&gt; _PullLoadWidgetState(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_PullLoadWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">PullLoadWidget</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> IndexedWidgetBuilder itemBuilder;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 载更多回调</span></span><br><span class="line">  <span class="keyword">final</span> RefreshCallback onLoadMore;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拉刷新回调</span></span><br><span class="line">  <span class="keyword">final</span> RefreshCallback onRefresh;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Key refreshKey;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 控制器，比如数据和一些配置</span></span><br><span class="line">  <span class="keyword">final</span> PullLoadWidgetController _controller;</span><br><span class="line"></span><br><span class="line">  _PullLoadWidgetState(<span class="keyword">this</span>._controller, <span class="keyword">this</span>.itemBuilder, <span class="keyword">this</span>.onRefresh, <span class="keyword">this</span>.onLoadMore, <span class="keyword">this</span>.refreshKey);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> ScrollController _scrollController = <span class="keyword">new</span> ScrollController();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="comment">// 添加滑动监听</span></span><br><span class="line">    _scrollController.addListener(() &#123;</span><br><span class="line">      <span class="comment">// 判断当前滑动位置是不是达到底部，触发加载更多的回调</span></span><br><span class="line">      <span class="keyword">if</span> (_scrollController.position.pixels == _scrollController.position.maxScrollExtent) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.onLoadMore != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>._controller.needLoadMore.value) &#123;</span><br><span class="line">          <span class="keyword">this</span>.onLoadMore();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  根据配置状态返回实际列表数量，</span></span><br><span class="line"><span class="comment">  实际上这里可以根据需要做更多处理，</span></span><br><span class="line"><span class="comment">  比如，多个头部，是否需要空白页面，是否需要显示加载更多。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  _getListCount() &#123;</span><br><span class="line">    <span class="comment">// 是否需要头部</span></span><br><span class="line">    <span class="keyword">if</span> (_controller.needHeader) &#123;</span><br><span class="line">      <span class="comment">// 如果需要，用Item 0的 Widget 作为ListView的头部</span></span><br><span class="line">      <span class="comment">// 列表数量大于0时，因为头部和底部加载更多选项，需要对列表数据总数 +2</span></span><br><span class="line">      <span class="keyword">return</span> (_controller.dataList.length &gt; <span class="number">0</span>) ? _controller.dataList.length + <span class="number">2</span> : _controller.dataList.length;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果不需要头部，在没有数据时，固定返回数量1，用于空页面呈现</span></span><br><span class="line">      <span class="keyword">if</span> (_controller.dataList.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果没有数据，因为头部加载更多选项，需要对列表总数 +1</span></span><br><span class="line">      <span class="keyword">return</span> (_controller.dataList.length &gt; <span class="number">0</span>) ? _controller.dataList.length + <span class="number">1</span> : _controller.dataList.length;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  根据配置状态返回实际列表渲染的 item</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  _getItem(<span class="built_in">int</span> index) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_controller.needHeader &amp;&amp; index == _controller.dataList.length &amp;&amp; _controller.dataList.length != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果不需要头部，并且数据不为0，当index等于数据长度时，渲染加载更多 Item（因为index是从0开始的）</span></span><br><span class="line">      <span class="keyword">return</span> _buildProgressIndicator();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_controller.needHeader &amp;&amp; index == _getListCount() - <span class="number">1</span> &amp;&amp; _controller.dataList.length != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果需要头部，并且数据不为0，当index等于实际渲染长度 -1时，渲染加载更多 Item（因为index是从0开始的）</span></span><br><span class="line">      <span class="keyword">return</span> _buildProgressIndicator();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!_controller.needHeader &amp;&amp; _controller.dataList.length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果不需要头部，并且数据为0，渲染空页面</span></span><br><span class="line">      <span class="keyword">return</span> _buildEmpty();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 回调外部，正常渲染 Item，如果这里有需要，可以直接返回相对位置的index</span></span><br><span class="line">      <span class="keyword">return</span> itemBuilder(context, index);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RefreshIndicator(</span><br><span class="line">        <span class="comment">// GlobalKey，用户外部获取RefreshIndicator的State，做显示刷新</span></span><br><span class="line">        key: refreshKey,</span><br><span class="line">        <span class="comment">// 下拉刷新触发，返回的是一个Future</span></span><br><span class="line">        onRefresh: onRefresh,</span><br><span class="line">        child: <span class="keyword">new</span> ListView.builder(</span><br><span class="line">          <span class="comment">// 保持ListView任何情况下都能滚动，解决在RefreshIndicator的兼容问题</span></span><br><span class="line">          physics: <span class="keyword">const</span> AlwaysScrollableScrollPhysics(),</span><br><span class="line">          <span class="comment">// 根据状态返回子控件</span></span><br><span class="line">          itemBuilder: (context, index) &#123;</span><br><span class="line">            <span class="keyword">return</span> _getItem(index);</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="comment">// 根据状态返回数量</span></span><br><span class="line">          itemCount: _getListCount(),</span><br><span class="line">          <span class="comment">// 滑动监听</span></span><br><span class="line">          controller: _scrollController,</span><br><span class="line">        ));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  空页面</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Widget _buildEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Container(</span><br><span class="line">      height: MediaQuery.of(context).size.height - <span class="number">100</span>,</span><br><span class="line">      child: <span class="keyword">new</span> Column(</span><br><span class="line">        mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          FlatButton(</span><br><span class="line">            onPressed: () &#123;&#125;,</span><br><span class="line">            child: <span class="keyword">new</span> Image(image: <span class="keyword">new</span> AssetImage(<span class="string">'static/images/welcome.png'</span>), width: <span class="number">70.0</span>, height: <span class="number">70.0</span>),</span><br><span class="line">          ),</span><br><span class="line">          Container(</span><br><span class="line">            child: Text(<span class="string">"空白页面"</span>, style: TextStyle(color: Color(<span class="number">0xFF121917</span>))),</span><br><span class="line">          )</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  上拉加载更多</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Widget _buildProgressIndicator() &#123;</span><br><span class="line">    <span class="comment">// 是否需要显示上拉加载更多的Loading</span></span><br><span class="line">    Widget bottomWidget = (_controller.needLoadMore.value)</span><br><span class="line">        ? <span class="keyword">new</span> Row(</span><br><span class="line">            mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">            children: &lt;Widget&gt;[</span><br><span class="line">              <span class="comment">// loading框</span></span><br><span class="line">              <span class="keyword">new</span> SpinKitRotatingCircle(color: Theme.of(context).primaryColor),</span><br><span class="line">              <span class="keyword">new</span> Container(width: <span class="number">5.0</span>),</span><br><span class="line"></span><br><span class="line">              <span class="comment">//加载中文本</span></span><br><span class="line">              <span class="keyword">new</span> Text(</span><br><span class="line">                <span class="string">"正在加载更多，请稍后..."</span>,</span><br><span class="line">                style: TextStyle(</span><br><span class="line">                  color: Color(<span class="number">0xFF121917</span>),</span><br><span class="line">                  fontSize: <span class="number">14.0</span>,</span><br><span class="line">                  fontWeight: FontWeight.bold,</span><br><span class="line">                ),</span><br><span class="line">              )</span><br><span class="line">            ],</span><br><span class="line">          )</span><br><span class="line">        <span class="comment">// 不需要加载更多</span></span><br><span class="line">        : <span class="keyword">new</span> Container();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Padding(</span><br><span class="line">      padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">20.0</span>),</span><br><span class="line">      child: <span class="keyword">new</span> Center(</span><br><span class="line">        child: bottomWidget,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PullLoadWidgetController</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 数据，对齐增减，不能替换</span></span><br><span class="line">  <span class="built_in">List</span> dataList = <span class="keyword">new</span> <span class="built_in">List</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否需要加载更多</span></span><br><span class="line">  ValueNotifier&lt;<span class="built_in">bool</span>&gt; needLoadMore = <span class="keyword">new</span> ValueNotifier(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否需要头部</span></span><br><span class="line">  <span class="built_in">bool</span> needHeader = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-Loading框"><a href="#1-3-Loading框" class="headerlink" title="1.3 Loading框"></a>1.3 Loading框</h2><p>系统默认提供了<code>CircularProgressIndicator</code>等，但是有时无法满足需求，这里有一个第三方库：<a href="https://pub.flutter-io.cn/packages/flutter_spinkit" target="_blank" rel="noopener">flutter_spinkit</a>。</p><p>具体代码实现可以看前面的<code>_buildProgressIndicator()</code>中的实现。</p><h2 id="1-4-矢量图标库"><a href="#1-4-矢量图标库" class="headerlink" title="1.4 矢量图标库"></a>1.4 矢量图标库</h2><p>比起一般的png图片，矢量图标：</p><ul><li>可以轻松定义颜色</li><li>任意调整大小，且不会模糊</li></ul><p>矢量图标库是通过引入<code>ttf</code>字体库文件实现，在Flutter中，通过<code>Icon</code>控件，加载对应的<code>IconData</code>显示即可。</p><p>Flutter中默认内置的<code>Icons</code>类就提供了丰富的图标，直接通过<code>Icons</code>对象即可使用，同时推荐阿里的<code>iconfont</code>。代码如下，在<code>pubspec.yaml</code>中添加字体库支持：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">fonts:</span></span><br><span class="line"><span class="attr">  - family:</span> <span class="string">wxcIconFont</span></span><br><span class="line"><span class="attr">    fonts:</span></span><br><span class="line"><span class="attr">      - asset:</span> <span class="string">static/font/iconfont.ttf</span></span><br></pre></td></tr></table></figure><p>在代码中就可直接使用：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Icons</span></span><br><span class="line"><span class="keyword">new</span> Tab(</span><br><span class="line">    child: <span class="keyword">new</span> Column(</span><br><span class="line">        mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">        children: &lt;Widget&gt;[<span class="keyword">new</span> Icon(Icons.list, size: <span class="number">16.0</span>), <span class="keyword">new</span> Text(<span class="string">"趋势"</span>)],</span><br><span class="line">    ),</span><br><span class="line">),</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用iconfont</span></span><br><span class="line"><span class="keyword">new</span> Tab(</span><br><span class="line">    child: <span class="keyword">new</span> Column(</span><br><span class="line">        mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">        children: &lt;Widget&gt;[<span class="keyword">new</span> Icon(IconData(<span class="number">0xe6d0</span>, fontFamily: <span class="string">"wxcIconFont"</span>), size: <span class="number">16.0</span>), <span class="keyword">new</span> Text(<span class="string">"我的"</span>)],</span><br><span class="line">    ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="1-5-路由跳转"><a href="#1-5-路由跳转" class="headerlink" title="1.5 路由跳转"></a>1.5 路由跳转</h2><p>Flutter中的页面跳转是通过<code>Navigator</code>实现的，路由跳转分为：<strong>带参数跳转和不带参数跳转。</strong></p><ul><li>不带参数跳转：默认可以通过<code>MaterialApp</code>的路由表跳转</li><li>带参数跳转：参数可以通过跳转页面的构造方法传递</li></ul><p>常用的跳转有如下几种使用：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不带参数的路由表跳转</span></span><br><span class="line">Navigator.pushNamed(context, routeName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳转新页面并且替换，比如登录页跳转主页</span></span><br><span class="line">Navigator.pushReplacementNamed(context, routeName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳转到新的路由，并且关闭给定路由的之前的所有页面</span></span><br><span class="line">Navigator.pushNamedAndRemoveUntil(context, <span class="string">'/calendar'</span>, ModalRoute.withName(<span class="string">'/'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带参数的路由跳转，并且监听返回</span></span><br><span class="line">Navigator.push(context, <span class="keyword">new</span> MaterialPageRoute(builder: (context) =&gt; <span class="keyword">new</span> NotifyPage())).then((res) &#123;</span><br><span class="line">    <span class="comment">// 获取返回处理</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>Navigato.push()</code>返回的是一个<code>Future</code>，这个<code>Future</code>的作用是<strong>在页面返回时被调用的</strong>。即，可以通过<code>Navigator.pop()</code>时返回参数，之后在<code>Future</code>中可以的监听中处理页面的返回结果。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@optionalTypeArgs</span></span><br><span class="line"><span class="keyword">static</span> Future&lt;T&gt; push&lt;T <span class="keyword">extends</span> <span class="built_in">Object</span>&gt;(BuildContext context, Route&lt;T&gt; route) &#123;</span><br><span class="line">    <span class="keyword">return</span> Navigator.of(context).push(route);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-数据模块"><a href="#2-数据模块" class="headerlink" title="2. 数据模块"></a>2. 数据模块</h1><h2 id="2-1-网络请求"><a href="#2-1-网络请求" class="headerlink" title="2.1 网络请求"></a>2.1 网络请求</h2><p>Flutter中，最常用的网络请求库是<a href="https://pub.flutter-io.cn/packages/dio" target="_blank" rel="noopener">dio</a>。dio中封装了网络请求的数据转换、拦截器、请求返回等。详细使用可以查看<a href="https://github.com/flutterchina/dio/blob/master/README-ZH.md" target="_blank" rel="noopener">文档</a>。</p><h2 id="2-2-JSON序列化"><a href="#2-2-JSON序列化" class="headerlink" title="2.2 JSON序列化"></a>2.2 JSON序列化</h2><p>Flutter中，比如使用前面的dio进行网络请求返回，如果配置了返回数据格式为JSON，实际上得到的是一个Map。在使用过程中不方便，需要对Map再次进行转化，转成Model实体。</p><p>可以使用<code>json_serializable</code>插件，在Flutter中文教程中<a href="https://flutterchina.club/json/" target="_blank" rel="noopener">JSON和序列化</a>已经做了介绍，这里说明一下具体的使用逻辑：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="comment"># Your other regular dependencies here</span></span><br><span class="line"><span class="attr">  json_annotation:</span> <span class="string">^3.0.0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dev_dependencies:</span></span><br><span class="line">  <span class="comment"># Your other dev_dependencies here</span></span><br><span class="line"><span class="attr">  build_runner:</span> <span class="string">^1.7.0</span></span><br><span class="line"><span class="attr">  json_serializable:</span> <span class="string">^3.2.2</span></span><br></pre></td></tr></table></figure><p>使用步骤：</p><ol><li>创建实体Model，继承<code>Object</code>，然后通过<code>@JsonSerializable()</code>标记类名。</li><li>通过<code>with _$TemplateSerializerMixin</code>，将<code>fromJson()</code>方法委托到<code>Template.g.dart</code>的实现中。其中<code>*.g.dart</code>、<code>_$*SerializerMixin</code>、<code>_$*fromJson</code>这三个方法的引入，和<strong>Model所在的dart的文件名与Model类名</strong>有关，具体可以看代码注释。</li><li>最后，通过<code>flutter packages pub run build_runner build</code>编译自动生成转换对象。</li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:json_annotation/json_annotation.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">关联文件、允许Template访问 Template.g.dart 中的私有方法</span></span><br><span class="line"><span class="comment">Template.g.dart 是通过命令生成的文件。名称为 xxx.g.dart，xxx为当前dart文件的名称</span></span><br><span class="line"><span class="comment">Template.g.dart 中实现了 _$TemplateFromJson()和_$TemplateToJson()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">part</span> <span class="string">'Template.g.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标志class需要实现json序列化功能</span></span><br><span class="line"><span class="meta">@JsonSerializable</span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Template</span> <span class="keyword">extends</span> <span class="title">Object</span></span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">int</span> id;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过</span></span><br><span class="line">  <span class="meta">@JsonKey</span>(name: <span class="string">"push_id"</span>)</span><br><span class="line">  <span class="built_in">int</span> pushId;</span><br><span class="line"></span><br><span class="line">  Template(<span class="keyword">this</span>.name, <span class="keyword">this</span>.id, <span class="keyword">this</span>.pushId);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 'Xxx.g.dart'文件中，默认会根据当前类名生成 _$XxxFromJson方法</span></span><br><span class="line">  <span class="keyword">factory</span> Template.fromJson(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>,<span class="keyword">dynamic</span>&gt; json) =&gt; _$TemplateFromJson(json);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>flutter packages pub run build_runner build</code>生成的<code>Template.g.dart</code>的代码如下，可以通过<code>_$TemplateFromJson()</code>和<code>_$TemplateToJson()</code>对实体和Map进行转化，再结合<code>json.decode()</code>和<code>json.encode()</code>，就可以在<code>String</code>、<code>Map</code>、实体间相互转化了。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GENERATED CODE - DO NOT MODIFY BY HAND</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">part</span> of <span class="string">'Template.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// **************************************************************************</span></span><br><span class="line"><span class="comment">// JsonSerializableGenerator</span></span><br><span class="line"><span class="comment">// **************************************************************************</span></span><br><span class="line"></span><br><span class="line">Template _$TemplateFromJson(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="keyword">dynamic</span>&gt; json) &#123;</span><br><span class="line">  <span class="keyword">return</span> Template(</span><br><span class="line">    json[<span class="string">'name'</span>] <span class="keyword">as</span> <span class="built_in">String</span>,</span><br><span class="line">    json[<span class="string">'id'</span>] <span class="keyword">as</span> <span class="built_in">int</span>,</span><br><span class="line">    json[<span class="string">'push_id'</span>] <span class="keyword">as</span> <span class="built_in">int</span>,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="keyword">dynamic</span>&gt; _$TemplateToJson(Template instance) =&gt; &lt;<span class="built_in">String</span>, <span class="keyword">dynamic</span>&gt;&#123;</span><br><span class="line">      <span class="string">'name'</span>: instance.name,</span><br><span class="line">      <span class="string">'id'</span>: instance.id,</span><br><span class="line">      <span class="string">'push_id'</span>: instance.pushId,</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><h2 id="2-3-Redux-State"><a href="#2-3-Redux-State" class="headerlink" title="2.3 Redux State"></a>2.3 Redux State</h2><p>Redux，全局状态管理机。可以用来实现跨控件管理、同步State。可以使用第三方库<a href="https://pub.flutter-io.cn/packages/flutter_redux" target="_blank" rel="noopener">flutter_redux</a>。</p><p>Flutter中是通过实现<code>State()</code>和<code>setState()</code>来渲染和改变<code>StatefulWidget</code>的。</p><p>使用<code>flutter_redux</code>是怎样的呢？</p><p>比如把用户信息存储在<code>redux</code>的<code>store</code>中，好处：比如修改某个页面修改了当前用户信息，所有绑定的该<code>State</code>的控件都将由<code>Redux</code>同步自动修改。<code>State</code>可以跨页面共享。</p><p><code>flutter_redux</code>的使用。在<code>redux</code>中引入了<code>action</code>、<code>reducer</code>、<code>store</code>的概念：</p><ul><li><code>action</code>：用于定义一个数据变化的请求。</li><li><code>reducer</code>：用于根据<code>action</code>产生新状态。</li><li><code>store</code>：用于存储和管理<code>state</code>，监听<code>action</code>，将<code>action</code>自动分配给<code>reducer</code>，并根据<code>reducer</code>返回的结果更新<code>state</code>。</li></ul><p>具体使用如下，首先创建一个<code>State</code>用于存储要保存的对象，其中关键代码在于<code>UserReducer</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局Redux State对象，用于保存State数据</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:tyler_flutter_app/single_demo/User.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:tyler_flutter_app/single_demo/user_reducer.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TylerState</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 用户信息</span></span><br><span class="line">  User userInfo;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造方法</span></span><br><span class="line">  TylerState(&#123;<span class="keyword">this</span>.userInfo&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 Reducer 创建 用于store 的 Reducer</span></span><br><span class="line">TylerState appReducer(TylerState state, action) &#123;</span><br><span class="line">  <span class="keyword">return</span> TylerState(</span><br><span class="line">    <span class="comment">// 通过 UserReducer 将 TylerState 内的 userInfo 和 action 关联在一起</span></span><br><span class="line">    userInfo: UserReducer(state.userInfo, action),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是<code>UserReducer</code>的实现。在里面主要通过<code>TypedReducer</code>将<code>Reducer</code>的处理逻辑与定义的<code>action</code>绑定，最后通过<code>combineReducer()</code>返回<code>Reducer&lt;User&gt;</code>对象应用于上面的<code>Store</code>中。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:redux/redux.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:tyler_flutter_app/single_demo/User.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// redux的 combineReducers，通过 TyperReducer 将 UpdateUserAction 与 UpdateUserAction 关联起来</span></span><br><span class="line"><span class="keyword">final</span> UserReducer = combineReducers&lt;User&gt;([TypedReducer&lt;User, UpdateUserAction&gt;(_updateLoaded)]);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果由 UpdateUserAction 发起一个请求时，</span></span><br><span class="line"><span class="comment">就会调用到 _updateLoaded()</span></span><br><span class="line"><span class="comment"> _updateLoaded 这里接受一个新的userInfo，并返回</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">User _updateLoaded(User user, action) &#123;</span><br><span class="line">  user = action.userInfo;</span><br><span class="line">  <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个 action，用于发起 usrInfo的改变</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpdateUserAction</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> User userInfo;</span><br><span class="line"></span><br><span class="line">  UpdateUserAction(<span class="keyword">this</span>.userInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，通过<code>StoreProvider</code>将创建的<code>store</code>引入到Flutter中。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt; runApp(FlutterReducerApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlutterReducerApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建Store，引用 TylerState 中的 appReducer() 创建的Reducer</span></span><br><span class="line">  <span class="keyword">final</span> store = <span class="keyword">new</span> Store&lt;TylerState&gt;(appReducer, initialState: <span class="keyword">new</span> TylerState(userInfo: User.empty()));</span><br><span class="line"></span><br><span class="line">  FlutterReducerApp(&#123;Key key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// 通过 StoreProvider 应用 store</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StoreProvider(</span><br><span class="line">        store: store,</span><br><span class="line">        child: <span class="keyword">new</span> MaterialApp(</span><br><span class="line">          home: DemoUserStorePage(),</span><br><span class="line">        ));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>DemoUserStorePage</code>中，通过<code>StoreConnector</code>将<code>State</code>绑定到<code>Widget</code>；然后通过<code>StoreProvider.of()</code>获取<code>state</code>对象；通过<code>dispatch()</code>一个<code>Action</code>可以更新<code>State</code>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter_redux/flutter_redux.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:tyler_flutter_app/single_demo/User.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:tyler_flutter_app/single_demo/tyler_state.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoUserStorePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// 通过 StoreConnector 关联 TylerState 中的 User</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StoreConnector&lt;TylerState, User&gt;(</span><br><span class="line">      <span class="comment">// 通过 converter 将 TylerState 中的 userInfo 返回</span></span><br><span class="line">      converter: (store) =&gt; store.state.userInfo,</span><br><span class="line">      <span class="comment">// 在 userInfo 中返回实际渲染的控件</span></span><br><span class="line">      builder: (context, userInfo) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Text(</span><br><span class="line">          userInfo.name,</span><br><span class="line">          style: Theme.of(context).textTheme.display1,</span><br><span class="line">        );</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"><span class="comment">// 通过 StoreProvider.of(context) （带有 StoreProvider 下的 context）</span></span><br><span class="line"><span class="comment">// 可以任意的位置访问到 state 中的数据</span></span><br><span class="line">StoreProvider.of(context).state.userInfo;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"><span class="comment">// 通过 dispatch UpdateUserAction，可以更新State</span></span><br><span class="line">StoreProvider.of(context).dispatch(<span class="keyword">new</span> UpdateUserAction(newUserInfo));</span><br></pre></td></tr></table></figure><h2 id="2-4-数据库"><a href="#2-4-数据库" class="headerlink" title="2.4 数据库"></a>2.4 数据库</h2><p>Flutter中常用的数据库第三方库是<a href="https://pub.flutter-io.cn/packages/sqflite" target="_blank" rel="noopener">sqflite</a>。完整代码如下，主要是对sqlite语法的使用。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:convert'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:meta/meta.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:sqflite/sqflite.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:tyler_flutter_app/single_demo/User.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">/// 数据库管理类</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoSqlManager</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> _VERSION = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> _NAME = <span class="string">"demo_github_app_flutter.db"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> Database _database;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  初始化</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> init() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">// 打开 Database</span></span><br><span class="line">    <span class="keyword">var</span> databasePath = <span class="keyword">await</span> getDatabasesPath();</span><br><span class="line">    <span class="built_in">String</span> path = databasePath + _NAME;</span><br><span class="line">    _database = <span class="keyword">await</span> openDatabase(path, version: _VERSION, onCreate: (Database db, <span class="built_in">int</span> version) <span class="keyword">async</span> &#123;</span><br><span class="line">      <span class="comment">// 打开 Database 时，创建一个表</span></span><br><span class="line">      <span class="keyword">await</span> db.execute(<span class="string">"CREATE TABLE Test (id INTEGER PRIMARY KEY, name TEXT, value INTEGER, num REAL)"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  表格是否存在</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> isTableExits(<span class="built_in">String</span> tableName) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> getCurrentDatabase();</span><br><span class="line">    <span class="keyword">var</span> res = <span class="keyword">await</span> _database.rawQuery(<span class="string">"select * from Sqlite_master where type = 'table' and name = '<span class="subst">$tableName</span>'"</span>);</span><br><span class="line">    <span class="keyword">return</span> res != <span class="keyword">null</span> &amp;&amp; res.length &gt; <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  获取当前数据库对象</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> Future&lt;Database&gt; getCurrentDatabase() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (_database == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">await</span> init();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _database;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  关闭</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> close() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_database != <span class="keyword">null</span>) &#123;</span><br><span class="line">      _database.close();</span><br><span class="line">      _database = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">/// 数据库数据提供的基类</span></span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoBaseDbProvider</span> </span>&#123;</span><br><span class="line">  <span class="built_in">bool</span> isTableExits = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  tableSqlString();</span><br><span class="line"></span><br><span class="line">  tableName();</span><br><span class="line"></span><br><span class="line">  tableBaseString(<span class="built_in">String</span> name, <span class="built_in">String</span> columnId) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'''</span></span><br><span class="line"><span class="string">        create table <span class="subst">$name</span> (</span></span><br><span class="line"><span class="string">        <span class="subst">$columnId</span> integer primary key autoincrement,</span></span><br><span class="line"><span class="string">      '''</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Future&lt;Database&gt; getDatabase() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> open();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@mustCallSuper</span></span><br><span class="line">  prepare(name, <span class="built_in">String</span> createSql) <span class="keyword">async</span> &#123;</span><br><span class="line">    isTableExits = <span class="keyword">await</span> DemoSqlManager.isTableExits(name);</span><br><span class="line">    <span class="keyword">if</span> (!isTableExits) &#123;</span><br><span class="line">      Database db = <span class="keyword">await</span> DemoSqlManager.getCurrentDatabase();</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">await</span> db.execute(createSql);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@mustCallSuper</span></span><br><span class="line">  open() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isTableExits) &#123;</span><br><span class="line">      <span class="keyword">await</span> prepare(tableName(), tableSqlString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> DemoSqlManager.getCurrentDatabase();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">用户表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoUserInfoDbProvider</span> <span class="keyword">extends</span> <span class="title">DemoBaseDbProvider</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> name = <span class="string">'UserInfo'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> columnId = <span class="string">"_id"</span>;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> columnUserName = <span class="string">"userName"</span>;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> columnData = <span class="string">"data"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">int</span> id;</span><br><span class="line">  <span class="built_in">String</span> userName;</span><br><span class="line">  <span class="built_in">String</span> data;</span><br><span class="line"></span><br><span class="line">  DemoUserInfoDbProvider();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="keyword">dynamic</span>&gt; toMap(<span class="built_in">String</span> userName, <span class="built_in">String</span> data) &#123;</span><br><span class="line">    <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="keyword">dynamic</span>&gt; map = &#123;columnUserName: userName, columnData: data&#125;;</span><br><span class="line">    <span class="keyword">if</span> (id != <span class="keyword">null</span>) &#123;</span><br><span class="line">      map[columnId] = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  DemoUserInfoDbProvider.fromMap(<span class="built_in">Map</span> map) &#123;</span><br><span class="line">    id = map[columnId];</span><br><span class="line">    userName = map[columnUserName];</span><br><span class="line">    data = map[columnData];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  tableName() &#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  tableSqlString() &#123;</span><br><span class="line">    <span class="keyword">return</span> tableBaseString(name, columnId) +</span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        <span class="subst">$columnUserName</span> text not null,</span></span><br><span class="line"><span class="string">        <span class="subst">$columnData</span> text not null)</span></span><br><span class="line"><span class="string">      '''</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Future _getUserProvider(Database db, <span class="built_in">String</span> userName) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="built_in">List</span>&lt;<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="keyword">dynamic</span>&gt;&gt; maps = <span class="keyword">await</span> db.query(name,</span><br><span class="line">        columns: [columnId, columnUserName, columnData], where: <span class="string">"<span class="subst">$columnUserName</span> = ?"</span>, whereArgs: [userName]);</span><br><span class="line">    <span class="keyword">if</span> (maps.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      DemoUserInfoDbProvider provider = DemoUserInfoDbProvider.fromMap(maps.first);</span><br><span class="line">      <span class="keyword">return</span> provider;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 插入到数据库</span></span><br><span class="line">  Future insert(<span class="built_in">String</span> userName, <span class="built_in">String</span> eventMapString) <span class="keyword">async</span> &#123;</span><br><span class="line">    Database db = <span class="keyword">await</span> getDatabase();</span><br><span class="line">    <span class="keyword">var</span> userProvider = <span class="keyword">await</span> _getUserProvider(db, userName);</span><br><span class="line">    <span class="keyword">if</span> (userProvider != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> result = <span class="keyword">await</span> db.delete(name, where: <span class="string">"<span class="subst">$columnUserName</span> = ?"</span>, whereArgs: [userName]);</span><br><span class="line">      <span class="built_in">print</span>(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> db.insert(name, toMap(userName, eventMapString));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取事件数据</span></span><br><span class="line">  Future&lt;User&gt; getUserInfo(<span class="built_in">String</span> userName) <span class="keyword">async</span> &#123;</span><br><span class="line">    Database db = <span class="keyword">await</span> getDatabase();</span><br><span class="line">    <span class="keyword">var</span> userProvider = <span class="keyword">await</span> _getUserProvider(db, userName);</span><br><span class="line">    <span class="keyword">if</span> (userProvider != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> User.fromJson(json.decode(userProvider.data));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路：通过定义<code>Provider</code>操作数据库：</p><ul><li>在<code>Provider</code>中定义表名和数据库字段常量，用于创建表和字段操作；</li><li>提供数据库与数据实体之间的映射，比如数据库对象与<code>User</code>对象之间的转化；</li><li>在调用<code>Provider</code>时，先判断表是否创建，然后再返回数据库对象进行用户查询。</li></ul><p>如果结合网络请求，通过闭包实现，再需要数据库时，先返回数据库，然后通过<code>next()</code>方法将网络请求的方法返回，最后外部可以通过调用<code>next()</code>方法再执行网络请求。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">UserDao.getUserInfo(userName, needDb: <span class="keyword">true</span>).then((res) &#123;</span><br><span class="line">  <span class="comment">// 数据库结果</span></span><br><span class="line">  <span class="keyword">if</span> (res != <span class="keyword">null</span> &amp;&amp; res.result) &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      userInfo = res.data;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.next;</span><br><span class="line">&#125;).then((res) &#123;</span><br><span class="line">  <span class="comment">// 网络结果</span></span><br><span class="line">  <span class="keyword">if</span> (res != <span class="keyword">null</span> &amp;&amp; res.result) &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      userInfo = res.data;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="3-其他功能"><a href="#3-其他功能" class="headerlink" title="3. 其他功能"></a>3. 其他功能</h1><h2 id="3-1-返回按键监听"><a href="#3-1-返回按键监听" class="headerlink" title="3.1 返回按键监听"></a>3.1 返回按键监听</h2><p>Flutter中，通过<code>WillPopScope</code>嵌套，可以用于监听处理Android返回键的逻辑。其实<code>WillPopScope</code>并不是监听返回键，而是当前页面将要被pop时，触发的回调。</p><p>通过<code>onWillPop()</code>回调返回的<code>Future</code>，判断是否响应pop。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 单机提示退出</span></span><br><span class="line">  Future&lt;<span class="built_in">bool</span>&gt; _dialogExitApp(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> showDialog(</span><br><span class="line">        context: context,</span><br><span class="line">        builder: (context) =&gt; <span class="keyword">new</span> AlertDialog(</span><br><span class="line">              content: <span class="keyword">new</span> Text(<span class="string">"是否退出？"</span>),</span><br><span class="line">              actions: &lt;Widget&gt;[</span><br><span class="line">                <span class="keyword">new</span> FlatButton(</span><br><span class="line">                  onPressed: () =&gt; Navigator.of(context).pop(<span class="keyword">false</span>),</span><br><span class="line">                  child: <span class="keyword">new</span> Text(<span class="string">"取消"</span>),</span><br><span class="line">                ),</span><br><span class="line">                <span class="keyword">new</span> FlatButton(</span><br><span class="line">                  onPressed: () =&gt; Navigator.of(context).pop(<span class="keyword">true</span>),</span><br><span class="line">                  child: <span class="keyword">new</span> Text(<span class="string">"确定"</span>),</span><br><span class="line">                )</span><br><span class="line">              ],</span><br><span class="line">            ));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> WillPopScope(</span><br><span class="line">      onWillPop: () &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        如果 return new Future.value(false); popped就不会被处理，</span></span><br><span class="line"><span class="comment">        如果 return new Future.value(true); popped就会触发，</span></span><br><span class="line"><span class="comment">        这里可以通过 showDialog() 弹出确定框，在返回时通过 Navigator.of(context).pop(true/false);</span></span><br><span class="line"><span class="comment">        决定是否退出</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> _dialogExitApp(context);</span><br><span class="line">      &#125;,</span><br><span class="line">      child: <span class="keyword">new</span> Container(</span><br><span class="line">        color: Colors.white,</span><br><span class="line">        child: <span class="keyword">new</span> Text(<span class="string">"测试"</span>),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-前后台监听"><a href="#3-2-前后台监听" class="headerlink" title="3.2 前后台监听"></a>3.2 前后台监听</h2><p><code>WidgetBindingObserver</code>包含了各种控件的生命周期通知，其中<code>didChangeAppLifecycleState()</code>可以用于做前后台状态监听。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_HomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">HomePage</span>&gt; <span class="title">with</span> <span class="title">WidgetsBindingObserver</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 重写 WidgetsBindingObserver 中的 didChangeAppLifecycleState()</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> didChangeAppLifecycleState(AppLifecycleState state) &#123;</span><br><span class="line">    <span class="comment">// 通过state判断App前后台切换</span></span><br><span class="line">    <span class="keyword">if</span> (state == AppLifecycleState.resumed) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Container();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-键盘焦点处理"><a href="#3-3-键盘焦点处理" class="headerlink" title="3.3 键盘焦点处理"></a>3.3 键盘焦点处理</h2><p>触摸收起键盘，<code>GestureDetector</code> + <code>FocusScope</code>实现。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_LoginPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">LoginPage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">      <span class="comment">// 定义触摸层</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> GestureDetector(</span><br><span class="line">        <span class="comment">// 透明也响应处理</span></span><br><span class="line">        behavior: HitTestBehavior.translucent,</span><br><span class="line">        onTap: () &#123;</span><br><span class="line">          <span class="comment">// 触摸收起键盘</span></span><br><span class="line">          FocusScope.of(context).requestFocus(<span class="keyword">new</span> FocusNode());</span><br><span class="line">        &#125;,</span><br><span class="line">        child: <span class="keyword">new</span> Container(</span><br><span class="line">        ),</span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-启动页"><a href="#3-4-启动页" class="headerlink" title="3.4 启动页"></a>3.4 启动页</h2><p>IOS启动页，在ios/Runner/Assets.xcassets/LaunchImage.imageset/下，<code>Contents.json</code>文件和启动图片，将你的启动页放置在这个目录下，并且修改<code>Contents.json</code>即可，具体尺寸自行谷歌即可。</p><p>Android启动页，在android/app/src/main/res/drawable/launch_background.xml中已经有写好的启动页，<code>&lt;item&gt;&lt;bitmap&gt;</code>部分被屏蔽，只需要打开这个屏蔽，并且将你启动图修改为<code>launch_image</code>并放置到各个<code>mipmap</code>文件夹即可，记得各个文件夹下提供相对于大小尺寸的文件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Demo地址：&lt;a href=&quot;https://gitee.com/QingFengBaiYu/tyler_flutter_app&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;tyler_flutter_app&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文将介绍如何搭建一
      
    
    </summary>
    
      <category term="Flutter" scheme="https://tylerLiu.top/categories/Flutter/"/>
    
      <category term="学习" scheme="https://tylerLiu.top/categories/Flutter/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Flutter" scheme="https://tylerLiu.top/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>一、Dart语言和Flutter基础</title>
    <link href="https://tylerLiu.top/2019/09/16/%E4%B8%80%E3%80%81Dart%E8%AF%AD%E8%A8%80%E5%92%8CFlutter%E5%9F%BA%E7%A1%80/"/>
    <id>https://tylerLiu.top/2019/09/16/一、Dart语言和Flutter基础/</id>
    <published>2019-09-16T02:15:07.000Z</published>
    <updated>2019-09-19T09:14:46.907Z</updated>
    
    <content type="html"><![CDATA[<p>Demo地址：<a href="https://gitee.com/QingFengBaiYu/tyler_flutter_app" target="_blank" rel="noopener">tyler_flutter_app</a></p><h1 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a>1. 基础</h1><h2 id="1-1-环境搭建"><a href="#1-1-环境搭建" class="headerlink" title="1.1 环境搭建"></a>1.1 环境搭建</h2><p>参照<a href="https://flutterchina.club/get-started/install/" target="_blank" rel="noopener">Flutter中文网</a>进行环境搭建即可。</p><p>需要注意，国内由于一些原因，有时需要配置Flutter的代理，并且国内在搜索Flutter第三方包时，也是在<a href="https://pub.flutter-io.cn/" target="_blank" rel="noopener">https://pub.flutter-io.cn/</a>中搜索，下面是需要配置的环境变量的地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// win直接配置到环境编辑即可，mac配置到bash_profile</span><br><span class="line">export PUB_HOSTED_URL=https://pub.flutter-io.cn</span><br><span class="line">export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn</span><br></pre></td></tr></table></figure><h1 id="2-Dart语言下的Flutter"><a href="#2-Dart语言下的Flutter" class="headerlink" title="2. Dart语言下的Flutter"></a>2. Dart语言下的Flutter</h1><h2 id="2-1-基本类型"><a href="#2-1-基本类型" class="headerlink" title="2.1 基本类型"></a>2.1 基本类型</h2><ul><li><code>var</code>：可以定义变量，如<code>var tag = &quot;1111&quot;</code>，这和JS、Kotlin类似，同时Dart算半个动态类型语言，同时支持闭包。</li><li>Darrt属于<strong>强类型语言</strong>，但可以用<code>var</code>声明变量，Dart会<strong>自动推导出数据类型</strong>，<code>var</code>实际上是编译器的“语法糖”。<strong><code>dynamic</code>表示动态类型</strong>，被编译后，实际是一个<code>Object</code>类型，在编译期间不进行任何的类型检查，而是在运行期进行类型检查。</li><li>Dart的number类型分为<code>int</code>和<code>double</code>，其中Java的long对应的也是Dart中的<code>int</code>类型。Dart中没有<code>float</code>类型。</li><li>Dart下只有<code>bool</code>类型可以用于<code>if</code>判断，不同于JS这种使用方式是不合法的<code>var g = &quot;null&quot;;  if(g){}</code>。</li><li>Dart中，switch支持<code>String</code>类型。</li></ul><h2 id="2-2-变量"><a href="#2-2-变量" class="headerlink" title="2.2 变量"></a>2.2 变量</h2><ul><li>Dart不需要给变量设置<code>setter</code>、<code>getter</code>方法，这和Kotlin类似。Dart中所有的基础类型、类都继承<code>Object</code>，默认值是<code>null</code>，自带<code>setter</code>、<code>getter</code>。如果是<code>final</code>或<code>const</code>的话，那么它只有一个<code>getter</code>方法。</li><li>Dart中<code>final</code>和<code>const</code>表示常量，比如<code>final name = &quot;111&quot;; const value = 10000</code>；同时<code>static const</code>组合代表了静态常量。其中<code>const</code>的值在编译期确定，<code>final</code>的值要到运行时才确定。<strong>Flutter在Release下是AOT模式。</strong></li><li>Dart下的数值，在作为字符串使用时，需要显示指定。比如，<code>int i = 0; print(&quot;aaa&quot; + i);</code>，这样是不支持的，需要<code>print(&quot;aaa&quot; + i.toString());</code>。<strong>所以在使用动态类型时，需要注意不要将number类型当作<code>String</code>类型使用。</strong></li><li>Dart中数组等于列表，所以<code>var list = [];</code>和<code>List list = new List();</code>可以简单看作是一样的。</li></ul><h2 id="2-3-方法"><a href="#2-3-方法" class="headerlink" title="2.3 方法"></a>2.3 方法</h2><ul><li>Dart下，<code>??</code>、<code>??=</code>属于操作符，如<code>AA ?? &quot;999&quot;</code>表示如果<code>AA</code>为空，返回<code>&quot;999&quot;</code>；<code>AA ??= &quot;999&quot;</code>表示如果<code>AA</code>为空，给<code>AA</code>设置成<code>&quot;999&quot;</code>。</li><li>Dart方法可以设置<strong>参数默认值</strong>和<strong>指定名称</strong>。如：<code>getDetail(String userName, reponsName, {branch = &quot;master&quot;}){}</code>方法，这里<code>branch</code>不设置的话，默认<code>&quot;master&quot;</code>。<strong>参数类型</strong>可以指定或不指定。调用效果：<code>getRepositoryDetailDao(&quot;aaa&quot;, &quot;bbb&quot;, branch : &quot;dev&quot;);</code>。</li><li>Dart不像Java，没有关键词<code>public</code>、<code>private</code>等修饰符，<code>_</code>表示<code>private</code>，但是有<code>@protected</code>注解。</li><li>Dart中多构造函数可以通过如下代码实现。默认构造方法只能有一个，而通过<code>Model.empty()</code>方法可以创建一个空参数的类，其实方法名可以随意创建。而变量初始化值时，只需要通过<code>this.name</code>在构造方法中指定即可：<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelA</span> </span>&#123;</span><br><span class="line">    <span class="built_in">String</span> name;</span><br><span class="line">    <span class="built_in">String</span> tag;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">///默认构造方法，赋值给name和tag</span></span></span><br><span class="line">    ModelA(<span class="keyword">this</span>.name, <span class="keyword">this</span>.tag);</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">///返回一个空的ModelA</span></span></span><br><span class="line">    ModelA.empty();</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">///返回一个设置了name的ModelA</span></span></span><br><span class="line">    ModelA.forName(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-4-Flutter"><a href="#2-4-Flutter" class="headerlink" title="2.4 Flutter"></a>2.4 Flutter</h2><p>Flutter支持<code>async</code>、<code>await</code>。这个E7类似，代码如下，只是定义的位置不同。同时异步操作也和E7中的<code>Promise</code>类似，只是Flutter中返回的是<code>Future</code>对象，通过<code>then</code>可以执行下一步。如果返回的还是<code>Future</code>，就可以通过<code>then().then()...</code>进行流式操作。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">///模拟等待两秒，返回OK</span></span></span><br><span class="line">request() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> Future.delayed(<span class="built_in">Duration</span>(seconds: <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"ok!"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">///得到"ok!"后，将"ok!"修改为"ok from request"</span></span></span><br><span class="line">doSomeThing() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="built_in">String</span> data = <span class="keyword">await</span> request();</span><br><span class="line">    data = <span class="string">"ok from request"</span>;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">///打印结果</span></span></span><br><span class="line">renderSome() &#123;</span><br><span class="line">    doSomeThing().then((value) &#123;</span><br><span class="line">        <span class="built_in">print</span>(value);</span><br><span class="line">        <span class="comment"><span class="markdown">///输出ok from request</span></span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Flutter中也是通过<code>state</code>跨帧实现管理数据状态的。</li><li>Flutter中一切都是由<code>Widget</code>呈现的，通过<code>build()</code>返回<code>Widget</code>。</li><li>Stream对应的<code>async</code>/<code>yield</code>也可用于异步。</li></ul><h1 id="3-Flutter-Widget"><a href="#3-Flutter-Widget" class="headerlink" title="3. Flutter Widget"></a>3. Flutter Widget</h1><p>在Flutter中，一切的显示都是<code>Widget</code>。<code>Widget</code>是一切的基础，作为响应式的渲染，类似MVVM的实现机制。</p><p>可以通过修改数据，再用<code>setState()</code>设置数据，Flutter会自动通过绑定的数据更新<code>Widget</code>。<strong>所以开发者要做的就是实现<code>Widget</code>界面，并且和数据绑定起来。</strong></p><p><code>Widget</code>分为<strong>有状态</strong>和<strong>无状态</strong>，在Flutter中每个页面都是一帧，无状态就是保持在那一帧，而有状态的<code>Widget</code>当数据更新时，其实是绘制了新的<code>Widget</code>，只是<code>State</code>实现了跨帧的数据同步保存。</p><blockquote><p>Tip：当代码框中输入<code>stl</code>时，可以自动弹出创建无状态控件的模板选项，而输入<code>stf</code>时，会弹出创建有状态<code>Widget</code>的模板选项。</p><p>代码格式化时，括号内外的逗号都会影响格式化时换行的位置。</p><p>如果默认换行的线太短，可以在Setting - Editor - Code - Style - Dart - Wrapping and Braces - Hard wrap at设置数值。</p></blockquote><h2 id="3-1-StatelessWidget"><a href="#3-1-StatelessWidget" class="headerlink" title="3.1 StatelessWidget"></a>3.1 StatelessWidget</h2><p>下面代码是无状态<code>Widget</code>的简单实现。</p><p><strong>继承<code>StatelessWidget</code>，通过<code>build()</code>方法返回一个布局好的控件。</strong></p><p><code>Widget</code>和<code>Widget</code>之间通过<code>child</code>进行嵌套。其中有的<code>Widget</code>只能有一个<code>child</code>，比如下面的<code>Container</code>；有的<code>Widget</code>可以有多个<code>child</code>，也就是<code>children</code>，比如<code>Column</code>布局。下面代码是<code>Container Widget</code>嵌套了<code>Text Widget</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> text;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 数据可以通过构造方法传递进来</span></span><br><span class="line">  DemoWidget(<span class="keyword">this</span>.text);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// 这里返回你需要的控件</span></span><br><span class="line">    <span class="comment">// 这里末尾有没有的逗号，对于格式化代码而已是不一样的</span></span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      <span class="comment">// 白色背景</span></span><br><span class="line">      color: Colors.white,</span><br><span class="line">      <span class="comment">// ?? 表示如果text为空，就返回尾号后的内容</span></span><br><span class="line">      child: Text(text ?? <span class="string">"无状态Demo"</span>),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-StatefulWidget"><a href="#3-2-StatefulWidget" class="headerlink" title="3.2 StatefulWidget"></a>3.2 StatefulWidget</h2><p>下面是有状态<code>widget</code>的实现。</p><p>需要创建管理的主要是<code>State</code>，通过<code>State</code>的<code>build()</code>方法去构建控件。在<code>State</code>中，可以动态改变数据，这类似MVVM的实现，在<code>setState()</code>之后，改变的数据会触发<code>Widget</code>重新构建刷新。下面代码中，通过延迟两秒之后，让文本显示为<code>“数值改变”</code>。</p><p>如下代码还可以看到，<code>State</code>中主要的生命周期有：</p><ul><li><code>initState()</code>：初始化，理论上只有初始化一次，后面会说一个特殊情况。</li><li><code>didChangeDependencies</code>：在<code>initState()</code>之后调用，此时可以获取其他<code>State</code>。</li><li><code>dispose()</code>：销毁，只会调用一次。</li></ul><p>Flutter关注点在于创建<code>StatelessWidget</code>或者<code>StatefulWidget</code>。<strong>在<code>build()</code>中添加布局，然后将数据添加到<code>Widget</code>中，最后通过<code>setState()</code>改变数据，从而实现画面变化。</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoStatefulWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> text;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过构造方法传值</span></span><br><span class="line">  DemoStatefulWidget(<span class="keyword">this</span>.text);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 主要是负责创建state</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _DemoStatefulWidgetState createState() =&gt; _DemoStatefulWidgetState(text);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_DemoStatefulWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">DemoStatefulWidget</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> text;</span><br><span class="line"></span><br><span class="line">  _DemoStatefulWidgetState(<span class="keyword">this</span>.text);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="comment">// 初始化，这个函数在生命周期中只调用一次</span></span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    <span class="comment">// 定时2秒</span></span><br><span class="line">    <span class="keyword">new</span> Future.delayed(<span class="keyword">const</span> <span class="built_in">Duration</span>(seconds: <span class="number">1</span>), () &#123;</span><br><span class="line">      setState(() &#123;</span><br><span class="line">        text = <span class="string">"数值改变"</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> didChangeDependencies() &#123;</span><br><span class="line">    <span class="comment">// 在initState()之后调 Called when a dependency of this [State] object changes.</span></span><br><span class="line">    <span class="keyword">super</span>.didChangeDependencies();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    <span class="comment">// 销毁</span></span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      child: Text(text ?? <span class="string">"这就是有状态Demo"</span>),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-Flutter布局"><a href="#4-Flutter布局" class="headerlink" title="4. Flutter布局"></a>4. Flutter布局</h1><p>Flutter内置了近30多种<a href="https://flutterchina.club/widgets/layout/" target="_blank" rel="noopener">布局<code>Widget</code></a>。下面是常用的布局。</p><table><thead><tr><th align="center">类型</th><th align="left">作用特点</th></tr></thead><tbody><tr><td align="center">Container</td><td align="left">只有一个子Widget。默认充满，包含了<code>padding</code>、<code>margin</code>、<code>color</code>、<code>height</code>、<code>width</code>、<code>decoration</code>等配置。</td></tr><tr><td align="center">Padding</td><td align="left">只有一个子Widget。只用于设置Padding，常用于嵌套<code>child</code>，给<code>child</code>设置<code>padding</code>。</td></tr><tr><td align="center">Center</td><td align="left">只有一个子Widget。只用于居中显示，常用于嵌套<code>child</code>，给<code>child</code>设置居中。</td></tr><tr><td align="center">Stack</td><td align="left">可以有多个子Widget。子Widget堆叠在一起。</td></tr><tr><td align="center">Column</td><td align="left">可以有多个子Widget。垂直布局。</td></tr><tr><td align="center">Row</td><td align="left">可以有多个子Widget。水平布局。</td></tr><tr><td align="center">Expanded</td><td align="left">只有一个子Widget。在<code>Column</code>和<code>Row</code>中充满。</td></tr><tr><td align="center">ListView</td><td align="left">可以有多个子Widget。</td></tr></tbody></table><ul><li><p><code>Container</code>：最常用的默认布局。只能包含一个<code>child</code>，支持配置<code>padding</code>、<code>margin</code>、<code>color</code>、<code>height</code>、<code>width</code>、<code>decoration</code>（一般配置边框和阴影）等配置。在Flutter中，不是所有的控件都有<code>padding</code>、<code>margin</code>、<code>color</code>、<code>height</code>、<code>width</code>等属性，所有才会有<code>Padding</code>、<code>Center</code>等<code>Widget</code>的存在。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Container(</span><br><span class="line">    <span class="comment">// 四周都是10的margin</span></span><br><span class="line">    margin: EdgeInsets.all(<span class="number">10.0</span>),</span><br><span class="line">    height: <span class="number">120.0</span>,</span><br><span class="line">    width: <span class="number">500.0</span>,</span><br><span class="line">    <span class="comment">// 透明黑色遮罩</span></span><br><span class="line">    decoration: <span class="keyword">new</span> BoxDecoration(</span><br><span class="line">        <span class="comment">// 弧度</span></span><br><span class="line">        borderRadius: BorderRadius.all(Radius.circular(<span class="number">10.0</span>)),</span><br><span class="line">        <span class="comment">// 设置了decoration的color，就不能设置Container的color</span></span><br><span class="line">        color: Colors.black,</span><br><span class="line">        <span class="comment">// 边框</span></span><br><span class="line">        border: <span class="keyword">new</span> Border.all(color: Colors.indigo, width: <span class="number">3.0</span>)),</span><br><span class="line">    child: <span class="keyword">new</span> Text(<span class="string">"77777"</span>),</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p><code>Column</code>和<code>Row</code>也是最常见的布局。如下，它们常用的属性配置有：主轴方向是<code>start</code>或<code>center</code>等；副轴方向是<code>start</code>或<code>center</code>等；<code>mainAxisSize</code>是充满最大尺寸，或者只根据子Widget显示最小尺寸。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主轴方向，Column的竖向、Row的横向</span></span><br><span class="line">mainAxisAlignment: MainAxisAlignment.start,</span><br><span class="line"><span class="comment">// 默认是最大充满或根据child显示最小大小</span></span><br><span class="line">mainAxisSize: MainAxisSize.max,</span><br><span class="line"><span class="comment">// 副轴方向，Column的横向、Row我的竖向</span></span><br><span class="line">crossAxisAlignment :CrossAxisAlignment.center,</span><br></pre></td></tr></table></figure></li><li><p><code>Expanded</code>：在<code>Column</code>和<code>Row</code>中表示平均充满，当有两个存在的时候，默认均分充满。同时页面可以设置<code>flex</code>属性决定比例。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Column(</span><br><span class="line">    <span class="comment">// 主轴居中，即竖直向居中</span></span><br><span class="line">    mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">    <span class="comment">// 大小按照最小显示</span></span><br><span class="line">    mainAxisSize: MainAxisSize.min,</span><br><span class="line">    <span class="comment">// 横向居中</span></span><br><span class="line">    crossAxisAlignment: CrossAxisAlignment.center,</span><br><span class="line">    children: &lt;Widget&gt;[</span><br><span class="line">    <span class="comment">// flex默认为1</span></span><br><span class="line">    <span class="keyword">new</span> Expanded(child: <span class="keyword">new</span> Text(<span class="string">"111"</span>), flex: <span class="number">2</span>),</span><br><span class="line">    <span class="keyword">new</span> Expanded(child: <span class="keyword">new</span> Text(<span class="string">"222"</span>)),</span><br><span class="line">    ],</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><p>下面来写一个复杂的控件。首先创建一个私有方法<code>_getBottomItem()</code>，返回一个<code>Expanded Widget</code>，后面会将这个方法返回的<code>Widget</code>在<code>Row</code>下平均充满。</p><p>如代码中注释，布局内主要实现一个居中的Icon图标和文本，中间间隔5.0的<code>padding</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个居中带图标和文本的Item</span></span><br><span class="line">_getBottomItem(IconData icon, <span class="built_in">String</span> text) &#123;</span><br><span class="line">  <span class="comment">// 充满 Row 横向的布局</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Expanded(</span><br><span class="line">    flex: <span class="number">1</span>,</span><br><span class="line">    <span class="comment">// 居中显示</span></span><br><span class="line">    child: <span class="keyword">new</span> Center(</span><br><span class="line">      <span class="comment">// 横向布局</span></span><br><span class="line">      child: <span class="keyword">new</span> Row(</span><br><span class="line">        <span class="comment">// 主轴居中,即是横向居中</span></span><br><span class="line">        mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">        <span class="comment">// 大小按照最大充满</span></span><br><span class="line">        mainAxisSize: MainAxisSize.max,</span><br><span class="line">        <span class="comment">// 竖向居中</span></span><br><span class="line">        crossAxisAlignment: CrossAxisAlignment.center,</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          <span class="comment">// 一个图标，大小16.0，灰色</span></span><br><span class="line">          <span class="keyword">new</span> Icon(icon, size: <span class="number">16.0</span>, color: Colors.grey),</span><br><span class="line">          <span class="comment">// 间隔</span></span><br><span class="line">          <span class="keyword">new</span> Padding(padding: <span class="keyword">new</span> EdgeInsets.only(left: <span class="number">5.0</span>)),</span><br><span class="line">          <span class="comment">// 显示文本</span></span><br><span class="line">          <span class="keyword">new</span> Text(</span><br><span class="line">            text,</span><br><span class="line">            <span class="comment">// 设置字体样式：颜色灰色，字体大小14.0</span></span><br><span class="line">            style: <span class="keyword">new</span> TextStyle(color: Colors.grey, fontSize: <span class="number">14.0</span>),</span><br><span class="line">            <span class="comment">// 超过的省略为...显示</span></span><br><span class="line">            overflow: TextOverflow.ellipsis,</span><br><span class="line">            <span class="comment">// 最长一行</span></span><br><span class="line">            maxLines: <span class="number">1</span>,</span><br><span class="line">          ),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着将上面的方法放到新的布局中。</p><ul><li>首先<code>Container</code>包含了<code>Card</code>，用于快速简单的实现圆角和阴影。</li><li>然后包含了<code>FlatButton</code>实现了点击，通过<code>Padding</code>实现边距。</li><li>接着通过<code>Column</code>垂直包含了两个子Widget，一个是<code>Contain</code>，一个是<code>Row</code>。</li><li><code>Row</code>内使用的是<code>_getBottomItem()</code>方法返回的<code>Widget</code>，效果图如下。<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Container(</span><br><span class="line">    <span class="comment">// 卡片包装</span></span><br><span class="line">    child: <span class="keyword">new</span> Card(</span><br><span class="line">        <span class="comment">// 点击效果</span></span><br><span class="line">        child: <span class="keyword">new</span> FlatButton(</span><br><span class="line">            onPressed: () &#123;</span><br><span class="line">              <span class="built_in">print</span>(<span class="string">"点击了"</span>);</span><br><span class="line">            &#125;,</span><br><span class="line">            child: <span class="keyword">new</span> Padding(</span><br><span class="line">              padding: <span class="keyword">new</span> EdgeInsets.only(</span><br><span class="line">                  left: <span class="number">0.0</span>, top: <span class="number">10.0</span>, right: <span class="number">10.0</span>, bottom: <span class="number">10.0</span>),</span><br><span class="line">              child: <span class="keyword">new</span> Column(</span><br><span class="line">                mainAxisSize: MainAxisSize.min,</span><br><span class="line">                children: &lt;Widget&gt;[</span><br><span class="line">                  <span class="comment">// 文本描述</span></span><br><span class="line">                  <span class="keyword">new</span> Container(</span><br><span class="line">                      child: <span class="keyword">new</span> Text(</span><br><span class="line">                        <span class="string">"这是一点描述"</span>,</span><br><span class="line">                        style: TextStyle(</span><br><span class="line">                          color: Colors.amber,</span><br><span class="line">                          fontSize: <span class="number">14.0</span>,</span><br><span class="line">                        ),</span><br><span class="line">                        <span class="comment">// 最长三行，超过 ... 显示</span></span><br><span class="line">                        maxLines: <span class="number">3</span>,</span><br><span class="line">                        overflow: TextOverflow.ellipsis,</span><br><span class="line">                      ),</span><br><span class="line">                      margin: <span class="keyword">new</span> EdgeInsets.only(top: <span class="number">6.0</span>, bottom: <span class="number">2.0</span>),</span><br><span class="line">                      alignment: Alignment.topLeft),</span><br><span class="line">                  <span class="keyword">new</span> Padding(padding: EdgeInsets.all(<span class="number">10.0</span>)),</span><br><span class="line">                  <span class="comment">// 三个平均分配的横向图标文字</span></span><br><span class="line">                  <span class="keyword">new</span> Row(</span><br><span class="line">                    crossAxisAlignment: CrossAxisAlignment.start,</span><br><span class="line">                    children: &lt;Widget&gt;[</span><br><span class="line">                      _getBottomItem(Icons.star, <span class="string">"1000"</span>),</span><br><span class="line">                      _getBottomItem(Icons.link, <span class="string">"1000"</span>),</span><br><span class="line">                      _getBottomItem(Icons.subject, <span class="string">"1000"</span>),</span><br><span class="line">                    ],</span><br><span class="line">                  ),</span><br><span class="line">                ],</span><br><span class="line">              ),</span><br><span class="line">            ))),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><img src="/2019/09/16/一、Dart语言和Flutter基础/1568624171.jpg"><h1 id="5-Flutter页面"><a href="#5-Flutter页面" class="headerlink" title="5. Flutter页面"></a>5. Flutter页面</h1><p>Flutter中除了布局的<code>Widget</code>，还有交互显示的<code>Widget</code>和完整页面呈现的<code>Widget</code>。常见的有<code>MaterialApp</code>、<code>Scaffold</code>、<code>Appbar</code>、<code>Text</code>、<code>Image</code>、<code>FlatBotton</code>等。</p><table><thead><tr><th align="center">类型</th><th align="left">作用特点</th></tr></thead><tbody><tr><td align="center">MaterialApp</td><td align="left">一般作为App顶层的主页入口，可配置主题、多语言、路由等</td></tr><tr><td align="center">Scaffold</td><td align="left">一般用户页面的承载Widget，包含<code>appbar</code>、<code>snackbar</code>、<code>drawer</code>等Material Design设定</td></tr><tr><td align="center">Appbar</td><td align="left">一般用于<code>Scaffold</code>的<code>appbar</code>，内有标题，二级页面返回按键等</td></tr><tr><td align="center">Text</td><td align="left">显示文本，主要是通过<code>style</code>设置<code>TextStyle</code>来设置字体样式等</td></tr><tr><td align="center">RichText</td><td align="left">富文本，通过设置<code>TextSpan</code>，可以拼接出富文本场景</td></tr><tr><td align="center">TextField</td><td align="left">文本输入框，<code>new TextField(controller: // 文本控制器, obscureText: &quot;hint文本&quot;);</code></td></tr><tr><td align="center">Image</td><td align="left">图片加载，<code>new FadeInImage.assetNetWork(placeholder: &quot;预览图&quot;, fit: BoxFit.fitWindth, image: &quot;url&quot;);</code></td></tr><tr><td align="center">FlatBotton</td><td align="left">按键点击，<code>new FlatBotton(onPressed:(){}, child: new Container());</code></td></tr></tbody></table><p>下面再实现一个完整的页面，实现：</p><ul><li>创建一个<code>StatefulWidget</code>：<code>DemoPage</code>。</li><li>在<code>_DemoPageState()</code>中，通过<code>build()</code>创建一个<code>Scaffold</code>。</li><li><code>Scaffold</code>内包含一个<code>Appbar</code>和一个<code>ListView</code>。</li><li><code>Appbar</code>类似标题区域，其中设置了<code>title</code>为<code>Text Widget</code>。</li><li><code>body</code>是<code>ListView</code>，返回20个之前创建的<code>DemoItem Widget</code>。<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:tyler_flutter_app/widget/demo_stateless_widget.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoPage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _DemoPageState createState() =&gt; _DemoPageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_DemoPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">DemoPage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// 一个页面的开始，如果是新页面，会自带返回按键</span></span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      <span class="comment">// 背景</span></span><br><span class="line">      backgroundColor: Colors.blue,</span><br><span class="line">      <span class="comment">// 标题栏</span></span><br><span class="line">      appBar: <span class="keyword">new</span> AppBar(</span><br><span class="line">        title: <span class="keyword">new</span> Text(<span class="string">"一个标题"</span>),</span><br><span class="line">      ),</span><br><span class="line">      <span class="comment">// 正式页面开始，一个ListView，内有20个ItemView</span></span><br><span class="line">      body: <span class="keyword">new</span> ListView.builder(</span><br><span class="line">        itemBuilder: (context, index) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> DemoItem();</span><br><span class="line">        &#125;,</span><br><span class="line">        itemCount: <span class="number">20</span>,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>将创建的<code>DemoPage</code>传入<code>main</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:tyler_flutter_app/widget/demo_page.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">// This widget is the root of your application.</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Tyler Flutter Demo'</span>,</span><br><span class="line">      theme: ThemeData(</span><br><span class="line">        primarySwatch: Colors.blue,</span><br><span class="line">      ),</span><br><span class="line">      home: DemoPage(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2019/09/16/一、Dart语言和Flutter基础/1568625942.jpg">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Demo地址：&lt;a href=&quot;https://gitee.com/QingFengBaiYu/tyler_flutter_app&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;tyler_flutter_app&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;1-基础&quot;
      
    
    </summary>
    
      <category term="Flutter" scheme="https://tylerLiu.top/categories/Flutter/"/>
    
      <category term="学习" scheme="https://tylerLiu.top/categories/Flutter/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Flutter" scheme="https://tylerLiu.top/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Android深入理解ActivityManagerService 02：ActivityTask和Activity栈管理</title>
    <link href="https://tylerLiu.top/2019/09/12/Android%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ActivityManagerService-02%EF%BC%9AActivityTask%E5%92%8CActivity%E6%A0%88%E7%AE%A1%E7%90%86/"/>
    <id>https://tylerLiu.top/2019/09/12/Android深入理解ActivityManagerService-02：ActivityTask和Activity栈管理/</id>
    <published>2019-09-12T01:42:50.000Z</published>
    <updated>2019-09-16T01:59:28.280Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-ActivityTask"><a href="#1-ActivityTask" class="headerlink" title="1. ActivityTask"></a>1. ActivityTask</h1><p><code>ActivityTask</code>是一个管理类，用来管理系统所有Activity的各种状态，其内部维护了<code>TaskRecord</code>的列表，因此从Activity任务栈这一角度来说，<code>ActivityTask</code>也可以理解为Activity堆栈。它由<code>ActivityStackSupervisor</code>来进行管理的，而<code>ActivityStackSupervisor</code>是在AMS中的构造方法中被创建。frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ActivityManagerService</span><span class="params">(Context systemContext)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    mStackSupervisor = <span class="keyword">new</span> ActivityStackSupervisor(<span class="keyword">this</span>);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-1-ActivityStack的实例类型"><a href="#1-1-ActivityStack的实例类型" class="headerlink" title="1.1 ActivityStack的实例类型"></a>1.1 ActivityStack的实例类型</h2><p><code>ActivityStackSupervisor</code>中有多种<code>ActivityStack</code>实例，如下：frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityStackSupervisor</span> <span class="keyword">implements</span> <span class="title">DisplayListener</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    ActivityStack mHomeStack;</span><br><span class="line">    ActivityStack mFocusedStack;</span><br><span class="line">    <span class="keyword">private</span> ActivityStack mLastFocusedStack;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>mHomeStack</code>用来存储Launcher App的所有Activity</li><li><code>mFocusedStack</code>表示当前正在接收输入或启动下一个Activity的所有Activity</li><li><code>mLastFocusedStack</code>表示当前接收输入的所有Activity</li></ul><p>通过<code>ActiviyStackSupervisor</code>提供了获取上述<code>ActivityStack</code>的方法，如，要获取<code>mFocusedStack</code>，就可以调用：frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ActivityStack <span class="title">getFocusedStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mFocusedStack;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-ActivityState"><a href="#1-2-ActivityState" class="headerlink" title="1.2 ActivityState"></a>1.2 ActivityState</h2><p><code>ActivityStack</code>中通过枚举存储了Activity的所有状态，如下：frameworks/base/services/core/java/com/android/server/am/ActivityStack.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> ActivityState &#123;</span><br><span class="line">    INITIALIZING,</span><br><span class="line">    RESUMED,</span><br><span class="line">    PAUSING,</span><br><span class="line">    PAUSED,</span><br><span class="line">    STOPPING,</span><br><span class="line">    STOPPED,</span><br><span class="line">    FINISHING,</span><br><span class="line">    DESTROYING,</span><br><span class="line">    DESTROYED</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用<code>ActivityState</code>的场景会有很多，比如：frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">overridePendingTransition</span><span class="params">(IBinder token, String packageName, <span class="keyword">int</span> enterAnim, <span class="keyword">int</span> exitAnim)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (self.state == ActivityState.RESUMED || self.state == ActivityState.PAUSING) &#123; <span class="comment">// 1</span></span><br><span class="line">        mWindowManager.overridePendingAppTransition(packageName, enterAnim, exitAnim, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>overridePendingAppTransition()</code>用于设置Activity的切换动画，注释1，可以看到只有<code>ActivityState</code>为<code>RESUMED</code>状态或<code>PASUED</code>状态时，才会调用WMS类型的<code>mWindowManager</code>对象的<code>overridePendingAppTransition()</code>来进行切换动画。</p><h2 id="1-3-特殊状态的Activity"><a href="#1-3-特殊状态的Activity" class="headerlink" title="1.3 特殊状态的Activity"></a>1.3 特殊状态的Activity</h2><p>在<code>ActivityStack</code>中定义了一些特殊状态的Activity，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正在暂停的Activity</span></span><br><span class="line">ActivityRecord mPausingActivity = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上一个已经暂停的Activity</span></span><br><span class="line">ActivityRecord mLastPausedActivity = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最近一次没有历史记录的Activity</span></span><br><span class="line">ActivityRecord mLastNoHistoryActivity = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 已经Resume的Activity</span></span><br><span class="line">ActivityRecord mResumedActivity = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最近一次启动的Activity</span></span><br><span class="line">ActivityRecord mLastStartedActivity = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传递给convertToTranslucent方法的最上层的Activity</span></span><br><span class="line">ActivityRecord mTranslucentActivityWaiting = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>这些特殊状态都是<code>ActivityRecord</code>类型的，<code>ActivityRecord</code>用来记录一个Activity的所有信息。从Activity任务栈的角度来说，一个或多个<code>ActivityRecord</code>会组成一个<code>TaskRecord</code>，<code>TaskRecors</code>用来记录Activity的栈，而<code>ActivityStack</code>包含了一个或多个<code>TaskRecord</code>。</p><img src="/2019/09/12/Android深入理解ActivityManagerService-02：ActivityTask和Activity栈管理/VeivrR.png"><h2 id="1-4-维护的ArrayList"><a href="#1-4-维护的ArrayList" class="headerlink" title="1.4 维护的ArrayList"></a>1.4 维护的ArrayList</h2><p><code>ActivityStack</code>内部维护了多个<code>ArrayList</code>，主要用来存储<code>ActivityRecord</code>和<code>TaskRecord</code>，其中<code>TaskRecord</code>用来记录Activity的Task。</p><table><thead><tr><th align="center">ArrayList</th><th align="center">元素类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">mTaskHistory</td><td align="center">TaskRecord</td><td align="center">所有没有被销毁的Task</td></tr><tr><td align="center">mLRUActivvities</td><td align="center">ActivtiyRecord</td><td align="center">正在运行的Activity，列表中第一个条目是最近最少使用的元素</td></tr><tr><td align="center">mNoAnimActivities</td><td align="center">ActivityRecord</td><td align="center">不考虑转换动画的Activity</td></tr><tr><td align="center">mValidateAppTokens</td><td align="center">TaskGroup</td><td align="center">用于与窗口管理器验证应用令牌</td></tr></tbody></table><h1 id="2-Activity栈管理"><a href="#2-Activity栈管理" class="headerlink" title="2. Activity栈管理"></a>2. Activity栈管理</h1><p>Activity是由任务栈来进行管理的，有了栈管理，就可以对应用程序进行操作，应用可以复用自身应用中以及其他应用的Activity，节省资源。</p><p>比如，使用一个App，这个App的联系人详情界面提供了联系人的邮箱，当点击邮箱时会跳转到发送邮件的界面。</p><img src="/2019/09/12/Android深入理解ActivityManagerService-02：ActivityTask和Activity栈管理/VeiL24.png"><p>App和系统Email中的Activity是处于不同程序进程的，而有了栈管理，就可以把发送邮件界面放到社交应用中详情界面所在栈的栈顶，来做到跨进程操作。</p><p>为了更灵活的进行栈管理，Android系统提供了很多配置，下面分别进行讨论。</p><h2 id="2-1-Launch-Mode"><a href="#2-1-Launch-Mode" class="headerlink" title="2.1 Launch Mode"></a>2.1 Launch Mode</h2><p>用于设定Activity的启动模式：</p><ul><li>standerd：默认模式，每次启动Activity都会创建一个新的Activity实例。</li><li>singleTop：如果要启动的Activity已经在栈顶，则不会重新创建Activity，同时该Activity的<code>onNewIntent()</code>方法会被调用。如果要启动Activity的不在栈顶，就会重新创建该Activity的实例。</li><li>singleTask：如果要启动的Activity已经存在栈中，就不会创建该Activity的实例，而是将栈中位于该Activity上的所有Activity出栈，同时该Activity的<code>onNewIntnent()</code>会被调用。如果要启动的Activity不存在在该栈中，则要先创建一个新栈，然后创建该Activity的实例，并入栈。</li><li>singleInstance：和singleTask类似，不同的是启动Activity时，首先要创建在一个新栈，然后创建该Activity实例并入栈，新栈中只会存在这一个Activity实例。</li></ul><h2 id="2-2-Intent的FLAG"><a href="#2-2-Intent的FLAG" class="headerlink" title="2.2 Intent的FLAG"></a>2.2 Intent的FLAG</h2><p><code>Intent</code>中定义了很多<code>FLAG</code>，其中有几个<code>FLAG</code>也可以设定Activity的启动方式，如果Launch Mode设定与<code>FLAG</code>设定的Activity的启动方式不同，则以<code>FLAG</code>设定的为准。</p><ul><li><code>FLAG_ACTIVITY_SINGLE_TOP</code>：与Launch Mode中的singleTop相同。</li><li><code>FLAG_ACTIVITY_NEW_TASK</code>：与Launch Mode中的singleTask相同。</li><li><code>FLAG_ACTIVITY_CLEAR_TOP</code>：Launch Mode中没有与之对应的模式，如果要启动Activity已经存在与栈中，则将所有位于它上面的Activity出栈。singleTop默认具有此标记位的效果。</li></ul><p>除了上面的三种<code>FLAG</code>，还有一些对分析栈管理有帮助的。</p><ul><li><code>FLAG_ACTIVITY_NO_HISTORY</code>：Activity一旦退出，就不会存在于栈中。同样的，也可以在<code>AndroidManifest.xml</code>中设置<code>&quot;android:noHistory&quot;</code>。</li><li><code>FLAG_ACTIVITY_MULTIPLE_TASK</code>：需要和<code>FLAG_ACTIVITY_NEW_TASK</code>共同使用才有效果，系统会启动一个新的栈来容纳新启动的Activity。</li><li><code>FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS</code>：Activity不会被放入到“最近启动的Activity”列表中。</li><li><code>FLAG_ACTIVITY_BROUGHT_TO_FRONT</code>：这个标志位通常不是由应用程序中的代码设置的，而是由Launch Mode为singleTask时，系统自动添加上的。</li><li><code>FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY</code>：这个标志位通常不是由应用程序中的代码设置的，而是从历史记录中启动的（长按HOME键调出）。</li><li><code>FLAG_ACTIVITY_CLEAR_TASK</code>：需要和<code>FLAG_ACTIVITY_NEW_TASK</code>共同使用才有效果，用于清除于启动的Activity相关的栈的所有其他Activity。</li></ul><p>下面通过源码查看<code>FLAG</code>的应用，在<a href="https://tylerliu.top/2019/09/02/Andorid深入理解四大组件-02%EF%BC%9A应用程序启动过程%EF%BC%88下%EF%BC%89/">Andorid深入理解四大组件 02：应用程序启动过程（下）</a>中讲过，根Activity启动时会调用AMS的<code>startActivity()</code>，经过层层调用，最终会调用<code>ActivityServer</code>的<code>startActivityUnchecked()</code>，如下时序图：</p><img src="/2019/09/12/Android深入理解ActivityManagerService-02：ActivityTask和Activity栈管理/VeiOxJ.png"><p>frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivityUnchecked</span><span class="params">(<span class="keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, <span class="keyword">int</span> startFlags, <span class="keyword">boolean</span> doResume, ActivityOptions options, TaskRecord inTask)</span> </span>&#123;</span><br><span class="line">    setInitialState(r, options, inTask, doResume, startFlags, sourceRecord, voiceSession, voiceInteractor); <span class="comment">// 1</span></span><br><span class="line">    computeLaunchingTaskFlags(); <span class="comment">// 2</span></span><br><span class="line">    computeSourceStack();</span><br><span class="line">    mIntent.setFlags(mLaunchFlags); <span class="comment">// 3</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，初始化启动Activity的各种配置，在初始化前会重置各种配置再进行配置，这些配置包括：<code>ActivityRecord</code>、<code>Intent</code>、<code>TaskReccord</code>和<code>LaunchFlags</code>（启动的<code>FLAG</code>）等。</p><p>注释2，用于计算出启动的<code>FLAG</code>，并将其赋值给<code>mLaunchFlags</code>。</p><p>注释3，将<code>mLaunchFlags</code>设置给<code>Intent</code>，达到设定Activity启动方式的目的。</p><p>再来看<code>computeLaunchingTaskFlags()</code>：frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">computeLaunchingTaskFlags</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (mInTask == <span class="keyword">null</span>) &#123; <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">if</span> (mSourceRecord == <span class="keyword">null</span>) &#123; <span class="comment">// 2</span></span><br><span class="line">            <span class="keyword">if</span> ((mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) == <span class="number">0</span> &amp;&amp; mInTask == <span class="keyword">null</span>) &#123; <span class="comment">// 3</span></span><br><span class="line">                Slog.w(TAG, <span class="string">"startActivity called from non-Activity context; forcing "</span> + <span class="string">"Intent.FLAG_ACTIVITY_NEW_TASK for: "</span> + mIntent);</span><br><span class="line">                mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mSourceRecord.launchMode == LAUNCH_SINGLE_INSTANCE) &#123; <span class="comment">// 4</span></span><br><span class="line">            mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mLaunchSingleInstance || mLaunchSingleTask) &#123; <span class="comment">// 5</span></span><br><span class="line">            mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算启动的<code>FLAG</code>逻辑比较复杂，这里截取了部分代码。</p><p>注释1，<code>TaskRecord</code>类型的<code>mInTask</code>为空时，说明Activity要加入的栈不存在。这段代码就是要解决Activity要加入的栈不存在时，如何计算出启动的<code>FLAG</code>的问题。</p><p>注释2，<code>ActivityRecord</code>类型的<code>mSourceRecord</code>是用于描述“初始Activity”的。比如ActivityA启动了ActivityB，ActivityA就是“初始Activity”。</p><p>同时满足了注释1和2的条件时，就需要创建一个新的栈。</p><p>注释4，如果“初始Activity”所在的栈只允许有一个Activity实例，则也需要创建一个新栈。</p><p>注释5，如果Launch Mode设置了singleTask或singleInstance，则也需要创建一个新栈。</p><h2 id="2-3-taskAffinity"><a href="#2-3-taskAffinity" class="headerlink" title="2.3 taskAffinity"></a>2.3 taskAffinity</h2><p>可以在<code>AndoridManifest.xml</code>中设置<code>&quot;android:taskAffinity&quot;</code>，用来指定Activity希望归属的栈，默认，同一个应用程序的所有Activity都有着相同的<code>taskAffinity</code>。</p><p><code>taskAffinity</code>会在下面两种情况产生效果：</p><ol><li><code>taskAffinity</code>与<code>FLAG_ACTIVITY_NEW_TASK</code>或者singleTask配合。如果新启动Activity的<code>taskAffinity</code>与栈的<code>taskAffiniy</code>相同（栈的<code>taskAffinity</code>取决于根Activity的<code>taskAffinity</code>），则加入到该栈中。如果不相同，就会创建新栈。</li><li><code>taskAffinity</code>与<code>allowTaskReparenting</code>配合。如果<code>allowTaskReparenting</code>为<code>true</code>，说明Activity具有转移的能力。用之前的邮件为例，当App启动了发送邮件的Activity，此时发送邮件的Activity和App应用处于同一个栈中。如果发送邮件的Activity的<code>allowTaskReparenting</code>设为<code>false</code>，此后邮件程序所在的栈就位于前台，这时发送邮件的Activity就会由App的栈中转移到与它更关系密切的邮件程序（<code>taskAffinity</code>相同）所在的栈中。</li></ol><p>接着通过源码查看<code>taskAffinity</code>的应用。<code>ActivityStackSupervisor</code>的<code>findTaskLocked</code>方法用于找到Activity最匹配的栈，最终会调用<code>ActivityTask</code>的<code>findTaskLocked()</code>：frameworks/base/services/core/java/com/android/server/am/ActivityStack.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findTaskLocked</span><span class="params">(ActivityRecord target, FindTaskResult result)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> taskNdx = mTaskHistory.size() - <span class="number">1</span>; taskNdx &gt;= <span class="number">0</span>; --taskNdx) &#123;<span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">final</span> TaskRecord task = mTaskHistory.get(taskNdx);<span class="comment">// 2</span></span><br><span class="line">        ......</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isDocument &amp;&amp; !taskIsDocument &amp;&amp; result.r == <span class="keyword">null</span> &amp;&amp; task.canMatchRootAffinity()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (task.rootAffinity.equals(target.taskAffinity)) &#123; <span class="comment">// 3</span></span><br><span class="line">                ......</span><br><span class="line">                result.r = r;</span><br><span class="line">                result.matchedByRootAffinity = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DEBUG_TASKS) Slog.d(TAG_TASKS, <span class="string">"Not a match: "</span> + task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，遍历<code>mTaskHistory</code>列表，列表的元素为<code>TaskRecord</code>，用于存储没有被销毁的Task。</p><p>注释2，得到某个Task的信息。</p><p>注释3，将Task的<code>rootAffinity</code>（初始的<code>taskAffinity</code>）和目标Activity的<code>taskAffinity</code>做对比，如果相同，则将<code>FindTaskResult</code>的<code>matchedByRootAffinity</code>属性设置为<code>true</code>，说明找到了匹配的<code>Task</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-ActivityTask&quot;&gt;&lt;a href=&quot;#1-ActivityTask&quot; class=&quot;headerlink&quot; title=&quot;1. ActivityTask&quot;&gt;&lt;/a&gt;1. ActivityTask&lt;/h1&gt;&lt;p&gt;&lt;code&gt;ActivityTask&lt;/
      
    
    </summary>
    
      <category term="Android进阶" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
      <category term="框架层" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/"/>
    
      <category term="深入理解ActivityManagerService" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ActivityManagerService/"/>
    
    
      <category term="ActivityManagerService" scheme="https://tylerLiu.top/tags/ActivityManagerService/"/>
    
  </entry>
  
  <entry>
    <title>Android深入理解ActivityManagerService 01：AMS启动流程和相关类</title>
    <link href="https://tylerLiu.top/2019/09/10/Android%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ActivityManagerService-01%EF%BC%9AAMS%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%92%8C%E7%9B%B8%E5%85%B3%E7%B1%BB/"/>
    <id>https://tylerLiu.top/2019/09/10/Android深入理解ActivityManagerService-01：AMS启动流程和相关类/</id>
    <published>2019-09-10T08:08:38.000Z</published>
    <updated>2019-09-12T01:34:15.212Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>AMS是系统的引导服务，应用程序进程的启动、切换和调度、四大组件的启动和管理都需要AMS的支持。当然，并不是AMS一个类去完成这些，还有一些其他关联的类共同完成，后面会讲到。本文主要涉及以下要点：</p><ul><li>AMS的启动流程</li><li>AMS与进程的启动</li><li>AMS相关（关联）的类</li></ul><h1 id="2-AMS的启动流程"><a href="#2-AMS的启动流程" class="headerlink" title="2. AMS的启动流程"></a>2. AMS的启动流程</h1><p>AMS的启动是在SystemServer进程中启动的，在<a href="https://tylerliu.top/2019/08/27/Android系统启动流程03%EF%BC%9ASystemServer进程/">Android系统启动流程 03：SystemServer进程</a>中提过，这里从SystemServer进程的<code>main()</code>开始讲起：frameworks/base/services/java/com/android/server/SystemServer.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> SystemServer().run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main()</code>调用了<code>SystemServer</code>的<code>run()</code>：frameworks/base/services/java/com/android/server/SystemServer.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">        System.loadLibrary(<span class="string">"android_servers"</span>); <span class="comment">// 1</span></span><br><span class="line">    ......</span><br><span class="line">        mSystemServiceManager = <span class="keyword">new</span> SystemServiceManager(mSystemContext); <span class="comment">// 2</span></span><br><span class="line">        LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);</span><br><span class="line">    ......  </span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, <span class="string">"StartServices"</span>);</span><br><span class="line">        startBootstrapServices(); <span class="comment">// 3</span></span><br><span class="line">        startCoreServices(); <span class="comment">// 4</span></span><br><span class="line">        startOtherServices(); <span class="comment">// 5</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，加载动态库<code>&quot;android_servers.so&quot;</code>。</p><p>注释2，创建<code>SystemServerManager</code>，它会对系统的服务进行创建、启动和生命周期管理。</p><p>注释3，<code>startBootstrapServices()</code>中，用<code>SystemServiceManager</code>启动了<code>ActivityManagerService</code>、<code>PowerManagerService</code>、<code>PackageManagerService</code>等服务。</p><p>注释4，<code>startCoreServices()</code>中，启动了<code>BatteryService</code>、<code>UsageStatsService</code>、和<code>WebViewUpdateSeervice</code>。</p><p>注释5，<code>startOtherServices()</code>中，启动了<code>CameraService</code>、<code>AlarmManagerService</code>、<code>VrManagerService</code>等服务。</p><p>这些服务的父类均为<code>SystemService</code>。从注释3、4、5可以看出，系统将服务分成三类，引导服务、核心服务和其他服务，其他服务是一些不紧要的和一些不需要立即启动的服务。系统服务总共有80多个，这里主要看看引导服务中的AMS是如何启动的，注释3的<code>startBootstrapServices()</code>：frameworks/base/services/java/com/android/server/SystemServer.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startBootstrapServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Installer installer = mSystemServiceManager.startService(Installer.class);</span><br><span class="line">    <span class="comment">// Activity manager runs the show.</span></span><br><span class="line">    mActivityManagerService = mSystemServiceManager.startService(ActivityManagerService.Lifecycle.class).getService(); <span class="comment">// 1</span></span><br><span class="line">    mActivityManagerService.setSystemServiceManager(mSystemServiceManager);</span><br><span class="line">    mActivityManagerService.setInstaller(installer);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，调用了<code>SystemServiceManager</code>的<code>startService()</code>，方法的参数是<code>ActivityManagerService.Lifecycle.class</code>：frameworks/base/services/core/java/com/android/server/SystemServiceManager.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> &lt;T extends SystemService&gt; <span class="function">T <span class="title">startService</span><span class="params">(Class&lt;T&gt; serviceClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">final</span> T service;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        Constructor&lt;T&gt; constructor = serviceClass.getConstructor(Context.class); <span class="comment">// 1</span></span><br><span class="line">        service = constructor.newInstance(mContext); <span class="comment">// 2</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException ex) &#123;</span><br><span class="line">        ......</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Register it.</span></span><br><span class="line">        mServices.add(service); <span class="comment">// 3</span></span><br><span class="line">        <span class="comment">// Start it.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            service.onStart(); <span class="comment">// 4</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failed to start service "</span> + name + <span class="string">": onStart threw an exception"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> service;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>startService()</code>传入的参数是<code>Lifecycle.class</code>，<code>Lifecycle</code>继承自<code>SystemService</code>。首先，通过反射来创建<code>Lifecycle</code>实例，注释1得到传进来的<code>Lifecycle</code>的构造器<code>Constructor</code>，在注释2调用<code>Constructor</code>的<code>newInstance()</code>来创建<code>Lifecycle</code>类型的<code>service</code>对象。</p><p>注释3，将刚创建的<code>service</code>添加到<code>ArrayList</code>类型的<code>mService</code>中来完成注册。</p><p>注释4，调用<code>onStart()</code>启动<code>service</code>，并返回该<code>service</code>。<code>Lifecycle</code>是AMS的内部类：frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Lifecycle</span> <span class="keyword">extends</span> <span class="title">SystemService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ActivityManagerService mService;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Lifecycle</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">        mService = <span class="keyword">new</span> ActivityManagerService(context); <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mService.start(); <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ActivityManagerService <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mService; <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码结合<code>SystemServiceManager</code>的<code>startService()</code>来分析，当通过反射来创建<code>Lifecycle</code>实例时，会调用注释1的方法创建ASM实例，当调用<code>Lifecycle</code>类型的<code>service</code>的<code>onStart()</code>时，实际上调用的是注释2处AMS的<code>start()</code>。在<code>SystemServer</code>的<code>startBootstrapService()</code>的注释1处，调用了如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mActivityManagerService = mSystemServiceManager.startService(ActivityManagerService.Lifecycle.class).getService();</span><br></pre></td></tr></table></figure><p><code>SystemServiceManager</code>的<code>startService()</code>最终会返回<code>Lifecycle</code>类型的对象，接着又调用<code>Lifecycle</code>的<code>getService()</code>，这个方法会返回AMS类型的<code>mService</code>对象，见注释3，这样AMS实例就会被创建并返回。</p><h1 id="3-AMS与进程启动"><a href="#3-AMS与进程启动" class="headerlink" title="3. AMS与进程启动"></a>3. AMS与进程启动</h1><p>在<a href="https://tylerliu.top/2019/08/27/Android系统启动流程02%EF%BC%9Azygote进程/">Android系统启动流程 02：zygote进程</a>中，在Zygote的Java框架层中，会创建一个Server端的Socket，这个Socket用来等待AMS请求Zygote来创建新的应用程序进程。要启动一个应用程序，首先要保证这个应用程序所需要的应用程序进程已经被启动。AMS在启动应用程序时，会检查这个应用程序需要的应用程序进程是否存在，不存在就会请求Zygote进程将需要的应用程序进程启动。Service的启动过程中会调用<code>ActiveService</code>的<code>bringUpServiceLocked()</code>：frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">bringUpServiceLocked</span><span class="params">(ServiceRecord r, <span class="keyword">int</span> intentFlags, <span class="keyword">boolean</span> execInFg, <span class="keyword">boolean</span> whileRestarting, <span class="keyword">boolean</span> permissionsReviewRequired)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">final</span> String procName = r.processName; <span class="comment">// 1</span></span><br><span class="line">    ProcessRecord app;</span><br><span class="line">    <span class="keyword">if</span> (!isolated) &#123;</span><br><span class="line">        app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, <span class="keyword">false</span>); <span class="comment">// 2</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; app.thread != <span class="keyword">null</span>) &#123; <span class="comment">// 3</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                app.addPackage(r.appInfo.packageName, r.appInfo.versionCode, mAm.mProcessStats);</span><br><span class="line">                realStartServiceLocked(r, app, execInFg); <span class="comment">// 4</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        app = r.isolatedProc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (app == <span class="keyword">null</span> &amp;&amp; !permissionsReviewRequired) &#123; <span class="comment">// 5</span></span><br><span class="line">        <span class="keyword">if</span> ((app=mAm.startProcessLocked(procName, r.appInfo, <span class="keyword">true</span>, intentFlags, <span class="string">"service"</span>, r.name, <span class="keyword">false</span>, isolated, <span class="keyword">false</span>)) == <span class="keyword">null</span>) &#123; <span class="comment">// 6</span></span><br><span class="line">           ......</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isolated) &#123;</span><br><span class="line">            r.isolatedProc = app;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，得到<code>ServiceRecorder</code>的<code>processName</code>，并赋值给<code>procName</code>，其中<code>ServiceRecorder</code>是用来描述<code>Service</code>的<code>andorid:process</code>属性。</p><p>注释2，将<code>procName</code>和<code>Service</code>的<code>uid</code>传入到AMS的<code>getProcessRecorderLocked()</code>中，来查询是否存在一个<code>Service</code>对应的<code>ProcessRecorder</code>类型的对象<code>app</code>，<code>ProcessRecorder</code>主要用来记录运行的应用程序进程的信息。</p><p>注释5，判断<code>Service</code>对应的<code>app</code>为空，则说明来运行<code>Service</code>的应用程序进程不存在，则调用注释6的<code>startProcessLocked()</code>来创建对应的应用程序进程，具体可以查看<a href="https://tylerliu.top/2019/08/30/Android应用程序进程启动过程01/">Android应用程序进程启动过程 01</a>。</p><h1 id="4-与AMS相关的类"><a href="#4-与AMS相关的类" class="headerlink" title="4. 与AMS相关的类"></a>4. 与AMS相关的类</h1><p><code>ActivityManager</code>是一个和AMS相关联的类，它主要对运行中的Activity进行管理，这些管理工作并不是由<code>ActivitManager</code>来处理的，而是交由AMS来处理，<code>ActivityManager</code>中的方法会通过<code>ActivityManagerNative</code>（后面简称AMN）的<code>getDefaule()</code>来得到<code>ActivityManagerProxy</code>（后面简称AMP），通过AMP就可以和AMN进行通信，而AMN是一个抽象类，它会将功能交给它的子类AMS来处理，因此，AMP是AMS的代理类。AMS作为系统核心服务，很多API不能直接暴露给<code>ActivityManager</code>的，例如Activity的启动过程中会调用<code>Instrumentation</code>的<code>execStartActivity()</code>：frameworks/base/core/java/android/app/Instrumentation.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, <span class="keyword">int</span> requestCode, Bundle options)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        intent.migrateExtraStreamToClipData();</span><br><span class="line">        intent.prepareToLeaveProcess(who);</span><br><span class="line">        <span class="keyword">int</span> result = ActivityManagerNative.getDefault().startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != <span class="keyword">null</span> ? target.mEmbeddedID : <span class="keyword">null</span>, requestCode, <span class="number">0</span>, <span class="keyword">null</span>, options);</span><br><span class="line">        checkStartActivityResult(result, intent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failure from system"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>execStartActivity()</code>中会调用AMN的<code>getDefault()</code>来获取AMS的代理类AMP。接着调用AMP的<code>startActivity()</code>，先来看AMN的<code>getDefault()</code>：frameworks/base/core/java/android/app/ActivityManagerNative.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> IActivityManager <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gDefault.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton&lt;IActivityManager&gt; gDefault = <span class="keyword">new</span> Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> IActivityManager <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        IBinder b = ServiceManager.getService(<span class="string">"activity"</span>); <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">            Log.v(<span class="string">"ActivityManager"</span>, <span class="string">"default service binder = "</span> + b);</span><br><span class="line">        &#125;</span><br><span class="line">        IActivityManager am = asInterface(b); <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">            Log.v(<span class="string">"ActivityManager"</span>, <span class="string">"default service = "</span> + am);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> am;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注释1，得到名为<code>&quot;activity&quot;</code>的Service引用，也就是Binder类型的AMS的引用。</p><p>注释2，将它封装成AMP类型对象，并将它保存到<code>gDefault</code>中，此后调用AMN的<code>getDefault()</code>就会直接获得AMS的代理对象AMP。注释2的<code>asInterface()</code>：frameworks/base/core/java/android/app/ActivityManagerNative.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> IActivityManager <span class="title">asInterface</span><span class="params">(IBinder obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor);</span><br><span class="line">    <span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> in;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ActivityManagerProxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要作用是将IBinder类型的AMS引用封装成AMP，AMP的构造方法如下：frameworks/base/core/java/android/app/ActivityManagerNative.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActivityManagerProxy</span> <span class="keyword">implements</span> <span class="title">IActivityManager</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ActivityManagerProxy</span><span class="params">(IBinder remote)</span> </span>&#123;</span><br><span class="line">        mRemote = remote;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AMP的构造方法中将AMS的引用赋值给了变量<code>mRemote</code>，这样在AMP中就可以使用AMS了。其中<code>IActivityManager</code>是一个接口，AMN和AMP都实现了这个接口，用于实现代理模式和Binder通信。</p><p>再回到<code>Instrumentation</code>的<code>execStartActivity()</code>，查看AMP的<code>startActivity()</code>，AMP是AMN的内部类：frameworks/base/core/java/android/app/ActivityManagerNative.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle options)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    data.writeInt(requestCode);</span><br><span class="line">    data.writeInt(startFlags);</span><br><span class="line">    ......</span><br><span class="line">    mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, <span class="number">0</span>); <span class="comment">// 1</span></span><br><span class="line">    reply.readException();+</span><br><span class="line">    <span class="keyword">int</span> result = reply.readInt();</span><br><span class="line">    reply.recycle();</span><br><span class="line">    data.recycle();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先会将传入的参数写入到<code>Parce</code>类型的<code>data</code>中。</p><p>注释1，通过<code>IBinder</code>类型对象<code>mRemote</code>（AMS的引用）向服务端的AMS发送一个<code>START_ACTIVITY_TRANSACTION</code>类型的进程间通信请求。那么服务端AMS就会从Binder线程池中读取客户端发送来的数据，最终会调用AMN的<code>onTransact()</code>：frameworks/base/core/java/android/app/ActivityManagerNative.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">    <span class="keyword">case</span> START_ACTIVITY_TRANSACTION:</span><br><span class="line">    &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">int</span> result = startActivity(app, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, options);</span><br><span class="line">        reply.writeNoException();</span><br><span class="line">        reply.writeInt(result);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>onTransact()</code>中会调用AMS的<code>startActivity()</code>：frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">        Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,</span><br><span class="line">            resultWho, requestCode, startFlags, profilerInfo, bOptions,</span><br><span class="line">            UserHandle.getCallingUserId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>startActivity()</code>的最后会<code>return</code>了<code>starttActivityAsUser()</code>：frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivityAsUser</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">        Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">"startActivity"</span>);</span><br><span class="line">    userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, <span class="keyword">false</span>, ALLOW_FULL_ONLY, <span class="string">"startActivity"</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> mActivityStarter.startActivityMayWait(caller, -<span class="number">1</span>, callingPackage, intent,</span><br><span class="line">            resolvedType, <span class="keyword">null</span>, <span class="keyword">null</span>, resultTo, resultWho, requestCode, startFlags,</span><br><span class="line">            profilerInfo, <span class="keyword">null</span>, <span class="keyword">null</span>, bOptions, <span class="keyword">false</span>, userId, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法中最后<code>return</code>了<code>startActivityMayWait()</code>，这里不再详细介绍，具体可以查看<a href="https://tylerliu.top/2019/09/02/Andorid深入理解四大组件-02%EF%BC%9A应用程序启动过程%EF%BC%88下%EF%BC%89/">Andorid深入理解四大组件 02：应用程序启动过程（下）</a>。</p><p>在Activity中启动过程中提到了AMP、AMN和AMS，如下所示：</p><img src="/2019/09/10/Android深入理解ActivityManagerService-01：AMS启动流程和相关类/VeigPS.png"><p>AMP是AMN的内部类，它们都实现了<code>IActivityManager</code>接口，这样它们就实现了代理模式，具体来讲是远程代理：AMP和AMN的运行在两个进程，AMP是Client端，AMN是Server端，Server端具体的功能都是由AMN的子类AMS来实现，因此，AMP是AMS在Client端的一个代理类。AMN又实现了<code>Binder</code>，这样AMP和AMS就可以通过<code>Binder</code>来进行进程间通信。</p><p><code>ActivityManager</code>通过AMN的<code>getDefault()</code>得到AMP，通过AMP就可以和AMN进行通信，也就间接的与AMS进行通信。除了<code>ActiviyManager</code>，其他要想与AMS进行通信的类都需要通过AMP。</p><img src="/2019/09/10/Android深入理解ActivityManagerService-01：AMS启动流程和相关类/Vei658.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h1&gt;&lt;p&gt;AMS是系统的引导服务，应用程序进程的启动、切换和调度、四大组件的启动和管理都需要AMS的支持。当然，并不是AMS一个类
      
    
    </summary>
    
      <category term="Android进阶" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
      <category term="框架层" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/"/>
    
      <category term="深入理解ActivityManagerService" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ActivityManagerService/"/>
    
    
      <category term="ActivityManagerService" scheme="https://tylerLiu.top/tags/ActivityManagerService/"/>
    
  </entry>
  
  <entry>
    <title>Android深入理解JNI 02：类型转换、方法签名和JNIEnv</title>
    <link href="https://tylerLiu.top/2019/09/10/Android%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JNI-02%EF%BC%9A%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E3%80%81%E6%96%B9%E6%B3%95%E7%AD%BE%E5%90%8D%E5%92%8CJNIEnv/"/>
    <id>https://tylerLiu.top/2019/09/10/Android深入理解JNI-02：类型转换、方法签名和JNIEnv/</id>
    <published>2019-09-10T05:35:32.000Z</published>
    <updated>2019-09-11T08:03:54.307Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-数据类型的转换"><a href="#1-数据类型的转换" class="headerlink" title="1. 数据类型的转换"></a>1. 数据类型的转换</h1><p>首先看看上篇文章中andorid_media_MediaRecorder.cpp中的<code>android_media_MediaRecorder_staret()</code>：frameworks/base/media/jni/android_media_MediaRecorder.cpp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static void android_media_MediaRecorder_start(JNIEnv *env, jobject thiz) &#123;</span><br><span class="line">    ALOGV(&quot;start&quot;);</span><br><span class="line">    sp&lt;MediaRecorder&gt; mr = getMediaRecorder(env, thiz);</span><br><span class="line">    process_media_recorder_call(env, mr-&gt;start(), &quot;java/lang/RuntimeException&quot;, &quot;start failed.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面有一个参数是<code>Object</code>类型，它是JNI层的数据类型，Java的数据类型到了JNI层就需要转换为JNI层的数据类型。Java的数据类型分为基本数据类型和引用数据类型，JNI层对于这两种类型也做了区分，先来看看基本数据类型的转换。</p><h2 id="1-1-基本数据类型的转换"><a href="#1-1-基本数据类型的转换" class="headerlink" title="1.1 基本数据类型的转换"></a>1.1 基本数据类型的转换</h2><table><thead><tr><th align="center">Java</th><th align="center">Native</th><th align="center">Signature（签名格式）</th></tr></thead><tbody><tr><td align="center">byte</td><td align="center">jbyte</td><td align="center">B</td></tr><tr><td align="center">char</td><td align="center">jchar</td><td align="center">C</td></tr><tr><td align="center">double</td><td align="center">jdouble</td><td align="center">D</td></tr><tr><td align="center">float</td><td align="center">jfloat</td><td align="center">F</td></tr><tr><td align="center">int</td><td align="center">jint</td><td align="center">I</td></tr><tr><td align="center">short</td><td align="center">jshort</td><td align="center">S</td></tr><tr><td align="center">long</td><td align="center">jlong</td><td align="center">J</td></tr><tr><td align="center">boolean</td><td align="center">jboolean</td><td align="center">Z</td></tr><tr><td align="center">void</td><td align="center">void</td><td align="center">V</td></tr></tbody></table><h2 id="1-2-引用数据类型的转换"><a href="#1-2-引用数据类型的转换" class="headerlink" title="1.2 引用数据类型的转换"></a>1.2 引用数据类型的转换</h2><table><thead><tr><th align="center">Java</th><th align="center">Native</th><th align="center">Signature（签名格式）</th></tr></thead><tbody><tr><td align="center">所有对象</td><td align="center">jobject</td><td align="center">L+classname+;</td></tr><tr><td align="center">Class</td><td align="center">jclass</td><td align="center">Ljava/lang/Class;</td></tr><tr><td align="center">String</td><td align="center">jstring</td><td align="center">Ljava/lang/String;</td></tr><tr><td align="center">Throwable</td><td align="center">jthrowable</td><td align="center">Ljava/lang/Throwable;</td></tr><tr><td align="center">Object[]</td><td align="center">jobjectArray</td><td align="center">[L+Classname+;</td></tr><tr><td align="center">byte[]</td><td align="center">jbyteArray</td><td align="center">[B</td></tr><tr><td align="center">char[]</td><td align="center">jcharArray</td><td align="center">[C</td></tr><tr><td align="center">double[]</td><td align="center">jdoubleArray</td><td align="center">[D</td></tr><tr><td align="center">float[]</td><td align="center">jfloatArray</td><td align="center">[F</td></tr><tr><td align="center">int[]</td><td align="center">jintArray</td><td align="center">[I</td></tr><tr><td align="center">short[]</td><td align="center">jshortArray</td><td align="center">[S</td></tr><tr><td align="center">long[]</td><td align="center">jlongArray</td><td align="center">[J</td></tr><tr><td align="center">boolean[]</td><td align="center">jbooleanArray</td><td align="center">[Z</td></tr></tbody></table><p>引用数据类型还具有继承关系：</p><img src="/2019/09/10/Android深入理解JNI-02：类型转换、方法签名和JNIEnv/VmCKhD.jpg"><p>再来例举<code>MediaRecorder</code>框架的Java方法：frameworks/base/media/java/android/media/MediaRecorder.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">_setOutputFile</span><span class="params">(FileDescriptor fd, <span class="keyword">long</span> offset, <span class="keyword">long</span> length)</span> <span class="keyword">throws</span> IllegalStateException, IOException</span></span><br></pre></td></tr></table></figure><p><code>_setOutputFile()</code>方法对应的JNI层的方法为：frameworks/base/media/jni/android_media_MediaRecorder.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_media_MediaRecorder_setOutputFileFD</span><span class="params">(JNIEnv *env, jobject thiz, jobject fileDescriptor, jlong offset, jlong length)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比这两个方法可以看到，<code>FileDescriptor</code>转成了<code>jobject</code>类型，<code>long</code>转成了<code>jlong</code>类型。</p><h1 id="2-方法签名"><a href="#2-方法签名" class="headerlink" title="2. 方法签名"></a>2. 方法签名</h1><p>前面已经列举了数据类型的签名格式，方法签名就是由签名格式组成的，方法签名有什么作用呢？</p><p>frameworks/base/media/jni/android_media_MediaRecorder.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> JNINativeMethod gMethods[] = &#123;</span><br><span class="line">    ......</span><br><span class="line">    &#123;<span class="string">"native_init"</span>,       <span class="string">"()V"</span>,        (<span class="keyword">void</span> *)android_media_MediaRecorder_native_init&#125;,</span><br><span class="line">    &#123;<span class="string">"native_setup"</span>,      <span class="string">"(Ljava/lang/Object;Ljava/lang/String;Ljava/lang/String;)V"</span>,</span><br><span class="line">    (<span class="keyword">void</span> *)android_media_MediaRecorder_native_setup&#125;,</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>gMethods[]</code>数组中存储的是<code>MediaRecorder</code>的Native方法与JNI层方法的对应关系，其中<code>&quot;()V&quot;</code>和<code>&quot;(Ljava/lang/Object;Ljava/lang/String;Ljava/lang/String;)V&quot;</code>就是方法签名。Java有重载方法，可以定义方法名相同，参数不同的方法，因此，在JNI中仅仅通过方法名是为u发找到对应Java的具体方法的，JNI为了解决这一问题，就将参数类型和返回值类型组合在一起作为方法签名。通过方法签名和方法名就可以找到对应的Java方法了。</p><p>JNI方法签名的格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(参数签名格式...)返回值签名格式</span><br></pre></td></tr></table></figure><p>拿上面的<code>gMethods()</code>数组的<code>native_setup()</code>为例，在Java中的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">native_setup</span><span class="params">(Object mediarecorder_this, String clientName, String opPackageName)</span> <span class="keyword">throws</span> IllegalStateException</span>;</span><br></pre></td></tr></table></figure><p>它在JNI中的方法签名为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(Ljava/lang/Object;Ljava/lang/String;Ljava/lang/String;)V&quot;</span><br></pre></td></tr></table></figure><p>参照前面的类型转换表格，<code>native_setup()</code>方法的第一个参数的签名为<code>&quot;Ljava/lang/Obnject;&quot;</code>，后面两个参数签名为<code>&quot;Ljava/lang/String;&quot;</code>，返回值的类型<code>Void</code>的签名为<code>&quot;V&quot;</code>，组合起来就是上面的签名了。</p><p>Java提供了<code>javap</code>命令来自动生成方法签名。</p><p>先写一个简单的<code>MediaRecorder.java</code>包含上面的<code>native_sertup()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MediaRecorder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">"media_jni"</span>);</span><br><span class="line">        native_init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">native_init</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">native_setup</span><span class="params">(Object mediarecorder_this, String clientName, String opPackageName)</span> <span class="keyword">throws</span> IllegalStateException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该文件的绝对路径为E:\Project\MyStudy\JNISample\media\src\main\java\com\example\MediaRecorder.java，接着执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac E:\Project\MyStudy\JNISample\media\src\main\java\com\example\MediaRecorder.java</span><br></pre></td></tr></table></figure><p>执行后会生成MediaRecorder.class文件，然后执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -s -p E:\Project\MyStudy\JNISample\media\src\main\java\com\example\MediaRecorder.class</span><br></pre></td></tr></table></figure><p>其中<code>s</code>表示输出内部类型签名，<code>p</code>表示打印出所有的方法和成员（默认打印public成员），最终打印如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\AHXIUWU_RJ_LY&gt;javap -s -p E:\Project\MyStudy\JNISample\media\src\main\java\com\example\MediaRecorder.class</span><br><span class="line">Compiled from &quot;MediaRecorder.java&quot;</span><br><span class="line">public class com.example.MediaRecorder &#123;</span><br><span class="line">  public com.example.MediaRecorder();</span><br><span class="line">    descriptor: ()V</span><br><span class="line"></span><br><span class="line">  private static final native void native_init();</span><br><span class="line">    descriptor: ()V</span><br><span class="line"></span><br><span class="line">  private final native void native_setup(java.lang.Object, java.lang.String, java.lang.String) throws java.lang.IllegalStateException;</span><br><span class="line">    descriptor: (Ljava/lang/Object;Ljava/lang/String;Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line">  static &#123;&#125;;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到输出的<code>native_setup</code>方法的签名和前面给出的一致。</p><h1 id="3-JNIEnv"><a href="#3-JNIEnv" class="headerlink" title="3. JNIEnv"></a>3. JNIEnv</h1><p>JNIEnv是一个指向全部JNI方法的指针，该指针只在创建它的线程有效，不能跨线程传递，因此，不同线程的JNIEnv是独立的，JNIEnv的主要作用：</p><ol><li>调用Java方法。</li><li>操作Java（获取Java中的对象和变量等）。</li></ol><p>先看看JNIEnv的定义：libnativehelper/include/nativehelper/jni.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__cplusplus)</span></span><br><span class="line"><span class="keyword">typedef</span> _JNIEnv JNIEnv; <span class="comment">// C++中JNIEnv的类型</span></span><br><span class="line"><span class="keyword">typedef</span> _JavaVM JavaVM; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">JNINativeInterface</span>* <span class="title">JNIEnv</span>;</span> <span class="comment">// C中JNIEnv的类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">JNIInvokeInterface</span>* <span class="title">JavaVM</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这里使用预定义宏<code>__cplusplus</code>来区分C和C++两种代码，如果定义了<code>__cplusplus</code>，则是C++代码中的定义，否则就是C代码中的定义。</p><p>在这里也看到了<code>JavaVM</code>，它是虚拟机在JNI层中的代表，在一个虚拟机进程中只有一个JavaVM，因此，该进程的所有线程都可以使用这个JavaVM。通过JavaVM的<code>AttachCurrentThread</code>函数可以获取这个线程的JNIEnv，这样就可以在不同的线程中调用Java方法了。要注意在使用<code>AttachCurrentThread</code>函数的线程推出前，使用<code>DetachCurrentThread</code>函数来释放资源。</p><h2 id="3-1-jfieldID和jmethodID"><a href="#3-1-jfieldID和jmethodID" class="headerlink" title="3.1 jfieldID和jmethodID"></a>3.1 jfieldID和jmethodID</h2><p>在JNI中使用<code>jfieldID</code>和<code>jmethodID</code>来代表Java类中的成员变量和方法，可以通过JNIEnv的下面两个方法来分别得到：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jfieldID  <span class="title">GetFieldID</span><span class="params">(jclass clazz,<span class="keyword">const</span> <span class="keyword">char</span> *name,<span class="keyword">const</span> <span class="keyword">char</span> *sig)</span></span>;</span><br><span class="line"><span class="function">jmethodID  <span class="title">GetFieldID</span><span class="params">(jclass clazz,<span class="keyword">const</span> <span class="keyword">char</span> *name,<span class="keyword">const</span> <span class="keyword">char</span> *sig)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，<code>jclass</code>代表Java类，<code>name</code>代表成员方法或成员变量的名字，<code>sig</code>为这个方法和变量的签名。再来查看<code>MediaRecorder</code>框架的JNI层是如何使用上述两个方法的：frameworks/base/media/jni/android_media_MediaRecorder.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_media_MediaRecorder_native_init</span><span class="params">(JNIEnv *env)</span> </span>&#123;</span><br><span class="line">    jclass clazz;</span><br><span class="line">    clazz = env-&gt;FindClass(<span class="string">"android/media/MediaRecorder"</span>); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fields.context = env-&gt;GetFieldID(clazz, <span class="string">"mNativeContext"</span>, <span class="string">"J"</span>); <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">if</span> (fields.context == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fields.surface = env-&gt;GetFieldID(clazz, <span class="string">"mSurface"</span>, <span class="string">"Landroid/view/Surface;"</span>); <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">if</span> (fields.surface == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    jclass surface = env-&gt;FindClass(<span class="string">"android/view/Surface"</span>);</span><br><span class="line">    <span class="keyword">if</span> (surface == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fields.post_event = env-&gt;GetStaticMethodID(clazz, <span class="string">"postEventFromNative"</span>, <span class="string">"(Ljava/lang/Object;IIILjava/lang/Object;)V"</span>); <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">if</span> (fields.post_event == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，通过<code>FindClass</code>来找到Java层的<code>MediaRecorder</code>的Class对象，并赋值给jclass类型的变量<code>clazz</code>，因此，<code>clazz</code>是Java层的<code>MediaRecorder</code>在JNI层的代表。</p><p>注释2和注释3，用来找到Java层的<code>MediaRecorder</code>中名为<code>mNativeContext</code>和<code>Surface</code>的成员变量，并分别赋值给<code>context</code>和<code>surface</code>。</p><p>注释4，获取Java层的<code>MediaRecorder</code>中名为<code>postEventFromNative()</code>的静态方法，并赋值给<code>post_event</code>。其中<code>fields</code>的定义为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fields_t</span> &#123;</span></span><br><span class="line">    jfieldID    context;</span><br><span class="line">    jfieldID    surface;</span><br><span class="line">    jmethodID   post_event;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">fields_t</span> fields;</span><br></pre></td></tr></table></figure><p>这些成员变量和方法赋值给<code>jfieldID</code>和<code>jmethodID</code>类型的变量，主要是为了效率考虑，如果每次调用相关方法都要进行查询方法和变量，显然效率会很低，因此在<code>MediaRecorder</code>框架JNI层的初始化方法<code>andorid_media_MediaRecorder_native_init()</code>中，将这些<code>jfieldID</code>和<code>jmethodID</code>类型的变量保存起来，以供后面使用。</p><h2 id="3-2-使用jfieldID和jmethodID"><a href="#3-2-使用jfieldID和jmethodID" class="headerlink" title="3.2 使用jfieldID和jmethodID"></a>3.2 使用jfieldID和jmethodID</h2><p>前面保存了<code>jfieldID</code>和<code>jmethodID</code>的变量，下面如何使用呢？frameworks/base/media/jni/android_media_MediaRecorder.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> JNIMediaRecorderListener::notify(<span class="keyword">int</span> msg, <span class="keyword">int</span> ext1, <span class="keyword">int</span> ext2) &#123;</span><br><span class="line">    ALOGV(<span class="string">"JNIMediaRecorderListener::notify"</span>);</span><br><span class="line">    JNIEnv *env = AndroidRuntime::getJNIEnv();</span><br><span class="line">    env-&gt;CallStaticVoidMethod(mClass, fields.post_event, mObject, msg, ext1, ext2, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在里面调用了JNIEnv的<code>CallStaticVoidMethod()</code>，其中传入了<code>fields.post_event</code>，从上面可以得知，它其实是保存了Java层的<code>MediaRecorder</code>的静态方法<code>postEventFromNative()</code>：frameworks/base/media/java/android/media/MediaRecorder.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postEventFromNative</span><span class="params">(Object mediarecorder_ref, <span class="keyword">int</span> what, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2, Object obj)</span> </span>&#123;</span><br><span class="line">    MediaRecorder mr = (MediaRecorder)((WeakReference)mediarecorder_ref).get();</span><br><span class="line">    <span class="keyword">if</span> (mr == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mr.mEventHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Message m = mr.mEventHandler.obtainMessage(what, arg1, arg2, obj);</span><br><span class="line">        mr.mEventHandler.sendMessage(m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就能在JNI层中访问Java的静态方法了。同理，要想访问Java的方法，则可以使用JNIEnv的<code>CallVoidMethod()</code>函数。</p><p>上面例子是使用了<code>jmethodID</code>，下面再来看看<code>jfieldID</code>：frameworks/base/media/jni/android_media_MediaRecorder.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_media_MediaRecorder_prepare</span><span class="params">(JNIEnv *env, jobject thiz)</span> </span>&#123;</span><br><span class="line">    ALOGV(<span class="string">"prepare"</span>);</span><br><span class="line">    sp&lt;MediaRecorder&gt; mr = getMediaRecorder(env, thiz);</span><br><span class="line">    jobject surface = env-&gt;GetObjectField(thiz, fields.surface); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> (surface != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Surface&gt; native_surface = get_surface(env, surface);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    process_media_recorder_call(env, mr-&gt;prepare(), <span class="string">"java/io/IOException"</span>, <span class="string">"prepare failed."</span>);</span><br></pre></td></tr></table></figure><p>注释1，调用了JNIEnv的<code>GetObjectField()</code>，参数中的<code>fields.surface</code>用来保存Java层<code>MediaRecorder</code>中的成员变量<code>mSurface</code>，<code>mSurface</code>的类型为<code>Surface</code>，这样通过<code>GetObjectField()</code>函数就可以得到<code>mSurface</code>在JNI层中对应的<code>jobject</code>类型的变量<code>mSurface</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-数据类型的转换&quot;&gt;&lt;a href=&quot;#1-数据类型的转换&quot; class=&quot;headerlink&quot; title=&quot;1. 数据类型的转换&quot;&gt;&lt;/a&gt;1. 数据类型的转换&lt;/h1&gt;&lt;p&gt;首先看看上篇文章中andorid_media_MediaRecorder.cpp
      
    
    </summary>
    
      <category term="Android进阶" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
      <category term="框架层" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/"/>
    
      <category term="深入理解JNI" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JNI/"/>
    
    
      <category term="JNI" scheme="https://tylerLiu.top/tags/JNI/"/>
    
  </entry>
  
  <entry>
    <title>Android深入理解JNI 01：JNI原理与静态、动态注册</title>
    <link href="https://tylerLiu.top/2019/09/09/Android%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JNI-01%EF%BC%9AJNI%E5%8E%9F%E7%90%86%E4%B8%8E%E9%9D%99%E6%80%81%E3%80%81%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C/"/>
    <id>https://tylerLiu.top/2019/09/09/Android深入理解JNI-01：JNI原理与静态、动态注册/</id>
    <published>2019-09-09T08:57:27.000Z</published>
    <updated>2019-09-11T08:03:52.554Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>JNI不仅在NDK开发中应用，更是Android系统中Java与Native交互的桥梁。</p><h1 id="1-JNI概述"><a href="#1-JNI概述" class="headerlink" title="1. JNI概述"></a>1. JNI概述</h1><p>Android系统按语言可以分成两个部分：Java部分和Native部分。这样分的原因是，一方面是性能，一方面是在Java诞生之前，就有很多程序和库是用Native编写的。Native编写的库具有更好的性能。</p><p>Java是如何使用Native的代码呢？可以使用桥梁JNI。</p><h1 id="2-MediaRecorder框架概述"><a href="#2-MediaRecorder框架概述" class="headerlink" title="2. MediaRecorder框架概述"></a>2. MediaRecorder框架概述</h1><p><code>MediaRecorder</code>，用于录音和录像。这里主要介绍其中用到的JNI。</p><img src="/2019/09/09/Android深入理解JNI-01：JNI原理与静态、动态注册/VmSY7T.png"><p>Java对应的是<code>MediaRecorder.java</code>，也就是应用开发中直接调用的类。JNI层对应的是<code>libmedia_jni.so</code>，它是一个JNI的动态库。Native层对应的是<code>libmedia.so</code>，这个动态库完成了实际的调用的功能。</p><h1 id="3-Java层的MediaRecorder"><a href="#3-Java层的MediaRecorder" class="headerlink" title="3. Java层的MediaRecorder"></a>3. Java层的MediaRecorder</h1><p>先来看看<code>MediaRecorder.java</code>的源码，下面截取了和JNI有关的部分：frameworks/base/media/java/android/media/MediaRecorder.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MediaRecorder</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">"media_jni"</span>); <span class="comment">// 1</span></span><br><span class="line">        native_init(); <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    .......</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">native_init</span><span class="params">()</span></span>; <span class="comment">// 3</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException</span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在静态代码块中，首先调用了注释1，用来加载名为<code>&quot;media_jni&quot;</code>的动态库，也就是<code>&quot;libmedia_jni.so&quot;</code>。接着调用注释2的<code>native_init()</code>。注释3的<code>native_init()</code>是用<code>native</code>来修饰的，说明它是一个<code>native</code>方法，表示会由JNI来实现。<code>MediaRecorder</code>的<code>start()</code>方法同样是一个<code>native</code>方法。</p><p>对于Java层楼来说，只要加载对应的JNI库，接着声明<code>native</code>方法就可以了，剩下的工作会由JNI层来完成。</p><h1 id="4-JNI层的MediaRecorder"><a href="#4-JNI层的MediaRecorder" class="headerlink" title="4. JNI层的MediaRecorder"></a>4. JNI层的MediaRecorder</h1><p><code>MediaRecorder</code>的JNI层是由<code>android_media_recorder.cpp</code>实现的，<code>native</code>方法<code>native_init()</code>和<code>start()</code>的JNI层实现如下：frameworks/base/media/jni/android_media_MediaRecorder.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_media_MediaRecorder_native_init</span><span class="params">(JNIEnv *env)</span> </span>&#123;</span><br><span class="line">    jclass clazz;</span><br><span class="line"></span><br><span class="line">    clazz = env-&gt;FindClass(<span class="string">"android/media/MediaRecorder"</span>);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   ......</span><br><span class="line">    fields.post_event = env-&gt;GetStaticMethodID(clazz, <span class="string">"postEventFromNative"</span>, <span class="string">"(Ljava/lang/Object;IIILjava/lang/Object;)V"</span>);</span><br><span class="line">    <span class="keyword">if</span> (fields.post_event == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_media_MediaRecorder_start</span><span class="params">(JNIEnv *env, jobject thiz)</span> </span>&#123;</span><br><span class="line">    ALOGV(<span class="string">"start"</span>);</span><br><span class="line">    sp&lt;MediaRecorder&gt; mr = getMediaRecorder(env, thiz);</span><br><span class="line">    process_media_recorder_call(env, mr-&gt;start(), <span class="string">"java/lang/RuntimeException"</span>, <span class="string">"start failed."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>android_media_MediaRecorder_native_init()</code>方法是<code>native_init()</code>方法在JNI层的实现，<code>android_media_MediaRecorder_start()</code>方法是<code>start()</code>在JNI层的实现。<code>native_init()</code>是如何找到对应的<code>android_media_MediaRecorder_native_init()</code>的呢？这就需要了解JNI方法注册的知识。</p><h1 id="5-JNI方法的注册"><a href="#5-JNI方法的注册" class="headerlink" title="5. JNI方法的注册"></a>5. JNI方法的注册</h1><p>JNI方法的注册分成静态注册和动态注册，其中静态注册多用于NDK开发，动态注册多用于Framework开发。</p><h2 id="5-1-静态注册"><a href="#5-1-静态注册" class="headerlink" title="5.1 静态注册"></a>5.1 静态注册</h2><p>在AS中新建一个Java Library名为media，这里参照系统的<code>MediaRecorder.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MediaRecorder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">"media_jni"</span>);</span><br><span class="line">        native_init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">native_init</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入项目的media/src/main/java目录中执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac com/example/MediaRecorder.java</span><br><span class="line">javah com.example.MediaRecorder</span><br></pre></td></tr></table></figure><p>在执行第二条命令后，会在当前目录下生成com_example_MediaRecorder.h文件：E:\Project\MyStudy\JNISample\media\src\main\java\com_example_MediaRecorder.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* DO NOT EDIT THIS FILE - it is machine generated */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Header for class com_example_MediaRecorder */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _Included_com_example_MediaRecorder</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _Included_com_example_MediaRecorder</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     com_example_MediaRecorder</span></span><br><span class="line"><span class="comment"> * Method:    native_init</span></span><br><span class="line"><span class="comment"> * Signature: ()V</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL Java_com_example_MediaRecorder_native_1init</span><br><span class="line">  (JNIEnv *, jclass); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     com_example_MediaRecorder</span></span><br><span class="line"><span class="comment"> * Method:    start</span></span><br><span class="line"><span class="comment"> * Signature: ()V</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL Java_com_example_MediaRecorder_start</span><br><span class="line">  (JNIEnv *, jobject);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>navite_init()</code>被声明为注释1的方法，即<code>Java_com_example_MediaRecorder_native_1init</code>，<code>Java</code>开头，说明是在Java平台中调用JNI方法，后面的<code>com_example_MediaRecorder_native_1init</code>指的是包名+类名+方法名的格式，原本在Java中是以<code>.</code>来进行分割，这里使用的是<code>_</code>，因为在Native中，<code>.</code>由特殊的含义。同时在里面多了一个<code>1</code>，这是因为Java的<code>native_init()</code>中包含了<code>&quot;&quot;</code>，转成JNI方法后，就变成了<code>_1</code>。</p><p>其中<code>JNIEnv</code>是一个指向全部JNI方法的指针，该指针只在创建它的线程有效，不能跨线程传递。<code>jclass</code>是JNI的数据类型，对应Java的java.lang.Class实例。<code>jobject</code>也是JNI的数据类型，对应Java的Object实例。</p><p>当在Java中调用<code>native_init()</code>时，就会从JNI中寻找<code>Java_com_example_MediaRecorder_native_1init()</code>，如果没有，就会报错，如果有，就会为<code>native_init()</code>和<code>Java_com_example_MediaRecorder_native_1init</code>建立关联，其实是保存JNI的方法指针，这样再次调用<code>native_init()</code>，就会直接使用这个方法指针了。</p><p>静态注册就是根据方法名，将Java方法和JNI方法建立关联，但它有一些缺点：</p><ul><li>JNI层的方法名称过长；</li><li>声明Native方法的类需要通过javah生成头文件；</li><li>初次调用JNI方法时，需要建立关联，影响效率。</li></ul><p>静态注册就是Java的Native方法通过方法指针来与JNI进行关联，如果Native方法知道它在JNI中对应的方法指针，就可以避免上面的缺点，这就是动态注册。</p><h2 id="5-2-动态注册"><a href="#5-2-动态注册" class="headerlink" title="5.2 动态注册"></a>5.2 动态注册</h2><p>JNI中有一种结构用来记录Java的Native方法和JNI方法的关联关系，它就是JNINativemethod，它在jni.h中被定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name; <span class="comment">// Java方法的名字</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* signature; <span class="comment">// Java方法的签名信息</span></span><br><span class="line">    <span class="keyword">void</span>*       fnPtr; <span class="comment">// JNI中对应的方法指针</span></span><br><span class="line">&#125; JNINativeMethod;</span><br></pre></td></tr></table></figure><p>系统的<code>MediaRecorder</code>采用的就是动态注册，来看看它的JNI层是如何定义的：frameworks/base/media/jni/android_media_MediaRecorder.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> JNINativeMethod gMethods[] = &#123;</span><br><span class="line">    ......</span><br><span class="line">    &#123;<span class="string">"start"</span>,            <span class="string">"()V"</span>,      (<span class="keyword">void</span> *)android_media_MediaRecorder_start&#125;, <span class="comment">// 1</span></span><br><span class="line">    &#123;<span class="string">"stop"</span>,             <span class="string">"()V"</span>,      (<span class="keyword">void</span> *)android_media_MediaRecorder_stop&#125;,</span><br><span class="line">    &#123;<span class="string">"pause"</span>,            <span class="string">"()V"</span>,      (<span class="keyword">void</span> *)android_media_MediaRecorder_pause&#125;,</span><br><span class="line">    &#123;<span class="string">"resume"</span>,           <span class="string">"()V"</span>,      (<span class="keyword">void</span> *)android_media_MediaRecorder_resume&#125;,</span><br><span class="line">    &#123;<span class="string">"native_reset"</span>,     <span class="string">"()V"</span>,      (<span class="keyword">void</span> *)android_media_MediaRecorder_native_reset&#125;,</span><br><span class="line">    &#123;<span class="string">"release"</span>,          <span class="string">"()V"</span>,      (<span class="keyword">void</span> *)android_media_MediaRecorder_release&#125;,</span><br><span class="line">    &#123;<span class="string">"native_init"</span>,      <span class="string">"()V"</span>,      (<span class="keyword">void</span> *)android_media_MediaRecorder_native_init&#125;,</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面定义了一个<code>JNINativeMethod</code>类型的<code>gMethods[]</code>数组，里面存储的就是<code>MediaRecorder</code>的Native方法与JNI层方法的对应关系，其中注释1处<code>&quot;start&quot;</code>是Java层的Native方法，它对应的JNI层的方法为<code>android_media_MediaRecorder_start()</code>。<code>&quot;()V&quot;</code>是<code>start()</code>方法的签名信息，会在后面介绍。</p><p>只定义<code>JNINativeMethod</code>类型的数组是没有用的，还需要注册它，注册的方法为<code>register_andorid_media_MediaRecorder()</code>：frameworks/base/media/jni/android_media_MediaRecorder.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JNI_OnLoad in android_media_MediaPlayer.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">register_android_media_MediaRecorder</span><span class="params">(JNIEnv *env)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> AndroidRuntime::registerNativeMethods(env, <span class="string">"android/media/MediaRecorder"</span>, gMethods, NELEM(gMethods));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>register_android_media_MediaRecorder()</code>中<code>return</code>了<code>AndroidRuntime</code>的<code>registerNativeMethods()</code>方法，如下：frameworks/base/core/jni/AndroidRuntime.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*static*/</span></span><br><span class="line"><span class="keyword">int</span> AndroidRuntime::registerNativeMethods(JNIEnv* env, <span class="keyword">const</span> <span class="keyword">char</span>* className, <span class="keyword">const</span> JNINativeMethod* gMethods, <span class="keyword">int</span> numMethods) &#123;</span><br><span class="line">    <span class="keyword">return</span> jniRegisterNativeMethods(env, className, gMethods, numMethods);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>registerNativeMethods()</code>中，又<code>return</code>了<code>jniRegisterNativeMethods()</code>：libnativehelper/JNIHelp.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">int</span> <span class="title">jniRegisterNativeMethods</span><span class="params">(JNIEnv* env, <span class="keyword">const</span> <span class="keyword">char</span>* className,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> JNINativeMethod* gMethods, <span class="keyword">int</span> numMethods)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (env-&gt;RegisterNatives(c.get(), gMethods, numMethods) &lt; <span class="number">0</span>) &#123; <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">char</span>* msg;</span><br><span class="line">        (<span class="keyword">void</span>)asprintf(&amp;msg, <span class="string">"RegisterNatives failed for '%s'; aborting..."</span>, className);</span><br><span class="line">        env-&gt;FatalError(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1可以看出，最终调用的<code>JNIEnv</code>的<code>RegisterNatives()</code>，<code>JNIEnv</code>在JNI中很重要，在后面会介绍。</p><p>所以，<code>register_android_media_MediaRecorder()</code>最终调用的是<code>JNIEnv</code>的<code>RegisterNatives()</code>。但是<code>register_android_media_MediaRecorder()</code>是在哪里被调用的呢？在它的注释上可以看到<code>&quot;&quot;JNI_OnLoad in android_media_MediaPlayer.cpp</code>。这个<code>JNI_OnLoad</code>方法会在<code>System.loadLibrary()</code>方法后调用，因为多媒体框架中的很多框架都要进行<code>JNINativeMethods</code>数组注册，因此，注册方法就被统一定义在<code>andorid_media_MediaPlayer.cpp</code>中的<code>JNI_OnLoad()</code>中：frameworks/base/media/jni/android_media_MediaPlayer.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM* vm, <span class="keyword">void</span>* <span class="comment">/* reserved */</span>)</span> </span>&#123;</span><br><span class="line">    JNIEnv* env = <span class="literal">NULL</span>;</span><br><span class="line">    jint result = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (vm-&gt;GetEnv((<span class="keyword">void</span>**) &amp;env, JNI_VERSION_1_4) != JNI_OK) &#123;</span><br><span class="line">        ALOGE(<span class="string">"ERROR: GetEnv failed\n"</span>);</span><br><span class="line">        <span class="keyword">goto</span> *bail;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(env != <span class="literal">NULL</span>);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (register_android_media_MediaPlayer(env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"ERROR: MediaPlayer native registration failed\n"</span>);</span><br><span class="line">        <span class="keyword">goto</span> *bail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (register_android_media_MediaRecorder(env) &lt; <span class="number">0</span>) &#123; <span class="comment">// 1</span></span><br><span class="line">        ALOGE(<span class="string">"ERROR: MediaRecorder native registration failed\n"</span>);</span><br><span class="line">        <span class="keyword">goto</span> *bail;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    result = JNI_VERSION_1_4;</span><br><span class="line">bail:</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>JNI_OnLoad()</code>中调用了整个多媒体框架的注册<code>JNINativeMethod</code>数组的方法。注释1调用了<code>register_android_media_MediaRecorder()</code>方法，同样的，<code>MediaPlayer</code>框架的注册<code>JNINativeMethod</code>数组的方法<code>register_android_media_MediaPlayer</code>也被调用了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;JNI不仅在NDK开发中应用，更是Android系统中Java与Native交互的桥梁。&lt;/p&gt;
&lt;h1 id=&quot;1-JNI概述&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="Android进阶" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
      <category term="框架层" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/"/>
    
      <category term="深入理解JNI" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JNI/"/>
    
    
      <category term="JNI" scheme="https://tylerLiu.top/tags/JNI/"/>
    
  </entry>
  
  <entry>
    <title>Android深入理解Context 02</title>
    <link href="https://tylerLiu.top/2019/09/09/Android%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Context-02/"/>
    <id>https://tylerLiu.top/2019/09/09/Android深入理解Context-02/</id>
    <published>2019-09-09T06:06:04.000Z</published>
    <updated>2019-09-11T08:03:46.428Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Activity的Context创建过程"><a href="#1-Activity的Context创建过程" class="headerlink" title="1. Activity的Context创建过程"></a>1. Activity的Context创建过程</h1><p>当在Activity中调用<code>startActivity()</code>时，实际上调用的是<code>Context</code>的<code>startActivity()</code>，如果想要在Activity中使用<code>Context</code>提供的方法，务必要先创建<code>Context</code>。Activity的<code>Context</code>会在Activity的启动过程中被创建，在<a href="https://tylerliu.top/2019/09/02/Andorid深入理解四大组件-02%EF%BC%9A应用程序启动过程%EF%BC%88下%EF%BC%89/#more">Andorid深入理解四大组件 02：应用程序启动过程（下）</a>第二节中，讲到<code>ActivityThread</code>启动Activity的过程，现在从这里开始分析。</p><p><code>ActivityThread</code>是应用程序进程的核心类，它的内部类<code>ApplicatonThread</code>会调用<code>scheduleLaunchActivity()</code>来启动Activity：frameworks/base/core/java/android/app/ActivityThread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleLaunchActivity</span><span class="params">(Intent intent, IBinder token, <span class="keyword">int</span> ident,</span></span></span><br><span class="line"><span class="function"><span class="params">        ActivityInfo info, Configuration curConfig, Configuration overrideConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">        CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> procState, Bundle state, PersistableBundle persistentState,</span></span></span><br><span class="line"><span class="function"><span class="params">        List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> notResumed, <span class="keyword">boolean</span> isForward, ProfilerInfo profilerInfo)</span> </span>&#123;</span><br><span class="line">    updateProcessState(procState, <span class="keyword">false</span>);</span><br><span class="line">    ActivityClientRecord r = <span class="keyword">new</span> ActivityClientRecord();</span><br><span class="line">    r.token = token;</span><br><span class="line">    ......</span><br><span class="line">    sendMessage(H.LAUNCH_ACTIVITY, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>scheduleLaunchActivity()</code>中会将启动Activity的参数封装成<code>ActivityClientRecord</code>，<code>sendMessage()</code>会向<code>H</code>类发送类型为<code>LAUNCH_ACTIVITY</code>的消息，并将<code>ActivityClientRecord</code>传递过去。<code>sendMessage()</code>的目的是将启动Activity的逻辑放在主线程中的消息队列中，这样启动Activity的逻辑就会在主线程中执行。<code>H</code>类中在<code>handleMessage()</code>的<code>LAUNCH_ACTIVITY</code>类型的消息进行处理，其中调用了<code>handleLaunchActivity()</code>，而<code>handleLaunchActivity()</code>中又调用了<code>performLaunchActivity()</code>，这个过程在上篇已经讲过，再来看看<code>performLaunchActivity()</code>：frameworks/base/core/java/android/app/ActivityThread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    Activity activity = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</span><br><span class="line">        activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent); <span class="comment">// 1</span></span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Context appContext = createBaseContextForActivity(r, activity); <span class="comment">// 2</span></span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">// 3</span></span><br><span class="line">            activity.attach(appContext, <span class="keyword">this</span>, getInstrumentation(), r.token,</span><br><span class="line">                    r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                    r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                    r.referrer, r.voiceInteractor, window);</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); <span class="comment">// 4</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，创建Activity的实例。</p><p>注释2，通过<code>createBaseContextForActivity()</code>创建Activity的<code>ContextImpl</code>，并将<code>ContextImpl</code>传入注释3的<code>activity</code>的<code>attach()</code>。</p><p>注释4，<code>Instrumentation</code>的<code>callActivityOnCreate()</code>中会调用Activiy的<code>onCreate()</code>。</p><p>先来看看注释2的<code>createBaseContextForActivity()</code>：frameworks/base/core/java/android/app/ActivityThread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Context <span class="title">createBaseContextForActivity</span><span class="params">(ActivityClientRecord r, <span class="keyword">final</span> Activity activity)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    ContextImpl appContext = ContextImpl.createActivityContext(<span class="keyword">this</span>, r.packageInfo, r.token, displayId, r.overrideConfig); <span class="comment">// 1</span></span><br><span class="line">    appContext.setOuterContext(activity); <span class="comment">// 2</span></span><br><span class="line">    Context baseContext = appContext;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> baseContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，调用<code>ContextImpl.createActivityContext()</code>来创建<code>ContextImpl</code>。</p><p>注释2，调用<code>Context.setOuterContext()</code>，将前面创建的Activity实例赋值给<code>ContextImpl</code>的成员变量<code>mOuterContext</code>，这样<code>ContextImpl</code>也可以访问Activity的变量和方法。</p><p>再回到<code>ActivityThread</code>的<code>performLaunchActivity()</code>，在注释3的<code>attach()</code>：frameworks/base/core/java/android/app/Activity.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context, ActivityThread aThread,</span></span></span><br><span class="line"><span class="function"><span class="params">        Instrumentation instr, IBinder token, <span class="keyword">int</span> ident,</span></span></span><br><span class="line"><span class="function"><span class="params">        Application application, Intent intent, ActivityInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">        CharSequence title, Activity parent, String id,</span></span></span><br><span class="line"><span class="function"><span class="params">        NonConfigurationInstances lastNonConfigurationInstances,</span></span></span><br><span class="line"><span class="function"><span class="params">        Configuration config, String referrer, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">        Window window)</span> </span>&#123;</span><br><span class="line">    attachBaseContext(context); <span class="comment">// 1</span></span><br><span class="line">    mFragments.attachHost(<span class="keyword">null</span> <span class="comment">/*parent*/</span>);</span><br><span class="line">    mWindow = <span class="keyword">new</span> PhoneWindow(<span class="keyword">this</span>, window); <span class="comment">// 2</span></span><br><span class="line">    mWindow.setWindowControllerCallback(<span class="keyword">this</span>);</span><br><span class="line">    mWindow.setCallback(<span class="keyword">this</span>); <span class="comment">// 3</span></span><br><span class="line">    mWindow.setOnWindowDismissedCallback(<span class="keyword">this</span>);</span><br><span class="line">    ......</span><br><span class="line">    mWindow.setWindowManager((WindowManager)context.getSystemService(Context.WINDOW_SERVICE), mToken, mComponent.flattenToString(), (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>); <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">if</span> (mParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mWindow.setContainer(mParent.getWindow());</span><br><span class="line">    &#125;</span><br><span class="line">    mWindowManager = mWindow.getWindowManager(); <span class="comment">// 5</span></span><br><span class="line">    mCurrentConfig = config;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释2，创建<code>PhoneWindow</code>，代表应用程序窗口。<code>PhoneWindow</code>在运行中会间接触发很多事件，比如点击事件、菜单弹出、屏幕焦点变化等事件，这些事件需要转发给与<code>PhoneWindow</code>关联的Activity，转发操作是通过<code>Window.Callback</code>接口实现，Activity实现了这个接口，在注释3处将当前Activity通过Window的<code>setCallback()</code>传递给<code>PhoneWindow</code>。</p><p>注释4，给<code>PhoneWindow</code>设置<code>WindowManager</code>，并在注释5处获取<code>WindowManager</code>并赋值给Activity的成员变量<code>mWindowManager</code>，这样在Activity中就可以通过<code>getWindowManager()</code>来获取<code>WindowManager</code>。</p><p>注释1，调用了<code>ContextThemeWrapper</code>的<code>attachBaseContext()</code>：frameworks/base/core/java/android/view/ContextThemeWrapper.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context newBase)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.attachBaseContext(newBase);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在里面调用了<code>ContextThemeWrapper</code>的父类<code>ContextWrapper</code>的<code>attachBaseContext()</code>：frameworks/base/core/java/android/content/ContextWrapper.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mBase != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Base context already set"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mBase = base; <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>base</code>指的是从前面传过来到Activity的<code>ContextImpl</code>，将它赋值给<code>ContextWrapper</code>的成员变量<code>mBase</code>。这样<code>ContextWrapper</code>的功能就可以交由<code>ContextImpl</code>处理，例如：frameworks/base/core/java/android/content/ContextWrapper.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Resources.<span class="function">Theme <span class="title">getTheme</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mBase.getTheme();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用<code>ContextWrapper</code>的<code>getTheme()</code>时，实际上调用的是<code>COntextImpl</code>的<code>getTheme()</code>。</p><p>总结，在启动Activity的过程中创建了<code>ContextImpl</code>，并赋值给了<code>ContextWrapper</code>的成员变量<code>mBase</code>中。Activity继承自<code>ContextWrapper</code>的子类<code>ContextThemeWrapper</code>，这样在Activity中就可以使用<code>ContextImpl</code>了。</p><p><code>ActivityThread</code>到<code>ContextImpl</code>的调用时序图：</p><img src="/2019/09/09/Android深入理解Context-02/VejzTg.png"><h1 id="2-Service的Context创建过程"><a href="#2-Service的Context创建过程" class="headerlink" title="2. Service的Context创建过程"></a>2. Service的Context创建过程</h1><p>Service的Context创建过程与Activity的Context创建过程类似，也是在Service的启动过程中被创建。在<a href="https://tylerliu.top/2019/09/03/Andorid深入理解四大组件-03%EF%BC%9AService的启动过程/#more">Andorid深入理解四大组件 03：Service的启动过程</a>第二节中讲到<code>ActivityThread</code>启动Service的过程，现在从这里开始分析。</p><p><code>ActivityThread</code>的内部类<code>ApplicationThread</code>会调用<code>scheduleCreateService()</code>来启动Service：frameworks/base/core/java/android/app/ActivityThread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleCreateService</span><span class="params">(IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">        ServiceInfo info, CompatibilityInfo compatInfo, <span class="keyword">int</span> processState)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    sendMessage(H.CREATE_SERVICE, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向<code>H</code>类发送类型为<code>CREATE_SERVICE</code>的消息。在<code>H</code>中，<code>handleMessage()</code>的对应<code>case</code>作出处理，在里面调用了<code>handleCreateService()</code>：frameworks/base/core/java/android/app/ActivityThread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleCreateService</span><span class="params">(CreateServiceData data)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">"Creating service "</span> + data.info.name);</span><br><span class="line">        ContextImpl context = ContextImpl.createAppContext(<span class="keyword">this</span>, packageInfo); <span class="comment">// 1</span></span><br><span class="line">        context.setOuterContext(service);</span><br><span class="line">        Application app = packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line">        service.attach(context, <span class="keyword">this</span>, data.info.name, data.token, app, ActivityManagerNative.getDefault()); <span class="comment">// 2</span></span><br><span class="line">        service.onCreate();</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，创建<code>ContextImpl</code>，并将该<code>ContextImpl</code>传入注释2中<code>Service.attach()</code>中：frameworks/base/core/java/android/app/Service.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context, ActivityThread thread, String className, IBinder token, Application application, Object activityManager)</span> </span>&#123;</span><br><span class="line">    attachBaseContext(context); <span class="comment">// 1</span></span><br><span class="line">    mThread = thread;</span><br><span class="line">    mClassName = className;</span><br><span class="line">    mToken = token;</span><br><span class="line">    mApplication = application;</span><br><span class="line">    mActivityManager = (IActivityManager)activityManager;</span><br><span class="line">    mStartCompatibility = getApplicationInfo().targetSdkVersion &lt; Build.VERSION_CODES.ECLAIR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，调用<code>ContextWrapper</code>的<code>attachBaseContext()</code>：frameworks/base/core/java/android/content/ContextWrapper.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mBase != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Base context already set"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mBase = base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法已经在前面讲过。</p><p>Service的Context创建过程就讲到这里，由于它和Activity的Context创建过程类似，因此，可以参考前文给出的<code>ActivityThread</code>到<code>ContextWrapper</code>的调用时序图。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Activity的Context创建过程&quot;&gt;&lt;a href=&quot;#1-Activity的Context创建过程&quot; class=&quot;headerlink&quot; title=&quot;1. Activity的Context创建过程&quot;&gt;&lt;/a&gt;1. Activity的Context
      
    
    </summary>
    
      <category term="Android进阶" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
      <category term="框架层" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/"/>
    
      <category term="深入理解Context" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Context/"/>
    
    
      <category term="Context" scheme="https://tylerLiu.top/tags/Context/"/>
    
  </entry>
  
  <entry>
    <title>Android深入理解Context 01</title>
    <link href="https://tylerLiu.top/2019/09/07/Android%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Context-01/"/>
    <id>https://tylerLiu.top/2019/09/07/Android深入理解Context-01/</id>
    <published>2019-09-07T07:35:49.000Z</published>
    <updated>2019-09-11T08:03:48.958Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Context</code>：上下文对象，这里基于Andorid 7.0源码进行解析。</p><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p><code>Context</code>：一个应用程序的环境信息的接口。</p><p>开发中使用场景主要有两类：</p><ul><li>使用<code>Context</code>调用方法，比如：启动Activity、访问资源、调用系统级服务等。</li><li>调用方法传入<code>Context</code>，比如：弹出<code>Toast</code>、创建<code>Dialog</code>等。</li></ul><p>Activity、Service和Application都间接继承了Context。因此可以计算出一个应用程序进程中有多少个Context，其个数等于Activity、Service的总和加1，这个1是Application。</p><p><code>Context</code>是一个抽象类，内部定义了很多方法和静态常量，它的具体实现是<code>ContextImpl</code>。和<code>Context</code>相关联的类，除了<code>ContextImpl</code>，还有<code>ContextWrapper</code>、<code>ContextThemeWrapper</code>和<code>Activity</code>等。下面是<code>Context</code>的关系图：</p><img src="/2019/09/07/Android深入理解Context-01/VejqSI.png"><p>图中可以看出，<code>ContextImpl</code>和<code>ContextWrapper</code>继承自<code>Context</code>，<code>ContextWrapper</code>内部包含有<code>Context</code>类型的<code>mBase</code>对象，<code>mBase</code>具体的指向是<code>ContextImpl</code>。<code>ContextImpl</code>提供了很多功能，但外界还需要使用和拓展<code>ContextImpl</code>，所以将其设计成装饰模式，<code>ContextWrapper</code>是装饰类，它对<code>ContextImpl</code>类进行了包装，<code>ContextWrapper</code>主要起方法传递作用，<code>ContextWrapper</code>中几乎所有的方法实现都是调用<code>ContextImpl</code>的相应方法来实现的。</p><p><code>ContextThemeWrapper</code>、<code>Service</code>和<code>Applicaiton</code>继承自<code>ContextWrapper</code>，它们都可以通过<code>mBase</code>来使用<code>Context</code>的方法，同时它们也都是装饰类，在<code>ContextWrapper</code>的基础上又添加了不同的功能。</p><p><code>ContextThemeWrapper</code>中包含了和主题相关的方法，比如：<code>getTheme()</code>。因此，需要主题的<code>Activity</code>继承自<code>ContextThemeWrapper</code>，而不需要主题的<code>Service</code>继承自<code>ContextWrapper</code>。</p><h1 id="2-Application-Context的创建过程"><a href="#2-Application-Context的创建过程" class="headerlink" title="2. Application Context的创建过程"></a>2. Application Context的创建过程</h1><p>通常使用<code>getApplicationContext()</code>来获取全局的Application Context，那么Application Context是如何创建的？</p><p>在<a href="https://tylerliu.top/2019/09/02/Andorid深入理解四大组件-02%EF%BC%9A应用程序启动过程%EF%BC%88下%EF%BC%89/">Andorid深入理解四大组件 02：应用程序启动过程（下）</a>中最后讲到<code>ActivityThread</code>启动Activity。<code>ActivityThread</code>作为应用程序进程的核心类，它会调用其内部的<code>ApplicationThread</code>的<code>scheduleLaunchActivity()</code>来启动Activity：frameworks/base/core/java/android/app/ActivityThread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleLaunchActivity</span><span class="params">(Intent intent, IBinder token, <span class="keyword">int</span> ident,</span></span></span><br><span class="line"><span class="function"><span class="params">        ActivityInfo info, Configuration curConfig, Configuration overrideConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">        CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> procState, Bundle state, PersistableBundle persistentState,</span></span></span><br><span class="line"><span class="function"><span class="params">        List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> notResumed, <span class="keyword">boolean</span> isForward, ProfilerInfo profilerInfo)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    updateProcessState(procState, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    ActivityClientRecord r = <span class="keyword">new</span> ActivityClientRecord();</span><br><span class="line"></span><br><span class="line">    r.token = token;</span><br><span class="line">    r.ident = ident;</span><br><span class="line">    r.intent = intent;</span><br><span class="line">    r.referrer = referrer;</span><br><span class="line">    r.voiceInteractor = voiceInteractor;</span><br><span class="line">    r.activityInfo = info;</span><br><span class="line">    r.compatInfo = compatInfo;</span><br><span class="line">    r.state = state;</span><br><span class="line">    r.persistentState = persistentState;</span><br><span class="line"></span><br><span class="line">    r.pendingResults = pendingResults;</span><br><span class="line">    r.pendingIntents = pendingNewIntents;</span><br><span class="line"></span><br><span class="line">    r.startsNotResumed = notResumed;</span><br><span class="line">    r.isForward = isForward;</span><br><span class="line"></span><br><span class="line">    r.profilerInfo = profilerInfo;</span><br><span class="line"></span><br><span class="line">    r.overrideConfig = overrideConfig;</span><br><span class="line">    updatePendingConfiguration(curConfig);</span><br><span class="line"></span><br><span class="line">    sendMessage(H.LAUNCH_ACTIVITY, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>ApplicationThread</code>的<code>scheduleLaunchActivity()</code>向<code>H</code>类发送类型为<code>LAUNCH_ACTIVITY</code>的消息，目的是将启动Activity的逻辑放到主线程中的消息列里中，这样启动Activity的逻辑就会在主线程中执行。再来查看<code>H</code>中对于<code>LAUNCH_ACTIVITY</code>的处理：frameworks/base/core/java/android/app/ActivityThread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> LAUNCH_ACTIVITY: &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"activityStart"</span>);</span><br><span class="line">        <span class="keyword">final</span> ActivityClientRecord r = (ActivityClientRecord) msg.obj;</span><br><span class="line">        r.packageInfo = getPackageInfoNoCheck(r.activityInfo.applicationInfo, r.compatInfo); <span class="comment">// 1</span></span><br><span class="line">        handleLaunchActivity(r, <span class="keyword">null</span>, <span class="string">"LAUNCH_ACTIVITY"</span>); <span class="comment">// 2</span></span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    &#125; </span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>注释1，通过<code>getPackageInfo()</code>获得<code>LoadedApk</code>的对象，并将该值赋值给<code>ActivityClientRecord.packageInfo</code>，<code>LoadedApk</code>是用来描述已加载的APK文件。</p><p>注释2，调用<code>handleLaunchActivity()</code>：frameworks/base/core/java/android/app/ActivityThread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent, String reason)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    Activity a = performLaunchActivity(r, customIntent);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看<code>performLaunchActivity()</code>：frameworks/base/core/java/android/app/ActivityThread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Application app = r.packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line">        ......</span><br><span class="line">    &#125; </span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只保留与Application Context相关的逻辑。从前面知道，这里的<code>r.packageInfo</code>是<code>LoadedApk</code>类型的，下面查看其<code>makeApplication()</code>：frameworks/base/core/java/android/app/LoadedApk.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Application <span class="title">makeApplication</span><span class="params">(<span class="keyword">boolean</span> forceDefaultAppClass, Instrumentation instrumentation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mApplication != <span class="keyword">null</span>) &#123; <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">return</span> mApplication;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        java.lang.ClassLoader cl = getClassLoader();</span><br><span class="line">        ......</span><br><span class="line">        ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, <span class="keyword">this</span>); <span class="comment">// 2</span></span><br><span class="line">        app = mActivityThread.mInstrumentation.newApplication(cl, appClass, appContext); <span class="comment">// 3</span></span><br><span class="line">        appContext.setOuterContext(app); <span class="comment">// 4</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    mActivityThread.mAllApplications.add(app);</span><br><span class="line">    mApplication = app; <span class="comment">// 5</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，如果<code>mApplication</code>不为空，就返回<code>mApplication</code>。这里假设是第一次启动应用程序，所以<code>mApplication</code>为空。</p><p>注释2，通过<code>ContextImpl</code>的<code>createAppContext()</code>创建其实例。</p><p>注释3，创建<code>Application</code>，在<code>Instrumentation</code>的<code>newApplication()</code>中传入了<code>ClassLoader</code>类型的对象以及注释2创建的<code>ContextImpl</code>。</p><p>注释4，将<code>Application</code>赋值给<code>ContextImpl</code>的<code>Context</code>类型的成员变量<code>mOuterContext</code>。</p><p>注释5，将<code>Application</code>赋值给<code>LoadedApk</code>的成员变量<code>mApplication</code>。</p><p>再来看看注释3的<code>Application</code>的创建，<code>Instrumentation</code>的<code>newApplication()</code>：frameworks/base/core/java/android/app/Instrumentation.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> Application <span class="title">newApplication</span><span class="params">(Class&lt;?&gt; clazz, Context context)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InstantiationException, IllegalAccessException, </span></span><br><span class="line"><span class="function">        ClassNotFoundException </span>&#123;</span><br><span class="line">    Application app = (Application)clazz.newInstance(); <span class="comment">// 1</span></span><br><span class="line">    app.attach(context);</span><br><span class="line">    <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Instrumentation</code>中有两个<code>newApplication()</code>重载方法，最终都会调用上面的这个重载方法。注释1，通过反射创建<code>Application</code>，并调用<code>Application</code>的<code>attach()</code>，传入<code>ContextImpl</code>：frameworks/base/core/java/android/app/Application.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    attachBaseContext(context);</span><br><span class="line">    mLoadedApk = ContextImpl.getImpl(context).mPackageInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>attach()</code>中调用了<code>attachBaseContext()</code>，它的实现在<code>Application</code>的父类<code>ContextWrapper</code>中：frameworks/base/core/java/android/content/ContextWrapper.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mBase != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Base context already set"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mBase = base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>base</code>指的就是<code>ContextImpl</code>，将<code>ContextImpl</code>赋值给<code>ContextWrapper</code>类型的成员变量<code>mBase</code>。Application Context创建的过程就到这里。</p><p>Application Context创建过程的时序图：</p><img src="/2019/09/07/Android深入理解Context-01/VejLlt.png"><h1 id="3-Application-Context的获取过程"><a href="#3-Application-Context的获取过程" class="headerlink" title="3. Application Context的获取过程"></a>3. Application Context的获取过程</h1><p>通过<code>getApplicationContext()</code>来获取Application Context，<code>getApplicationContext()</code>的实现是在<code>ContextWrapper</code>中：frameworks/base/core/java/android/content/ContextWrapper.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Context <span class="title">getApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mBase.getApplicationContext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从前面得知，<code>mBase</code>指的就是<code>ContextImpl</code>，再来查看<code>ComtextImpl</code>的<code>getApplicationContext()</code>：frameworks/base/core/java/android/app/ContextImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Context <span class="title">getApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (mPackageInfo != <span class="keyword">null</span>) ? mPackageInfo.getApplication() : mMainThread.getApplication();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<code>LoadedApk</code>不为空，就调用<code>LoadedApk</code>的<code>getApplication()</code>，否则就调用<code>ActivityThread</code>的<code>getApplication()</code>。由于应用程序进程已经启动，所以<code>LoadedApk</code>不会为空，就会调用<code>LoadedApk.getApplication()</code>：frameworks/base/core/java/android/app/LoadedApk.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Application <span class="title">getApplication</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mApplication;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>mApplication</code>就是在<code>LoadedApk.makeApplication()</code>中注释5被赋值。这样就通过<code>getApplicationContext()</code>获取Application Context了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Context&lt;/code&gt;：上下文对象，这里基于Andorid 7.0源码进行解析。&lt;/p&gt;
&lt;h1 id=&quot;1-概述&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="Android进阶" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
      <category term="框架层" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/"/>
    
      <category term="深入理解Context" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Context/"/>
    
    
      <category term="Context" scheme="https://tylerLiu.top/tags/Context/"/>
    
  </entry>
  
  <entry>
    <title>Andorid深入理解四大组件 08：Android 8.0 根Activity启动过程（下）</title>
    <link href="https://tylerLiu.top/2019/09/07/Andorid%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6-08%EF%BC%9AAndroid-8-0-%E6%A0%B9Activity%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>https://tylerLiu.top/2019/09/07/Andorid深入理解四大组件-08：Android-8-0-根Activity启动过程（下）/</id>
    <published>2019-09-07T03:08:35.000Z</published>
    <updated>2019-09-11T08:03:27.983Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-ActivityThread启动Activity过程"><a href="#1-ActivityThread启动Activity过程" class="headerlink" title="1. ActivityThread启动Activity过程"></a>1. ActivityThread启动Activity过程</h1><p><a href="https://tylerliu.top/2019/09/04/Andorid深入理解四大组件-07%EF%BC%9AAndroid-8-0-根Activity启动过程%EF%BC%88上%EF%BC%89/#more">Andorid深入理解四大组件 07：Android 8.0 根Activity启动过程（上）</a>中已经介绍到代码逻辑运行在应用程序进程中。先来查看<code>ActivityThread</code>启动Activity的过程的时序图。</p><img src="/2019/09/07/Andorid深入理解四大组件-08：Android-8-0-根Activity启动过程（下）/VeqcKU.png"><p>接着查看<code>ApplicationThread</code>的<code>scheduleLaunchActivity()</code>，其中<code>ApplicationThread</code>是<code>ActivityThread</code>的内部类，应用程序进程创建后会运行代表主线程的实例<code>ActivityThread</code>，它会管理当前应用程序进程的线程。frameworks/base/core/java/android/app/ActivityThread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleLaunchActivity</span><span class="params">(Intent intent, IBinder token, <span class="keyword">int</span> ident,</span></span></span><br><span class="line"><span class="function"><span class="params">        ActivityInfo info, Configuration curConfig, Configuration overrideConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">        CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> procState, Bundle state, PersistableBundle persistentState,</span></span></span><br><span class="line"><span class="function"><span class="params">        List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> notResumed, <span class="keyword">boolean</span> isForward, ProfilerInfo profilerInfo)</span> </span>&#123;</span><br><span class="line">    updateProcessState(procState, <span class="keyword">false</span>);</span><br><span class="line">    ActivityClientRecord r = <span class="keyword">new</span> ActivityClientRecord();</span><br><span class="line">    r.token = token;</span><br><span class="line">    r.ident = ident;</span><br><span class="line">    r.intent = intent;</span><br><span class="line">    r.referrer = referrer;</span><br><span class="line">    ......</span><br><span class="line">    updatePendingConfiguration(curConfig);</span><br><span class="line">    sendMessage(H.LAUNCH_ACTIVITY, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>scheduleLaunchActivity()</code>会将启动Activity的参数封装成<code>ActivityClientRecord</code>，<code>sendMessage()</code>会向<code>H</code>发送类型为<code>LAUNCH_ACTIVITY</code>的消息，并将<code>ActivityClientRecord</code>的对象发送出去：frameworks/base/core/java/android/app/ActivityThread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">int</span> what, Object obj, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    Message msg = Message.obtain();</span><br><span class="line">    msg.what = what;</span><br><span class="line">    msg.obj = obj;</span><br><span class="line">    msg.arg1 = arg1;</span><br><span class="line">    msg.arg2 = arg2;</span><br><span class="line">    <span class="keyword">if</span> (async) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mH.sendMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终会调用<code>H</code>的方法，现在查看<code>H</code>的<code>handleMessage()</code>中对于<code>LAUNCH_ACTIVITY</code>的处理：frameworks/base/core/java/android/app/ActivityThread.H.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> LAUNCH_ACTIVITY: &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"activityStart"</span>);</span><br><span class="line">        <span class="keyword">final</span> ActivityClientRecord r = (ActivityClientRecord) msg.obj; <span class="comment">// 1</span></span><br><span class="line">        r.packageInfo = getPackageInfoNoCheck(r.activityInfo.applicationInfo, r.compatInfo); <span class="comment">// 2</span></span><br><span class="line">        handleLaunchActivity(r, <span class="keyword">null</span>, <span class="string">"LAUNCH_ACTIVITY"</span>); <span class="comment">// 3</span></span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    &#125; </span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>注释1，将传来的<code>msg.obj</code>转成<code>ActivityCLientRecord</code>。</p><p>注释2，通过<code>getPackageInfoNoCheck()</code>获得<code>LoadedApk</code>类型的对象并赋值给<code>ActivityClientRecord</code>的成员变量<code>packageInfo</code>。应用程序进程要启动Activity时需要将该Activity所属的APK加载进来，而<code>LoadedApk</code>就是用来描述已加载的APK文件。</p><p>注释3，调用<code>handleLaunchActivity()</code>：frameworks/base/core/java/android/app/ActivityThread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent, String reason)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    WindowManagerGlobal.initialize();</span><br><span class="line">    <span class="comment">// 启动Activity</span></span><br><span class="line">    Activity a = performLaunchActivity(r, customIntent); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">        r.createdConfig = <span class="keyword">new</span> Configuration(mConfiguration);</span><br><span class="line">        reportSizeConfigurations(r);</span><br><span class="line">        Bundle oldState = r.state;</span><br><span class="line">        <span class="comment">// 将Activity的状态设置为Resume</span></span><br><span class="line">        handleResumeActivity(r.token, <span class="keyword">false</span>, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason); <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">if</span> (!r.activity.mFinished &amp;&amp; r.startsNotResumed) &#123;</span><br><span class="line">            performPauseActivityIfNeeded(r, reason);</span><br><span class="line">            <span class="keyword">if</span> (r.isPreHoneycomb()) &#123;</span><br><span class="line">                r.state = oldState;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 停止Activity启动</span></span><br><span class="line">            ActivityManager.getService().finishActivity(r.token, Activity.RESULT_CANCELED, <span class="keyword">null</span>, Activity.DONT_FINISH_TASK_WITH_ACTIVITY);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，<code>performLaunchActivity()</code>用来启动Activity。</p><p>注释2，用来将Activity的状态设置为Resume。</p><p>如果该Activity为空，就通知AMS停止启动Activity。</p><p>先看看<code>performLaunchActivity()</code>：frameworks/base/core/java/android/app/ActivityThread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">    ActivityInfo aInfo = r.activityInfo; <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> (r.packageInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">        r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo, Context.CONTEXT_INCLUDE_CODE); <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    ComponentName component = r.intent.getComponent(); <span class="comment">// 3</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 创建要启动Activity的上下文环境</span></span><br><span class="line">    ContextImpl appContext = createBaseContextForActivity(r); <span class="comment">// 4</span></span><br><span class="line">    Activity activity = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        java.lang.ClassLoader cl = appContext.getClassLoader();</span><br><span class="line">        <span class="comment">// 用类加载器创建该Activity的实例</span></span><br><span class="line">        activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent); <span class="comment">// 5</span></span><br><span class="line">        StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">        r.intent.setExtrasClassLoader(cl);</span><br><span class="line">        r.intent.prepareToEnterProcess();</span><br><span class="line">        <span class="keyword">if</span> (r.state != <span class="keyword">null</span>) &#123;</span><br><span class="line">            r.state.setClassLoader(cl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Application app = r.packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation); <span class="comment">// 6</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">// 7</span></span><br><span class="line">            activity.attach(appContext, <span class="keyword">this</span>, getInstrumentation(), r.token,</span><br><span class="line">                    r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                    r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                    r.referrer, r.voiceInteractor, window, r.configCallback);</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); <span class="comment">// 8</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        r.paused = <span class="keyword">true</span>;</span><br><span class="line">        mActivities.put(r.token, r);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SuperNotCalledException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，获取<code>ActivityInfo</code>，用于存储代码和<code>AndroidManifest</code>设置的Activity和<code>receiver</code>节点信息，比如Activity的<code>theme</code>和<code>launchMode</code>。</p><p>注释2，获取APK文件的描述类<code>LoadedApk</code>。</p><p>注释3，获取要启动的Activity的<code>ComponentName</code>类，在其中保存了该Activity的包名和类名。</p><p>注释4，创建要启动Activity的上下文环境。</p><p>注释5，根据<code>ComponentName</code>中存储的Activity类名，用类加载器创建该Activity的实例。</p><p>注释6，创建<code>Applicaiton</code>，<code>nakeApplication()</code>内部会调用<code>Application</code>的<code>onCreate()</code>。</p><p>注释7，调用Activity的<code>attach()</code>初始化Activity，<code>attach()</code>中会创建Window对象（<code>PhoneWindow</code>）并与Activity自身进行关联。</p><p>注释8，调用<code>Instrumentation</code>的<code>callActivityOnCreate()</code>来启动Activity：frameworks/base/core/java/android/app/Instrumentation.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callActivityOnCreate</span><span class="params">(Activity activity, Bundle icicle)</span> </span>&#123;</span><br><span class="line">    prePerformCreate(activity);</span><br><span class="line">    activity.performCreate(icicle);</span><br><span class="line">    postPerformCreate(activity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在里面调用了Activity的<code>performCreate()</code>：frameworks/base/core/java/android/app/Activity.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performCreate</span><span class="params">(Bundle icicle)</span> </span>&#123;</span><br><span class="line">    restoreHasCurrentPermissionRequest(icicle);</span><br><span class="line">    onCreate(icicle);</span><br><span class="line">    mActivityTransitionState.readState(icicle);</span><br><span class="line">    performCreateCommon();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>performCreate()</code>中会调用Activity的<code>onCreate()</code>。这样根Activity就启动了，即应用程序启动了。</p><h1 id="2-根Activity启动过程中涉及的进程"><a href="#2-根Activity启动过程中涉及的进程" class="headerlink" title="2. 根Activity启动过程中涉及的进程"></a>2. 根Activity启动过程中涉及的进程</h1><p>在应用程序进程没有创建的情况下，根Activity启动过程会涉及到4个进程，分别是Zygote进程、Launcher进程、AMS所在的进程（SystemServer进程）和应用程序进程。它们之间的关系如下：</p><img src="/2019/09/07/Andorid深入理解四大组件-08：Android-8-0-根Activity启动过程（下）/VeqyvT.png"><p>首先Launcher进程向AMS请求创建根Activity，AMS会判断根Activity所需的应用程序进程是否存在并启动，如果不存在就会请求Zygote进程创建应用程序进程。应用程序进程准备就绪后会通知AMS，AMS会请求应用程序进程创建根Activity。上图中步骤2采用的是Stock通信，步骤1和步骤4采用的是Binder通信。</p><p>下面是四个进程调用的时序图：</p><img src="/2019/09/07/Andorid深入理解四大组件-08：Android-8-0-根Activity启动过程（下）/Veqs2V.png"><p>普通Activity启动过程会涉及两个进程，AMS所在的进程和应用程序进程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-ActivityThread启动Activity过程&quot;&gt;&lt;a href=&quot;#1-ActivityThread启动Activity过程&quot; class=&quot;headerlink&quot; title=&quot;1. ActivityThread启动Activity过程&quot;&gt;&lt;/a&gt;1
      
    
    </summary>
    
      <category term="Android进阶" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
      <category term="框架层" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/"/>
    
      <category term="深入理解四大组件" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/"/>
    
    
      <category term="四大组件" scheme="https://tylerLiu.top/tags/%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>HTTP FAILED: java.net.UnknownServiceException: CLEARTEXT communication to 包名</title>
    <link href="https://tylerLiu.top/2019/09/06/HTTP-FAILED-java-net-UnknownServiceException-CLEARTEXT-communication-to-%E5%8C%85%E5%90%8D/"/>
    <id>https://tylerLiu.top/2019/09/06/HTTP-FAILED-java-net-UnknownServiceException-CLEARTEXT-communication-to-包名/</id>
    <published>2019-09-06T08:45:04.000Z</published>
    <updated>2019-09-06T08:48:08.542Z</updated>
    
    <content type="html"><![CDATA[<p>Android P以后，如果使用HTTP，将会报以下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP FAILED: java.net.UnknownServiceException: CLEARTEXT communication to &quot;包名&quot; not permitted by</span><br></pre></td></tr></table></figure><p>Android P默认是不允许使用明文网络传输的，会强制让应用都使用https。</p><p>经过网上查证，还有可以兼容http的方法，在res下新建一个xml目录，然后创建一个名为：network_security_config.xml文件 ，该文件内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">network-security-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">base-config</span> <span class="attr">cleartextTrafficPermitted</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">network-security-config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在清单文件的<code>application</code>标签内加上：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:networkSecurityConfig="@xml/network_security_config"</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Android P以后，如果使用HTTP，将会报以下错误：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre
      
    
    </summary>
    
      <category term="Android" scheme="https://tylerLiu.top/categories/Android/"/>
    
      <category term="异常" scheme="https://tylerLiu.top/categories/Android/%E5%BC%82%E5%B8%B8/"/>
    
    
      <category term="异常" scheme="https://tylerLiu.top/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>Andorid深入理解四大组件 07：Android 8.0 根Activity启动过程（上）</title>
    <link href="https://tylerLiu.top/2019/09/04/Andorid%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6-07%EF%BC%9AAndroid-8-0-%E6%A0%B9Activity%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>https://tylerLiu.top/2019/09/04/Andorid深入理解四大组件-07：Android-8-0-根Activity启动过程（上）/</id>
    <published>2019-09-04T06:26:22.000Z</published>
    <updated>2019-09-11T08:03:26.028Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>Activity的启动分为两种，一种是根Activity的启动过程，另一种是普通Activity的启动过程，根Activity指的是应用程序进程启动的第一个Activity，因此根Activity一般情况下也能理解为应用程序的启动过程。普通Activity指的是除了应用程序启动的第一个Activity之外的其他Activity。这里介绍的是根Activity的启动过程，它和普通Activity的启动过程又重叠部分。根Activity的启动过程一般指的就是应用程序的启动过程。</p><p>根Activity的启动过程比较复杂，这里分成三个部分，分别是<code>Launcher</code>请求AMS的过程、AMS到<code>ApplicationThread</code>的调用过程和<code>ActivityThread</code>启动Activity的。</p><h1 id="2-Launcher请求ASM的过程"><a href="#2-Launcher请求ASM的过程" class="headerlink" title="2. Launcher请求ASM的过程"></a>2. Launcher请求ASM的过程</h1><p><code>Launcher</code>启动后会将已经安装的应用程序的快捷图标显示到桌面上，这些应用程序的快捷图标就是启动根Activity的入口，当点击某个应用程序的快捷图标时，就会通过<code>Launcher</code>请求AMS来启动该应用程序。</p><img src="/2019/09/04/Andorid深入理解四大组件-07：Android-8-0-根Activity启动过程（上）/Veb67d.png"><p>当点击应用程序快捷图标时，就会调用<code>Launcher</code>的<code>startActivitySafely()</code>：packages/apps/Launcher3/src/com/android/launcher3/Launcher.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startActivitySafely</span><span class="params">(View v, Intent intent, ItemInfo item)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">        intent.setSourceBounds(getViewBounds(v));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Utilities.ATLEAST_MARSHMALLOW &amp;&amp; (item <span class="keyword">instanceof</span> ShortcutInfo) &amp;&amp; (item.itemType == Favorites.ITEM_TYPE_SHORTCUT || item.itemType == Favorites.ITEM_TYPE_DEEP_SHORTCUT) &amp;&amp; !((ShortcutInfo) item).isPromise()) &#123;</span><br><span class="line">            startShortcutIntentSafely(intent, optsBundle, item);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (user == <span class="keyword">null</span> || user.equals(Process.myUserHandle())) &#123;</span><br><span class="line">            startActivity(intent, optsBundle); <span class="comment">// 2</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LauncherAppsCompat.getInstance(<span class="keyword">this</span>).startActivityForProfile(intent.getComponent(), user, intent.getSourceBounds(), optsBundle);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ActivityNotFoundException|SecurityException e) &#123;</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>, R.string.activity_not_found, Toast.LENGTH_SHORT).show();</span><br><span class="line">        Log.e(TAG, <span class="string">"Unable to launch. tag="</span> + item + <span class="string">" intent="</span> + intent, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，设置<code>Flag</code>为<code>Intent.FALG_ACTIVITY_NEW_TASK</code>，这样根Activity会在新的任务栈中启动。</p><p>注释2，调用<code>startActivity()</code>，这个<code>startActivity()</code>的实现在<code>Activity</code>中：frameworks/base/core/java/android/app/Activity.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent, @Nullable Bundle options)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (options != <span class="keyword">null</span>) &#123;</span><br><span class="line">        startActivityForResult(intent, -<span class="number">1</span>, options);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        startActivityForResult(intent, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在里面会调用<code>startActivityForResult()</code>，它的第二个参数为-1，表示<code>Launcher</code>不需要知道Activtiy的启动结果：frameworks/base/core/java/android/app/Activity.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityForResult</span><span class="params">(@RequiresPermission Intent intent, <span class="keyword">int</span> requestCode, @Nullable Bundle options)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mParent == <span class="keyword">null</span>) &#123; <span class="comment">// 1</span></span><br><span class="line">        Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity(<span class="keyword">this</span>, mMainThread.getApplicationThread(), mToken, <span class="keyword">this</span>, intent, requestCode, options);</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，<code>mParent</code>是<code>Activity</code>类型，表示当前Activity的父类。因为目前根Activity还没有创建出来，所以<code>mParent == null</code>为<code>true</code>，接着调用<code>Instrumentation</code>的<code>execStartActivity()</code>，<code>Instrumentation</code>主要用来监听应用程序和系统的交互，<code>execStartActivity()</code>代码如下：frameworks/base/core/java/android/app/Instrumentation.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(Context who, IBinder contextThread, IBinder token, String target, Intent intent, <span class="keyword">int</span> requestCode, Bundle options)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        intent.migrateExtraStreamToClipData();</span><br><span class="line">        intent.prepareToLeaveProcess(who);</span><br><span class="line">        <span class="keyword">int</span> result = ActivityManager.getService().startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target, requestCode, <span class="number">0</span>, <span class="keyword">null</span>, options);</span><br><span class="line">        checkStartActivityResult(result, intent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failure from system"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先调用<code>ActivityManager</code>的<code>getService()</code>获取AMS的代理对象，接着调用它的<code>startActivity()</code>。这里和Android 7.0不同的是，Android 7.0是通过<code>ActivityManagerNative</code>的<code>getDefault()</code>来获取AMS的代理对象的，现在这个逻辑封装到了<code>ActivityManager</code>中。首先看看<code>ActivtiyManager.getService()</code>：frameworks/base/core/java/android/app/ActivityManager.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IActivityManager <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> IActivityManagerSingleton.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =</span><br><span class="line">        <span class="keyword">new</span> Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> IActivityManager <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">final</span> IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE); <span class="comment">// 1</span></span><br><span class="line">                <span class="keyword">final</span> IActivityManager am = IActivityManager.Stub.asInterface(b); <span class="comment">// 2</span></span><br><span class="line">                <span class="keyword">return</span> am;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><p><code>getService()</code>中调用了<code>IActivtyManagerSingleton</code>的<code>get()</code>。<code>IActivityManagerSingleton</code>是一个<code>Singleton</code>类。</p><p>注释1，获取一个名为<code>&quot;activity&quot;</code>的Service引用，就是<code>IBinder</code>类型的AMS引用。</p><p>注释2，将其转换为<code>IActivityManager</code>类型的对象，这段代码采用的是AIDL，<code>IActivityManager.java</code>类是由AIDL工具在编译时自动生成的，<code>IActivityManager.aidl</code>的文件路径为：frameworks/base/core/java/android/app/IActivityManager.aidl。要实现进程间通信，服务端——AMS只需要继承<code>IActivityManager.Stub</code>类并实现相应的方法就可以了。</p><p>Android 8.0之前没有采用AIDL，而是采用了类似AIDL的形式，用AMS的代理对象<code>ActivityManagerProxy</code>来与AMS进行进程间通信，Android 8.0去除了<code>ActivityManagerNative</code>的内部类<code>ActivityManagerProxy</code>，替代它的是<code>IActivityManager</code>，它是AMS在本地的代理。</p><p>回到<code>Instrumentation</code>类的<code>execStartActivity()</code>，从上面得知<code>execStartActivity()</code>最终调用的是AMS的<code>startActivity()</code>。</p><h1 id="3-AMS到ApplicationThread的调用过程"><a href="#3-AMS到ApplicationThread的调用过程" class="headerlink" title="3. AMS到ApplicationThread的调用过程"></a>3. AMS到ApplicationThread的调用过程</h1><p><code>Launcher</code>请求AMS后，代码逻辑已经走到了AMS中，接着AMS到<code>ApplicationThread</code>的调用流程，时序图：</p><img src="/2019/09/04/Andorid深入理解四大组件-07：Android-8-0-根Activity启动过程（上）/Veby0H.png"><p>AMS的<code>startActivity()</code>如下：frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, UserHandle.getCallingUserId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在里面<code>return</code>了<code>startActivityAsUser()</code>，可以发现<code>startActivityAsUser()</code>方法比<code>startActivity()</code>多了一个参数<code>UserHandle.getCallingUserId()</code>，这个方法会获得调用者的<code>UserId</code>，AMS会根据<code>UserId</code>来确定调用者的权限。frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivityAsUser</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">        Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断调用者进程是否被隔离</span></span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">"startActivity"</span>); <span class="comment">// 1</span></span><br><span class="line">    <span class="comment">// 检查调用者权限</span></span><br><span class="line">    userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(),</span><br><span class="line">            userId, <span class="keyword">false</span>, ALLOW_FULL_ONLY, <span class="string">"startActivity"</span>, <span class="keyword">null</span>); <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> mActivityStarter.startActivityMayWait(caller, -<span class="number">1</span>, callingPackage, intent,</span><br><span class="line">            resolvedType, <span class="keyword">null</span>, <span class="keyword">null</span>, resultTo, resultWho, requestCode, startFlags,</span><br><span class="line">            profilerInfo, <span class="keyword">null</span>, <span class="keyword">null</span>, bOptions, <span class="keyword">false</span>, userId, <span class="keyword">null</span>, <span class="keyword">null</span>,</span><br><span class="line">            <span class="string">"startActivityAsUser"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，判断调用者进程是否被隔离，如果是，抛出<code>SecurityException</code>。</p><p>注释2，检查调用者的权限，如果没有权限，也会抛出<code>SecurityException</code>。</p><p>最后调用<code>ActivityStarter</code>的<code>startActivityMayWait()</code>，倒数第二个参数是<code>TaskRecord</code>，表示启动的Activity所在的栈。最后一个参数<code>&quot;startActivityAsUser&quot;</code>表示启动的理由：frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivityMayWait</span><span class="params">(IApplicationThread caller, <span class="keyword">int</span> callingUid,</span></span></span><br><span class="line"><span class="function"><span class="params">            String callingPackage, Intent intent, String resolvedType,</span></span></span><br><span class="line"><span class="function"><span class="params">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">            IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> startFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">            ProfilerInfo profilerInfo, WaitResult outResult,</span></span></span><br><span class="line"><span class="function"><span class="params">            Configuration globalConfig, Bundle bOptions, <span class="keyword">boolean</span> ignoreTargetSecurity, <span class="keyword">int</span> userId,</span></span></span><br><span class="line"><span class="function"><span class="params">            IActivityContainer iContainer, TaskRecord inTask, String reason)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">int</span> res = startActivityLocked(caller, intent, ephemeralIntent, resolvedType,</span><br><span class="line">                    aInfo, rInfo, voiceSession, voiceInteractor,</span><br><span class="line">                    resultTo, resultWho, requestCode, callingPid,</span><br><span class="line">                    callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,</span><br><span class="line">                    options, ignoreTargetSecurity, componentSpecified, outRecord, container,</span><br><span class="line">                    inTask, reason);</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ActivityStarter</code>是Andorid 8.0新加入的类，它是加载Activity的控制类，会收集所有的逻辑来决定如何将<code>Intent</code>和<code>Flag</code>转换为<code>Activity</code>，并将<code>Activity</code>和<code>Task</code>以及<code>Stack</code>相关联。<code>startActivityMayWait()</code>里面调用了<code>startActivityLocked()</code>：frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">startActivityLocked</span><span class="params">(IApplicationThread caller, Intent intent, Intent ephemeralIntent,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">        IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> callingPid, <span class="keyword">int</span> callingUid,</span></span></span><br><span class="line"><span class="function"><span class="params">        String callingPackage, <span class="keyword">int</span> realCallingPid, <span class="keyword">int</span> realCallingUid, <span class="keyword">int</span> startFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">        ActivityOptions options, <span class="keyword">boolean</span> ignoreTargetSecurity, <span class="keyword">boolean</span> componentSpecified,</span></span></span><br><span class="line"><span class="function"><span class="params">        ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container,</span></span></span><br><span class="line"><span class="function"><span class="params">        TaskRecord inTask, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(reason)) &#123;<span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Need to specify a reason."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mLastStartReason = reason;</span><br><span class="line">    mLastStartActivityTimeMs = System.currentTimeMillis();</span><br><span class="line">    mLastStartActivityRecord[<span class="number">0</span>] = <span class="keyword">null</span>;</span><br><span class="line">    mLastStartActivityResult = startActivity(caller, intent, ephemeralIntent, resolvedType,</span><br><span class="line">            aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode,</span><br><span class="line">            callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,</span><br><span class="line">            options, ignoreTargetSecurity, componentSpecified, mLastStartActivityRecord,</span><br><span class="line">            container, inTask);</span><br><span class="line">    <span class="keyword">if</span> (outActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// mLastStartActivityRecord[0] is set in the call to startActivity above.</span></span><br><span class="line">        outActivity[<span class="number">0</span>] = mLastStartActivityRecord[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mLastStartActivityResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，判断启动的理由不为空，如果为空，抛出<code>IllegalArgumentException()</code>。接着调用<code>startActivity()</code>：frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(IApplicationThread caller, Intent intent, Intent ephemeralIntent,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">        IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> callingPid, <span class="keyword">int</span> callingUid,</span></span></span><br><span class="line"><span class="function"><span class="params">        String callingPackage, <span class="keyword">int</span> realCallingPid, <span class="keyword">int</span> realCallingUid, <span class="keyword">int</span> startFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">        ActivityOptions options, <span class="keyword">boolean</span> ignoreTargetSecurity, <span class="keyword">boolean</span> componentSpecified,</span></span></span><br><span class="line"><span class="function"><span class="params">        ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container,</span></span></span><br><span class="line"><span class="function"><span class="params">        TaskRecord inTask)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err = ActivityManager.START_SUCCESS;</span><br><span class="line">    <span class="keyword">final</span> Bundle verificationBundle = options != <span class="keyword">null</span> ? options.popAppVerificationBundle() : <span class="keyword">null</span>;</span><br><span class="line">    ProcessRecord callerApp = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123; <span class="comment">// 1</span></span><br><span class="line">        <span class="comment">// 获取Launcher进程</span></span><br><span class="line">        callerApp = mService.getRecordForAppLocked(caller); <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">if</span> (callerApp != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 获取Launcher进程的pid和uid并赋值</span></span><br><span class="line">            callingPid = callerApp.pid;</span><br><span class="line">            callingUid = callerApp.info.uid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ......</span><br><span class="line">            err = ActivityManager.START_PERMISSION_DENIED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 创建即将要启动的Activity的描述类ActivityRecord</span></span><br><span class="line">    ActivityRecord r = <span class="keyword">new</span> ActivityRecord(mService, callerApp, callingPid, callingUid,</span><br><span class="line">            callingPackage, intent, resolvedType, aInfo, mService.getGlobalConfiguration(),</span><br><span class="line">            resultRecord, resultWho, requestCode, componentSpecified, voiceSession != <span class="keyword">null</span>,</span><br><span class="line">            mSupervisor, container, options, sourceRecord); <span class="comment">// 2  </span></span><br><span class="line">    <span class="keyword">if</span> (outActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        outActivity[<span class="number">0</span>] = r; <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    doPendingActivityLaunchesLocked(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">return</span> startActivity(r, sourceRecord, voiceSession, voiceInteractor, startFlags, <span class="keyword">true</span>, options, inTask, outActivity); <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，判断<code>IApplicationThread</code>类型的<code>caller</code>是否为空，这个<code>caller</code>指向的是Launche进程的<code>ApplicationThread</code>对象。</p><p>注释2，调用AMS的<code>getRecordForAppLocked()</code>获取代表<code>Launcher</code>进程的<code>callerApp</code>对象，它是<code>ProcessRecord</code>类型的，<code>ProcessRecord</code>是用于描述一个应用程序进程。同样的，<code>ActivityRecord</code>用于描述一个Activity，用来记录一个Activity的所有信息。在注释2创建了一个<code>ActiviytRecord</code>，用于描述即将启动的Activity，并在注释3将创建的<code>ActivtiyRecord</code>赋值给<code>ActivityRecord[]</code>类型的<code>outActivity</code>。这个<code>outActivity</code>会在注释4的<code>startActivitiy()</code>传递下去。frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(<span class="keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> startFlags, <span class="keyword">boolean</span> doResume, ActivityOptions options, TaskRecord inTask,</span></span></span><br><span class="line"><span class="function"><span class="params">        ActivityRecord[] outActivity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = START_CANCELED;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mService.mWindowManager.deferSurfaceLayout();</span><br><span class="line">        result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor, startFlags, doResume, options, inTask, outActivity);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ActivityManager.isStartResultSuccessful(result)</span><br><span class="line">                &amp;&amp; mStartActivity.getTask() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mStartActivity.getTask().removeActivity(mStartActivity);</span><br><span class="line">        &#125;</span><br><span class="line">        mService.mWindowManager.continueSurfaceLayout();</span><br><span class="line">    &#125;</span><br><span class="line">    postStartActivityProcessing(r, result, mSupervisor.getLastStack().mStackId,  mSourceRecord, mTargetStack);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在里面调用了<code>startActivityUnchecked()</code>：frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivityUnchecked</span><span class="params">(<span class="keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> startFlags, <span class="keyword">boolean</span> doResume, ActivityOptions options, TaskRecord inTask,</span></span></span><br><span class="line"><span class="function"><span class="params">        ActivityRecord[] outActivity)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (mStartActivity.resultTo == <span class="keyword">null</span> &amp;&amp; mInTask == <span class="keyword">null</span> &amp;&amp; !mAddingToTask &amp;&amp; (mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != <span class="number">0</span>) &#123; <span class="comment">// 1</span></span><br><span class="line">        newTask = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 创建新的TaskRecord</span></span><br><span class="line">        result = setTaskFromReuseOrCreateNewTask(taskToAffiliate, preferredLaunchStackId, topStack); <span class="comment">// 2</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mSourceRecord != <span class="keyword">null</span>) &#123;</span><br><span class="line">        result = setTaskFromSourceRecord();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mInTask != <span class="keyword">null</span>) &#123;</span><br><span class="line">        result = setTaskFromInTask();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        setTaskToCurrentTopOrCreateNewTask();</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (mDoResume) &#123;</span><br><span class="line">        <span class="keyword">final</span> ActivityRecord topTaskActivity = mStartActivity.getTask().topRunningActivityLocked();</span><br><span class="line">        <span class="keyword">if</span> (!mTargetStack.isFocusable() || (topTaskActivity != <span class="keyword">null</span> &amp;&amp; topTaskActivity.mTaskOverlay &amp;&amp; mStartActivity != topTaskActivity)) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mTargetStack.isFocusable() &amp;&amp; !mSupervisor.isFocusedStack(mTargetStack)) &#123;</span><br><span class="line">                mTargetStack.moveToFront(<span class="string">"startActivityUnchecked"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity, mOptions); <span class="comment">// 3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mTargetStack.addRecentActivityLocked(mStartActivity);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>startActivityUnchecked()</code>中主要处理栈管理的相关逻辑。</p><p>注释1，前面得知，启动根Activity时，会将<code>Intent</code>的<code>Flag</code>设置为<code>FLAG_ACTIVITY_NEW_TASK</code>，这里的条件就能满足，接着执行注释2的<code>setTaskFromReuseOrCreateNewTask()</code>，内部会创建一个新的<code>TaskRecord</code>，<code>TaskRecord</code>用来描述一个Activity任务栈。Activity任务栈其实是一个假象模型。</p><p>注释3，调用<code>ActivityStackSupervisor</code>的<code>resumeFocusedStackTopActivityLocked()</code>：frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">resumeFocusedStackTopActivityLocked</span><span class="params">(ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (targetStack != <span class="keyword">null</span> &amp;&amp; isFocusedStack(targetStack)) &#123;</span><br><span class="line">        <span class="keyword">return</span> targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取要启动的Activity所在栈的栈顶的不是处于停止状态的ActivityRecord</span></span><br><span class="line">    <span class="keyword">final</span> ActivityRecord r = mFocusedStack.topRunningActivityLocked();<span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> (r == <span class="keyword">null</span> || r.state != RESUMED) &#123; <span class="comment">// 2</span></span><br><span class="line">        mFocusedStack.resumeTopActivityUncheckedLocked(<span class="keyword">null</span>, <span class="keyword">null</span>); <span class="comment">// 3</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.state == RESUMED) &#123;</span><br><span class="line">        <span class="comment">// Kick off any lingering app transitions form the MoveTaskToFront operation.</span></span><br><span class="line">        mFocusedStack.executeAppTransition(targetOptions);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，调用<code>ActivityStack</code>的<code>topRunningActivityLocked()</code>获取要启动的Activity所在的栈的栈顶的不是处于停止状态的<code>ActivityRecord</code>。</p><p>注释2，如果<code>ActivityRecord</code>不为空，或者要启动的Activity的状态不是<code>RESUMED</code>，就会调用注释3的<code>ActivityStack</code>的<code>resumeTopActivityUncheckedLocked()</code>：frameworks/base/services/core/java/com/android/server/am/ActivityStack.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">resumeTopActivityUncheckedLocked</span><span class="params">(ActivityRecord prev, ActivityOptions options)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mStackSupervisor.inResumeTopActivity) &#123;</span><br><span class="line">        <span class="comment">// Don't even start recursing.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Protect against recursion.</span></span><br><span class="line">        mStackSupervisor.inResumeTopActivity = <span class="keyword">true</span>;</span><br><span class="line">        result = resumeTopActivityInnerLocked(prev, options); <span class="comment">// 1</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mStackSupervisor.inResumeTopActivity = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mStackSupervisor.checkReadyForSleepLocked();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，<code>resumeTopActivityInnerLocked()</code>：frameworks/base/services/core/java/com/android/server/am/ActivityStack.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">resumeTopActivityInnerLocked</span><span class="params">(ActivityRecord prev, ActivityOptions options)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    &#123;</span><br><span class="line">       mStackSupervisor.startSpecificActivityLocked(next, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意调用了<code>ActivityStackSupervisor</code>的<code>startSpecificActivityLocked()</code>：frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startSpecificActivityLocked</span><span class="params">(ActivityRecord r, <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Is this activity's application already running?</span></span><br><span class="line">    <span class="comment">// 获取将要启动的Activity所在的应用程序进程</span></span><br><span class="line">    ProcessRecord app = mService.getProcessRecordLocked(r.processName, r.info.applicationInfo.uid, <span class="keyword">true</span>); <span class="comment">// 1</span></span><br><span class="line">    r.getStack().setLaunchTime(r);</span><br><span class="line">    <span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; app.thread != <span class="keyword">null</span>) &#123; <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == <span class="number">0</span> || !<span class="string">"android"</span>.equals(r.info.packageName)) &#123;</span><br><span class="line">                app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode, mService.mProcessStats);</span><br><span class="line">            &#125;</span><br><span class="line">            realStartActivityLocked(r, app, andResume, checkConfig); <span class="comment">// 3</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mService.startProcessLocked(r.processName, r.info.applicationInfo, <span class="keyword">true</span>, <span class="number">0</span>, <span class="string">"activity"</span>, r.intent.getComponent(), <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，获取将要启动的Activity所在的应用程序进程。</p><p>注释2，判断要启动的Activity所在的应用程序进程已经在运行后，调用注释3的<code>realStartActivityLocked()</code>，方法的第二个参数是要启动的Activity所在应用程序进程的<code>ProcessRecord</code>：frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">realStartActivityLocked</span><span class="params">(ActivityRecord r, ProcessRecord app, <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    app.thread.scheduleLaunchActivity(<span class="keyword">new</span> Intent(r.intent), r.appToken,</span><br><span class="line">        System.identityHashCode(r), r.info, <span class="keyword">new</span> Configuration(mService.mConfiguration),</span><br><span class="line">        <span class="keyword">new</span> Configuration(task.mOverrideConfig), r.compat, r.launchedFromPackage,</span><br><span class="line">        task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results,</span><br><span class="line">        newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo);</span><br><span class="line">    ......      </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>app.thread</code>指的是<code>IApplicationThread</code>，它的实现是<code>ActivityThread</code>的内部类<code>ApplicationThread</code>，其中<code>ApplicationThread</code>继承了<code>IApplicationThread.Stub</code>。<code>app</code>指的是传入要启动的Activity的所在的应用程序进程，因此，注释1的代码指的是要在目标应用程序进程启动Activity。当前代码逻辑运行在AMS所在的进程（SystemServer进程），通过<code>ApplicationThread</code>来与应用程序进程进行Binder通信，即，<code>ApplicationThread</code>是AMS所在进程（SystemServer进程）和应用程序进程的通信桥梁，如下图：</p><img src="/2019/09/04/Andorid深入理解四大组件-07：Android-8-0-根Activity启动过程（上）/VebDXD.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h1&gt;&lt;p&gt;Activity的启动分为两种，一种是根Activity的启动过程，另一种是普通Activity的启动过程，根Activ
      
    
    </summary>
    
      <category term="Android进阶" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
      <category term="框架层" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/"/>
    
      <category term="深入理解四大组件" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/"/>
    
    
      <category term="四大组件" scheme="https://tylerLiu.top/tags/%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Andorid深入理解四大组件 06：ContentProvider的启动过程</title>
    <link href="https://tylerLiu.top/2019/09/04/Andorid%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6-06%EF%BC%9AContentProvider%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"/>
    <id>https://tylerLiu.top/2019/09/04/Andorid深入理解四大组件-06：ContentProvider的启动过程/</id>
    <published>2019-09-04T01:38:27.000Z</published>
    <updated>2019-09-11T08:03:24.358Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-query方法到AMS的调用"><a href="#1-query方法到AMS的调用" class="headerlink" title="1. query方法到AMS的调用"></a>1. query方法到AMS的调用</h1><p>下面是一个常规<code>ContentProvider</code>在Activity中的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContentProviderActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String TAG = <span class="string">"ContentProviderActivity"</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_content_provider);</span><br><span class="line">        Uri uri = Uri.parse(<span class="string">"content://com.example.liuwangshu.mooncontentprovide.GameProvider"</span>);</span><br><span class="line">        ContentValues mContentValues = <span class="keyword">new</span> ContentValues();</span><br><span class="line">        mContentValues.put(<span class="string">"_id"</span>, <span class="number">2</span>);</span><br><span class="line">        mContentValues.put(<span class="string">"name"</span>, <span class="string">"323232"</span>);</span><br><span class="line">        mContentValues.put(<span class="string">"describe"</span>, <span class="string">"32323232"</span>);</span><br><span class="line">        getContentResolver().insert(uri, mContentValues); <span class="comment">// 1</span></span><br><span class="line">        Cursor gameCursor = getContentResolver().query(uri, <span class="keyword">new</span> String[]&#123;<span class="string">"name"</span>, <span class="string">"describe"</span>&#125;, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">     ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，使用<code>ContentProvider</code>，需要调用``getContentResolver()`：frameworks/base/core/Java/android/content/ContextWrapper.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ContentResolver <span class="title">getContentResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mBase.getContentResolver();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mBase</code>指的是<code>ContextImpl</code>，<code>ContextImpl</code>的<code>getContentResolver()</code>：frameworks/base/core/java/android/app/ContextImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ContentResolver <span class="title">getContentResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mContentResolver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终<code>return</code>了<code>ApplicationContentResolver</code>类型的<code>mContentResolver</code>对象，<code>ApplicationContentResolver</code>是<code>ContextImpl</code>的静态内部类，继承自<code>ContentResolver</code>，它在<code>ContextImpl</code>的构造方法中被创建。</p><p>当调用<code>ContentResolver</code>的<code>insert()</code>、<code>query()</code>、<code>update()</code>等方法时，就会启动<code>ContentProvider</code>，这里用<code>query()</code>为例。</p><p><code>query()</code>的实现在<code>ApplicationContentResolver</code>的父类<code>ContentResolver</code>中：frameworks/base/core/java/android/content/ContentResolver.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> <span class="function">Cursor <span class="title">query</span><span class="params">(<span class="keyword">final</span> @RequiresPermission.Read @NonNull Uri uri,</span></span></span><br><span class="line"><span class="function"><span class="params">        @Nullable String[] projection, @Nullable String selection,</span></span></span><br><span class="line"><span class="function"><span class="params">        @Nullable String[] selectionArgs, @Nullable String sortOrder,</span></span></span><br><span class="line"><span class="function"><span class="params">        @Nullable CancellationSignal cancellationSignal)</span> </span>&#123;</span><br><span class="line">    Preconditions.checkNotNull(uri, <span class="string">"uri"</span>);</span><br><span class="line">    IContentProvider unstableProvider = acquireUnstableProvider(uri); <span class="comment">// 1</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            qCursor = unstableProvider.query(mPackageName, uri, projection, selection, selectionArgs, sortOrder, remoteCancellationSignal); <span class="comment">// 2</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (DeadObjectException e) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，通过<code>acquireUnstableProvider()</code>返回<code>IContentProvider</code>类型的<code>unstableProvider</code>对象。</p><p>注释2，调用<code>IContentProvider</code>的<code>query()</code>。</p><p>先来看看<code>acquireUnstableProvider()</code>：frameworks/base/core/java/android/content/ContentResolver.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> IContentProvider <span class="title">acquireUnstableProvider</span><span class="params">(Uri uri)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!SCHEME_CONTENT.equals(uri.getScheme())) &#123; <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String auth = uri.getAuthority();</span><br><span class="line">    <span class="keyword">if</span> (auth != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> acquireUnstableProvider(mContext, uri.getAuthority()); <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，检查<code>Uri</code>的<code>scheme</code>是否为<code>&quot;content&quot;</code>，如果不是，就返回<code>null</code>。</p><p>注释2，调用<code>acquireUnstableProvider()</code>，这是一个抽象方法，它的实现在<code>ContentProvider</code>的子类<code>ApplicationContentResolver</code>中：frameworks/base/core/java/android/app/ContextImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> IContentProvider <span class="title">acquireUnstableProvider</span><span class="params">(Context c, String auth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mMainThread.acquireProvider(c, ContentProvider.getAuthorityWithoutUserId(auth), resolveUserIdFromAuthority(auth), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>return</code>了<code>ActivityThread</code>类型的<code>mMainThread</code>的<code>acquireProvider()</code>：frameworks/base/core/java/android/app/ActivityThread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> IContentProvider <span class="title">acquireProvider</span><span class="params">(Context c, String auth, <span class="keyword">int</span> userId, <span class="keyword">boolean</span> stable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> IContentProvider provider = acquireExistingProvider(c, auth, userId, stable); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> (provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> provider;</span><br><span class="line">    &#125;</span><br><span class="line">    IActivityManager.ContentProviderHolder holder = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        holder = ActivityManagerNative.getDefault().getContentProvider(getApplicationThread(), auth, userId, stable); <span class="comment">// 2</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Slog.e(TAG, <span class="string">"Failed to find provider info for "</span> + auth);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    holder = installProvider(c, holder, holder.info, <span class="keyword">true</span> <span class="comment">/*noisy*/</span>, holder.noReleaseNeeded, stable); <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">return</span> holder.provider;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> IContentProvider <span class="title">acquireExistingProvider</span><span class="params">(Context c, String auth, <span class="keyword">int</span> userId, <span class="keyword">boolean</span> stable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mProviderMap) &#123;</span><br><span class="line">        <span class="keyword">final</span> ProviderKey key = <span class="keyword">new</span> ProviderKey(auth, userId);</span><br><span class="line">        <span class="keyword">final</span> ProviderClientRecord pr = mProviderMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (pr == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        IContentProvider provider = pr.mProvider;</span><br><span class="line">        IBinder jBinder = provider.asBinder();</span><br><span class="line">        <span class="keyword">if</span> (!jBinder.isBinderAlive()) &#123;</span><br><span class="line">            ......</span><br><span class="line">            handleUnstableProviderDiedLocked(jBinder, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ProviderRefCount prc = mProviderRefCountMap.get(jBinder);</span><br><span class="line">        <span class="keyword">if</span> (prc != <span class="keyword">null</span>) &#123;</span><br><span class="line">            incProviderRefLocked(prc, stable);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> provider;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，调用<code>acquireExistingProvider()</code>，检查<code>ActivityThread</code>中<code>ArrayMap</code>类型的<code>mProviderMap</code>中是否有目标<code>ContentProvider</code>存在，如果有，就返回，没有，就在注释2处调用AMP的<code>getContentProvider()</code>。</p><p>注释3，<code>installProvider()</code>用来将注释2处返回的<code>ContentProvider</code>相关的数据存储在<code>mProviderMap</code>中，起到缓存的作用，这样使用相同的<code>ContentProvider</code>时，就不再需要每次都调用AMS的<code>getContentProvider()</code>。</p><p>接着查看AMS的<code>getContentProvider()</code>：frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ContentProviderHolder <span class="title">getContentProvider</span><span class="params">(IApplicationThread caller, String name, <span class="keyword">int</span> userId, <span class="keyword">boolean</span> stable)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> getContentProviderImpl(caller, name, <span class="keyword">null</span>, stable, userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getContentProvider()</code>方法<code>return</code>了<code>getContentProviderImpl()</code>：frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ContentProviderHolder <span class="title">getContentProviderImpl</span><span class="params">(IApplicationThread caller, String name, IBinder token, <span class="keyword">boolean</span> stable, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (!providerRunning) &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">// If the provider is not already being launched, then get it</span></span><br><span class="line">            <span class="comment">// started.</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= N) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ......</span><br><span class="line">                    ProcessRecord proc = getProcessRecordLocked(cpi.processName, cpr.appInfo.uid, <span class="keyword">false</span>); <span class="comment">// 1</span></span><br><span class="line">                    <span class="keyword">if</span> (proc != <span class="keyword">null</span> &amp;&amp; proc.thread != <span class="keyword">null</span> &amp;&amp; !proc.killed) &#123;</span><br><span class="line">                        ......</span><br><span class="line">                        <span class="keyword">if</span> (!proc.pubProviders.containsKey(cpi.name)) &#123;</span><br><span class="line">                            checkTime(startTime, <span class="string">"getContentProviderImpl: scheduling install"</span>);</span><br><span class="line">                            proc.pubProviders.put(cpi.name, cpr);</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                proc.thread.scheduleInstallProvider(cpi); <span class="comment">// 2</span></span><br><span class="line">                            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        checkTime(startTime, <span class="string">"getContentProviderImpl: before start process"</span>);</span><br><span class="line">                        proc = startProcessLocked(cpi.processName, cpr.appInfo, <span class="keyword">false</span>, <span class="number">0</span>, <span class="string">"content provider"</span>, <span class="keyword">new</span> ComponentName(cpi.applicationInfo.packageName, cpi.name), <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>); <span class="comment">// 3</span></span><br><span class="line">                        checkTime(startTime, <span class="string">"getContentProviderImpl: after start process"</span>);</span><br><span class="line">                        ......</span><br><span class="line">                    &#125;</span><br><span class="line">                    cpr.launchingApp = proc;</span><br><span class="line">                    mLaunchingProviders.add(cpr);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    Binder.restoreCallingIdentity(origId);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> cpr != <span class="keyword">null</span> ? cpr.newHolder(conn) : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，<code>getProcessRecordLocked()</code>获取目标<code>ContentProvider</code>的应用程序进程信息，这些信息会保存在<code>ProcessRecord</code>类型的<code>proc</code>中。如果该应用程序进程已经启动，就会调用注释2的代码，否则就调用注释3的<code>startProcessLocked()</code>来启动进程。这里假设<code>ContentProvider</code>的应用程序进程还没有启动，应用程序进程的启动过程，详细查看<a href="https://tylerliu.top/2019/09/02/Andorid深入理解四大组件-01%EF%BC%9A应用程序启动过程%EF%BC%88上%EF%BC%89/#more">Andorid深入理解四大组件 01：应用程序启动过程（上）</a>，最终会调用<code>ActivityThread</code>的<code>main()</code>：frameworks/base/core/java/android/app/ActivityThread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    Looper.prepareMainLooper(); <span class="comment">// 1</span></span><br><span class="line">    ActivityThread thread = <span class="keyword">new</span> ActivityThread(); <span class="comment">// 2</span></span><br><span class="line">    thread.attach(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">        Looper.myLooper().setMessageLogging(<span class="keyword">new</span></span><br><span class="line">                LogPrinter(Log.DEBUG, <span class="string">"ActivityThread"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// End of event ActivityThreadMain.</span></span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    Looper.loop();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，在<code>ThreadLocal</code>中获取<code>Looper</code>，并在注释3处开启消息循环。</p><p>注释2，创建<code>ActivityThread</code>，并调用其<code>attach()</code>：frameworks/base/core/java/android/app/ActivityThread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(<span class="keyword">boolean</span> system)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (!system) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">final</span> IActivityManager mgr = ActivityManagerNative.getDefault(); <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mgr.attachApplication(mAppThread);<span class="comment">// 2</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，获取AMS实例。</p><p>注释2，调用AMS的<code>attachApplication()</code>，并将<code>ApplicationThread</code>类型的<code>mAppThread</code>对象传进去。</p><p><code>query()</code>到AMS的调用过程时序图（省略了应用程序进程启动过程）：</p><img src="/2019/09/04/Andorid深入理解四大组件-06：ContentProvider的启动过程/VeHqSK.png"><h1 id="2-AMS启动ContentProvider过程"><a href="#2-AMS启动ContentProvider过程" class="headerlink" title="2. AMS启动ContentProvider过程"></a>2. AMS启动ContentProvider过程</h1><p>接着看AMS的<code>atrachApplication()</code>：frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attachApplication</span><span class="params">(IApplicationThread thread)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> callingPid = Binder.getCallingPid();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">        attachApplicationLocked(thread, callingPid);</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在里面又调用了<code>attachApplicationLocked()</code>：frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span><span class="params">(IApplicationThread thread, <span class="keyword">int</span> pid)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        thread.bindApplication(processName, appInfo, providers, app.instrumentationClass,</span><br><span class="line">                profilerInfo, app.instrumentationArguments, app.instrumentationWatcher,</span><br><span class="line">                app.instrumentationUiAutomationConnection, testMode,</span><br><span class="line">                mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">                isRestrictedBackupMode || !normalMode, app.persistent,</span><br><span class="line">                <span class="keyword">new</span> Configuration(mConfiguration), app.compat,</span><br><span class="line">                getCommonServicesLocked(app.isolated),</span><br><span class="line">                mCoreSettingsObserver.getCoreSettingsLocked());</span><br><span class="line">        updateLruProcessLocked(app, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        app.lastRequestedGc = app.lastLowMemory = SystemClock.uptimeMillis();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在里面调用了<code>thread</code>的<code>bindApplication()</code>，thread是<code>IApplicationThread</code>类型的，该类用于进程间通信，具体实现<code>bindApplication()</code>的是<code>ApplicationThreadProxy</code>类：frameworks/base/core/java/android/app/ApplicationThreadNative.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationThreadProxy</span> <span class="keyword">implements</span> <span class="title">IApplicationThread</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bindApplication</span><span class="params">(String packageName, ApplicationInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">            List&lt;ProviderInfo&gt; providers, ComponentName testName, ProfilerInfo profilerInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">            Bundle testArgs, IInstrumentationWatcher testWatcher,</span></span></span><br><span class="line"><span class="function"><span class="params">            IUiAutomationConnection uiAutomationConnection, <span class="keyword">int</span> debugMode,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> enableBinderTracking, <span class="keyword">boolean</span> trackAllocation, <span class="keyword">boolean</span> restrictedBackupMode,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> persistent, Configuration config, CompatibilityInfo compatInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">            Map&lt;String, IBinder&gt; services, Bundle coreSettings)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        mRemote.transact(BIND_APPLICATION_TRANSACTION, data, <span class="keyword">null</span>, IBinder.FLAG_ONEWAY);</span><br><span class="line">        data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到目前为止，上面的代码都还是在AMS进程中执行的，因此，需要通过<code>IBinder</code>类型的<code>mRemote</code>对象向新创建的应用程序进程（目标<code>ContentProvider</code>所在的进程）发送<code>BIND_APPLICATION_TRSANSACTION</code>类型的通信请求。处理这个通信请求的是在新创建的应用程序进程中执行的<code>ApplicationThread</code>的<code>bindApplication()</code>：frameworks/base/core/java/android/app/ActivityThread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bindApplication</span><span class="params">(String processName, ApplicationInfo appInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">        List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName,</span></span></span><br><span class="line"><span class="function"><span class="params">        ProfilerInfo profilerInfo, Bundle instrumentationArgs,</span></span></span><br><span class="line"><span class="function"><span class="params">        IInstrumentationWatcher instrumentationWatcher,</span></span></span><br><span class="line"><span class="function"><span class="params">        IUiAutomationConnection instrumentationUiConnection, <span class="keyword">int</span> debugMode,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> enableBinderTracking, <span class="keyword">boolean</span> trackAllocation,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> isRestrictedBackupMode, <span class="keyword">boolean</span> persistent, Configuration config,</span></span></span><br><span class="line"><span class="function"><span class="params">        CompatibilityInfo compatInfo, Map&lt;String, IBinder&gt; services, Bundle coreSettings)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    sendMessage(H.BIND_APPLICATION, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在最后调用<code>sendMessage()</code>向<code>H</code>发送<code>BIND_APPLICATION</code>类型的消息：frameworks/base/core/java/android/app/ActivityThread.H.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> BIND_APPLICATION:</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"bindApplication"</span>);</span><br><span class="line">    AppBindData data = (AppBindData)msg.obj;</span><br><span class="line">    handleBindApplication(data);</span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>再来看看<code>handleBindApplicaiton()</code>：frameworks/base/core/java/android/app/ActivityThread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleBindApplication</span><span class="params">(AppBindData data)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">final</span> ContextImpl appContext = ContextImpl.createAppContext(<span class="keyword">this</span>, data.info); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> ClassLoader cl = instrContext.getClassLoader();</span><br><span class="line">        mInstrumentation = (Instrumentation)cl.loadClass(data.instrumentationName.getClassName()).newInstance(); <span class="comment">// 2</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> ComponentName component = <span class="keyword">new</span> ComponentName(ii.packageName, ii.name);</span><br><span class="line">    mInstrumentation.init(<span class="keyword">this</span>, instrContext, appContext, component, data.instrumentationWatcher, data.instrumentationUiAutomationConnection); <span class="comment">// 3</span></span><br><span class="line">    ......</span><br><span class="line">    Application app = data.info.makeApplication(data.restrictedBackupMode, <span class="keyword">null</span>); <span class="comment">// 4</span></span><br><span class="line">    mInitialApplication = app;</span><br><span class="line">    <span class="keyword">if</span> (!data.restrictedBackupMode) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ArrayUtils.isEmpty(data.providers)) &#123;</span><br><span class="line">            installContentProviders(app, data.providers); <span class="comment">// 5</span></span><br><span class="line">            mH.sendEmptyMessageDelayed(H.ENABLE_JIT, <span class="number">10</span>*<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    mInstrumentation.callApplicationOnCreate(app); <span class="comment">// 6</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，创建<code>ContextImpl</code>。</p><p>注释2，通过反射创建<code>Instrumentation</code>，并在注释3对其进行初始化。</p><p>注释4，创建<code>Application</code>，并在注释6调用<code>Application</code>的<code>onCreate()</code>，这意味着<code>ContentProvider</code>所在的应用程序进程已经启动完毕。</p><p>在这之前，注释5调用<code>installContentProviders()</code>来启动<code>ContentProvider</code>：frameworks/base/core/java/android/app/ActivityThread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installContentProviders</span><span class="params">(Context context, List&lt;ProviderInfo&gt; providers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;IActivityManager.ContentProviderHolder&gt; results = <span class="keyword">new</span> ArrayList&lt;IActivityManager.ContentProviderHolder&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ProviderInfo cpi : providers) &#123; <span class="comment">// 1</span></span><br><span class="line">        ......</span><br><span class="line">        IActivityManager.ContentProviderHolder cph = installProvider(context, <span class="keyword">null</span>, cpi, <span class="keyword">false</span> <span class="comment">/*noisy*/</span>, <span class="keyword">true</span> <span class="comment">/*noReleaseNeeded*/</span>, <span class="keyword">true</span> <span class="comment">/*stable*/</span>); <span class="comment">// 2</span></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ActivityManagerNative.getDefault().publishContentProviders(getApplicationThread(), results); <span class="comment">// 3</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，遍历当前应用程序进程的<code>ProviderInfo</code>列表，得到每个<code>ContentProvider</code>的<code>ProviderInfo</code>（存储<code>ContentProvider</code>的信息），并在注释2调用<code>installProvider()</code>来启动这些<code>ContentProvider</code>。</p><p>注释3，通过AMS的<code>publishContentProviders()</code>将这些<code>ContentProvider</code>存储在AMS的<code>mProviderMap</code>，这个<code>mProviderMap</code>能起到缓存作用。</p><p>再来看看<code>installProvider()</code>是如何启动<code>ContentProvdier</code>的：frameworks/base/core/java/android/app/ActivityThread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> IActivityManager.<span class="function">ContentProviderHolder <span class="title">installProvider</span><span class="params">(Context context, IActivityManager.ContentProviderHolder holder, ProviderInfo info, <span class="keyword">boolean</span> noisy, <span class="keyword">boolean</span> noReleaseNeeded, <span class="keyword">boolean</span> stable)</span> </span>&#123;</span><br><span class="line">    ContentProvider localProvider = <span class="keyword">null</span>;</span><br><span class="line">    IContentProvider provider;</span><br><span class="line">    <span class="keyword">if</span> (holder == <span class="keyword">null</span> || holder.provider == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> java.lang.ClassLoader cl = c.getClassLoader();</span><br><span class="line">            localProvider = (ContentProvider)cl.loadClass(info.name).newInstance(); <span class="comment">// 1</span></span><br><span class="line">            provider = localProvider.getIContentProvider();</span><br><span class="line">            <span class="keyword">if</span> (provider == <span class="keyword">null</span>) &#123;</span><br><span class="line">                ......</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">            localProvider.attachInfo(c, info);  <span class="comment">// 2</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.lang.Exception e) &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> retHolder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，通过反射创建<code>ContentProvider</code>类型的对象<code>localProvider</code>，并在注释2调用它的<code>attachInfo()</code>：frameworks/base/core/java/android/content/ContentProvider.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attachInfo</span><span class="params">(Context context, ProviderInfo info, <span class="keyword">boolean</span> testing)</span> </span>&#123;</span><br><span class="line">    mNoPerms = testing;</span><br><span class="line">    <span class="keyword">if</span> (mContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mContext = context;</span><br><span class="line">        <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mTransport.mAppOpsManager = (AppOpsManager) context.getSystemService(Context.APP_OPS_SERVICE);</span><br><span class="line">        &#125;</span><br><span class="line">        mMyUid = Process.myUid();</span><br><span class="line">        <span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;</span><br><span class="line">            setReadPermission(info.readPermission);</span><br><span class="line">            setWritePermission(info.writePermission);</span><br><span class="line">            setPathPermissions(info.pathPermissions);</span><br><span class="line">            mExported = info.exported;</span><br><span class="line">            mSingleUser = (info.flags &amp; ProviderInfo.FLAG_SINGLE_USER) != <span class="number">0</span>;</span><br><span class="line">            setAuthorities(info.authority);</span><br><span class="line">        &#125;</span><br><span class="line">        ContentProvider.<span class="keyword">this</span>.onCreate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在最后调用了<code>onCreate()</code>，它是一个抽象方法。这样<code>ContentProvider</code>就启动完成了。</p><p>AMS启动<code>ContentProvider</code>时序图：</p><img src="/2019/09/04/Andorid深入理解四大组件-06：ContentProvider的启动过程/VeHHW6.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-query方法到AMS的调用&quot;&gt;&lt;a href=&quot;#1-query方法到AMS的调用&quot; class=&quot;headerlink&quot; title=&quot;1. query方法到AMS的调用&quot;&gt;&lt;/a&gt;1. query方法到AMS的调用&lt;/h1&gt;&lt;p&gt;下面是一个常规&lt;code
      
    
    </summary>
    
      <category term="Android进阶" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
      <category term="框架层" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/"/>
    
      <category term="深入理解四大组件" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/"/>
    
    
      <category term="四大组件" scheme="https://tylerLiu.top/tags/%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Andorid深入理解四大组件 05：广播的注册、发送和接收</title>
    <link href="https://tylerLiu.top/2019/09/03/Andorid%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6-05%EF%BC%9A%E5%B9%BF%E6%92%AD%E7%9A%84%E6%B3%A8%E5%86%8C%E3%80%81%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6/"/>
    <id>https://tylerLiu.top/2019/09/03/Andorid深入理解四大组件-05：广播的注册、发送和接收/</id>
    <published>2019-09-03T07:02:24.000Z</published>
    <updated>2019-09-11T08:03:22.745Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-广播的注册"><a href="#1-广播的注册" class="headerlink" title="1. 广播的注册"></a>1. 广播的注册</h1><p>BroadcastReceiver的注册分为两种，静态注册和动添注册。静态注册在应用安装时由<code>PackageManagerService</code>来完成注册，这个会在后续介绍<code>PackageManagerService</code>中详细介绍。本文重点介绍动态注册。调用其<code>registerReceiver()</code>，它的实现在<code>ContextWrapper</code>中：frameworks/base/core/java/android/content/ContextWrapper.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">registerReceiver</span><span class="params">(BroadcastReceiver receiver, IntentFilter filter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mBase.registerReceiver(receiver, filter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>mBase</code>指向的是<code>ComtextImpl</code>，已经在<a href="https://tylerliu.top/2019/09/03/Andorid深入理解四大组件-03%EF%BC%9AService的启动过程/#more">Andorid深入理解四大组件 03：Service的启动过程</a>说过。<code>ContextImpl</code>的<code>registerReceiver()</code>由很多重载，最终都会调用<code>registerReceiverInternal()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Intent <span class="title">registerReceiverInternal</span><span class="params">(BroadcastReceiver receiver, <span class="keyword">int</span> userId, IntentFilter filter, String broadcastPermission, Handler scheduler, Context context)</span> </span>&#123;</span><br><span class="line">    IIntentReceiver rd = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (receiver != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mPackageInfo != <span class="keyword">null</span> &amp;&amp; context != <span class="keyword">null</span>) &#123; <span class="comment">// 1</span></span><br><span class="line">            <span class="keyword">if</span> (scheduler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                scheduler = mMainThread.getHandler();</span><br><span class="line">            &#125;</span><br><span class="line">            rd = mPackageInfo.getReceiverDispatcher(</span><br><span class="line">                receiver, context, scheduler,</span><br><span class="line">                mMainThread.getInstrumentation(), <span class="keyword">true</span>); <span class="comment">// 2</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (scheduler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                scheduler = mMainThread.getHandler();</span><br><span class="line">            &#125;</span><br><span class="line">            rd = <span class="keyword">new</span> LoadedApk.ReceiverDispatcher(receiver, context, scheduler, <span class="keyword">null</span>, <span class="keyword">true</span>).getIIntentReceiver(); <span class="comment">// 3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Intent intent = ActivityManagerNative.getDefault().registerReceiver(mMainThread.getApplicationThread(), mBasePackageName, rd, filter, broadcastPermission, userId); <span class="comment">// 4</span></span><br><span class="line">        <span class="keyword">if</span> (intent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            intent.setExtrasClassLoader(getClassLoader());</span><br><span class="line">            intent.prepareToEnterProcess();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intent;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，判断如果<code>LoadedApk</code>类型的<code>mPackageInfo</code>不为<code>null</code>且<code>context</code>不为<code>null</code>，就调用注释2的代码，通过<code>mPackageInfo</code>的<code>getReceiverDispatcher()</code>获取<code>rd</code>对象，否则就调用注释3的代码来创建<code>rd</code>对象。注释2和注释3的目的都是要获取<code>IIntentReceiver</code>类型的对象<code>rd</code>，<code>IIntentReceiver</code>是一个<code>Binder</code>接口，用于进行跨进程的通信。它的具体实现在<code>LoadedApk.ReceiverDispatcher.InnerReceiver</code>：frameworks/base/core/java/android/app/LoadedApk.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiverDispatcher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerReceiver</span> <span class="keyword">extends</span> <span class="title">IIntentReceiver</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> WeakReference&lt;LoadedApk.ReceiverDispatcher&gt; mDispatcher;</span><br><span class="line">        <span class="keyword">final</span> LoadedApk.ReceiverDispatcher mStrongRef;</span><br><span class="line">        InnerReceiver(LoadedApk.ReceiverDispatcher rd, <span class="keyword">boolean</span> strong) &#123;</span><br><span class="line">            mDispatcher = <span class="keyword">new</span> WeakReference&lt;LoadedApk.ReceiverDispatcher&gt;(rd);</span><br><span class="line">            mStrongRef = strong ? rd : <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到<code>registerReceiverInternal()</code>，在注释4调用了<code>ActivityManagerProxy</code>（AMP）的<code>registerReceiver()</code>，实际上就是调用AMS的<code>registerReceiver()</code>，并将<code>rd</code>传进去：frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">registerReceiver</span><span class="params">(IApplicationThread caller, String callerPackage, IIntentReceiver receiver, IntentFilter filter, String permission, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">        Iterator&lt;String&gt; actions = filter.actionsIterator(); <span class="comment">// 1</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// Collect stickies of users</span></span><br><span class="line">        <span class="keyword">int</span>[] userIds = &#123; UserHandle.USER_ALL, UserHandle.getUserId(callingUid) &#125;;</span><br><span class="line">        <span class="keyword">while</span> (actions.hasNext()) &#123;</span><br><span class="line">            String action = actions.next();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> id : userIds) &#123;</span><br><span class="line">                ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt; stickies = mStickyBroadcasts.get(id);</span><br><span class="line">                <span class="keyword">if</span> (stickies != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    ArrayList&lt;Intent&gt; intents = stickies.get(action);</span><br><span class="line">                    <span class="keyword">if</span> (intents != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (stickyIntents == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            stickyIntents = <span class="keyword">new</span> ArrayList&lt;Intent&gt;();</span><br><span class="line">                        &#125;</span><br><span class="line">                        stickyIntents.addAll(intents); <span class="comment">// 2</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;Intent&gt; allSticky = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (stickyIntents != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> ContentResolver resolver = mContext.getContentResolver();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, N = stickyIntents.size(); i &lt; N; i++) &#123;</span><br><span class="line">            Intent intent = stickyIntents.get(i);</span><br><span class="line">            <span class="keyword">if</span> (filter.match(resolver, intent, <span class="keyword">true</span>, TAG) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (allSticky == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    allSticky = <span class="keyword">new</span> ArrayList&lt;Intent&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">                allSticky.add(intent); <span class="comment">// 3</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">        ReceiverList rl = mRegisteredReceivers.get(receiver.asBinder()); <span class="comment">// 4</span></span><br><span class="line">        <span class="keyword">if</span> (rl == <span class="keyword">null</span>) &#123;</span><br><span class="line">            rl = <span class="keyword">new</span> ReceiverList(<span class="keyword">this</span>, callerApp, callingPid, callingUid, userId, receiver); <span class="comment">// 5</span></span><br><span class="line">            <span class="keyword">if</span> (rl.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">                rl.app.receivers.add(rl);</span><br><span class="line">            &#125; </span><br><span class="line">            ......</span><br><span class="line">        &#125; </span><br><span class="line">        ......</span><br><span class="line">        BroadcastFilter bf = <span class="keyword">new</span> BroadcastFilter(filter, rl, callerPackage, permission, callingUid, userId); <span class="comment">// 6</span></span><br><span class="line">        rl.add(bf); <span class="comment">// 7</span></span><br><span class="line">        <span class="keyword">if</span> (!bf.debugCheck()) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"==&gt; For Dynamic broadcast"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mReceiverResolver.addFilter(bf); <span class="comment">// 8</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> sticky;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，根据传入的<code>IntentFilter</code>类型的<code>filter</code>得到<code>actions</code>列表，根据<code>actions</code>列表和<code>userIds</code>（<code>userId</code>可以理解为应用程序的<code>uid</code>）得到所有的粘性广播的<code>intent</code>，并在注释2传到<code>stickyIntents</code>中。</p><p>注释3，将这些粘性广播的<code>intent</code>传入到<code>allSticky</code>列表中，从这里可以看出粘性广播是存储在AMS中。</p><p>注释4，获取<code>ReceiverList</code>列表，如果为空，则在注释5处创建，<code>ReceiverList</code>继承自<code>ArrayList</code>，用来存储广播接收者。</p><p>注释6，创建<code>BroadcastFilter</code>，并传入此前创建的<code>ReceiverList</code>，<code>BroadcastFilter</code>用来描述注册的广播接收者，并在注释7通过<code>add()</code>添加将自身添加到<code>ReceiverList</code>中。</p><p>注释8，将<code>BroadcastFilter</code>添加到<code>mReceiverResolver</code>中，这样当AMS接收到广播时就可以从<code>mReceiverResolver</code>中获取相应的广播接收者了。</p><p>广播注册过程时序图：</p><img src="/2019/09/03/Andorid深入理解四大组件-05：广播的注册、发送和接收/VeA1Ds.png"><h1 id="2-广播的发送和接收"><a href="#2-广播的发送和接收" class="headerlink" title="2. 广播的发送和接收"></a>2. 广播的发送和接收</h1><h2 id="2-1-ContextImpl到AMS的调用过程"><a href="#2-1-ContextImpl到AMS的调用过程" class="headerlink" title="2.1 ContextImpl到AMS的调用过程"></a>2.1 ContextImpl到AMS的调用过程</h2><p>广播可以发送多种类型，包括无序广播（普通广播）、有序广播和粘性广播，这里以无序广播为例。</p><p>要发送无序广播，要调用<code>sendBroadcast()</code>，它的实现同样在<code>ContextWrapper</code>中：frameworks/base/core/java/android/content/ContextWrapper.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendBroadcast</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">     mBase.sendBroadcast(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看看<code>ContextImpl</code>中的<code>sendBroadcast()</code>：frameworks/base/core/java/android/app/ContextImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendBroadcast</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        intent.prepareToLeaveProcess(<span class="keyword">this</span>);</span><br><span class="line">        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, <span class="keyword">null</span>, Activity.RESULT_OK, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, AppOpsManager.OP_NONE, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, getUserId()); <span class="comment">// 1</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，之前已经介绍过，最终会调用AMS的<code>broadcastIntent()</code>：frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">broadcastIntent</span><span class="params">(IApplicationThread caller,</span></span></span><br><span class="line"><span class="function"><span class="params">        Intent intent, String resolvedType, IIntentReceiver resultTo,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> resultCode, String resultData, Bundle resultExtras,</span></span></span><br><span class="line"><span class="function"><span class="params">        String[] requiredPermissions, <span class="keyword">int</span> appOp, Bundle bOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> serialized, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">"broadcastIntent"</span>);</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        intent = verifyBroadcastLocked(intent); <span class="comment">// 1</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">int</span> res = broadcastIntentLocked(callerApp,</span><br><span class="line">                callerApp != <span class="keyword">null</span> ? callerApp.info.packageName : <span class="keyword">null</span>,</span><br><span class="line">                intent, resolvedType, resultTo, resultCode, resultData, resultExtras,</span><br><span class="line">                requiredPermissions, appOp, bOptions, serialized, sticky,</span><br><span class="line">                callingPid, callingUid, userId);</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，调用了<code>verifyBroadcastLocked()</code>：frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Intent <span class="title">verifyBroadcastLocked</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (intent != <span class="keyword">null</span> &amp;&amp; intent.hasFileDescriptors() == <span class="keyword">true</span>) &#123; <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"File descriptors passed in Intent"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> flags = intent.getFlags(); <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">if</span> (!mProcessesReady) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((flags&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT) != <span class="number">0</span>) &#123; <span class="comment">// 3</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((flags&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY) == <span class="number">0</span>) &#123; <span class="comment">// 4</span></span><br><span class="line">            Slog.e(TAG, <span class="string">"Attempt to launch receivers of broadcast intent "</span> + intent + <span class="string">" before boot completion"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot broadcast before boot completed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((flags&amp;Intent.FLAG_RECEIVER_BOOT_UPGRADE) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Can't use FLAG_RECEIVER_BOOT_UPGRADE here"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>verifyBroadcasstLocked()</code>主要是验证广播是否合法。</p><p>注释1，验证<code>intent</code>是否不为<code>null</code>，且有文件描述符。</p><p>注释2，获得<code>intent</code>的<code>flag</code>。</p><p>注释3，如果系统正在启动过程中，判断<code>flag</code>是否设置为<code>FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT</code>（启动检查时只接受动态广播注册的广播接收者），则不做处理；如果不是，则在注释4判断<code>flag</code>是否设置为<code>FLAG_RECEIVER_REGISTERED_ONLY</code>，如果没有，则抛出异常。</p><p>再回到<code>broadcastIntent()</code>，在里面的注释2处调用了<code>broadcastIntentLocked()</code>：frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">broadcastIntentLocked</span><span class="params">(ProcessRecord callerApp,</span></span></span><br><span class="line"><span class="function"><span class="params">        String callerPackage, Intent intent, String resolvedType,</span></span></span><br><span class="line"><span class="function"><span class="params">        IIntentReceiver resultTo, <span class="keyword">int</span> resultCode, String resultData,</span></span></span><br><span class="line"><span class="function"><span class="params">        Bundle resultExtras, String[] requiredPermissions, <span class="keyword">int</span> appOp, Bundle bOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> callingPid, <span class="keyword">int</span> callingUid, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> ((receivers != <span class="keyword">null</span> &amp;&amp; receivers.size() &gt; <span class="number">0</span>) || resultTo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        BroadcastQueue queue = broadcastQueueForIntent(intent);</span><br><span class="line">        <span class="comment">// 1</span></span><br><span class="line">        BroadcastRecord r = <span class="keyword">new</span> BroadcastRecord(queue, intent, callerApp,</span><br><span class="line">                callerPackage, callingPid, callingUid, resolvedType,</span><br><span class="line">                requiredPermissions, appOp, brOptions, receivers, resultTo, resultCode,</span><br><span class="line">                resultData, resultExtras, ordered, sticky, <span class="keyword">false</span>, userId);</span><br><span class="line">        ......               </span><br><span class="line">        <span class="keyword">boolean</span> replaced = replacePending &amp;&amp; queue.replaceOrderedBroadcastLocked(r);</span><br><span class="line">        <span class="keyword">if</span> (!replaced) &#123;</span><br><span class="line">            queue.enqueueOrderedBroadcastLocked(r);</span><br><span class="line">            queue.scheduleBroadcastsLocked(); <span class="comment">// 2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> ActivityManager.BROADCAST_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里省略了很多代码，前面的工作主要是将动添注册的广播接收者和静态注册的广播接收者按照优先级高低存储在不同的列表中，再将这两个列表合并到<code>receivers</code>列表中，这样<code>receivers</code>列表中就包含了所有的广播接收者（有序广播和无序广播）。</p><p>注释1，创建<code>BroadcastRecord</code>对象，并将<code>receivers</code>传入。</p><p>注释2，调用<code>BroadcastQueue</code>的<code>scheduleBroadcastsLocked()</code>。</p><p>这里先给出<code>ContextImpl</code>到AMS的调用过程时序图：</p><img src="/2019/09/03/Andorid深入理解四大组件-05：广播的注册、发送和接收/VeA3bn.png"><h2 id="2-2-AMS到BroadReceiver的调用过程"><a href="#2-2-AMS到BroadReceiver的调用过程" class="headerlink" title="2.2 AMS到BroadReceiver的调用过程"></a>2.2 AMS到BroadReceiver的调用过程</h2><p><code>BroadcastQueue</code>的<code>scheduleBroadcastsLocked()</code>：<br>frameworks/base/services/core/java/com/android/server/am/BroadcastQueue.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleBroadcastsLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   ......</span><br><span class="line">    <span class="keyword">if</span> (mBroadcastsScheduled) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, <span class="keyword">this</span>)); <span class="comment">// 1</span></span><br><span class="line">    mBroadcastsScheduled = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，向<code>BroadcastHandler</code>类型的<code>mHandler</code>对象发送<code>BROADCAST_INTENT_MSG</code>消息，该消息在<code>BroadcastHandler</code>中的处理：frameworks/base/services/core/java/com/android/server/am/BroadcastQueue.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> BROADCAST_INTENT_MSG: &#123;</span><br><span class="line">    ......</span><br><span class="line">    processNextBroadcast(<span class="keyword">true</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>调用了<code>processNextBroadcast()</code>，该方法对无序广播和有序广播分别进行了处理：frameworks/base/services/core/java/com/android/server/am/BroadcastQueue.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">processNextBroadcast</span><span class="params">(<span class="keyword">boolean</span> fromMsg)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (fromMsg) &#123;</span><br><span class="line">        mBroadcastsScheduled = <span class="keyword">false</span>; <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// First, deliver any non-serialized broadcasts right away.</span></span><br><span class="line">    <span class="keyword">while</span> (mParallelBroadcasts.size() &gt; <span class="number">0</span>) &#123; <span class="comment">// 2</span></span><br><span class="line">        r = mParallelBroadcasts.remove(<span class="number">0</span>); <span class="comment">// 3</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">          Object target = r.receivers.get(i);</span><br><span class="line">          ......</span><br><span class="line">          deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, <span class="keyword">false</span>, i); <span class="comment">// 4</span></span><br><span class="line">        &#125;</span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面传入的值得知，<code>fromMsg</code>为<code>true</code>。</p><p>注释1，将<code>mBroadcastsScheduled</code>设置为<code>false</code>，表示对此前发来的<code>BROADCAST_INTENT_MSG</code>类型的消息已经做了处理。</p><p>注释2，<code>mParalleBroadcasts</code>用来存储无序广播，通过<code>while()</code>循环将<code>mParalleBroadcasts</code>列表中的无序广播发送给对应的广播接收者。</p><p>注释3，获取每一个<code>mParalleBroadcasts</code>列表中存储的<code>BroadcastsRecord</code>类型的<code>r</code>对象。</p><p>注释4，将这些<code>r</code>对象描述的广播发送给对应的广播接收者。<code>deliverToRegisteredReceiverLocked</code>：frameworks/base/services/core/java/com/android/server/am/BroadcastQueue.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deliverToRegisteredReceiverLocked</span><span class="params">(BroadcastRecord r, BroadcastFilter filter, <span class="keyword">boolean</span> ordered, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (filter.receiverList.app != <span class="keyword">null</span> &amp;&amp; filter.receiverList.app.inFullBackup) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ordered) &#123;</span><br><span class="line">                skipReceiverLocked(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            performReceiveLocked(filter.receiverList.app, filter.receiverList.receiver, <span class="keyword">new</span> Intent(r.intent), r.resultCode, r.resultData, r.resultExtras, r.ordered, r.initialSticky, r.userId); <span class="comment">// 1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ordered) &#123;</span><br><span class="line">            r.state = BroadcastRecord.CALL_DONE_RECEIVE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>try</code>前面省略了很多代码，这些代码是用来检查广播发送者和广播接收者的权限。如果通过了权限检查，就会调用注释1的<code>performReceiveLocked()</code>：frameworks/base/services/core/java/com/android/server/am/BroadcastQueue.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">performReceiveLocked</span><span class="params">(ProcessRecord app, IIntentReceiver receiver, Intent intent, <span class="keyword">int</span> resultCode, String data, Bundle extras, <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> sendingUser)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (app != <span class="keyword">null</span>) &#123; <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">if</span> (app.thread != <span class="keyword">null</span>) &#123; <span class="comment">// 2</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode, data, extras, ordered, sticky, sendingUser, app.repProcState); <span class="comment">// 3</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemoteException(<span class="string">"app.thread must not be null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        receiver.performReceive(intent, resultCode, data, extras, ordered, sticky, sendingUser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1和2表示如果广播接收者所在的应用程序进程存在并且正在运行，则执行注释3，表示用广播接收者所在的应用程序进程来接收广播，这里<code>app.thread</code>指的是<code>ApplicationThread</code>，再来查看<code>ApplicationThread</code>的``scheduleRegisteredReceiver()`：frameworks/base/core/java/android/app/ActivityThread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleRegisteredReceiver</span><span class="params">(IIntentReceiver receiver, Intent intent, <span class="keyword">int</span> resultCode, String dataStr, Bundle extras, <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> sendingUser, <span class="keyword">int</span> processState)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    updateProcessState(processState, <span class="keyword">false</span>);</span><br><span class="line">    receiver.performReceive(intent, resultCode, dataStr, extras, ordered, sticky, sendingUser); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，调用了<code>IIntentReceiver</code>类型的对象<code>receiver</code>的<code>performReceiver()</code>，这里实现<code>receiver</code>的类为<code>LoadedApk.ReceiverDispatcher.InnerReceiver</code>：frameworks/base/core/java/android/app/LoadedApk.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadedApk</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiverDispatcher</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerReceiver</span> <span class="keyword">extends</span> <span class="title">IIntentReceiver</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> WeakReference&lt;LoadedApk.ReceiverDispatcher&gt; mDispatcher;</span><br><span class="line">            <span class="keyword">final</span> LoadedApk.ReceiverDispatcher mStrongRef;</span><br><span class="line">            InnerReceiver(LoadedApk.ReceiverDispatcher rd, <span class="keyword">boolean</span> strong) &#123;</span><br><span class="line">                mDispatcher = <span class="keyword">new</span> WeakReference&lt;LoadedApk.ReceiverDispatcher&gt;(rd);</span><br><span class="line">                mStrongRef = strong ? rd : <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performReceive</span><span class="params">(Intent intent, <span class="keyword">int</span> resultCode, String data,</span></span></span><br><span class="line"><span class="function"><span class="params">                    Bundle extras, <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> sendingUser)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">final</span> LoadedApk.ReceiverDispatcher rd;</span><br><span class="line">                ......</span><br><span class="line">                <span class="keyword">if</span> (rd != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    rd.performReceive(intent, resultCode, data, extras, ordered, sticky, sendingUser); <span class="comment">// 1</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ......</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，调用了<code>ReceiverDispatcher</code>类型的<code>rd</code>对象的<code>performReceiver()</code>：frameworks/base/core/java/android/app/LoadedApk.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performReceive</span><span class="params">(Intent intent, <span class="keyword">int</span> resultCode, String data, Bundle extras, <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> sendingUser)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Args args = <span class="keyword">new</span> Args(intent, resultCode, data, extras, ordered, sticky, sendingUser); <span class="comment">// 1</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (intent == <span class="keyword">null</span> || !mActivityThread.post(args)) &#123; <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">if</span> (mRegistered &amp;&amp; ordered) &#123;</span><br><span class="line">            IActivityManager mgr = ActivityManagerNative.getDefault();</span><br><span class="line">            <span class="keyword">if</span> (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG, <span class="string">"Finishing sync broadcast to "</span> + mReceiver);</span><br><span class="line">            args.sendFinished(mgr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，将广播的<code>intent</code>等信息封装为<code>Args</code>对象，并在注释2调用<code>mActivityThread</code>的<code>post()</code>传入<code>Ages</code>对象。这里的<code>mAcvitiyThread</code>是<code>Handler</code>类型，具体的指向就是<code>H</code>。</p><p>注释2，将<code>Args</code>对象通过<code>H</code>发送到主线程的消息队列中，<code>Args</code>继承了<code>Runnable</code>，这个消息最终会在<code>Args</code>重写的<code>run()</code>中执行：frameworks/base/core/java/android/app/LoadedApk.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Args</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span>.<span class="title">PendingResult</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ClassLoader cl =  mReceiver.getClass().getClassLoader();</span><br><span class="line">            intent.setExtrasClassLoader(cl);</span><br><span class="line">            intent.prepareToEnterProcess();</span><br><span class="line">            setExtrasClassLoader(cl);</span><br><span class="line">            receiver.setPendingResult(<span class="keyword">this</span>);</span><br><span class="line">            receiver.onReceive(mContext, intent); <span class="comment">// 1</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，执广播接收者的<code>onReceive()</code>，这样注册的广播jjie接收者就能接收广播并得到<code>intent</code>。</p><p>剩余部分的时序图：</p><img src="/2019/09/03/Andorid深入理解四大组件-05：广播的注册、发送和接收/VeAGEq.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-广播的注册&quot;&gt;&lt;a href=&quot;#1-广播的注册&quot; class=&quot;headerlink&quot; title=&quot;1. 广播的注册&quot;&gt;&lt;/a&gt;1. 广播的注册&lt;/h1&gt;&lt;p&gt;BroadcastReceiver的注册分为两种，静态注册和动添注册。静态注册在应用安装时由&lt;c
      
    
    </summary>
    
      <category term="Android进阶" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
      <category term="框架层" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/"/>
    
      <category term="深入理解四大组件" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/"/>
    
    
      <category term="四大组件" scheme="https://tylerLiu.top/tags/%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Andorid深入理解四大组件 04：Service的绑定过程</title>
    <link href="https://tylerLiu.top/2019/09/03/Andorid%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6-04%EF%BC%9AService%E7%9A%84%E7%BB%91%E5%AE%9A%E8%BF%87%E7%A8%8B/"/>
    <id>https://tylerLiu.top/2019/09/03/Andorid深入理解四大组件-04：Service的绑定过程/</id>
    <published>2019-09-03T02:56:45.000Z</published>
    <updated>2019-09-11T08:03:20.933Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>可以通过<code>Context</code>的<code>startService()</code>来绑定Service，也可以通过<code>Context</code>的<code>bindService</code>来绑定Service。</p><h1 id="1-ContextImpl到ActivityManagerService的调用过程"><a href="#1-ContextImpl到ActivityManagerService的调用过程" class="headerlink" title="1. ContextImpl到ActivityManagerService的调用过程"></a>1. ContextImpl到ActivityManagerService的调用过程</h1><p>可以用<code>bindService()</code>来绑定Service，它的实现在<code>ContextWrapper</code>中：<br>frameworks/base/core/java/android/content/ContextWrapper.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">bindService</span><span class="params">(Intent service, ServiceConnection conn, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mBase.bindService(service, conn, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>mBase</code>具体指向就是<code>ContextImpl</code>，在<a href="https://tylerliu.top/2019/09/03/Andorid深入理解四大组件-03%EF%BC%9AService的启动过程/#more">Andorid深入理解四大组件 03：Service的启动过程</a>中已经讲解过。下面看看<code>ContextImpl</code>的<code>bindService()</code>：frameworks/base/core/java/android/app/ContextImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">bindService</span><span class="params">(Intent service, ServiceConnection conn, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    <span class="keyword">return</span> bindServiceCommon(service, conn, flags, mMainThread.getHandler(), Process.myUserHandle());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在里面<code>return bindServiceCommon()</code>：frameworks/base/core/java/android/app/ContextImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">bindServiceCommon</span><span class="params">(Intent service, ServiceConnection conn, <span class="keyword">int</span> flags, Handler handler, UserHandle user)</span> </span>&#123;</span><br><span class="line">    IServiceConnection sd;</span><br><span class="line">    <span class="keyword">if</span> (conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"connection is null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mPackageInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), handler, flags); <span class="comment">// 1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Not supported in system context"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    validateServiceIntent(service);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        IBinder token = getActivityToken();</span><br><span class="line">        <span class="keyword">if</span> (token == <span class="keyword">null</span> &amp;&amp; (flags&amp;BIND_AUTO_CREATE) == <span class="number">0</span> &amp;&amp; mPackageInfo != <span class="keyword">null</span> &amp;&amp; mPackageInfo.getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123;</span><br><span class="line">            flags |= BIND_WAIVE_PRIORITY;</span><br><span class="line">        &#125;</span><br><span class="line">        service.prepareToLeaveProcess(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">int</span> res = ActivityManagerNative.getDefault().bindService(mMainThread.getApplicationThread(), getActivityToken(), service, service.resolveTypeIfNeeded(getContentResolver()), sd, flags, getOpPackageName(), user.getIdentifier());</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Not allowed to bind to service "</span> + service);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res != <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，调用<code>LoadedApk</code>类型的对象<code>mPackageInfo</code>的<code>getServiceDispatcher()</code>，将<code>ServiceConnection</code>封装为<code>IServiceConnection</code>类型的对象<code>sd</code>，<code>IServiceConnection</code>实现了Binder机制，这样Service的绑定就支持跨进程。</p><p>注释2，调用ASM的<code>bindService()</code>绑定。</p><p><code>ContextImpl</code>到<code>ActivityManagerService</code>调用过程时序图：</p><img src="/2019/09/03/Andorid深入理解四大组件-04：Service的绑定过程/VeAp9O.png"><h1 id="2-Service的绑定"><a href="#2-Service的绑定" class="headerlink" title="2. Service的绑定"></a>2. Service的绑定</h1><p>AMS的<code>bindService()</code>：frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bindService</span><span class="params">(IApplicationThread caller, IBinder token, Intent service, String resolvedType, IServiceConnection connection, <span class="keyword">int</span> flags, String callingPackage, <span class="keyword">int</span> userId)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">"bindService"</span>);</span><br><span class="line">    <span class="keyword">if</span> (service != <span class="keyword">null</span> &amp;&amp; service.hasFileDescriptors() == <span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"File descriptors passed in Intent"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (callingPackage == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"callingPackage cannot be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mServices.bindServiceLocked(caller, token, service, resolvedType, connection, flags, callingPackage, userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>bindService()</code>最后会调用<code>ActiveServices</code>类型对象<code>mServices</code>的<code>bindServiceLocked()</code>：frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bindServiceLocked</span><span class="params">(IApplicationThread caller, IBinder token, Intent service, String resolvedType, <span class="keyword">final</span> IServiceConnection connection, <span class="keyword">int</span> flags, String callingPackage, <span class="keyword">final</span> <span class="keyword">int</span> userId)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> ((flags&amp;Context.BIND_AUTO_CREATE) != <span class="number">0</span>) &#123;</span><br><span class="line">            s.lastActivity = SystemClock.uptimeMillis();</span><br><span class="line">            <span class="comment">// 1</span></span><br><span class="line">            <span class="keyword">if</span> (bringUpServiceLocked(s, service.getFlags(), callerFg, <span class="keyword">false</span>, permissionsReviewRequired) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (s.app != <span class="keyword">null</span> &amp;&amp; b.intent.received) &#123; <span class="comment">// 2</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                c.conn.connected(s.name, b.intent.binder); <span class="comment">// 3</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            ......</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (b.intent.apps.size() == <span class="number">1</span> &amp;&amp; b.intent.doRebind) &#123; <span class="comment">// 4</span></span><br><span class="line">                requestServiceBindingLocked(s, b.intent, callerFg, <span class="keyword">true</span>); <span class="comment">// 5</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!b.intent.requested) &#123; <span class="comment">// 6</span></span><br><span class="line">            requestServiceBindingLocked(s, b.intent, callerFg, <span class="keyword">false</span>); <span class="comment">// 7</span></span><br><span class="line">        &#125;</span><br><span class="line">        getServiceMap(s.userId).ensureNotStartingBackground(s);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，在<code>bringUpServiceLocked()</code>中会调用<code>realStartSewrviceLocked()</code>，最终由<code>ActivityThread</code>来调用Service的<code>onCreate()</code>方法启动Service，这在<a href="https://tylerliu.top/2019/09/03/Andorid深入理解四大组件-03%EF%BC%9AService的启动过程/#more">Andorid深入理解四大组件 03：Service的启动过程</a>中已经讲过。</p><p>注释2，<code>s.app != null</code>表示Service已经运行，其中<code>s</code>是<code>ServiceRecord</code>类型对象，<code>app</code>是<code>ProcessRecord</code>类型对象。<code>b.intent.recevied</code>表示当前应用程序进程的客户端已经接收到绑定Service时返回的<code>Binder</code>，这样应用程序进程的客户端就可以通过<code>Binder</code>来获取要绑定的Service的访问接口。</p><p>注释3，调用<code>c.conn.connected()</code>，其中<code>c.conn</code>指的是<code>IServiceConnection</code>，它的具体实现为<code>ServiceDispatcher.InnerCooection</code>，其中<code>ServiceDispatcher</code>是<code>LoadedApk</code>的内部类，<code>InnerConnection</code>的<code>connected()</code>内部会调用<code>H</code>的<code>post()</code>，向主线程发送消息，从而解决当前应该程序进程和Service跨进程通信的问题。</p><p>注释4，如果当前应用程序进程的客户端第一次与Service进行绑定，并且Service已经调用<code>onUnBind()</code>，就需要调用注释5的代码。</p><p>注释6，如果应用程序进程客户端没有发送过绑定Service的请求，就会调用注释7，注释7与之前注释5唯一的区别是最后一个参数<code>rebind</code>为<code>fasle</code>，表示不重新绑定。<code>requestServiceBindingLocked()</code>：frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">requestServiceBindingLocked</span><span class="params">(ServiceRecord r, IntentBindRecord i, <span class="keyword">boolean</span> execInFg, <span class="keyword">boolean</span> rebind)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> ((!i.requested || rebind) &amp;&amp; i.apps.size() &gt; <span class="number">0</span>) &#123; <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bumpServiceExecutingLocked(r, execInFg, <span class="string">"bind"</span>);</span><br><span class="line">            r.app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);</span><br><span class="line">            r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind, r.app.repProcState); <span class="comment">// 2</span></span><br><span class="line">            ......</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TransactionTooLargeException e) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，<code>i.requested</code>表示是否发送过绑定Service的请求，从前面的代码得知是没有发送过的，因此<code>!i.requested</code>为<code>true</code>。而<code>rebind</code>为<code>false</code>，那么<code>!i.requested || rebind</code>就是<code>true</code>。如果<code>IntentBindRecord</code>中的应用程序进程记录大于0，则会调用注释2的代码，<code>r.app.thread</code>的类型为<code>IApplicationThread</code>，它的实现是<code>ActivityThread</code>的内部类<code>ApplicationThread</code>，其<code>scheduleBindService()</code>如下：frameworks/base/core/java/android/app/ActivityThread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleBindService</span><span class="params">(IBinder token, Intent intent, <span class="keyword">boolean</span> rebind, <span class="keyword">int</span> processState)</span> </span>&#123;</span><br><span class="line">    updateProcessState(processState, <span class="keyword">false</span>);</span><br><span class="line">    BindServiceData s = <span class="keyword">new</span> BindServiceData();</span><br><span class="line">    s.token = token;</span><br><span class="line">    s.intent = intent;</span><br><span class="line">    s.rebind = rebind;</span><br><span class="line">    ......</span><br><span class="line">    sendMessage(H.BIND_SERVICE, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先将Service的信息封装成<code>BindServiceData</code>对象，<code>BindServiceData</code>成员变量<code>rebind</code>值为<code>fasle</code>，后面会用到。接着将<code>BindServiceData</code>传入到<code>sendMessage()</code>中。<code>sendMessage()</code>向<code>H</code>发送消息，再来看看<code>H</code>中的<code>handleMessage()</code>，这里只看<code>case BIND_SERVICE</code>的处理：frameworks/base/core/java/android/app/ActivityThread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> BIND_SERVICE:</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"serviceBind"</span>);</span><br><span class="line">    handleBindService((BindServiceData)msg.obj);</span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p><code>H</code>在接收到<code>BIND_SERVICE</code>类型消息时，会在里面调用<code>handleBindService()</code>：frameworks/base/core/java/android/app/ActivityThread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleBindService</span><span class="params">(BindServiceData data)</span> </span>&#123;</span><br><span class="line">    Service s = mServices.get(data.token); <span class="comment">// 1</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            data.intent.setExtrasClassLoader(s.getClassLoader());</span><br><span class="line">            data.intent.prepareToEnterProcess();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!data.rebind) &#123; <span class="comment">// 2</span></span><br><span class="line">                    IBinder binder = s.onBind(data.intent); <span class="comment">// 3</span></span><br><span class="line">                    ActivityManagerNative.getDefault().publishService(data.token, data.intent, binder); <span class="comment">// 4</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    s.onRebind(data.intent); <span class="comment">// 5</span></span><br><span class="line">                    ActivityManagerNative.getDefault().serviceDoneExecuting(data.token, SERVICE_DONE_EXECUTING_ANON, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                ensureJitEnabled();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，获取要绑定的Service。</p><p>注释2，<code>BindServiceData</code>的<code>rebind</code>值为<code>fasle</code>，这时，就会在注释3调用Service的<code>onBind()</code>，这样Service就处于绑定状态了。如果<code>rebind</code>为<code>true</code>，就会调用注释5的Service的<code>onRebind()</code>。结合前面的<code>bindServiceLocked()</code>的注释4，得知当前应用程序进程的客户端第一次与Service进行绑定，并且Service已经调用过<code>OnUnBind()</code>，则会调用Service的<code>onRebind()</code>。</p><p>注释4，实际上调用的是AMS<code>publishService()</code>。</p><p>这部分的时序图（不包含Service的启动过程）</p><img src="/2019/09/03/Andorid深入理解四大组件-04：Service的绑定过程/Vekz4K.png"><p>下面看看AMS的<code>publishService()</code>：frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishService</span><span class="params">(IBinder token, Intent intent, IBinder service)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (intent != <span class="keyword">null</span> &amp;&amp; intent.hasFileDescriptors() == <span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"File descriptors passed in Intent"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(token <span class="keyword">instanceof</span> ServiceRecord)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid service token"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mServices.publishServiceLocked((ServiceRecord)token, intent, service);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用了<code>ActiveServices</code>类型的<code>mServices</code>对象的<code>publishServiceLocked()</code>：frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">publishServiceLocked</span><span class="params">(ServiceRecord r, Intent intent, IBinder service)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (b != <span class="keyword">null</span> &amp;&amp; !b.received) &#123;</span><br><span class="line">                ......</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> conni=r.connections.size()-<span class="number">1</span>; conni&gt;=<span class="number">0</span>; conni--) &#123;</span><br><span class="line">                    ArrayList&lt;ConnectionRecord&gt; clist = r.connections.valueAt(conni);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;clist.size(); i++) &#123;</span><br><span class="line">                        ConnectionRecord c = clist.get(i);</span><br><span class="line">                        ......</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            c.conn.connected(r.name, service); <span class="comment">// 1</span></span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            ......</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            serviceDoneExecutingLocked(r, mDestroyingServices.contains(r), <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，<code>c.conn</code>指的是<code>IServiceConnect</code>，它的具体实现为<code>ServiceDispatcher.InnerConnection</code>，其中<code>ServiceDispatcher</code>是<code>LoadedApk</code>的内部类，<code>ServiceDispatcher.InnerConnection</code>的<code>connected()</code>代码如下：frameworks/base/core/java/android/app/LoadedApk.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceDispatcher</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerConnection</span> <span class="keyword">extends</span> <span class="title">IServiceConnection</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> WeakReference&lt;LoadedApk.ServiceDispatcher&gt; mDispatcher;</span><br><span class="line">        InnerConnection(LoadedApk.ServiceDispatcher sd) &#123;</span><br><span class="line">            mDispatcher = <span class="keyword">new</span> WeakReference&lt;LoadedApk.ServiceDispatcher&gt;(sd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connected</span><span class="params">(ComponentName name, IBinder service)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            LoadedApk.ServiceDispatcher sd = mDispatcher.get();</span><br><span class="line">            <span class="keyword">if</span> (sd != <span class="keyword">null</span>) &#123;</span><br><span class="line">                sd.connected(name, service); <span class="comment">// 1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，调用<code>ServiceDispatcher</code>类型的<code>sd</code>对象的<code>connected()</code>：frameworks/base/core/java/android/app/LoadedApk.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mActivityThread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mActivityThread.post(<span class="keyword">new</span> RunConnection(name, service, <span class="number">0</span>)); <span class="comment">// 1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        doConnected(name, service);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，调用<code>Handler</code>类型的对象<code>mActivityThread</code>的<code>post()</code>方法，<code>mActivityThread</code>实际上指向的是<code>H</code>。因此，通过调用<code>H</code>的<code>post()</code>方法将<code>RunConnection</code>对象的内容运行在主线程中。<code>RunConnection</code>的定义如下：frameworks/base/core/java/android/app/LoadedApk.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RunConnection</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    RunConnection(ComponentName name, IBinder service, <span class="keyword">int</span> command) &#123;</span><br><span class="line">        mName = name;</span><br><span class="line">        mService = service;</span><br><span class="line">        mCommand = command;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mCommand == <span class="number">0</span>) &#123;</span><br><span class="line">            doConnected(mName, mService);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mCommand == <span class="number">1</span>) &#123;</span><br><span class="line">            doDeath(mName, mService);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> ComponentName mName;</span><br><span class="line">    <span class="keyword">final</span> IBinder mService;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> mCommand;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>RunConnection</code>的<code>run()</code>方法中调用了<code>doConnected()</code>方法：frameworks/base/core/java/android/app/LoadedApk.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// If there was an old service, it is not disconnected.</span></span><br><span class="line">    <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mConnection.onServiceDisconnected(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If there is a new service, it is now connected.</span></span><br><span class="line">    <span class="keyword">if</span> (service != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mConnection.onServiceConnected(name, service); <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，调用了<code>ServiceConnection</code>类型的对象<code>mConnection</code>的<code>onServcieConnected()</code>方法，这样在客户端中实现了<code>ServcieConnection</code>接口的类的<code>onServiceConnected()</code>方法就会被执行。至此，Service的绑定过程就分析完了。</p><p>剩余部分的时序图：</p><img src="/2019/09/03/Andorid深入理解四大组件-04：Service的绑定过程/VekxN6.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;可以通过&lt;code&gt;Context&lt;/code&gt;的&lt;code&gt;startService()&lt;/code&gt;来绑定Service，也可以通过&lt;c
      
    
    </summary>
    
      <category term="Android进阶" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
      <category term="框架层" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/"/>
    
      <category term="深入理解四大组件" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/"/>
    
    
      <category term="四大组件" scheme="https://tylerLiu.top/tags/%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Andorid深入理解四大组件 03：Service的启动过程</title>
    <link href="https://tylerLiu.top/2019/09/03/Andorid%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6-03%EF%BC%9AService%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"/>
    <id>https://tylerLiu.top/2019/09/03/Andorid深入理解四大组件-03：Service的启动过程/</id>
    <published>2019-09-03T00:59:05.000Z</published>
    <updated>2019-09-11T08:03:18.914Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-ContextImpl到ActrivityManagerService的调用过程"><a href="#1-ContextImpl到ActrivityManagerService的调用过程" class="headerlink" title="1. ContextImpl到ActrivityManagerService的调用过程"></a>1. ContextImpl到ActrivityManagerService的调用过程</h1><p>要启动Service，就要调用<code>startService()</code>，它的实现是在<code>ContextWrapper</code>中：frameworks/base/core/java/android/content/ContextWrapper.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextWrapper</span> <span class="keyword">extends</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    Context mBase;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ComponentName <span class="title">startService</span><span class="params">(Intent service)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mBase.startService(service);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在里面调用了<code>mBase.staretService()</code>。<code>mBase</code>指的是什么呢？在<a href="https://tylerliu.top/2019/09/02/Andorid深入理解四大组件-02%EF%BC%9A应用程序启动过程%EF%BC%88下%EF%BC%89/#more">Andorid深入理解四大组件 02：应用程序启动过程（下）</a>中，<code>ActivityThread</code>启动Activity时会调用如下代码创建Activity的上下文环境：frameworks/base/core/java/android/app/ActivityThread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Context appContext = createBaseContextForActivity(r, activity); <span class="comment">// 1</span></span><br><span class="line">            ......</span><br><span class="line">            activity.attach(appContext, <span class="keyword">this</span>, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window);</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，创建了上下文对象<code>appContext</code>，并传入了Activity的<code>attach()</code>方法中，将Activity上下文对象<code>appContext</code>关联起来，这个<code>appContext</code>上下文对象具体指的是什么？再来看看<code>createBaseContextForActivity()</code>：frameworks/base/core/java/android/app/ActivityThread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Context <span class="title">createBaseContextForActivity</span><span class="params">(ActivityClientRecord r, <span class="keyword">final</span> Activity activity)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    ContextImpl appContext = ContextImpl.createActivityContext(<span class="keyword">this</span>, r.packageInfo, r.token, displayId, r.overrideConfig);</span><br><span class="line">    appContext.setOuterContext(activity);</span><br><span class="line">    Context baseContext = appContext;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> baseContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，上下文对象<code>appContext</code>的具体类型就是<code>ContextImpl</code>。Activity的<code>attach()</code>方法中将<code>ContextImpl</code>赋值给<code>ContextWrapper</code>的成员变量<code>mBase</code>中，因此，<code>mBase</code>具体指向就是<code>ContextImpl</code>。</p><p>再来查看<code>ContextImpl</code>的<code>startService()</code>：frameworks/base/core/java/android/app/ContextImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ComponentName <span class="title">startService</span><span class="params">(Intent service)</span> </span>&#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    <span class="keyword">return</span> startServiceCommon(service, mUser);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ComponentName <span class="title">startServiceCommon</span><span class="params">(Intent service, UserHandle user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        validateServiceIntent(service);</span><br><span class="line">        service.prepareToLeaveProcess(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 1</span></span><br><span class="line">        ComponentName cn = ActivityManagerNative.getDefault().startService(mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(getContentResolver()), getOpPackageName(), user.getIdentifier());</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> cn;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，调用了AMS的代理对象<code>ActivityManagerProxy</code>（AMP）的<code>startService()</code>，最终会调用AMS的<code>satrtService()</code>。</p><p><code>ContextImpl</code>到<code>ActivityManagerService</code>的调用过程的时序图：</p><img src="/2019/09/03/Andorid深入理解四大组件-03：Service的启动过程/Vek73F.png"><h1 id="2-ActivityThread启动Service"><a href="#2-ActivityThread启动Service" class="headerlink" title="2. ActivityThread启动Service"></a>2. ActivityThread启动Service</h1><p>下面看看AMS的<code>startService()</code>：frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ComponentName <span class="title">startService</span><span class="params">(IApplicationThread caller, Intent service, String resolvedType, String callingPackage, <span class="keyword">int</span> userId)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">"startService"</span>);</span><br><span class="line">    <span class="keyword">if</span> (service != <span class="keyword">null</span> &amp;&amp; service.hasFileDescriptors() == <span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"File descriptors passed in Intent"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (callingPackage == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"callingPackage cannot be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> callingPid = Binder.getCallingPid();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> callingUid = Binder.getCallingUid();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">        ComponentName res = mServices.startServiceLocked(caller, service, resolvedType, callingPid, callingUid, callingPackage, userId); <span class="comment">// 1</span></span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，调用<code>mService.startServiceLocked()</code>，<code>mService</code>的类型是<code>ActiveServices</code>，<code>ActiveServices</code>的<code>startServiceLocked()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ComponentName <span class="title">startServiceLocked</span><span class="params">(IApplicationThread caller, Intent service, String resolvedType, <span class="keyword">int</span> callingPid, <span class="keyword">int</span> callingUid, String callingPackage, <span class="keyword">final</span> <span class="keyword">int</span> userId)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> startServiceInnerLocked(smap, service, r, callerFg, addToStarting);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ComponentName <span class="title">startServiceInnerLocked</span><span class="params">(ServiceMap smap, Intent service, ServiceRecord r, <span class="keyword">boolean</span> callerFg, <span class="keyword">boolean</span> addToStarting)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    String error = bringUpServiceLocked(r, service.getFlags(), callerFg, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> r.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>startServiceLocked()</code>中<code>return startServiceInnerLocked()</code>，而<code>startServiceInnerLocked()</code>中又调用了<code>bringUpServiceLocked()</code>：frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">bringUpServiceLocked</span><span class="params">(ServiceRecord r, <span class="keyword">int</span> intentFlags, <span class="keyword">boolean</span> execInFg, <span class="keyword">boolean</span> whileRestarting, <span class="keyword">boolean</span> permissionsReviewRequired)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">final</span> String procName = r.processName; <span class="comment">// 1</span></span><br><span class="line">    ProcessRecord app;</span><br><span class="line">    <span class="keyword">if</span> (!isolated) &#123;</span><br><span class="line">        app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, <span class="keyword">false</span>); <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; app.thread != <span class="keyword">null</span>) &#123; <span class="comment">// 3</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                app.addPackage(r.appInfo.packageName, r.appInfo.versionCode, mAm.mProcessStats);</span><br><span class="line">                realStartServiceLocked(r, app, execInFg); <span class="comment">// 4</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (TransactionTooLargeException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Exception when starting service "</span> + r.shortName, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        app = r.isolatedProc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (app == <span class="keyword">null</span> &amp;&amp; !permissionsReviewRequired) &#123; <span class="comment">// 5</span></span><br><span class="line">        <span class="keyword">if</span> ((app=mAm.startProcessLocked(procName, r.appInfo, <span class="keyword">true</span>, intentFlags, <span class="string">"service"</span>, r.name, <span class="keyword">false</span>, isolated, <span class="keyword">false</span>)) == <span class="keyword">null</span>) &#123; <span class="comment">// 6</span></span><br><span class="line">            String msg = <span class="string">"Unable to launch app "</span></span><br><span class="line">                    + r.appInfo.packageName + <span class="string">"/"</span></span><br><span class="line">                    + r.appInfo.uid + <span class="string">" for service "</span></span><br><span class="line">                    + r.intent.getIntent() + <span class="string">": process is bad"</span>;</span><br><span class="line">            Slog.w(TAG, msg);</span><br><span class="line">            bringDownServiceLocked(r);</span><br><span class="line">            <span class="keyword">return</span> msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isolated) &#123;</span><br><span class="line">            r.isolatedProc = app;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，得到<code>ServiceRecord</code>的<code>processName</code>的值，并赋值给变量<code>procName</code>，其中<code>processName</code>是用来描述Service要运行在哪个线程，默认是当前线程，可以在AndoridManifest配置文件中设置<code>android:process</code>属性来新开启一个进程，运行Service。</p><p>注释2，将<code>procName</code>和Service的<code>uid</code>传入AMS的<code>getProcessRecordLocked()</code>中，来查询是否存在一个与Service对应的<code>ProcessRecord</code>类型的对象<code>app</code>，<code>ProcessRecord</code>主要用来记录运行的应用程序进程的信息。</p><p>注释5，判断两个条件，一个是用来运行Service的应用程序进程不存在，另一个是应用程序之间的组件调用不需要检查权限，满足这两个条件就调用注释6的AMS的<code>startProcessLocked()</code>来创建对应的应用程序进程。</p><p>关于创建应用程序进程可以看<a href="https://tylerliu.top/2019/09/02/Andorid深入理解四大组件-01%EF%BC%9A应用程序启动过程%EF%BC%88上%EF%BC%89/#more">Andorid深入理解四大组件 01：应用程序启动过程（上）</a>和<a href="https://tylerliu.top/2019/09/02/Andorid深入理解四大组件-02%EF%BC%9A应用程序启动过程%EF%BC%88下%EF%BC%89/#more">Andorid深入理解四大组件 02：应用程序启动过程（下）</a>。</p><p>注释3，判断如果用来运行Service的应用程序进程存在，则调用注释4的<code>realStartServiceLocked()</code>：frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">realStartServiceLocked</span><span class="params">(ServiceRecord r, ProcessRecord app, <span class="keyword">boolean</span> execInFg)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        app.thread.scheduleCreateService(r, r.serviceInfo, mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo), app.repProcState);</span><br><span class="line">        r.postNotification();</span><br><span class="line">        created = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (DeadObjectException e) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在里面调用了<code>app.thread</code>的<code>scheduleCreateService()</code>。其中<code>app.thread</code>是<code>IApplicationThread</code>类型，它的实现是<code>ActivityThread</code>的内部类<code>ApplicationThread</code>，其中<code>ApplicationThread</code>继承了<code>ApplicationThreadNative</code>，而<code>ApplicationThreadNative</code>又继承了<code>Binder</code>并实现了<code>IApplicationThread</code>接口。<code>ApplicationThread</code>的<code>scheduleCreateService()</code>：frameworks/base/core/java/android/app/ActivityThread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleCreateService</span><span class="params">(IBinder token, ServiceInfo info, CompatibilityInfo compatInfo, <span class="keyword">int</span> processState)</span> </span>&#123;</span><br><span class="line">    updateProcessState(processState, <span class="keyword">false</span>);</span><br><span class="line">    CreateServiceData s = <span class="keyword">new</span> CreateServiceData();</span><br><span class="line">    s.token = token;</span><br><span class="line">    s.info = info;</span><br><span class="line">    s.compatInfo = compatInfo;</span><br><span class="line">    sendMessage(H.CREATE_SERVICE, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先将要启动的信息封装成<code>CreateServiceData</code>对象，并传到<code>sendMessage()</code>中，<code>sendMessage()</code>向<code>H</code>发送了<code>CREATE_SERVICE</code>消息。这个过程和应用程序的启动过程（根Activity启动）类似。再来看看<code>H</code>的<code>handleMessage()</code>在接收到消息后做了哪些：frameworks/base/core/java/android/app/ActivityThread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> CREATE_SERVICE:</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (<span class="string">"serviceCreate: "</span> + String.valueOf(msg.obj)));</span><br><span class="line">            handleCreateService((CreateServiceData)msg.obj);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在里面调用了<code>handleCreateService()</code>：frameworks/base/core/java/android/app/ActivityThread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleCreateService</span><span class="params">(CreateServiceData data)</span> </span>&#123;</span><br><span class="line">    unscheduleGcIdler();</span><br><span class="line">    LoadedApk packageInfo = getPackageInfoNoCheck(data.info.applicationInfo, data.compatInfo); <span class="comment">// 1</span></span><br><span class="line">    Service service = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        java.lang.ClassLoader cl = packageInfo.getClassLoader(); <span class="comment">// 2</span></span><br><span class="line">        service = (Service) cl.loadClass(data.info.name).newInstance(); <span class="comment">// 3</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">"Creating service "</span> + data.info.name);</span><br><span class="line">        ContextImpl context = ContextImpl.createAppContext(<span class="keyword">this</span>, packageInfo); <span class="comment">// 4</span></span><br><span class="line">        context.setOuterContext(service);</span><br><span class="line">        Application app = packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line">        service.attach(context, <span class="keyword">this</span>, data.info.name, data.token, app, ActivityManagerNative.getDefault()); <span class="comment">// 5</span></span><br><span class="line">        service.onCreate(); <span class="comment">// 6</span></span><br><span class="line">        mServices.put(data.token, service); <span class="comment">// 7</span></span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，获取要启动Service的应用程序的<code>LoadedApk</code>，<code>LoadedApk</code>是一个APK文件的描述类。</p><p>注释2，通过调用<code>LoadedApk</code>的<code>getClassLoader()</code>获取类加载器。</p><p>注释3，根据<code>CreateServiceData</code>中存储的Service信息，将Service加载到内存中。</p><p>注释4，创建Service的上下文环境<code>ComtextImpl</code>对象。</p><p>注释5，通过Service的<code>attach()</code>初始化Service。</p><p>注释6，调用Service的<code>onCreate()</code>，启动Service。</p><p>注释7，将启动的Service加入到<code>ActivityThread</code>的成员变量<code>mService</code>中，其中<code>mService</code>是<code>ArrayMap</code>类型。</p><p>时序图：</p><img src="/2019/09/03/Andorid深入理解四大组件-03：Service的启动过程/VekHc4.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-ContextImpl到ActrivityManagerService的调用过程&quot;&gt;&lt;a href=&quot;#1-ContextImpl到ActrivityManagerService的调用过程&quot; class=&quot;headerlink&quot; title=&quot;1. Conte
      
    
    </summary>
    
      <category term="Android进阶" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
      <category term="框架层" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/"/>
    
      <category term="深入理解四大组件" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/"/>
    
    
      <category term="四大组件" scheme="https://tylerLiu.top/tags/%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Andorid深入理解四大组件 02：应用程序启动过程（下）</title>
    <link href="https://tylerLiu.top/2019/09/02/Andorid%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6-02%EF%BC%9A%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>https://tylerLiu.top/2019/09/02/Andorid深入理解四大组件-02：应用程序启动过程（下）/</id>
    <published>2019-09-02T07:36:22.000Z</published>
    <updated>2019-09-11T08:03:16.462Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-AMS到ApplicationThread的调用流程"><a href="#1-AMS到ApplicationThread的调用流程" class="headerlink" title="1. AMS到ApplicationThread的调用流程"></a>1. AMS到ApplicationThread的调用流程</h1><p>AMS的<code>startActivity()</code>中返回了<code>startActivityAsUser()</code>：frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivityAsUser</span><span class="params">(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">"startActivity"</span>);</span><br><span class="line">    userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, <span class="keyword">false</span>, ALLOW_FULL_ONLY, <span class="string">"startActivity"</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> mActivityStarter.startActivityMayWait(caller, -<span class="number">1</span>, callingPackage, intent, resolvedType, <span class="keyword">null</span>, <span class="keyword">null</span>, resultTo, resultWho, requestCode, startFlags, profilerInfo, <span class="keyword">null</span>, <span class="keyword">null</span>, bOptions, <span class="keyword">false</span>, userId, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p><code>startActivityAsUaser()</code>中返回了<code>mActivityStarter</code>的<code>startActivityMayWait()</code>：frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivityMayWait</span><span class="params">(IApplicationThread caller, <span class="keyword">int</span> callingUid,</span></span></span><br><span class="line"><span class="function"><span class="params">    String callingPackage, Intent intent, String resolvedType,</span></span></span><br><span class="line"><span class="function"><span class="params">    IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">    IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> startFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">    ProfilerInfo profilerInfo, IActivityManager.WaitResult outResult, Configuration config,</span></span></span><br><span class="line"><span class="function"><span class="params">    Bundle bOptions, <span class="keyword">boolean</span> ignoreTargetSecurity, <span class="keyword">int</span> userId,</span></span></span><br><span class="line"><span class="function"><span class="params">    IActivityContainer iContainer, TaskRecord inTask)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">int</span> res = startActivityLocked(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity, componentSpecified, outRecord, container, inTask);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在里面调用了<code>startActivityLocked()</code>：frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivityLocked</span><span class="params">(IApplicationThread caller, Intent intent, Intent ephemeralIntent, String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> callingPid, <span class="keyword">int</span> callingUid, String callingPackage, <span class="keyword">int</span> realCallingPid, <span class="keyword">int</span> realCallingUid, <span class="keyword">int</span> startFlags, ActivityOptions options, <span class="keyword">boolean</span> ignoreTargetSecurity, <span class="keyword">boolean</span> componentSpecified, ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container, TaskRecord inTask)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    doPendingActivityLaunchesLocked(<span class="keyword">false</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在里面主要关注<code>doPendingActivitylaunchedLocked()</code>：frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doPendingActivityLaunchesLocked</span><span class="params">(<span class="keyword">boolean</span> doResume)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!mPendingActivityLaunches.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">final</span> PendingActivityLaunch pal = mPendingActivityLaunches.remove(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> resume = doResume &amp;&amp; mPendingActivityLaunches.isEmpty();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> result = startActivityUnchecked(pal.r, pal.sourceRecord, <span class="keyword">null</span>, <span class="keyword">null</span>, pal.startFlags, resume, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            postStartActivityUncheckedProcessing(pal.r, result, mSupervisor.mFocusedStack.mStackId, mSourceRecord,mTargetStack);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Slog.e(TAG, <span class="string">"Exception during pending activity launch pal="</span> + pal, e);</span><br><span class="line">            pal.sendErrorResult(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在里面调用了<code>startActivityUnchecked()</code>：frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivityUnchecked</span><span class="params">(<span class="keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, <span class="keyword">int</span> startFlags, <span class="keyword">boolean</span> doResume, ActivityOptions options, TaskRecord inTask)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mSupervisor.resumeFocusedStackTopActivityLocked();  </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> START_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在里面调用了<code>ActivityStackSupervisor</code>类型的<code>mSopervisor</code>的<code>resumeFocusedStackTopActivityLocked()</code>：frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">resumeFocusedStackTopActivityLocked</span><span class="params">(ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (targetStack != <span class="keyword">null</span> &amp;&amp; isFocusedStack(targetStack)) &#123;</span><br><span class="line">        <span class="keyword">return</span> targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> ActivityRecord r = mFocusedStack.topRunningActivityLocked();</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="keyword">null</span> || r.state != RESUMED) &#123;</span><br><span class="line">        mFocusedStack.resumeTopActivityUncheckedLocked(<span class="keyword">null</span>, <span class="keyword">null</span>); <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，调用了<code>ActivityStack</code>类型的<code>mFocusedStack</code>的<code>resumeTopActivityUncheckedLocked()</code>：rameworks/base/services/core/java/com/android/server/am/ActivityStack.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">resumeTopActivityUncheckedLocked</span><span class="params">(ActivityRecord prev, ActivityOptions options)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        result = resumeTopActivityInnerLocked(prev, options);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mStackSupervisor.inResumeTopActivity = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">resumeTopActivityInnerLocked</span><span class="params">(ActivityRecord prev, ActivityOptions options)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mStackSupervisor.startSpecificActivityLocked(next, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><p>在里面主要调用了<code>ActivityStackSupervisor</code>类型<code>mStackSupervisor</code>的<code>startSpecificActivityLocked()</code>：frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startSpecificActivityLocked</span><span class="params">(ActivityRecord r, <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> </span>&#123;</span><br><span class="line">    ProcessRecord app = mService.getProcessRecordLocked(r.processName, r.info.applicationInfo.uid, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    r.task.stack.setLaunchTime(r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; app.thread != <span class="keyword">null</span>) &#123; <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == <span class="number">0</span> || !<span class="string">"android"</span>.equals(r.info.packageName)) &#123;</span><br><span class="line">                app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode, mService.mProcessStats);</span><br><span class="line">            &#125;</span><br><span class="line">            realStartActivityLocked(r, app, andResume, checkConfig); <span class="comment">// 2</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Exception when starting activity "</span> + r.intent.getComponent().flattenToShortString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mService.startProcessLocked(r.processName, r.info.applicationInfo, <span class="keyword">true</span>, <span class="number">0</span>, <span class="string">"activity"</span>, r.intent.getComponent(), <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，如果在当前Activity所在的Application运行的话，会执行注释2的代码。<code>realStartActivityLocked()</code>：frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">realStartActivityLocked</span><span class="params">(ActivityRecord r, ProcessRecord app, <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    app.thread.scheduleLaunchActivity(<span class="keyword">new</span> Intent(r.intent), r.appToken, System.identityHashCode(r), r.info, <span class="keyword">new</span> Configuration(mService.mConfiguration), <span class="keyword">new</span> Configuration(task.mOverrideConfig), r.compat, r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results, newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo);</span><br><span class="line">    ...      </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>app.thread</code>指的是<code>IApplicationThread</code>，它的实现是<code>ActivityThread</code>的内部类<code>ApplicationThread</code>，其中<code>ApplicationThread</code>继承了<code>ApplicationThreadNative</code>，而<code>ApplicationThreadNative</code>继承了<code>Binder</code>并实现了<code>IApplicationThread</code>接口。</p><p>AMS到<code>ApplicationThread</code>调用过程的时序图：</p><img src="/2019/09/02/Andorid深入理解四大组件-02：应用程序启动过程（下）/Vek5NV.png"><h1 id="2-ActivityThread启动Activity"><a href="#2-ActivityThread启动Activity" class="headerlink" title="2. ActivityThread启动Activity"></a>2. ActivityThread启动Activity</h1><p><a href="https://tylerliu.top/2019/08/30/Android应用程序进程启动过程01/">Android应用程序进程启动过程 01</a>中提到过<code>ActivityThread</code>，在应用程序进程启动过程中会创建<code>ActivityThread</code>实例。<code>ActivityThread</code>是应用程序进程的核心类，它是如何启动应用程序（Activity）的呢？</p><p>根据上文接着查看<code>ApplicationThread</code>的<code>scheduleLaunchActivity</code>：frameworks/base/core/java/android/app/ActivityThread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleLaunchActivity</span><span class="params">(Intent intent, IBinder token, <span class="keyword">int</span> ident,</span></span></span><br><span class="line"><span class="function"><span class="params">        ActivityInfo info, Configuration curConfig, Configuration overrideConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">        CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> procState, Bundle state, PersistableBundle persistentState,</span></span></span><br><span class="line"><span class="function"><span class="params">        List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> notResumed, <span class="keyword">boolean</span> isForward, ProfilerInfo profilerInfo)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    updateProcessState(procState, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    ActivityClientRecord r = <span class="keyword">new</span> ActivityClientRecord();</span><br><span class="line"></span><br><span class="line">    r.token = token;</span><br><span class="line">    r.ident = ident;</span><br><span class="line">    r.intent = intent;</span><br><span class="line">    r.referrer = referrer;</span><br><span class="line">    r.voiceInteractor = voiceInteractor;</span><br><span class="line">    r.activityInfo = info;</span><br><span class="line">    r.compatInfo = compatInfo;</span><br><span class="line">    r.state = state;</span><br><span class="line">    r.persistentState = persistentState;</span><br><span class="line"></span><br><span class="line">    r.pendingResults = pendingResults;</span><br><span class="line">    r.pendingIntents = pendingNewIntents;</span><br><span class="line"></span><br><span class="line">    r.startsNotResumed = notResumed;</span><br><span class="line">    r.isForward = isForward;</span><br><span class="line"></span><br><span class="line">    r.profilerInfo = profilerInfo;</span><br><span class="line"></span><br><span class="line">    r.overrideConfig = overrideConfig;</span><br><span class="line">    updatePendingConfiguration(curConfig);</span><br><span class="line"></span><br><span class="line">    sendMessage(H.LAUNCH_ACTIVITY, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在里面会启动Activity的参数封装成<code>ActivityClientRecord</code>，<code>sendMessage()</code>会向<code>H</code>类发送一个名为<code>LAUNCH_ACTIVITY</code>的消息，并将<code>ActivityClientRecord</code>传递过去，<code>sendMessage()</code>如下：frameworks/base/core/java/android/app/ActivityThread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">int</span> what, Object obj, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mH.sendMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mH</code>指的就是<code>H</code>类，它是<code>ActivityThread</code>的内部类，继承了<code>Handler</code>：frameworks/base/core/java/android/app/ActivityThread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">H</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LAUNCH_ACTIVITY = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PAUSE_ACTIVITY = <span class="number">101</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="string">"&gt;&gt;&gt; handling: "</span> + codeToString(msg.what));</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> LAUNCH_ACTIVITY: &#123;</span><br><span class="line">                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"activityStart"</span>);</span><br><span class="line">                <span class="keyword">final</span> ActivityClientRecord r = (ActivityClientRecord) msg.obj; <span class="comment">// 1</span></span><br><span class="line">                r.packageInfo = getPackageInfoNoCheck(</span><br><span class="line">                        r.activityInfo.applicationInfo, r.compatInfo); <span class="comment">// 2</span></span><br><span class="line">                handleLaunchActivity(r, <span class="keyword">null</span>, <span class="string">"LAUNCH_ACTIVITY"</span>); <span class="comment">// 3</span></span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RELAUNCH_ACTIVITY: &#123;</span><br><span class="line">                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"activityRestart"</span>);</span><br><span class="line">                ActivityClientRecord r = (ActivityClientRecord)msg.obj;</span><br><span class="line">                handleRelaunchActivity(r);</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看<code>H</code>中<code>handleMessage()</code>对<code>LAUNCH_ACTIVITY</code>的处理，在注释1处将传过来的<code>msg</code>的成员变量<code>obj</code>转为<code>ActivityClientRecord</code>。</p><p>注释2，通过<code>getPackageInfoNoCheck()</code>获得<code>LoadedApk</code>类型的对象并赋值给<code>ActivityClientRecord</code>的成员变量<code>packageInfo</code>。应用程序进程要启动Activity时需要将该Activity所属的APK加载进来，而<code>LoadedApk</code>就是用来描述已加载的APK文件。</p><p>注释3，调用<code>handleLaunchActivity()</code>：frameworks/base/core/java/android/app/ActivityThread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent, String reason)</span> </span>&#123;</span><br><span class="line">    unscheduleGcIdler();</span><br><span class="line">    mSomeActivitiesChanged = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (r.profilerInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mProfiler.setProfiler(r.profilerInfo);</span><br><span class="line">        mProfiler.startProfiling();</span><br><span class="line">    &#125;</span><br><span class="line">    handleConfigurationChanged(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (localLOGV) Slog.v(</span><br><span class="line">        TAG, <span class="string">"Handling launch of "</span> + r);</span><br><span class="line">    WindowManagerGlobal.initialize();</span><br><span class="line">    Activity a = performLaunchActivity(r, customIntent); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">        r.createdConfig = <span class="keyword">new</span> Configuration(mConfiguration);</span><br><span class="line">        reportSizeConfigurations(r);</span><br><span class="line">        Bundle oldState = r.state;</span><br><span class="line">        handleResumeActivity(r.token, <span class="keyword">false</span>, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!r.activity.mFinished &amp;&amp; r.startsNotResumed) &#123;</span><br><span class="line">            performPauseActivityIfNeeded(r, reason);</span><br><span class="line">            <span class="keyword">if</span> (r.isPreHoneycomb()) &#123;</span><br><span class="line">                r.state = oldState;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ActivityManagerNative.getDefault().finishActivity(r.token, Activity.RESULT_CANCELED, <span class="keyword">null</span>,Activity.DONT_FINISH_TASK_WITH_ACTIVITY);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，<code>perfprmLaunchActivity()</code>用来启动Activity。</p><p>注释2，用来将Activity的状态设置为<code>Resume</code>。如果该Activity为<code>null</code>，则会通知<code>ActivityManager</code>停止启动Activity。</p><p><code>perfprmLaunchActivity()</code>：frameworks/base/core/java/android/app/ActivityThread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">    ActivityInfo aInfo = r.activityInfo; <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> (r.packageInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">        r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo, Context.CONTEXT_INCLUDE_CODE); <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    ComponentName component = r.intent.getComponent(); <span class="comment">// 3</span></span><br><span class="line">    ......</span><br><span class="line">    Activity activity = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</span><br><span class="line">        activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent); <span class="comment">// 4</span></span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Application app = r.packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation); <span class="comment">// 5</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Context appContext = createBaseContextForActivity(r, activity); <span class="comment">// 6</span></span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">// 7</span></span><br><span class="line">            activity.attach(appContext, <span class="keyword">this</span>, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window);</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); <span class="comment">// 8</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SuperNotCalledException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，获取<code>ActivityInfo</code>。</p><p>注释2，获取APK文件的描述类<code>LoadedApk</code>。</p><p>注释3，获取要启动的Activity的<code>ComponentName</code>类，<code>ComponentName</code>类中保存了该Activity的包名和类名。</p><p>注释4，根据<code>ComponentName</code>中存储的Activity类名，用类加载器创建该Activity的实例。</p><p>注释5，创建<code>Application</code>，<code>makeApplication()</code>内部会调用<code>Application</code>的<code>onCreate()</code>。</p><p>注释6，创建要启动Activity的上下文环境。</p><p>注释7，调用Activity的<code>attach()</code>初始化Activity，<code>attach()</code>内部会创建Window对象（<code>PhoneWindow</code>）并与Activity自身进行关联。</p><p>注释8，调用<code>Instrumentation</code>的<code>callActivityOnCreate()</code>来启动Activity：frameworks/base/core/java/android/app/Instrumentation.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callActivityOnCreate</span><span class="params">(Activity activity, Bundle icicle)</span> </span>&#123;</span><br><span class="line">    prePerformCreate(activity);</span><br><span class="line">    activity.performCreate(icicle);</span><br><span class="line">    postPerformCreate(activity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在里面调用了<code>activity.performCreate()</code>：frameworks/base/core/java/android/app/Activity.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performCreate</span><span class="params">(Bundle icicle)</span> </span>&#123;</span><br><span class="line">    restoreHasCurrentPermissionRequest(icicle);</span><br><span class="line">    onCreate(icicle);</span><br><span class="line">    mActivityTransitionState.readState(icicle);</span><br><span class="line">    performCreateCommon();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>performCreate()</code>中会调用Activity的<code>onCreate()</code>，这样Activity就启动了，即应用程序启动了。</p><p><code>ActivityThread</code>启动Activity的时序图：</p><img src="/2019/09/02/Andorid深入理解四大组件-02：应用程序启动过程（下）/Vek4A0.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-AMS到ApplicationThread的调用流程&quot;&gt;&lt;a href=&quot;#1-AMS到ApplicationThread的调用流程&quot; class=&quot;headerlink&quot; title=&quot;1. AMS到ApplicationThread的调用流程&quot;&gt;&lt;/a&gt;1
      
    
    </summary>
    
      <category term="Android进阶" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
      <category term="框架层" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/"/>
    
      <category term="深入理解四大组件" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/"/>
    
    
      <category term="四大组件" scheme="https://tylerLiu.top/tags/%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Andorid深入理解四大组件 01：应用程序启动过程（上）</title>
    <link href="https://tylerLiu.top/2019/09/02/Andorid%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6-01%EF%BC%9A%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>https://tylerLiu.top/2019/09/02/Andorid深入理解四大组件-01：应用程序启动过程（上）/</id>
    <published>2019-09-02T02:00:52.000Z</published>
    <updated>2019-09-11T08:03:12.990Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面介绍了Android系统启动过程和应用程序进程启动过程。下面再来看看Android应用程序启动过程，即Activity的启动过程。基于Android 7.0。</p><h1 id="1-Launch请求ActivityManagerService"><a href="#1-Launch请求ActivityManagerService" class="headerlink" title="1. Launch请求ActivityManagerService"></a>1. Launch请求ActivityManagerService</h1><p>在<a href="https://tylerliu.top/2019/08/28/Android系统启动流程04%EF%BC%9ALauncher启动过程和系统启动流程/#more">Android系统启动流程 04：Launcher启动过程和系统启动流程</a>中，讲过Launch启动后会将已安装应用程序的快捷图标显示到界面上，当点击应用程序的快捷图标时，就会调用<code>Launcher</code>的<code>startActivitySafely()</code>方法：packages/apps/Launcher3/src/com/android/launcher3/Launcher.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startActivitySafely</span><span class="params">(View v, Intent intent, Object tag)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        success = startActivity(v, intent, tag);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ActivityNotFoundException e) &#123;</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>, R.string.activity_not_found, Toast.LENGTH_SHORT).show();</span><br><span class="line">        Log.e(TAG, <span class="string">"Unable to launch. tag="</span> + tag + <span class="string">" intent="</span> + intent, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在里面主要调用了<code>startActivity()</code>：packages/apps/Launcher3/src/com/android/launcher3/Launcher.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">startActivity</span><span class="params">(View v, Intent intent, Object tag)</span> </span>&#123;</span><br><span class="line">   intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); <span class="comment">// 1</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     ...</span><br><span class="line">       <span class="keyword">if</span> (user == <span class="keyword">null</span> || user.equals(UserHandleCompat.myUserHandle())) &#123;</span><br><span class="line">           StrictMode.VmPolicy oldPolicy = StrictMode.getVmPolicy();</span><br><span class="line">           <span class="keyword">try</span> &#123;            </span><br><span class="line">               StrictMode.setVmPolicy(<span class="keyword">new</span> StrictMode.VmPolicy.Builder().detectAll()</span><br><span class="line">                       .penaltyLog().build());</span><br><span class="line">               startActivity(intent, optsBundle); <span class="comment">// 2</span></span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               StrictMode.setVmPolicy(oldPolicy);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           launcherApps.startActivityForProfile(intent.getComponent(), user,</span><br><span class="line">                   intent.getSourceBounds(), optsBundle);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (SecurityException e) &#123;      </span><br><span class="line">     ...</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，设置<code>Flag</code>为<code>Intent.FLAG_ACTIVITY_NEW_TASK</code>，这样根Activity会在新的任务栈中启动。</p><p>注释2，调用了<code>startActivity()</code>：frameworks/base/core/java/android/app/Activity.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent, @Nullable Bundle options)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (options != <span class="keyword">null</span>) &#123;</span><br><span class="line">        startActivityForResult(intent, -<span class="number">1</span>, options);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        startActivityForResult(intent, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>startActivity()</code>会调用<code>startActvitiyForResult()</code>，其中第二个参数为<code>-1</code>，表示<code>Launcher</code>不需要知道Actiivty的启动结果，<code>startActivityForResult()</code>：frameworks/base/core/java/android/app/Activity.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityForResult</span><span class="params">(@RequiresPermission Intent intent, <span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="function"><span class="params">       @Nullable Bundle options)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (mParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">       Instrumentation.ActivityResult ar =</span><br><span class="line">           mInstrumentation.execStartActivity(</span><br><span class="line">               <span class="keyword">this</span>, mMainThread.getApplicationThread(), mToken, <span class="keyword">this</span>,</span><br><span class="line">               intent, requestCode, options);</span><br><span class="line">    ...</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mParent</code>是<code>Activity</code>类型的，表示当前Activtiy的父类。因为目前根Acitvity还没有创建出来，因此，<code>mParent == null</code>为<code>true</code>。接着调用<code>Insxtrumentation</code>的<code>exeStartActivity()</code>，<code>Instrumentation</code>主要用来监控应用程序和系统的交互，<code>execStartActivity()</code>：frameworks/base/core/java/android/app/Instrumentation.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Context who, IBinder contextThread, IBinder token, Activity target,</span></span></span><br><span class="line"><span class="function"><span class="params">        Intent intent, <span class="keyword">int</span> requestCode, Bundle options)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        intent.migrateExtraStreamToClipData();</span><br><span class="line">        intent.prepareToLeaveProcess(who);</span><br><span class="line">        <span class="keyword">int</span> result = ActivityManagerNative.getDefault()</span><br><span class="line">            .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                    intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                    token, target != <span class="keyword">null</span> ? target.mEmbeddedID : <span class="keyword">null</span>,</span><br><span class="line">                    requestCode, <span class="number">0</span>, <span class="keyword">null</span>, options);</span><br><span class="line">        checkStartActivityResult(result, intent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failure from system"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先会调用<code>ActivityManagerNative</code>的<code>getDefault()</code>来获取<code>ActivityManagerService</code>（后面简称AMS）的代理对象，接着调用它的<code>startActivtiy()</code>。首先看看<code>ActivityManagerNative</code>的<code>getDefault()</code>：frameworks/base/core/java/android/app/ActivityManagerNative.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> IActivityManager <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gDefault.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton&lt;IActivityManager&gt; gDefault = <span class="keyword">new</span> Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> IActivityManager <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        IBinder b = ServiceManager.getService(<span class="string">"activity"</span>); <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">            Log.v(<span class="string">"ActivityManager"</span>, <span class="string">"default service binder = "</span> + b);</span><br><span class="line">        &#125;</span><br><span class="line">        IActivityManager am = asInterface(b); <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">            Log.v(<span class="string">"ActivityManager"</span>, <span class="string">"default service = "</span> + am);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> am;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>getDefault()</code>调用了<code>gDefault</code>的<code>get()</code>，<code>gDefault</code>是一个单例类。</p><p>注释1，得到名为<code>&quot;activity&quot;</code>的Service引用，也就是<code>IBinder</code>类型的<code>ActivtiyManagerService</code>的引用。</p><p>注释2，将它封装成<code>ActivtiyManagerProxy</code>（后面简称AMP）类型对象，并将它保存到<code>gDefault</code>中，此后调用<code>ActivityManagerNative</code>的<code>getDefault()</code>就会直接获得AMS的代理AMP对象。</p><p>回到<code>Instrumentation</code>的<code>exeStartActivity()</code>中，从上面得知就是调用AMP的<code>startActivity()</code>，其中AMP是<code>ActivityManagerNative</code>的内部类：frameworks/base/core/java/android/app/ActivityManagerNative.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(IApplicationThread caller, String callingPackage, Intent intent,</span></span></span><br><span class="line"><span class="function"><span class="params">       String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle options)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">   Parcel data = Parcel.obtain();</span><br><span class="line">   Parcel reply = Parcel.obtain();</span><br><span class="line">   data.writeInterfaceToken(IActivityManager.descriptor);</span><br><span class="line">   data.writeStrongBinder(caller != <span class="keyword">null</span> ? caller.asBinder() : <span class="keyword">null</span>);</span><br><span class="line">   data.writeString(callingPackage);</span><br><span class="line">   intent.writeToParcel(data, <span class="number">0</span>);</span><br><span class="line">   data.writeString(resolvedType);</span><br><span class="line">   data.writeStrongBinder(resultTo);</span><br><span class="line">   data.writeString(resultWho);</span><br><span class="line">   data.writeInt(requestCode);</span><br><span class="line">   data.writeInt(startFlags);</span><br><span class="line">   <span class="keyword">if</span> (profilerInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">       data.writeInt(<span class="number">1</span>);</span><br><span class="line">       profilerInfo.writeToParcel(data, Parcelable.PARCELABLE_WRITE_RETURN_VALUE);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       data.writeInt(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (options != <span class="keyword">null</span>) &#123;</span><br><span class="line">       data.writeInt(<span class="number">1</span>);</span><br><span class="line">       options.writeToParcel(data, <span class="number">0</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       data.writeInt(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, <span class="number">0</span>); <span class="comment">// 1</span></span><br><span class="line">   reply.readException();</span><br><span class="line">   <span class="keyword">int</span> result = reply.readInt();</span><br><span class="line">   reply.recycle();</span><br><span class="line">   data.recycle();</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先将传入的参数写入到<code>Parcel</code>类的<code>data</code>中。</p><p>注释1，通过<code>IBinder</code>类型对象<code>mRemote向AMS发送一个</code>START_ACTIVITY_TRANSACTION<code>类型的进程间通信请求。服务端AMS就会从Binder线程池中读取客户端发送来的数据，最终调用</code>ActivityManagerNative<code>的</code>toTransact()`：frameworks/base/core/java/android/app/ActivityManagerNative.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">    <span class="keyword">case</span> START_ACTIVITY_TRANSACTION:</span><br><span class="line">    &#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">int</span> result = startActivity(app, callingPackage, intent, resolvedType,</span><br><span class="line">                resultTo, resultWho, requestCode, startFlags, profilerInfo, options);</span><br><span class="line">        reply.writeNoException();</span><br><span class="line">        reply.writeInt(result);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>onTransact()</code>中会调用AMS的<code>startActivity()</code>：frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">     Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,</span><br><span class="line">         resultWho, requestCode, startFlags, profilerInfo, bOptions,</span><br><span class="line">         UserHandle.getCallingUserId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Launcher</code>到AMS调用过程的时序图。</p><img src="/2019/09/02/Andorid深入理解四大组件-01：应用程序启动过程（上）/Vekw7t.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前面介绍了Android系统启动过程和应用程序进程启动过程。下面再来看看Android应用程序启动过程，即Activity的启动过程。基于A
      
    
    </summary>
    
      <category term="Android进阶" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
      <category term="框架层" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/"/>
    
      <category term="深入理解四大组件" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/"/>
    
    
      <category term="四大组件" scheme="https://tylerLiu.top/tags/%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Android应用程序进程启动过程 02</title>
    <link href="https://tylerLiu.top/2019/08/31/Android%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B02/"/>
    <id>https://tylerLiu.top/2019/08/31/Android应用程序进程启动过程02/</id>
    <published>2019-08-31T02:42:53.000Z</published>
    <updated>2019-09-11T08:04:12.244Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面讲到Android应用程序进程启动的过程，留下了一点：在应用程序进程创建过程中会启动Binder创建线程池以及在应用程序进程启动后会创建消息循环。</p><h1 id="1-Binder线程池启动过程"><a href="#1-Binder线程池启动过程" class="headerlink" title="1. Binder线程池启动过程"></a>1. Binder线程池启动过程</h1><p><code>RuntimeInit</code>的<code>zygoteInit()</code>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">zygoteInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"RuntimeInit: Starting application from zygote"</span>);</span><br><span class="line">  Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"RuntimeInit"</span>);</span><br><span class="line">  redirectLogStreams();</span><br><span class="line">  commonInit();</span><br><span class="line">  nativeZygoteInit(); <span class="comment">// 1</span></span><br><span class="line">  applicationInit(targetSdkVersion, argv, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，在新创建的应用程序进程中创建Binder线程池，来看看<code>nativeZygoteInit()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeZygoteInit</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p><code>nativeZygoteInit()</code>是一个jni方法，在AndoridRuntime.cpp中，<code>JNINativeMethod</code>数组中得知它对应的函数是<code>com_android_internal_os_RuntimeInit_nativeZygoteInit</code>：frameworks/base/core/jni/AndroidRuntime.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> JNINativeMethod gMethods[] = &#123;</span><br><span class="line">    &#123; <span class="string">"nativeFinishInit"</span>, <span class="string">"()V"</span>,</span><br><span class="line">        (<span class="keyword">void</span>*) com_android_internal_os_RuntimeInit_nativeFinishInit &#125;,</span><br><span class="line">    &#123; <span class="string">"nativeZygoteInit"</span>, <span class="string">"()V"</span>,</span><br><span class="line">        (<span class="keyword">void</span>*) com_android_internal_os_RuntimeInit_nativeZygoteInit &#125;,</span><br><span class="line">    &#123; <span class="string">"nativeSetExitWithoutCleanup"</span>, <span class="string">"(Z)V"</span>,</span><br><span class="line">        (<span class="keyword">void</span>*) com_android_internal_os_RuntimeInit_nativeSetExitWithoutCleanup &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面看看<code>com_android_internal_os_RuntimeInit_nativeZygoteInit()</code>：frameworks/base/core/jni/AndroidRuntime.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">com_android_internal_os_RuntimeInit_nativeZygoteInit</span><span class="params">(JNIEnv* env, jobject clazz)</span> </span>&#123;</span><br><span class="line">    gCurRuntime-&gt;onZygoteInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gCurRuntime</code>在<code>AndoridRuntime</code>初始化就创建了：frameworks/base/core/jni/AndroidRuntime.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AndroidRuntime::AndroidRuntime(<span class="keyword">char</span>* argBlockStart, <span class="keyword">const</span> <span class="keyword">size_t</span> argBlockLength) :</span><br><span class="line">        mExitWithoutCleanup(<span class="literal">false</span>),</span><br><span class="line">        mArgBlockStart(argBlockStart),</span><br><span class="line">        mArgBlockLength(argBlockLength) &#123;</span><br><span class="line">   ...</span><br><span class="line">    gCurRuntime = <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<a href="https://tylerliu.top/2019/08/27/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B02%EF%BC%9Azygote%E8%BF%9B%E7%A8%8B/#more">Android系统启动流程 02：zygote进程</a>中，得知<code>AppRuntime</code>继承<code>AndroidRuntime</code>，<code>AppRuntime</code>创建时会调用<code>AndroidRuntime</code>的构造函数，<code>gCurRuntime</code>就会被初始化，它指向的是<code>AppRuntime</code>，所以下面来查看<code>AppRunTime</code>的<code>onZygoteInit()</code>，<code>AppRuntime</code>的实现在app_main.cpp中：frameworks/base/cmds/app_process/app_main.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onZygoteInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sp&lt;ProcessState&gt; proc = ProcessState::self();</span><br><span class="line">    ALOGV(<span class="string">"App process: starting thread pool.\n"</span>);</span><br><span class="line">    proc-&gt;startThreadPool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一行会调用<code>ProcessState</code>的<code>startThreadPool()</code>：frameworks/native/libs/binder/ProcessState.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ProcessState::startThreadPool() &#123;</span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line">    <span class="keyword">if</span> (!mThreadPoolStarted) &#123;</span><br><span class="line">        mThreadPoolStarted = <span class="literal">true</span>;</span><br><span class="line">        spawnPooledThread(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>支持Binder通信的进程中都有一个<code>ProcessState</code>类，它里面有一个<code>mThreadPoolState</code>变量，来表示Binder线程池是否已经被启动过，默认值为<code>false</code>。每次调用这个函数前会先检查这个标记，确保binder线程池只会被启动一次。如果Binder线程池未设置<code>mThreadPoolState</code>为<code>true</code>，最后会调用<code>spawwnPooledThread()</code>来创建线程池中的第一个线程，即线程池中的main线程。frameworks/native/libs/binder/ProcessState.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ProcessState::spawnPooledThread(<span class="keyword">bool</span> isMain) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mThreadPoolStarted) &#123;</span><br><span class="line">        String8 name = makeBinderThreadName();</span><br><span class="line">        ALOGV(<span class="string">"Spawning new pooled thread, name=%s\n"</span>, name.<span class="built_in">string</span>());</span><br><span class="line">        sp&lt;Thread&gt; t = <span class="keyword">new</span> PoolThread(isMain);</span><br><span class="line">        t-&gt;run(name.<span class="built_in">string</span>()); <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到Binder线程为一个<code>PoolThread</code>。注释1，调用<code>PoolThread</code>的<code>run()</code>来启动一个新的线程。看看<code>PoolThread</code>类：frameworks/native/libs/binder/ProcessState.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PoolThread</span> :</span> <span class="keyword">public</span> Thread &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">threadLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            IPCThreadState::self()-&gt;joinThreadPool(mIsMain); <span class="comment">// 1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">bool</span> mIsMain;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>PoolThread</code>继承了<code>Thread</code>。注释1，调用<code>IPCThreadState</code>的<code>joinThreadPool()</code>函数，将当前线程注册到Binder驱动程序中，这样创建的线程就加入了Binder线程池中，新创建的应用程序线程也就支持Binder线程间通信。</p><h1 id="2-消息循环创建过程"><a href="#2-消息循环创建过程" class="headerlink" title="2. 消息循环创建过程"></a>2. 消息循环创建过程</h1><p>上篇最后讲到<code>RuntimeInit</code>的<code>invokeStaticMain()</code>：frameworks/base/core/java/com/android/internal/os/RuntimeInit.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeStaticMain</span><span class="params">(String className, String[] argv, ClassLoader classLoader)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line">    Class&lt;?&gt; cl;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteInit.MethodAndArgsCaller(m, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在最后会抛出<code>MethodAndArgsCaller()</code>异常，这个异常会被<code>ZygoteInit</code>的<code>main()</code>捕获：frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">     ...</span><br><span class="line">  &#125; <span class="keyword">catch</span> (MethodAndArgsCaller caller) &#123;</span><br><span class="line">      caller.run(); <span class="comment">// 1</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">      Log.e(TAG, <span class="string">"Zygote died with exception"</span>, ex);</span><br><span class="line">      closeServerSocket();</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，捕获<code>MethodAndArgsCaller</code>时会执行<code>caler</code>的<code>run()</code>：frameworks/base/core/java/com/android/internal/os/RuntimeInit.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAndArgsCaller</span> <span class="keyword">extends</span> <span class="title">Exception</span></span></span><br><span class="line"><span class="class">       <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Method mMethod;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> String[] mArgs;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">MethodAndArgsCaller</span><span class="params">(Method method, String[] args)</span> </span>&#123;</span><br><span class="line">       mMethod = method;</span><br><span class="line">       mArgs = args;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           mMethod.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[] &#123; mArgs &#125;); <span class="comment">// 1</span></span><br><span class="line">       &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">       &#125;</span><br><span class="line">       ...</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上一篇得知，<code>mMethod</code>指的就是<code>ActivityThread</code>的<code>main()</code>，<code>mArgs</code>指的是应用程序进程的启动参数。在注释1调用了<code>ActivityThread</code>的<code>main()</code>：frameworks/base/core/java/android/app/ActivityThread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"ActivityThreadMain"</span>);</span><br><span class="line">    SamplingProfilerIntegration.start();</span><br><span class="line">    ...</span><br><span class="line">    Looper.prepareMainLooper(); <span class="comment">// 1</span></span><br><span class="line">    ActivityThread thread = <span class="keyword">new</span> ActivityThread(); <span class="comment">// 2</span></span><br><span class="line">    thread.attach(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">        Looper.myLooper().setMessageLogging(<span class="keyword">new</span></span><br><span class="line">                LogPrinter(Log.DEBUG, <span class="string">"ActivityThread"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    Looper.loop(); <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，在当前应用程序进程中创建消息循环。</p><p>注释2，创建<code>ActivityThread</code>。</p><p>注释3，调用<code>Looper</code>的<code>loop()</code>，是的<code>Looper</code>开始处理消息。</p><p>系统在应用程序进程启动完成后，就会创建一个消息循环，用来方便的使用Android消息处理机制。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前面讲到Android应用程序进程启动的过程，留下了一点：在应用程序进程创建过程中会启动Binder创建线程池以及在应用程序进程启动后会创建
      
    
    </summary>
    
      <category term="Android进阶" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
      <category term="框架层" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/"/>
    
      <category term="应用进程启动流程" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    
    
      <category term="Android系统启动" scheme="https://tylerLiu.top/tags/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>Android应用程序进程启动过程 01</title>
    <link href="https://tylerLiu.top/2019/08/30/Android%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B01/"/>
    <id>https://tylerLiu.top/2019/08/30/Android应用程序进程启动过程01/</id>
    <published>2019-08-30T02:44:38.000Z</published>
    <updated>2019-09-11T08:04:09.862Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-应用程序进程概述"><a href="#1-应用程序进程概述" class="headerlink" title="1. 应用程序进程概述"></a>1. 应用程序进程概述</h1><p>要启动一个应用程序，首先要保证这个应用程序所需要的应用程序进程已经启动，<code>ActivityManagerService</code>在启动应用程序时会先检查这个应用程序对应的进程是否已经存在，如果不存在，就请求Zygote进程将需要的应用程序进程启动。</p><p>在<a href="https://tylerliu.top/2019/08/27/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B02%EF%BC%9Azygote%E8%BF%9B%E7%A8%8B/#more">Android系统启动流程 02：zygote进程</a>中，提到Zygote的Java框架中，会创建一个服务端的Socket，用来等待<code>ActivityManagerService</code>来请求Zygote创建一个新的应用程序进程。Zygote进程通过fock自身创建的应用程序进程，这样应用程序进程就会获得Zygote进程在启动时创建的虚拟机实例。在应用程序创建过程中，除了获取虚拟机实例，还可以获得Binder线程池和循环消息，这样运行应用程序进程中的应用程序就可以使用Binder进行进程间通信和消息处理机制。</p><p>Binder线程池如何启动和创建会在后面介绍。</p><p>应用程序进程启动过程时序图：</p><img src="/2019/08/30/Android应用程序进程启动过程01/Vev4cq.png"><h1 id="2-应用程序进程创建过程"><a href="#2-应用程序进程创建过程" class="headerlink" title="2. 应用程序进程创建过程"></a>2. 应用程序进程创建过程</h1><h2 id="2-1-发送创建应用程序进程请求"><a href="#2-1-发送创建应用程序进程请求" class="headerlink" title="2.1 发送创建应用程序进程请求"></a>2.1 发送创建应用程序进程请求</h2><p><code>ActivityManagerService</code>会通过调用<code>startProcessLocked()</code>向Zygote进程发送请求：frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startProcessLocked</span><span class="params">(ProcessRecord app, String hostingType,</span></span></span><br><span class="line"><span class="function"><span class="params">        String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> userId = UserHandle.getUserId(app.uid);</span><br><span class="line">                AppGlobals.getPackageManager().checkPackageStartable(app.info.packageName, userId);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e.rethrowAsRuntimeException();</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">int</span> uid = app.uid; <span class="comment">// 1</span></span><br><span class="line">            <span class="keyword">int</span>[] gids = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">int</span> mountExternal = Zygote.MOUNT_EXTERNAL_NONE;</span><br><span class="line">            <span class="keyword">if</span> (!app.isolated) &#123;</span><br><span class="line">              ...</span><br><span class="line">               <span class="comment">/**</span></span><br><span class="line"><span class="comment">                * 2 对gids进行创建和赋值</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> (ArrayUtils.isEmpty(permGids)) &#123;</span><br><span class="line">                    gids = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    gids = <span class="keyword">new</span> <span class="keyword">int</span>[permGids.length + <span class="number">2</span>];</span><br><span class="line">                    System.arraycopy(permGids, <span class="number">0</span>, gids, <span class="number">2</span>, permGids.length);</span><br><span class="line">                &#125;</span><br><span class="line">                gids[<span class="number">0</span>] = UserHandle.getSharedAppGid(UserHandle.getAppId(uid));</span><br><span class="line">                gids[<span class="number">1</span>] = UserHandle.getUserGid(UserHandle.getUserId(uid));</span><br><span class="line">            &#125;</span><br><span class="line">         </span><br><span class="line">           ...</span><br><span class="line">            <span class="keyword">if</span> (entryPoint == <span class="keyword">null</span>) entryPoint = <span class="string">"android.app.ActivityThread"</span>; <span class="comment">// 3</span></span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"Start proc: "</span> +</span><br><span class="line">                    app.processName);</span><br><span class="line">            checkTime(startTime, <span class="string">"startProcess: asking zygote to start proc"</span>);</span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 4</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            Process.ProcessStartResult startResult = Process.start(entryPoint,</span><br><span class="line">                    app.processName, uid, uid, gids, debugFlags, mountExternal,</span><br><span class="line">                    app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet,</span><br><span class="line">                    app.info.dataDir, entryPointArgs);</span><br><span class="line">           ...</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，创建应用程序进程的用户ID。</p><p>注释2，对用户组ID——<code>gids</code>进行创建和赋值。</p><p>注释3，如果<code>entryPoint</code>为<code>null</code>，则赋值为<code>&quot;android.app.ActivityThread&quot;</code>。</p><p>注释4，调用<code>Process</code>的<code>start()</code>，将此前得到的应用程序进程用户ID和用户组ID传入，第一个参数<code>entryPoint</code>就是前面赋值的<code>&quot;android.app.ActivityThread&quot;</code>，后面会介绍。</p><p>下面看看<code>Process</code>的<code>start()</code>：frameworks/base/core/java/android/os/Process.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ProcessStartResult <span class="title">start</span><span class="params">(<span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> debugFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> targetSdkVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String seInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String abi,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String appDataDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String[] zygoteArgs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> startViaZygote(processClass, niceName, uid, gid, gids,</span><br><span class="line">                debugFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">                abi, instructionSet, appDataDir, zygoteArgs);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ZygoteStartFailedEx ex) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在里面只调用了<code>startViaZygote()</code>：frameworks/base/core/java/android/os/Process.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ProcessStartResult <span class="title">startViaZygote</span><span class="params">(<span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">final</span> <span class="keyword">int</span> uid, <span class="keyword">final</span> <span class="keyword">int</span> gid,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">final</span> <span class="keyword">int</span>[] gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> debugFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> targetSdkVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String seInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String abi,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String appDataDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String[] extraArgs)</span></span></span><br><span class="line"><span class="function">                              <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(Process.class) &#123;</span><br><span class="line">        <span class="comment">// 1</span></span><br><span class="line">        ArrayList&lt;String&gt; argsForZygote = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        argsForZygote.add(<span class="string">"--runtime-args"</span>);</span><br><span class="line">        argsForZygote.add(<span class="string">"--setuid="</span> + uid);</span><br><span class="line">        argsForZygote.add(<span class="string">"--setgid="</span> + gid);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (gids != <span class="keyword">null</span> &amp;&amp; gids.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            sb.append(<span class="string">"--setgroups="</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> sz = gids.length;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                    sb.append(<span class="string">','</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                sb.append(gids[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            argsForZygote.add(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        argsForZygote.add(processClass);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (extraArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String arg : extraArgs) &#123;</span><br><span class="line">                argsForZygote.add(arg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，创建<code>argsForZygote</code>，并将启动应用程序进程的参数保存在其中。<code>startViaZygote()</code>最后调用了<code>zygoteSendArgsAndGetResult()</code>，其中第一个参数调用了<code>openZygoteSocketIfNeeded()</code>，第二个参数是<code>argsForZygote</code>。</p><p><code>zygoteSendArgsAndGetResult()</code>如下：frameworks/base/core/java/android/os/Process.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ProcessStartResult <span class="title">zygoteSendArgsAndGetResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ZygoteState zygoteState, ArrayList&lt;String&gt; args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = args.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (args.get(i).indexOf(<span class="string">'\n'</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"embedded newlines not allowed"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> BufferedWriter writer = zygoteState.writer;</span><br><span class="line">        <span class="keyword">final</span> DataInputStream inputStream = zygoteState.inputStream;</span><br><span class="line">        writer.write(Integer.toString(args.size()));</span><br><span class="line">        writer.newLine();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            String arg = args.get(i);</span><br><span class="line">            writer.write(arg);</span><br><span class="line">            writer.newLine();</span><br><span class="line">        &#125;</span><br><span class="line">        writer.flush();</span><br><span class="line">        ProcessStartResult result = <span class="keyword">new</span> ProcessStartResult();</span><br><span class="line">        result.pid = inputStream.readInt();</span><br><span class="line">        result.usingWrapper = inputStream.readBoolean();</span><br><span class="line">        <span class="keyword">if</span> (result.pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"fork() failed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        zygoteState.close();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法主要是将传入的<code>argsForZygote</code>写入到<code>ZygoteState</code>中，而<code>ZygoteState</code>是由<code>openZygoteSocketIfNeeded()</code>返回的：frameworks/base/core/java/android/os/Process.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ZygoteState <span class="title">openZygoteSocketIfNeeded</span><span class="params">(String abi)</span> <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (primaryZygoteState == <span class="keyword">null</span> || primaryZygoteState.isClosed()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            primaryZygoteState = ZygoteState.connect(ZYGOTE_SOCKET); <span class="comment">// 1</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"Error connecting to primary zygote"</span>, ioe);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (primaryZygoteState.matches(abi)) &#123; <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">return</span> primaryZygoteState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (secondaryZygoteState == <span class="keyword">null</span> || secondaryZygoteState.isClosed()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        secondaryZygoteState = ZygoteState.connect(SECONDARY_ZYGOTE_SOCKET); <span class="comment">// 3</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"Error connecting to secondary zygote"</span>, ioe);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (secondaryZygoteState.matches(abi)) &#123;</span><br><span class="line">        <span class="keyword">return</span> secondaryZygoteState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"Unsupported zygote ABI: "</span> + abi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Zygote进程启动过程中，Zygote的<code>main()</code>会创建<code>name</code>为<code>&quot;zygote&quot;</code>的服务端Socket。</p><p>注释1，调用<code>ZygoteState</code>的<code>connect()</code>与名称为<code>ZYGOE_STOCKET</code>的Stoccket建立连接，这里<code>ZYGOE_STOCKET</code>的值为<code>zygote</code>。</p><p>注释2，如果连接<code>name</code>为<code>zygote</code>的Socket返回的<code>primaryZygoteState</code>与当前的<code>abi</code>不匹配，则会在注释3处连接<code>name</code>为<code>zygote_secondary</code>的Socket。</p><p>这两个Socket的区别是：<code>name</code>为<code>zygote</code>的Socket是运行在64位Zygote进程中，而<code>name</code>为<code>zygote_secondary</code>的Socket是运行在32位Zygote进程中。既然应用程序进程是通过Zygote进程fock产生的，当要连接Zygote中的Socket时，也需要保证位数的一致。</p><h2 id="2-2-接收请求并创建应用程序进程"><a href="#2-2-接收请求并创建应用程序进程" class="headerlink" title="2.2 接收请求并创建应用程序进程"></a>2.2 接收请求并创建应用程序进程</h2><p>Socket进行连接成功并匹配<code>abi</code>后会返回<code>ZygoteState</code>类型对象，在<code>zygoteSendArgsAndGetResult()</code>中讲过，会将应用程序进程的启动参数<code>argsForZygote</code>写入到<code>ZygoteState</code>中，这样Zygote进程就会收到一个创建新的应该程序进程的请求，回到<code>ZygoteInit</code>的<code>main()</code>：frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">     ...       </span><br><span class="line">        <span class="comment">// 注册Zygote用的Socket</span></span><br><span class="line">        registerZygoteSocket(socketName);  <span class="comment">// 1</span></span><br><span class="line">       ...</span><br><span class="line">       <span class="comment">// 预加载类和资源</span></span><br><span class="line">       preload(); <span class="comment">// 2</span></span><br><span class="line">       ...</span><br><span class="line">        <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">        <span class="comment">// 启动SystemServer进程</span></span><br><span class="line">            startSystemServer(abiList, socketName); <span class="comment">// 3</span></span><br><span class="line">        &#125;</span><br><span class="line">        Log.i(TAG, <span class="string">"Accepting command socket connections"</span>);</span><br><span class="line">        <span class="comment">// 等待客户端请求</span></span><br><span class="line">        runSelectLoop(abiList); <span class="comment">// 4</span></span><br><span class="line">        closeServerSocket();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MethodAndArgsCaller caller) &#123;</span><br><span class="line">        caller.run();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"Zygote died with exception"</span>, ex);</span><br><span class="line">        closeServerSocket();</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些内容在<a href="https://tylerliu.top/2019/08/27/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B02%EF%BC%9Azygote%E8%BF%9B%E7%A8%8B/#more">Android系统启动流程 02：zygote进程</a>中已经讲过。</p><p>注释1，通过<code>registerZygoteSocket()</code>创建一个服务端的Socket，这个<code>name</code>为<code>zygote</code>的Socket用来等待<code>ActivityManagerService</code>来请求Zygote进程创建新的应用程序进程。</p><p>注释2，预加载类和资源。</p><p>注释3，启动SystemServer进程，这样系统的关键服务也会由SystemServer进程启动起来。</p><p>注释4，调用<code>runSelectLoop()</code>等待<code>ActivityManagerService</code>的请求。</p><p>现在看看<code>runSelectLoop()</code>：frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runSelectLoop</span><span class="params">(String abiList)</span> <span class="keyword">throws</span> MethodAndArgsCaller </span>&#123;</span><br><span class="line">   ArrayList&lt;FileDescriptor&gt; fds = <span class="keyword">new</span> ArrayList&lt;FileDescriptor&gt;();</span><br><span class="line">   ArrayList&lt;ZygoteConnection&gt; peers = <span class="keyword">new</span> ArrayList&lt;ZygoteConnection&gt;(); <span class="comment">// 2</span></span><br><span class="line">   fds.add(sServerSocket.getFileDescriptor());</span><br><span class="line">   peers.add(<span class="keyword">null</span>);</span><br><span class="line">   <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">   ...</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = pollFds.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">           <span class="keyword">if</span> ((pollFds[i].revents &amp; POLLIN) == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">               ZygoteConnection newPeer = acceptCommandPeer(abiList);</span><br><span class="line">               peers.add(newPeer);</span><br><span class="line">               fds.add(newPeer.getFileDesciptor());</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">boolean</span> done = peers.get(i).runOnce(); <span class="comment">// 1</span></span><br><span class="line">               <span class="keyword">if</span> (done) &#123;</span><br><span class="line">                   peers.remove(i);</span><br><span class="line">                   fds.remove(i);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当有<code>ActivityManagerService</code>的请求数据到来时，会调用注释1的代码，结合注释2的代码，可以得知注释1的代码实际是调用<code>ZygoteCConnection</code>的<code>runOnce()</code>用来处理请求的数据：frameworks/base/core/java/com/android/internal/os/ZygoteConnection.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">runOnce</span><span class="params">()</span> <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line">    String args[];</span><br><span class="line">    Arguments parsedArgs = <span class="keyword">null</span>;</span><br><span class="line">    FileDescriptor[] descriptors;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        args = readArgumentList(); <span class="comment">// 1</span></span><br><span class="line">        descriptors = mSocket.getAncillaryFileDescriptors();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"IOException on command socket "</span> + ex.getMessage());</span><br><span class="line">        closeSocket();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        parsedArgs = <span class="keyword">new</span> Arguments(args); <span class="comment">// 2</span></span><br><span class="line">    ...</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 3</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,</span><br><span class="line">                parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,</span><br><span class="line">                parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet,</span><br><span class="line">                parsedArgs.appDataDir);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">      ....</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// in child</span></span><br><span class="line">            IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">            serverPipeFd = <span class="keyword">null</span>;</span><br><span class="line">            handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// in parent...pid of &lt; 0 means failure</span></span><br><span class="line">            IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">            childPipeFd = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">        IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，调用<code>readArgumentList()</code>获取应用程序进程的启动参数。</p><p>注释2，将<code>readArgumentList()</code>返回的字符串封装到<code>Arguments</code>的对象<code>parsedArgs</code>中。</p><p>注释3，调用<code>Zygote</code>的<code>forkAndSpecialize()</code>来创建应用程序进程，参数为<code>paresedArgs</code>中存储的应用程序进程启动参数，返回值为<code>pid</code>。<code>forkAndSpecialize()</code>主要是通过fork当前进程来创建一个子进程的，如果<code>pid</code>为0，表示在创建新的子进程中执行，就会调用<code>handleChildProc()</code>来启动这个子进程，即应用程序进程：frameworks/base/core/java/com/android/internal/os/ZygoteConnection.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleChildProc</span><span class="params">(Arguments parsedArgs,</span></span></span><br><span class="line"><span class="function"><span class="params">       FileDescriptor[] descriptors, FileDescriptor pipeFd, PrintStream newStderr)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">       RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion,</span><br><span class="line">               parsedArgs.remainingArgs, <span class="keyword">null</span> <span class="comment">/* classLoader */</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>handleChildProc()</code>中调用了<code>RutimeInit</code>的<code>zygoteInit()</code>：frameworks/base/core/java/com/android/internal/os/RuntimeInit.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">zygoteInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"RuntimeInit: Starting application from zygote"</span>);</span><br><span class="line">  Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"RuntimeInit"</span>);</span><br><span class="line">  redirectLogStreams();</span><br><span class="line">  commonInit();</span><br><span class="line">  nativeZygoteInit(); <span class="comment">// 1</span></span><br><span class="line">  applicationInit(targetSdkVersion, argv, classLoader); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，在新创建的应用程序进程中创建Binder线程池，这个会在后面详细介绍。</p><p>注释2，带哟<code>applicationInit()</code>：frameworks/base/core/java/com/android/internal/os/RuntimeInit.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">applicationInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">   <span class="keyword">final</span> Arguments args;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       args = <span class="keyword">new</span> Arguments(argv);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">       Slog.e(TAG, ex.getMessage());</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">   invokeStaticMain(args.startClass, args.startArgs, classLoader); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，调用<code>invlkeStaticMain()</code>，第一个参数是<code>args.startClass</code>，这里指的就是文章开头的参数<code>&quot;android.app.ActivityThread&quot;</code>。下面卡看看<code>invlkeStaticMain()</code>：frameworks/base/core/java/com/android/internal/os/RuntimeInit.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeStaticMain</span><span class="params">(String className, String[] argv, ClassLoader classLoader)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line">    Class&lt;?&gt; cl;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cl = Class.forName(className, <span class="keyword">true</span>, classLoader); <span class="comment">// 1</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Missing class when invoking static main "</span> + className,</span><br><span class="line">                ex);</span><br><span class="line">    &#125;</span><br><span class="line">    Method m;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        m = cl.getMethod(<span class="string">"main"</span>, <span class="keyword">new</span> Class[] &#123; String[].class &#125;); <span class="comment">// 2</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Missing static main on "</span> + className, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteInit.MethodAndArgsCaller(m, argv); <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，通过反射得到<code>android.app.ActivityThread</code>类。</p><p>注释2，获得<code>ActivityThread</code>的<code>main()</code>，并将<code>main()</code>传入到注释3的<code>ZygoteInit</code>中<code>MethodAndArgsCaller</code>类的构造函数中，<code>MethodAndArgsCaller</code>类内部会通过反射，调用<code>ActivityThread</code>的<code>main()</code>，这样应用程序进程就创建完成了，并且运行了代表主线程的实例<code>ActivityThread</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-应用程序进程概述&quot;&gt;&lt;a href=&quot;#1-应用程序进程概述&quot; class=&quot;headerlink&quot; title=&quot;1. 应用程序进程概述&quot;&gt;&lt;/a&gt;1. 应用程序进程概述&lt;/h1&gt;&lt;p&gt;要启动一个应用程序，首先要保证这个应用程序所需要的应用程序进程已经启动，
      
    
    </summary>
    
      <category term="Android进阶" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
      <category term="框架层" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/"/>
    
      <category term="应用进程启动流程" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    
    
      <category term="Android系统启动" scheme="https://tylerLiu.top/tags/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>Android AOSP 03：Android系统源码的整编和单编</title>
    <link href="https://tylerLiu.top/2019/08/29/Android-AOSP03%EF%BC%9AAndroid%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%9A%84%E6%95%B4%E7%BC%96%E5%92%8C%E5%8D%95%E7%BC%96/"/>
    <id>https://tylerLiu.top/2019/08/29/Android-AOSP03：Android系统源码的整编和单编/</id>
    <published>2019-08-29T05:51:29.000Z</published>
    <updated>2019-09-11T08:03:35.253Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面已经将Android系统源码下载下来，但是往往，不止要查看源码，有时还需要：</p><ul><li>动态调试Android系统源码</li><li>定制Android系统</li><li>将最新版本的Android系统刷入到自己的Android设备中</li><li>将系统源码导入到Android Studio中</li></ul><p>为了实现这些需求，就需要去编译系统源码。</p><h1 id="1-编译系统概述"><a href="#1-编译系统概述" class="headerlink" title="1. 编译系统概述"></a>1. 编译系统概述</h1><p>需要了解的概念。</p><ul><li>Makefile：Android平台的编译系统，其实就是用Makefile写出来的一个独立项目。它定义了编译的规则，实现“自动化编译”<br>，不仅将分散在数百个Git库中的代码整合起来、统一编译，而且还把产物分门别类的输出到一个目录，打包成手机的ROM，还可以生成应用开发时所使用的SDK、NDK等。因此，采用Makefile编写的编译系统，也可称为Makefile编译系统。</li><li>Andorid.mk：Makefile编译系统的一部分，定义了一个模块的必要参数，使模块随着平台编译。通俗来讲就是告诉编译系统，以什么样的规则编译源代码，并生成对应的目标文件。</li><li>Ninja：是一个致力于速度的小型编译系统，如果把其他的编译系统看作高级语言，那么Ninja目标就是汇编。</li><li>Soong：使谷歌用来替代此前的Makefile编译系统的替代品，负责解析Andorid.bp文件，并将之转换为Ninja文件。</li><li>Blueprint：用来解析Andorid.bp文件翻译成Ninja语法文件。</li><li>kati：谷歌专门为Android开发的一个小项目，基于Golang和C++。目的是把Android中的Makefile转化为Ninja文件。</li><li>Android.bp：用来替代Android.mk的配置文件。</li></ul><p>Android.mk、Ninja、Soong、kati、Andorid.bp的联系如下：</p><img src="/2019/08/29/Android-AOSP03：Android系统源码的整编和单编/VZRxYQ.png"><p>Blueprint负责解析Android.bp文件内容，Blueprint类似一个处理相关语法的库文件，Soong则是定义具体如何处理相应的语法以及命令实现。通俗来讲就是Soong借助于Blueprint定义的Android.bp语法，完成Android.bp的解析，最终转化成Ninja文件。</p><p>Makefile会通过kati转化为Nanja文件。</p><p>随着Android工程越来越大，采用Makefile的编译系统花费的时间越来越长，因此谷歌在Android 7.0 开始引入Ninja来编译系统，相对于Makefile，Ninja在大的项目管理中速度和并行方面有优势。</p><p>Makefile默认文件名为Makefile或makefile，也常用.make或.mk作为文件后缀。Ninja的默认文件名为build.ninja，其他文件以.ninja为后缀。Makefile与Ninja的区别在于，Makefile是设计来给开发编写的，而Ninja设计出来是给其他程序生成的。如果Makefile是Java语言，那么Ninja就是汇编语言。</p><h1 id="2-编译源码的方式"><a href="#2-编译源码的方式" class="headerlink" title="2. 编译源码的方式"></a>2. 编译源码的方式</h1><p>Android系统源码编译主要有以下几种方式：</p><ul><li>在Linux中直接进行系统源码编译（Android官方支持）</li><li>在Mac OS中直接进行系统源码编译（Android官方支持）</li><li>使用<a href="https://www.docker.com/products" target="_blank" rel="noopener">Docker</a>编译，支持Mac OS和Windows</li></ul><p>Docker支持的最低版本为Win7，建议在Win10下使用，因为Win7要借助Docker Toolbox和VritualBox中的容器进行通信，效率低。</p><p>本文在Linux中直接进行系统源码编译。</p><h1 id="3-编译环境"><a href="#3-编译环境" class="headerlink" title="3. 编译环境"></a>3. 编译环境</h1><h2 id="3-1-安装jdk8"><a href="#3-1-安装jdk8" class="headerlink" title="3.1 安装jdk8"></a>3.1 安装jdk8</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install openjdk-8-jdk</span><br></pre></td></tr></table></figure><h2 id="3-2-使用Ubuntu-14-，需要安装以下依赖包："><a href="#3-2-使用Ubuntu-14-，需要安装以下依赖包：" class="headerlink" title="3.2 使用Ubuntu 14+，需要安装以下依赖包："></a>3.2 使用Ubuntu 14+，需要安装以下依赖包：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git-core gnupg flex bison gperf build-essential zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z-dev ccache libgl1-mesa-dev libxml2-utils xsltproc unzip</span><br></pre></td></tr></table></figure><h2 id="3-3-设置处理器数量"><a href="#3-3-设置处理器数量" class="headerlink" title="3.3 设置处理器数量"></a>3.3 设置处理器数量</h2><p>设置 –&gt; 系统 –&gt; 处理器选项，设置为6。</p><h2 id="3-4-源码整编"><a href="#3-4-源码整编" class="headerlink" title="3.4 源码整编"></a>3.4 源码整编</h2><p>整编就是编译整个Android源码，整编主要有三个步骤：</p><h2 id="3-4-1-初始化环境：在AOSP根目录中，运行如下命令"><a href="#3-4-1-初始化环境：在AOSP根目录中，运行如下命令" class="headerlink" title="3.4.1. 初始化环境：在AOSP根目录中，运行如下命令"></a>3.4.1. 初始化环境：在AOSP根目录中，运行如下命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source build/envsetup.sh</span><br><span class="line">// 编译前删除build文件夹A</span><br><span class="line">// make clobber</span><br></pre></td></tr></table></figure><p>使用build目录中的envsetup.sh脚本初始化环境，这个脚本会引入其他的执行脚本。</p><h2 id="3-4-2-选择编译目标"><a href="#3-4-2-选择编译目标" class="headerlink" title="3.4.2. 选择编译目标"></a>3.4.2. 选择编译目标</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lunch</span><br></pre></td></tr></table></figure><p><code>lunch</code>命令是envsetup.sh中定义的一个命令，用来让用户选择编译目标。</p><p>会有以下信息输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">You&apos;re building on Linux</span><br><span class="line"></span><br><span class="line">Lunch menu... pick a combo:</span><br><span class="line">     1. aosp_arm-eng</span><br><span class="line">     2. aosp_arm64-eng</span><br><span class="line">     3. aosp_mips-eng</span><br><span class="line">     4. aosp_mips64-eng</span><br><span class="line">     5. aosp_x86-eng</span><br><span class="line">     6. aosp_x86_64-eng</span><br><span class="line">     7. aosp_car_arm-userdebug</span><br><span class="line">     8. aosp_car_arm64-userdebug</span><br><span class="line">     9. aosp_car_x86-userdebug</span><br><span class="line">     10. aosp_car_x86_64-userdebug</span><br><span class="line">     11. mini_emulator_arm64-userdebug</span><br><span class="line">     12. m_e_arm-userdebug</span><br><span class="line">     13. m_e_mips64-eng</span><br><span class="line">     14. m_e_mips-userdebug</span><br><span class="line">     15. mini_emulator_x86_64-userdebug</span><br><span class="line">     16. mini_emulator_x86-userdebug</span><br><span class="line">     17. uml-userdebug</span><br><span class="line">     18. aosp_cf_x86_auto-userdebug</span><br><span class="line">     19. aosp_cf_x86_phone-userdebug</span><br><span class="line">     20. aosp_cf_x86_tablet-userdebug</span><br><span class="line">     21. aosp_cf_x86_tablet_3g-userdebug</span><br><span class="line">     22. aosp_cf_x86_tv-userdebug</span><br><span class="line">     23. aosp_cf_x86_wear-userdebug</span><br><span class="line">     24. aosp_cf_x86_64_auto-userdebug</span><br><span class="line">     25. aosp_cf_x86_64_phone-userdebug</span><br><span class="line">     26. aosp_cf_x86_64_tablet-userdebug</span><br><span class="line">     27. aosp_cf_x86_64_tablet_3g-userdebug</span><br><span class="line">     28. aosp_cf_x86_64_tv-userdebug</span><br><span class="line">     29. aosp_cf_x86_64_wear-userdebug</span><br><span class="line">     30. cf_x86_auto-userdebug</span><br><span class="line">     31. cf_x86_phone-userdebug</span><br><span class="line">     32. cf_x86_tablet-userdebug</span><br><span class="line">     33. cf_x86_tablet_3g-userdebug</span><br><span class="line">     34. cf_x86_tv-userdebug</span><br><span class="line">     35. cf_x86_wear-userdebug</span><br><span class="line">     36. cf_x86_64_auto-userdebug</span><br><span class="line">     37. cf_x86_64_phone-userdebug</span><br><span class="line">     38. cf_x86_64_tablet-userdebug</span><br><span class="line">     39. cf_x86_64_tablet_3g-userdebug</span><br><span class="line">     40. cf_x86_64_tv-userdebug</span><br><span class="line">     41. cf_x86_64_wear-userdebug</span><br><span class="line">     42. aosp_marlin-userdebug</span><br><span class="line">     43. aosp_marlin_svelte-userdebug</span><br><span class="line">     44. aosp_sailfish-userdebug</span><br><span class="line">     45. aosp_walleye-userdebug</span><br><span class="line">     46. aosp_walleye_test-userdebug</span><br><span class="line">     47. aosp_taimen-userdebug</span><br><span class="line">     48. hikey-userdebug</span><br><span class="line">     49. hikey64_only-userdebug</span><br><span class="line">     50. hikey960-userdebug</span><br><span class="line"></span><br><span class="line">Which would you like? [aosp_arm-eng]</span><br></pre></td></tr></table></figure><p>意思是要选择编译目标的格式，编译目标的格式组成为BUILD_BUILDTYPE，比如<code>aosp_arm-eng</code>的BUILD为<code>aosp_arm</code>，BUILDTYPE为<code>eng</code>。</p><p>其中BUILD表示编译出的镜像可以运行在什么环境，<code>aosp</code>表示Android开源项目，<code>arm</code>表示系统是运行在ARM架构的处理器上。</p><p>更多可以参考<a href="https://source.android.google.cn/source/running.html#selecting-device-build" target="_blank" rel="noopener">官方文档</a>。</p><p>BUILDTYPE指的是编译类型，有以下三种：</p><ul><li><code>user</code>：用于正式发布到市场的版本，权限受限，如果没有root权限，不能debug，adb默认处于停用状态。</li><li><code>userdebug</code>：在user版本上开放了root权限和debug权限，adb默认处于停用状态。一般用于调试真机。</li><li><code>eng</code>：开发工程师版本，拥有最大的权限，具有额外调试工具的开发配置。一般用于模拟器。</li></ul><p>如果没有Nexus设备，只想在编译完成后，在模拟器上查看，那么BUILD可以选择<code>aosp_x86</code>，BUILDTYPE选择<code>eng</code>，直接在<code>Which would you like? [aosp_arm-eng]</code>后面输入对应的序号（这里是5）即可。</p><p>也可以直接指定编译的目标：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lunch aosp_x86-eng</span><br></pre></td></tr></table></figure><p>或者（不同的系统版本，序号的对应会有差别，建议不要直接用序号）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lunch 5</span><br></pre></td></tr></table></figure><h2 id="3-4-3-开始编译"><a href="#3-4-3-开始编译" class="headerlink" title="3.4.3. 开始编译"></a>3.4.3. 开始编译</h2><p>通过<code>-jN</code>参数来设置编译的并行任务数，以提高编译速度，此前设置的CPU核心数为6，这里的<code>N</code>值最好在6~12之间，这里设置8：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j6</span><br></pre></td></tr></table></figure><p>编译成功后会打印如下提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于采用的是虚拟机整编，编译速度会很慢。</p><p>最终会在out/target/product/generic_x86下生成三个重要的镜像文件：system.img、userdata.img、ramdisk.img。</p><ul><li>system.img：系统镜像，里面包含Andorid系统主要的目录和文件，通过init.rc解析并mount挂载到/system目录下。</li><li>userdata.img：用户镜像，Android系统中存放用户数据的，通过init.rc解析并mount挂载到/data目录下。</li><li>ramdisk.img：根文件系统镜像，包含一些启动Android系统的重要文件，如init.rc。</li></ul><p><strong>运行模拟器</strong></p><p>在编译完成之后，可以通过下面的命令运行Android虚拟机了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source build/envsetup.sh</span><br><span class="line">lunch 5</span><br><span class="line">emulator</span><br></pre></td></tr></table></figure><p>由于前面已经完成整编编译，即已经执行过<code>source</code>和<code>lunch</code>，所以这里直接执行<code>emulator</code>即可。</p><h2 id="3-5-源码单编"><a href="#3-5-源码单编" class="headerlink" title="3.5 源码单编"></a>3.5 源码单编</h2><p>比如要编译系统的Settings应用模块，在AOSP根目录执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source build/envsetup.sh</span><br><span class="line">lunch 5</span><br></pre></td></tr></table></figure><p>进入Settings目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd packages/apps/Settings</span><br></pre></td></tr></table></figure><p><code>mm</code>，编译当前目录下的模块，不编译依赖模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mm</span><br></pre></td></tr></table></figure><p>编译成功后会提示生成文件的存放路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前面已经将Android系统源码下载下来，但是往往，不止要查看源码，有时还需要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;动态调试Android系统源码&lt;
      
    
    </summary>
    
      <category term="Android进阶" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
      <category term="框架层" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/"/>
    
      <category term="AOSP" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/AOSP/"/>
    
    
      <category term="AOSP" scheme="https://tylerLiu.top/tags/AOSP/"/>
    
  </entry>
  
  <entry>
    <title>Android AOSP 02：AOSP源码下载</title>
    <link href="https://tylerLiu.top/2019/08/29/Android-AOSP02%EF%BC%9AAOSP%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD/"/>
    <id>https://tylerLiu.top/2019/08/29/Android-AOSP02：AOSP源码下载/</id>
    <published>2019-08-29T05:35:22.000Z</published>
    <updated>2019-09-11T08:03:33.312Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-关于AOSP"><a href="#1-关于AOSP" class="headerlink" title="1. 关于AOSP"></a>1. 关于AOSP</h1><p>AOSP就是Andorid系统源码，通过它可以定制Andorid操作系统。国内由于不可抗力，一般使用镜像。</p><ul><li><a href="https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/" target="_blank" rel="noopener">清华大学镜像站</a></li><li><a href="https://lug.ustc.edu.cn/wiki/mirrors/help/aosp" target="_blank" rel="noopener">中科大镜像站</a></li></ul><p>本文以清华大学镜像站为例。</p><h1 id="2-下载repo工具"><a href="#2-下载repo工具" class="headerlink" title="2. 下载repo工具"></a>2. 下载repo工具</h1><p>Andorid包含数百个Git库，要下载这么多Git库会很麻烦，谷歌开发了trpo，用于管理Android版本库的一个工具，使用Python对Git进行了封装，简化了多个Git版本库的管理。</p><p>安装Git，在Ubuntu命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure><p>创建bin，并添加到PATH中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/bin</span><br><span class="line">PATH=~/bin:$PATH</span><br></pre></td></tr></table></figure><p>安装curl库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install curl</span><br></pre></td></tr></table></figure><p>下载repo，并设置权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl https://mirrors.tuna.tsinghua.edu.cn/git/git-repo &gt; ~/bin/repo</span><br><span class="line">chmod a+x ~/bin/repo</span><br></pre></td></tr></table></figure><p>安装Python，repo初始化的时候会用到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python</span><br></pre></td></tr></table></figure><p>重启虚拟机后，开始下载源码。</p><h1 id="3-下载源码"><a href="#3-下载源码" class="headerlink" title="3. 下载源码"></a>3. 下载源码</h1><p>新建工作目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir aosp</span><br><span class="line">cd aosp</span><br></pre></td></tr></table></figure><p>repo的运行过程中会尝试访问官方的git源更新自己，如果想使用tuna的镜像源进行更新，可以将如下内容复制到你的~/.bashrc里，<br>.bashrc为隐藏文件，在home下按Ctrl + h就能打开隐藏文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export REPO_URL=&apos;https://mirrors.tuna.tsinghua.edu.cn/git/git-repo/&apos;</span><br></pre></td></tr></table></figure><p>为Git添加邮箱和用户名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email &quot;piratemorgen@gmail.com&quot;</span><br><span class="line">git config --global user.name &quot;piratemorgen&quot;</span><br></pre></td></tr></table></figure><p>初始化仓库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest</span><br></pre></td></tr></table></figure><p>初始化指定源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-9.0.0_r8</span><br></pre></td></tr></table></figure><p>同步源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo sync</span><br></pre></td></tr></table></figure><p>即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-关于AOSP&quot;&gt;&lt;a href=&quot;#1-关于AOSP&quot; class=&quot;headerlink&quot; title=&quot;1. 关于AOSP&quot;&gt;&lt;/a&gt;1. 关于AOSP&lt;/h1&gt;&lt;p&gt;AOSP就是Andorid系统源码，通过它可以定制Andorid操作系统。国内由于不可抗
      
    
    </summary>
    
      <category term="Android进阶" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
      <category term="框架层" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/"/>
    
      <category term="AOSP" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/AOSP/"/>
    
    
      <category term="AOSP" scheme="https://tylerLiu.top/tags/AOSP/"/>
    
  </entry>
  
  <entry>
    <title>Android AOSP 01：VM VirtualBox安装Ubuntu</title>
    <link href="https://tylerLiu.top/2019/08/29/Android-AOSP01%EF%BC%9AVM-VirtualBox%E5%AE%89%E8%A3%85Ubuntu/"/>
    <id>https://tylerLiu.top/2019/08/29/Android-AOSP01：VM-VirtualBox安装Ubuntu/</id>
    <published>2019-08-29T05:09:34.000Z</published>
    <updated>2019-09-11T08:03:31.315Z</updated>
    
    <content type="html"><![CDATA[<p>需要下载的两个文件：</p><ul><li><a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="noopener">virtualbox</a></li><li><a href="https://ubuntu.com/download/desktop" target="_blank" rel="noopener">Ubuntu</a></li></ul><p>具体的软件安装和Ubuntu的安装不再说明，这里在配置Ubuntu的虚拟硬盘时，因为要安装AOSP，所以建议配置200GB，内存4GB。</p><h1 id="安装增强工具"><a href="#安装增强工具" class="headerlink" title="安装增强工具"></a>安装增强工具</h1><p>方便虚拟机和主机之间的复制和粘贴。</p><p>设备 -&gt; 共享文件夹，新建一个共享文件夹，选择自动挂载和固定分配。</p><img src="/2019/08/29/Android-AOSP01：VM-VirtualBox安装Ubuntu/VZg0mT.png"><p>设备 -&gt; 安装增强功能，会在桌面生成一个VBox_GAs_6.0.10，点击运行软件，进行安装配置。</p><img src="/2019/08/29/Android-AOSP01：VM-VirtualBox安装Ubuntu/企业微信截图_15670560508763.png"><p>接着就会在桌面生成一个文件夹sf_share。</p><img src="/2019/08/29/Android-AOSP01：VM-VirtualBox安装Ubuntu/企业微信截图_156705615722.png"><p>通过它就能和主机之间进行文件共享了。</p><p>设备 -&gt; 共享粘贴板，设备 -&gt; 拖放，都选择双向。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;需要下载的两个文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.virtualbox.org/wiki/Downloads&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;virtualbox&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a hre
      
    
    </summary>
    
      <category term="Android进阶" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
      <category term="框架层" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/"/>
    
      <category term="AOSP" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/AOSP/"/>
    
    
      <category term="AOSP" scheme="https://tylerLiu.top/tags/AOSP/"/>
    
  </entry>
  
  <entry>
    <title>Android系统启动流程 04：Launcher启动过程和系统启动流程</title>
    <link href="https://tylerLiu.top/2019/08/28/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B04%EF%BC%9ALauncher%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    <id>https://tylerLiu.top/2019/08/28/Android系统启动流程04：Launcher启动过程和系统启动流程/</id>
    <published>2019-08-28T02:49:16.000Z</published>
    <updated>2019-09-11T08:04:03.815Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/08/28/Android系统启动流程04：Launcher启动过程和系统启动流程/VekSyj.jpg"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面介绍了init进程、Zygote进程和SystemServer进程的启动过程，现在看看Android系统启动的最后一步：Launcher的启动流程。</p><h1 id="1-Launcher概述"><a href="#1-Launcher概述" class="headerlink" title="1. Launcher概述"></a>1. Launcher概述</h1><p>Andorid系统启动的最后一步是启动一个Home应用程序，这个应用程序用来显示系统中已经安装的应用程序，这个Home程序就叫Launcher。应用程序Launcher在启动过程中会请求<code>PackageManagerService</code>返回系统已经安装的应用程序的信息，并将这些信息封装成一个快捷图标列表显示在系统屏幕上，这样用户就能通过点击这些图标来启动相应的应用程序。</p><h1 id="2-Launcher启动流程"><a href="#2-Launcher启动流程" class="headerlink" title="2. Launcher启动流程"></a>2. Launcher启动流程</h1><p>SystemServer进程启动的过程中会启动<code>PackagerManagerService</code>，<code>PackagerManagerService</code>启动后会将系统中的应用程序安装完成。此前已经启动的<code>ActivityManagerService</code>会将Launcher启动起来。</p><p>启动Launcher的入口为<code>ActiivtyManagerService</code>的<code>systemReady()</code>：frameworks/base/services/java/com/android/server/SystemServer.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startOtherServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> ...</span><br><span class="line">    mActivityManagerService.systemReady(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Slog.i(TAG, <span class="string">"Making services ready"</span>);</span><br><span class="line">                mSystemServiceManager.startBootPhase(</span><br><span class="line">                        SystemService.PHASE_ACTIVITY_MANAGER_READY);</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>startOtherServices()</code>中，会调用<code>ActivityManagerService</code>的<code>systemReady()</code>：frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">systemReady</span><span class="params">(<span class="keyword">final</span> Runnable goingCallback)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        mStackSupervisor.resumeFocusedStackTopActivityLocked();</span><br><span class="line">        mUserController.sendUserSwitchBroadcastsLocked(-<span class="number">1</span>, currentUserId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>systemReady()</code>中调用了<code>ActivityStackSupervisor</code>的<code>resumeFocusedStackTopActivityLocked()</code>：frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">resumeFocusedStackTopActivityLocked</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (targetStack != <span class="keyword">null</span> &amp;&amp; isFocusedStack(targetStack)) &#123;</span><br><span class="line">        <span class="keyword">return</span> targetStack.resumeTopActivityUncheckedLocked(target, targetOptions); <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> ActivityRecord r = mFocusedStack.topRunningActivityLocked();</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="keyword">null</span> || r.state != RESUMED) &#123;</span><br><span class="line">        mFocusedStack.resumeTopActivityUncheckedLocked(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，调用<code>ActivityStack</code>的<code>resumeTopActivityUncheckedLocked()</code>，<code>ActivityStack</code>对象是用来描述Activity堆栈的。<code>resumeTopActivityUncheckedLocked()</code>：frameworks/base/services/core/java/com/android/server/am/ActivityStack.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">resumeTopActivityUncheckedLocked</span><span class="params">(ActivityRecord prev, ActivityOptions options)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mStackSupervisor.inResumeTopActivity) &#123;</span><br><span class="line">        <span class="comment">// Don't even start recursing.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Protect against recursion.</span></span><br><span class="line">        mStackSupervisor.inResumeTopActivity = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (mService.mLockScreenShown == ActivityManagerService.LOCK_SCREEN_LEAVING) &#123;</span><br><span class="line">            mService.mLockScreenShown = ActivityManagerService.LOCK_SCREEN_HIDDEN;</span><br><span class="line">            mService.updateSleepIfNeededLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        result = resumeTopActivityInnerLocked(prev, options); <span class="comment">// 1</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mStackSupervisor.inResumeTopActivity = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，调用了<code>resumeTopActivityInnerLocked()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">resumeTopActivityInnerLocked</span><span class="params">(ActivityRecord prev, ActivityOptions options)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> isOnHomeDisplay() &amp;&amp;</span><br><span class="line">            mStackSupervisor.resumeHomeStackTask(returnTaskType, prev, <span class="string">"prevFinished"</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在里面调用了<code>ActivityStackSupervisor</code>的<code>resumeHomeStackTask()</code>：<br>frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">resumeHomeStackTask</span><span class="params">(<span class="keyword">int</span> homeStackTaskType, ActivityRecord prev, String reason)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span> &amp;&amp; !r.finishing) &#123;</span><br><span class="line">        mService.setFocusedActivityLocked(r, myReason);</span><br><span class="line">        <span class="keyword">return</span> resumeFocusedStackTopActivityLocked(mHomeStack, prev, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mService.startHomeActivityLocked(mCurrentUser, myReason); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，调用了<code>ActivityManagerService</code>的<code>startHomeActivityLocked()</code>：<br>frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startHomeActivityLocked</span><span class="params">(<span class="keyword">int</span> userId, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL</span><br><span class="line">            &amp;&amp; mTopAction == <span class="keyword">null</span>) &#123; <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Intent intent = getHomeIntent(); <span class="comment">// 2</span></span><br><span class="line">    ActivityInfo aInfo = resolveActivityInfo(intent, STOCK_PM_FLAGS, userId);</span><br><span class="line">    <span class="keyword">if</span> (aInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        intent.setComponent(<span class="keyword">new</span> ComponentName(aInfo.applicationInfo.packageName, aInfo.name));</span><br><span class="line">        aInfo = <span class="keyword">new</span> ActivityInfo(aInfo);</span><br><span class="line">        aInfo.applicationInfo = getAppInfoForUser(aInfo.applicationInfo, userId);</span><br><span class="line">        ProcessRecord app = getProcessRecordLocked(aInfo.processName,</span><br><span class="line">                aInfo.applicationInfo.uid, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (app == <span class="keyword">null</span> || app.instrumentationClass == <span class="keyword">null</span>) &#123; <span class="comment">// 3</span></span><br><span class="line">            intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">            mActivityStarter.startHomeActivityLocked(intent, aInfo, reason); <span class="comment">// 4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Slog.wtf(TAG, <span class="string">"No home screen found for "</span> + intent, <span class="keyword">new</span> Throwable());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，<code>mFactoryTest</code>表示系统的运行模式，系统的运行模式分成三种，分别是非工厂模式、低级工厂模式和高级工厂模式。<code>mTopAction</code>用来描述第一个被启动Activity的组件Action，它的值为<code>Intent.ACTION_MAIN</code>。因此，注释1的代码的意思是<code>mFactoryTest</code>为<code>FactoryTest.FACTORY_TEST_LOW_LECEL</code>（低级工厂模式），并且<code>mTopAction == null</code>时，直接返回<code>false</code>。</p><p>注释2，<code>getHomeIntent()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Intent <span class="title">getHomeIntent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(mTopAction, mTopData != <span class="keyword">null</span> ? Uri.parse(mTopData) : <span class="keyword">null</span>);</span><br><span class="line">    intent.setComponent(mTopComponent);</span><br><span class="line">    intent.addFlags(Intent.FLAG_DEBUG_TRIAGED_MISSING);</span><br><span class="line">    <span class="keyword">if</span> (mFactoryTest != FactoryTest.FACTORY_TEST_LOW_LEVEL) &#123;</span><br><span class="line">        intent.addCategory(Intent.CATEGORY_HOME);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getHomeIntent()</code>中创建了<code>Intent</code>，并将<code>mTopAction</code>和<code>mTopData</code>传入。<code>mTopAction</code>的值为<code>Intent.ACITON_MAIN</code>，并且如果系统运行模式不是低级工厂模式，则将<code>Intent</code>的<code>Category</code>设置为<code>Intnent.CATEGORY_HOME</code>。</p><p>再回到<code>ActivityManagerService</code>的<code>startHomeActivityLocked()</code>，假设系统的运行默模式不是低级工厂模式，在注释3处判断符合<code>Action</code>为<code>Intent.ACTION_MAIN</code>，<code>Category</code>为<code>Intent.CATEGORY_HOME</code>的应用程序是否已经启动，如果没有启动，则调用注释4的方法启动该应用程序。</p><p>这个被启动的应用程序就是Launcher，因为Launcher的Manifest文件中的<code>intent-filter</code>标签匹配了<code>Action</code>为<code>Intent.ACTION_MAIN</code>，<code>Category</code>为<code>Intent.CATEGORY_HOME</code>。Launcher的Manifest文件如下：packages/apps/Launcher3/AndroidManifest.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">"com.android.launcher3"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-sdk</span> <span class="attr">android:targetSdkVersion</span>=<span class="string">"23"</span> <span class="attr">android:minSdkVersion</span>=<span class="string">"16"</span>/&gt;</span></span><br><span class="line"> ...</span><br><span class="line"> <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span></span></span><br><span class="line">        &lt;activity</span><br><span class="line">            android:name="com.android.launcher3.Launcher"</span><br><span class="line">            android:launchMode="singleTask"</span><br><span class="line">            android:clearTaskOnLaunch="true"</span><br><span class="line">            android:stateNotNeeded="true"</span><br><span class="line">            android:theme="@style/Theme"</span><br><span class="line">            android:windowSoftInputMode="adjustPan"</span><br><span class="line">            android:screenOrientation="nosensor"</span><br><span class="line">            android:configChanges="keyboard|keyboardHidden|navigation"</span><br><span class="line">            android:resumeWhilePausing="true"</span><br><span class="line">            android:taskAffinity=""</span><br><span class="line">            android:enabled="true"&gt;</span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.HOME"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.MONKEY"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">application</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样，应用程序Launcher就被启动起来了，并执行其<code>OnCreate()</code>。</p><h1 id="3-Launcher中应用图标显示流程"><a href="#3-Launcher中应用图标显示流程" class="headerlink" title="3. Launcher中应用图标显示流程"></a>3. Launcher中应用图标显示流程</h1><p>Launcher的<code>onCreate()</code>代码如下：packages/apps/Launcher3/src/com/android/launcher3/Launcher.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    LauncherAppState app = LauncherAppState.getInstance(); <span class="comment">// 1</span></span><br><span class="line">    mDeviceProfile = getResources().getConfiguration().orientation</span><br><span class="line">            == Configuration.ORIENTATION_LANDSCAPE ?</span><br><span class="line">            app.getInvariantDeviceProfile().landscapeProfile</span><br><span class="line">            : app.getInvariantDeviceProfile().portraitProfile;</span><br><span class="line">    mSharedPrefs = Utilities.getPrefs(<span class="keyword">this</span>);</span><br><span class="line">    mIsSafeModeEnabled = getPackageManager().isSafeMode();</span><br><span class="line">    mModel = app.setLauncher(<span class="keyword">this</span>); <span class="comment">// 2</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!mRestoring) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DISABLE_SYNCHRONOUS_BINDING_CURRENT_PAGE) &#123;</span><br><span class="line">            mModel.startLoader(PagedView.INVALID_RESTORE_PAGE); <span class="comment">// 3</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mModel.startLoader(mWorkspace.getRestorePage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，获取<code>LauncherAppState</code>实例，并在注释2调用其<code>setLauncher()</code>，将<code>Launcher</code>对象传入，<code>Launcher</code>的<code>setLauncher()</code>如下：packages/apps/Launcher3/src/com/android/launcher3/LauncherAppState.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LauncherModel <span class="title">setLauncher</span><span class="params">(Launcher launcher)</span> </span>&#123;</span><br><span class="line">    getLauncherProvider().setLauncherProviderChangeListener(launcher);</span><br><span class="line">    mModel.initialize(launcher); <span class="comment">// 1</span></span><br><span class="line">    mAccessibilityDelegate = ((launcher != <span class="keyword">null</span>) &amp;&amp; Utilities.ATLEAST_LOLLIPOP) ?</span><br><span class="line">       <span class="keyword">new</span> LauncherAccessibilityDelegate(launcher) : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> mModel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，调用<code>LauncherModel</code>的<code>initialize()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(Callbacks callbacks)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        unbindItemInfosAndClearQueuedBindRunnables();</span><br><span class="line">        mCallbacks = <span class="keyword">new</span> WeakReference&lt;Callbacks&gt;(callbacks);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>initialize()</code>中，会将<code>callbacks</code>，即传入的<code>Launcher</code>封装成一个弱引用对象，。所以可以得知，<code>mCallbacks</code>变量指的就是封装成弱引用对象的<code>Launcher</code>，这个<code>mCallbacks</code>后面会用到。</p><p>现在在回到<code>Launcher</code>的<code>onCreate()</code>，在注释3调用了<code>LauncherModel</code>的<code>startLoader()</code>：packages/apps/Launcher3/src/com/android/launcher3/LauncherModel.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">@Thunk</span> <span class="keyword">static</span> <span class="keyword">final</span> HandlerThread sWorkerThread = <span class="keyword">new</span> HandlerThread(<span class="string">"launcher-loader"</span>); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        sWorkerThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Thunk</span> <span class="keyword">static</span> <span class="keyword">final</span> Handler sWorker = <span class="keyword">new</span> Handler(sWorkerThread.getLooper()); <span class="comment">// 2</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startLoader</span><span class="params">(<span class="keyword">int</span> synchronousBindPage, <span class="keyword">int</span> loadFlags)</span> </span>&#123;s</span><br><span class="line">    InstallShortcutReceiver.enableInstallQueue();</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mDeferredBindRunnables) &#123;</span><br><span class="line">            mDeferredBindRunnables.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mCallbacks != <span class="keyword">null</span> &amp;&amp; mCallbacks.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stopLoaderLocked();</span><br><span class="line">            mLoaderTask = <span class="keyword">new</span> LoaderTask(mApp.getContext(), loadFlags); <span class="comment">// 3</span></span><br><span class="line">            <span class="keyword">if</span> (synchronousBindPage != PagedView.INVALID_RESTORE_PAGE</span><br><span class="line">                    &amp;&amp; mAllAppsLoaded &amp;&amp; mWorkspaceLoaded &amp;&amp; !mIsLoaderTaskRunning) &#123;</span><br><span class="line">                mLoaderTask.runBindSynchronousPage(synchronousBindPage);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sWorkerThread.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">                sWorker.post(mLoaderTask); <span class="comment">// 4</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，创建具有消息循环的线程<code>HanlderThread</code>对象。</p><p>注释2，创建<code>Handler</code>，并传入<code>HandlerThread</code>的<code>Looper</code>。<code>Handler</code>的作用就是向<code>HandlerThread</code>发送消息。</p><p>注释3，创建<code>LoaderTask</code>。</p><p>注释4，将<code>LoaderTask</code>作为消息，发送给<code>HandlerThread</code>。<code>LoaderTask</code>实现了<code>Runnable</code>接口，当<code>LoaderTask</code>所描述的消息被处理时，会调用它的<code>run()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LoaderTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mStopped) &#123;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mIsLoaderTaskRunning = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        keep_running: &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_LOADERS) Log.d(TAG, <span class="string">"step 1: loading workspace"</span>);</span><br><span class="line">            loadAndBindWorkspace(); <span class="comment">// 1</span></span><br><span class="line">            <span class="keyword">if</span> (mStopped) &#123;</span><br><span class="line">                <span class="keyword">break</span> keep_running;</span><br><span class="line">            &#125;</span><br><span class="line">            waitForIdle();</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_LOADERS) Log.d(TAG, <span class="string">"step 2: loading all apps"</span>);</span><br><span class="line">            loadAndBindAllApps(); <span class="comment">// 2</span></span><br><span class="line">        &#125;</span><br><span class="line">        mContext = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mLoaderTask == <span class="keyword">this</span>) &#123;</span><br><span class="line">                mLoaderTask = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mIsLoaderTaskRunning = <span class="keyword">false</span>;</span><br><span class="line">            mHasLoaderCompletedOnce = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Launcher</code>是用工作区的形式来显示系统安装的应用程序的快捷图标，每一个工作区都是来描述一个抽象的桌面的，它是由n个屏幕组成，每个屏幕又分成n个单元格，每个单元格用来显示一个应用程序的快捷图标。</p><p>注释1，调用<code>loadAndBindWorkspace()</code>来加载工作区信息。</p><p>注释2，调用<code>loadAndBindAllApps()</code>来加载系统已经安装的应用程序的信息。</p><p><code>loadAndBindAllApps()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadAndBindAllApps</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_LOADERS) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"loadAndBindAllApps mAllAppsLoaded="</span> + mAllAppsLoaded);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!mAllAppsLoaded) &#123;</span><br><span class="line">        loadAllApps(); <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">synchronized</span> (LoaderTask.<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mStopped) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        updateIconCache();</span><br><span class="line">        <span class="keyword">synchronized</span> (LoaderTask.<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mStopped) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mAllAppsLoaded = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        onlyBindAllApps();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果系统没有加载已经安装的应用程序信息，则会调用注释1的<code>loadAllApps()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadAllApps</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> bindTime = SystemClock.uptimeMillis();</span><br><span class="line">            <span class="keyword">final</span> Callbacks callbacks = tryGetCallbacks(oldCallbacks);</span><br><span class="line">            <span class="keyword">if</span> (callbacks != <span class="keyword">null</span>) &#123;</span><br><span class="line">                callbacks.bindAllApplications(added); <span class="comment">// 1</span></span><br><span class="line">                <span class="keyword">if</span> (DEBUG_LOADERS) &#123;</span><br><span class="line">                    Log.d(TAG, <span class="string">"bound "</span> + added.size() + <span class="string">" apps in "</span></span><br><span class="line">                            + (SystemClock.uptimeMillis() - bindTime) + <span class="string">"ms"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Log.i(TAG, <span class="string">"not binding apps: no Launcher activity"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，调用<code>bindAllApplications()</code>，从前面得知这个<code>callbacks</code>实际指向的是<code>Launcher</code>的弱引用，所以实际调用的是<code>Launcher</code>的<code>bindAllApplications()</code>：<br>packages/apps/Launcher3/src/com/android/launcher3/Launcher.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bindAllApplications</span><span class="params">(<span class="keyword">final</span> ArrayList&lt;AppInfo&gt; apps)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (waitUntilResume(mBindAllApplicationsRunnable, <span class="keyword">true</span>)) &#123;</span><br><span class="line">        mTmpAppsList = apps;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mAppsView != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mAppsView.setApps(apps); <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mLauncherCallbacks != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mLauncherCallbacks.bindAllApplications(apps);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，调用<code>AllAppsContainerView</code>的<code>setApps()</code>，并将包含应用信息的列表<code>apps</code>传进去，<code>setApps()</code>：packages/apps/Launcher3/src/com/android/launcher3/allapps/AllAppsContainerView.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApps</span><span class="params">(List&lt;AppInfo&gt; apps)</span> </span>&#123;</span><br><span class="line">    mApps.setApps(apps);</span><br><span class="line">&#125;</span><br><span class="line">包含应用程序信息的列表的`apps`传递给了`AllAppsContainerView`，再看看`AllAppsContainerView`的`onFinishInflate()`：</span><br><span class="line">```java</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onFinishInflate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onFinishInflate();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Load the all apps recycler view</span></span><br><span class="line">    mAppsRecyclerView = (AllAppsRecyclerView) findViewById(R.id.apps_list_view); <span class="comment">// 1</span></span><br><span class="line">    mAppsRecyclerView.setApps(mApps); <span class="comment">// 2</span></span><br><span class="line">    mAppsRecyclerView.setLayoutManager(mLayoutManager);</span><br><span class="line">    mAppsRecyclerView.setAdapter(mAdapter); <span class="comment">// 3</span></span><br><span class="line">    mAppsRecyclerView.setHasFixedSize(<span class="keyword">true</span>);</span><br><span class="line">    mAppsRecyclerView.addOnScrollListener(mElevationController);</span><br><span class="line">    mAppsRecyclerView.setElevationController(mElevationController);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>onFinishInflate()</code>在加载完xml文件后就会调用。</p><p>注释1，得到<code>AllAppsRecyclerView</code>用来显示App列表。</p><p>注释2，将<code>apps</code>的信息列表传进去。</p><p>注释3，为<code>AllAppsRecyclerView</code>设置<code>Adapter</code>。</p><p>这样应用程序快捷图标就会显示在屏幕上。</p><p><code>Launcher</code>的启动流程就结束了，下面看看Android系统启动流程。</p><h1 id="4-Android系统启动流程"><a href="#4-Android系统启动流程" class="headerlink" title="4. Android系统启动流程"></a>4. Android系统启动流程</h1><p>结合前面的所有内容，就可以得出Android系统启动流程。</p><h2 id="4-1-启动电源以及系统启动"><a href="#4-1-启动电源以及系统启动" class="headerlink" title="4.1 启动电源以及系统启动"></a>4.1 启动电源以及系统启动</h2><p>当按下电源时，引导芯片代码开始从预定义的地方（固化在ROM）开始执行。加载引导程序Bootloader到RAM，然后执行。</p><h2 id="4-2-引导程序BootLoader"><a href="#4-2-引导程序BootLoader" class="headerlink" title="4.2 引导程序BootLoader"></a>4.2 引导程序BootLoader</h2><p>引导程序BootLoader是在Android操作系统开始运行前的一个小程序，主要作用是把系统OS拉起并运行。</p><h2 id="4-3-Linux内核启动"><a href="#4-3-Linux内核启动" class="headerlink" title="4.3 Linux内核启动"></a>4.3 Linux内核启动</h2><p>内核启动时，设置缓存、被保护存储器、计划列表、加载驱动。当内核完成系统设置，它首先在系统文件中寻找init.rc文件，并启动init进程。</p><h2 id="4-4-init进程启动"><a href="#4-4-init进程启动" class="headerlink" title="4.4 init进程启动"></a>4.4 init进程启动</h2><p>初始化和启动属性服务，并启动Zygote进程。</p><h2 id="4-5-Zygote进程启动"><a href="#4-5-Zygote进程启动" class="headerlink" title="4.5 Zygote进程启动"></a>4.5 Zygote进程启动</h2><p>创建Java VM并为Java VM注册JNI，创建服务端Socket，启动SystemServer进程。</p><h2 id="4-6-SystemServer进程启动"><a href="#4-6-SystemServer进程启动" class="headerlink" title="4.6 SystemServer进程启动"></a>4.6 SystemServer进程启动</h2><p>启动Binder线程池和<code>SystemServiceManager</code>，并启动各种系统服务。</p><h2 id="4-7-Launcher启动"><a href="#4-7-Launcher启动" class="headerlink" title="4.7 Launcher启动"></a>4.7 Launcher启动</h2><p>被SystemServer进程启动的<code>ActivityManagerService</code>会启动<code>Launcher</code>，<code>Launcer</code>启动后，会将已经安装的应用的快捷图标显示在屏幕上。</p><img src="/2019/08/28/Android系统启动流程04：Launcher启动过程和系统启动流程/VeFzlQ.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/08/28/Android系统启动流程04：Launcher启动过程和系统启动流程/VekSyj.jpg&quot;&gt;

&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="Android进阶" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
      <category term="框架层" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/"/>
    
      <category term="系统启动" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8/"/>
    
    
      <category term="Android系统启动" scheme="https://tylerLiu.top/tags/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>Android系统启动流程 03：SystemServer进程</title>
    <link href="https://tylerLiu.top/2019/08/27/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B03%EF%BC%9ASystemServer%E8%BF%9B%E7%A8%8B/"/>
    <id>https://tylerLiu.top/2019/08/27/Android系统启动流程03：SystemServer进程/</id>
    <published>2019-08-27T07:45:13.000Z</published>
    <updated>2019-09-11T08:04:01.284Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上文知道，Zygote进程最终启动了SystemServer进程，现在就来看看SystemServer进程的启动过程。基于Android 7.0。</p><h1 id="1-Zygote启动SystemServer进程"><a href="#1-Zygote启动SystemServer进程" class="headerlink" title="1. Zygote启动SystemServer进程"></a>1. Zygote启动SystemServer进程</h1><p>上篇说到，在<code>ZygoteInit.java</code>中的<code>startSystemServer()</code>启动了SystemServer进程：frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">startSystemServer</span><span class="params">(String abiList, String socketName)</span></span></span><br><span class="line"><span class="function">           <span class="keyword">throws</span> MethodAndArgsCaller, RuntimeException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">       <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (hasSecondZygote(abiList)) &#123;</span><br><span class="line">               waitForSecondaryZygote(socketName);</span><br><span class="line">           &#125;</span><br><span class="line">           handleSystemServerProcess(parsedArgs);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在里面最终通过<code>handleSystemServerProcess()</code>来启动了SystemServer进程。</p><h1 id="2-SystemServer进程的启动过程"><a href="#2-SystemServer进程的启动过程" class="headerlink" title="2. SystemServer进程的启动过程"></a>2. SystemServer进程的启动过程</h1><p><code>handleSystemServerProcess()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleSystemServerProcess</span><span class="params">(ZygoteConnection.Arguments parsedArgs)</span> <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line"></span><br><span class="line">    closeServerSocket(); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parsedArgs.invokeWith != <span class="keyword">null</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        ......</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ClassLoader cl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (systemServerClasspath != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cl = createSystemServerClassLoader(systemServerClasspath, parsedArgs.targetSdkVersion);</span><br><span class="line">            Thread.currentThread().setContextClassLoader(cl);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Pass the remaining arguments to SystemServer.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl); <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SystemServer进程复制了Zygote进程地址空间，因此也会得到Zygote进程创建的Socket，这个Socket对于SystemServer进程没有用处，因此，需要用注释1的代码关闭Socket。</p><p>注释2，调用<code>RuntimeInit</code>的<code>zygoteInte()</code>：frameworks/base/core/java/com/android/internal/os/RuntimeInit.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">zygoteInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"RuntimeInit: Starting application from zygote"</span>);</span><br><span class="line"></span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"RuntimeInit"</span>);</span><br><span class="line">    redirectLogStreams();</span><br><span class="line"></span><br><span class="line">    commonInit();</span><br><span class="line">    nativeZygoteInit(); <span class="comment">// 1</span></span><br><span class="line">    applicationInit(targetSdkVersion, argv, classLoader); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，调用<code>nativeZygoteInit()</code>，在里面调用了Native层的代码。</p><h2 id="2-1-启动Binder线程池"><a href="#2-1-启动Binder线程池" class="headerlink" title="2.1 启动Binder线程池"></a>2.1 启动Binder线程池</h2><p><code>nativeZygoteInit()</code>对应的JNI文件：frameworks/base/core/jni/AndroidRuntime.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> JNINativeMethod gMethods[] = &#123;</span><br><span class="line">    &#123; <span class="string">"nativeFinishInit"</span>, <span class="string">"()V"</span>,</span><br><span class="line">        (<span class="keyword">void</span>*) com_android_internal_os_RuntimeInit_nativeFinishInit &#125;,</span><br><span class="line">    &#123; <span class="string">"nativeZygoteInit"</span>, <span class="string">"()V"</span>,</span><br><span class="line">        (<span class="keyword">void</span>*) com_android_internal_os_RuntimeInit_nativeZygoteInit &#125;,</span><br><span class="line">    &#123; <span class="string">"nativeSetExitWithoutCleanup"</span>, <span class="string">"(Z)V"</span>,</span><br><span class="line">        (<span class="keyword">void</span>*) com_android_internal_os_RuntimeInit_nativeSetExitWithoutCleanup &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过JNI的<code>gMethods()</code>数组，可以看出<code>nativeZygoteInit()</code>对应的是JNI文件AndroidRuntime.cpp的<code>com_android_internal_os_RuntimeInit_nativeZygote()</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">static</span> AndroidRuntime* gCurRuntime = <span class="literal">NULL</span>;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">com_android_internal_os_RuntimeInit_nativeZygoteInit</span><span class="params">(JNIEnv* env, jobject clazz)</span></span>&#123;</span><br><span class="line">    gCurRuntime-&gt;onZygoteInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<code>gCurRuntime</code>是<code>AndoridRuntime</code>类型的指针，<code>AndroidRuntime</code>的子类<code>AppRuntime</code>在app_main.cpp中定义，下面查看<code>AppRuntime</code>的<code>onZygoteInit()</code>：frameworks/base/cmds/app_process/app_main.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onZygoteInit</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sp&lt;ProcessState&gt; proc = ProcessState::self();</span><br><span class="line">    ALOGV(<span class="string">"App process: starting thread pool.\n"</span>);</span><br><span class="line">    proc-&gt;startThreadPool(); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，用来启动一个Binder线程池，这样SystemServer进程就可以使用Binder来与其他进程进行通信了。所以<code>RuntimeInit.java</code>的<code>nativeZygote()</code>主要是启动Binder线程池。</p><h2 id="2-2-invokeStaticMain"><a href="#2-2-invokeStaticMain" class="headerlink" title="2.2 invokeStaticMain"></a>2.2 invokeStaticMain</h2><p>再回到<code>RuntimeInit.java</code>，在注释2处调用了<code>applicationInit()</code>：frameworks/base/core/java/com/android/internal/os/RuntimeInit.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">applicationInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    invokeStaticMain(args.startClass, args.startArgs, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>applicationInit()</code>最终主要调用了<code>invokeStaticMain()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeStaticMain</span><span class="params">(String className, String[] argv, ClassLoader classLoader)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line">    Class&lt;?&gt; cl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cl = Class.forName(className, <span class="keyword">true</span>, classLoader); <span class="comment">// 1</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Missing class when invoking static main "</span> + className,</span><br><span class="line">                ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Method m;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        m = cl.getMethod(<span class="string">"main"</span>, <span class="keyword">new</span> Class[] &#123; String[].class &#125;); <span class="comment">// 2</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Missing static main on "</span> + className, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SecurityException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Problem getting static main on "</span> + className, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> modifiers = m.getModifiers();</span><br><span class="line">    <span class="keyword">if</span> (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Main method is not public and static on "</span> + className);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This throw gets caught in ZygoteInit.main(), which responds</span></span><br><span class="line"><span class="comment">     * by invoking the exception's run() method. This arrangement</span></span><br><span class="line"><span class="comment">     * clears up all the stack frames that were required in setting</span></span><br><span class="line"><span class="comment">     * up the process.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteInit.MethodAndArgsCaller(m, argv); <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，<code>className</code>为<code>&quot;com.android.server.SystemServer&quot;</code>，因此通过反射返回的<code>cl</code>为<code>SystemServer</code>类。</p><p>注释2，找到<code>SystemServer</code>中的<code>main()</code>。</p><p>注释3，将找到的<code>main()</code>传入到<code>MethodAndArgsCaller()</code>异常中，并抛出该异常。截获<code>MethodAndArgsCaller()</code>异常的代码在<code>ZygoteInit.java</code>的<code>main()</code>中。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span> </span>&#123;</span><br><span class="line">     ...</span><br><span class="line">          closeServerSocket();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (MethodAndArgsCaller caller) &#123;</span><br><span class="line">          caller.run(); <span class="comment">// 1</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">          Log.e(TAG, <span class="string">"Zygote died with exception"</span>, ex);</span><br><span class="line">          closeServerSocket();</span><br><span class="line">          <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，调用了<code>MethodAndArgsCaller</code>的<code>run()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mMethod.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[] &#123; mArgs &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>mMethod</code>指的就是<code>SystemServer</code>中的<code>main()</code>，此时<code>main()</code>就被动态调用起来。</p><h1 id="3-解析SystemServer进行"><a href="#3-解析SystemServer进行" class="headerlink" title="3. 解析SystemServer进行"></a>3. 解析SystemServer进行</h1><p>下面看看<code>SystemServer</code>的<code>main()</code>：frameworks/base/services/java/com/android/server/SystemServer.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">new</span> SystemServer().run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在里面只是调用了<code>SystemServer</code>的<code>run()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">       System.loadLibrary(<span class="string">"android_servers"</span>); <span class="comment">// 1</span></span><br><span class="line">   ...</span><br><span class="line">       mSystemServiceManager = <span class="keyword">new</span> SystemServiceManager(mSystemContext); <span class="comment">// 2</span></span><br><span class="line">       LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);</span><br><span class="line">   ...    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, <span class="string">"StartServices"</span>);</span><br><span class="line">       startBootstrapServices(); <span class="comment">// 3</span></span><br><span class="line">       startCoreServices(); <span class="comment">// 4</span></span><br><span class="line">       startOtherServices(); <span class="comment">// 5</span></span><br><span class="line">   &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">       Slog.e(<span class="string">"System"</span>, <span class="string">"******************************************"</span>);</span><br><span class="line">       Slog.e(<span class="string">"System"</span>, <span class="string">"************ Failure starting system services"</span>, ex);</span><br><span class="line">       <span class="keyword">throw</span> ex;</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，加载lib库andorid_servers.so。</p><p>注释2，创建<code>SystemServiceManager</code>，它会对系统的服务进行创建、启动和生命周期管理。</p><p>下面就是启动系统的各种服务。</p><p>注释3，<code>startBootstrapServices()</code>中使用<code>SystemServiceManager</code>启动了<code>ActivityManagerService</code>、<code>PowerManagerService</code>、<code>PackageManagerService</code>等服务。</p><p>注释4，<code>startCoreServices()</code>中启动了<code>BatteryService</code>、<code>UsageStatesService</code>和<code>WebViewUpdateService</code>。</p><p>注释5，<code>startOtherServices()</code>中启动了<code>CameraService</code>、<code>AlarmManagerService</code>、<code>VrManagerService</code>等服务。</p><p>这些服务的父类为<code>SystemService</code>。</p><p>从注释3、4、5可以看出，官方将服务分成三类，引导服务、核心服务和其他服务，其中其他服务是一些非紧要的和一些不需要立即启动的服务。系统服务大约有80多个，下面列举了部分服务及其作用。</p><table><thead><tr><th align="left"><strong>引导服务</strong></th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">Installer</td><td align="left">系统安装APK时的一个服务类，启动完成Installer服务后，才能启动其它的系统服务</td></tr><tr><td align="left">ActivtyManagerService</td><td align="left">负责四大组件的启动、切换和调度</td></tr><tr><td align="left">PowerManagerService</td><td align="left">计算系统中和Power相关的计算，然后决策系统应该如何反应</td></tr><tr><td align="left">LightsService</td><td align="left">管理和显示背光LED</td></tr><tr><td align="left">DisplayManagerService</td><td align="left">用来管理所有显示设备</td></tr><tr><td align="left">UserManagerService</td><td align="left">多用户模式管理</td></tr><tr><td align="left">SensorService</td><td align="left">为系统提供各种感应器服务</td></tr><tr><td align="left">PackageManagerService</td><td align="left">用来对APK进行安装、解析、删除、卸载等操作</td></tr><tr><td align="left"><strong>核心服务</strong></td><td align="left"></td></tr><tr><td align="left">BatteryService</td><td align="left">管理电池相关的服务</td></tr><tr><td align="left">UsageStatsService</td><td align="left">收集用户使用每一个APP的频率、使用时长</td></tr><tr><td align="left">WebViewUpdateService</td><td align="left">WebView更新服务</td></tr><tr><td align="left"><strong>其他服务</strong></td><td align="left"></td></tr><tr><td align="left">CameraService</td><td align="left">摄像头相关服务</td></tr><tr><td align="left">AlarmManagerService</td><td align="left">全局定时器管理服务</td></tr><tr><td align="left">InputManagerService</td><td align="left">管理输入事件</td></tr><tr><td align="left">WindowManagerService</td><td align="left">窗口管理服务</td></tr><tr><td align="left">VrManagerService</td><td align="left">VR模式管理服务</td></tr><tr><td align="left">BluetoothService</td><td align="left">蓝牙管理服务</td></tr><tr><td align="left">NotificationManagerService</td><td align="left">通知管理服务</td></tr><tr><td align="left">DevicesStorageMonitorService</td><td align="left">存储相关服务</td></tr><tr><td align="left">LocationManagerService</td><td align="left">定位管理服务</td></tr><tr><td align="left">AudioService</td><td align="left">音频管理服务</td></tr><tr><td align="left">…</td><td align="left">…</td></tr></tbody></table><p>假如要启动<code>PowerManagerService</code>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class);</span><br></pre></td></tr></table></figure><p><code>SystemServiceManager</code>的<code>startService()</code>启动了<code>PowerManagerService</code>，<code>startService()</code>具体如下：frameworks/base/services/core/java/com/android/server/SystemServerManager.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T extends SystemService&gt; <span class="function">T <span class="title">startService</span><span class="params">(Class&lt;T&gt; serviceClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> String name = serviceClass.getName();</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, <span class="string">"StartService "</span> + name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create the service.</span></span><br><span class="line">        <span class="keyword">if</span> (!SystemService.class.isAssignableFrom(serviceClass)) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> T service;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Constructor&lt;T&gt; constructor = serviceClass.getConstructor(Context.class);</span><br><span class="line">            service = constructor.newInstance(mContext); <span class="comment">// 1</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException ex) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Register it.</span></span><br><span class="line">        mServices.add(service); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start it.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            service.onStart(); <span class="comment">// 3</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> service;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，创建<code>SystemServer</code>，这里的<code>SystemServer</code>就是前面传进来的<code>PowerManagerService</code>。</p><p>注释2，将<code>PowerManagerService</code>添加到<code>mServices</code>中，这里的<code>mServices</code>是一个存储<code>SystemService</code>类型的<code>ArrayList</code>。</p><p>注释3，调用传进来的<code>PowerManagerSerivce</code>的<code>onStart()</code>启动<code>PowerManagerService</code>并返回。</p><p>除了使用<code>mSystemServiceManager</code>的<code>startService()</code>来启动系统服务之外，还可以通知如下形式来启动系统服务，以<code>PackageManagerService</code>为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mPackageManagerService = PackageManagerService.main(mSystemContext, installer, mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);</span><br></pre></td></tr></table></figure><p>直接调用了<code>PackageManagerService</code>的<code>main()</code>：frameworks/base/service/core/java/com/android/server/pm/PackageManagerService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PackageManagerService <span class="title">main</span><span class="params">(Context context, Installer installer,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> factoryTest, <span class="keyword">boolean</span> onlyCore)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Self-check for initial settings.</span></span><br><span class="line">    PackageManagerServiceCompilerMapping.checkProperties();</span><br><span class="line"></span><br><span class="line">    PackageManagerService m = <span class="keyword">new</span> PackageManagerService(context, installer,</span><br><span class="line">            factoryTest, onlyCore); <span class="comment">// 1</span></span><br><span class="line">    m.enableSystemUserPackages();</span><br><span class="line">    <span class="comment">// Disable any carrier apps. We do this very early in boot to prevent the apps from being</span></span><br><span class="line">    <span class="comment">// disabled after already being started.</span></span><br><span class="line">    CarrierAppUtils.disableCarrierAppsUntilPrivileged(context.getOpPackageName(), m,</span><br><span class="line">            UserHandle.USER_SYSTEM);</span><br><span class="line">    ServiceManager.addService(<span class="string">"package"</span>, m); <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，创建<code>PackageManagerService</code>。</p><p>注释2，将<code>PackageManagerService</code>注册到<code>ServiceManager</code>中，<code>ServiceManager</code>用来管理系统中的各种Service。由于系统C/S架构中的Binder机制通信：Client端要使用某个Service，则需要先到<code>ServiceManager</code>中查询Service的相关信息，然后根据Service的相关信息与Service进程建立通讯通路，这样Client就能使用Service了。</p><p>还有服务是直接注册到<code>ServiceManager</code>中的：framewokrs/base/services/java/com/android/server/SystemServer.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">telephonyRegistry = <span class="keyword">new</span> TelephonyRegistry(context);</span><br><span class="line">ServiceManager.addService(<span class="string">"telephony.registry"</span>, telephonyRegistry);</span><br></pre></td></tr></table></figure><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p><code>SystemServer</code>主要做了以下的工作：</p><ol><li>启动Binder线程池，这样就可以与其他进程进行通信；</li><li>创建<code>SystemServiceManager</code>用于对系统服务进行创建、启动和生命周期的管理；</li><li>启动各种系统服务。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上文知道，Zygote进程最终启动了SystemServer进程，现在就来看看SystemServer进程的启动过程。基于Android 7
      
    
    </summary>
    
      <category term="Android进阶" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
      <category term="框架层" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/"/>
    
      <category term="系统启动" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8/"/>
    
    
      <category term="Android系统启动" scheme="https://tylerLiu.top/tags/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>Android系统启动流程 02：zygote进程</title>
    <link href="https://tylerLiu.top/2019/08/27/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B02%EF%BC%9Azygote%E8%BF%9B%E7%A8%8B/"/>
    <id>https://tylerLiu.top/2019/08/27/Android系统启动流程02：zygote进程/</id>
    <published>2019-08-27T01:46:23.000Z</published>
    <updated>2019-09-11T08:04:03.671Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面说到init进程的启动过程主要做了三件事，其中一件就是创建zygote进程，那么zygote进程做了什么？</p><h1 id="1-zygote简介"><a href="#1-zygote简介" class="headerlink" title="1. zygote简介"></a>1. zygote简介</h1><p>在Android系统中，DVM（Dalvik虚拟机）、应用程序进程以及运行系统的关键服务的SystemServer进程都由zygote进程来创建的，称为孵化器。它通过<code>fork</code>（复制进程）的形式来创建应用进程和SystemServer进程，由于zygote进程在启动时，会创建DVM，因此通过<code>fork</code>创建的应用程序和SystemServer进程可以在内部获取一个DVM的实例拷贝。</p><p>这里主要分析Android 7.0中zygote的启动流程。</p><h1 id="2-AppRuntime分析"><a href="#2-AppRuntime分析" class="headerlink" title="2. AppRuntime分析"></a>2. AppRuntime分析</h1><p>上文得知，init启动zygote时主要是调用app_main.cpp的<code>main</code>函数中的AppRuntime的<code>start</code>来启动zygote进程的，所以从app_main.cpp的<code>main</code>函数开始分析：frameworks/base/cmds/app_process/app_main.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function">AppRuntime <span class="title">runtime</span><span class="params">(argv[<span class="number">0</span>], computeArgBlockSize(argc, argv))</span></span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">     Vector&lt;String8&gt; args;</span><br><span class="line">    <span class="keyword">if</span> (!className.isEmpty()) &#123;</span><br><span class="line">        args.add(application ? String8(<span class="string">"application"</span>) : String8(<span class="string">"tool"</span>));</span><br><span class="line">        runtime.setClassNameAndArgs(className, argc - i, argv + i);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// We're in zygote mode.</span></span><br><span class="line">        maybeCreateDalvikCache();</span><br><span class="line">        <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">            args.add(String8(<span class="string">"start-system-server"</span>));<span class="comment">// 1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> prop[PROP_VALUE_MAX];</span><br><span class="line">        <span class="keyword">if</span> (property_get(ABI_LIST_PROPERTY, prop, <span class="literal">NULL</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            LOG_ALWAYS_FATAL(<span class="string">"app_process: Unable to determine ABI list from property %s."</span>,</span><br><span class="line">                ABI_LIST_PROPERTY);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">String8 <span class="title">abiFlag</span><span class="params">(<span class="string">"--abi-list="</span>)</span></span>;</span><br><span class="line">        abiFlag.append(prop);</span><br><span class="line">        args.add(abiFlag);</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; argc; ++i) &#123;</span><br><span class="line">            args.add(String8(argv[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!niceName.isEmpty()) &#123;</span><br><span class="line">        runtime.setArgv0(niceName.<span class="built_in">string</span>());</span><br><span class="line">        set_process_name(niceName.<span class="built_in">string</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (zygote) &#123;</span><br><span class="line">        runtime.start(<span class="string">"com.android.internal.os.ZygoteInit"</span>, args, zygote);<span class="comment">// 2</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className) &#123;</span><br><span class="line">        runtime.start(<span class="string">"com.android.internal.os.RuntimeInit"</span>, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error: no class name or --zygote supplied.\n"</span>);</span><br><span class="line">        app_usage();</span><br><span class="line">        LOG_ALWAYS_FATAL(<span class="string">"app_process: no class name or --zygote supplied."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，如果<code>startSystemServer</code>为<code>true</code>的话（默认为<code>true</code>），将<code>&quot;start_system_server&quot;</code>放入启动的参数<code>args</code>。</p><p>注释2，调用<code>runtime</code>的<code>start()</code>函数来启动zygote进程，并将<code>args</code>传入，这样，启动zygote进程后，zygote进程就会将SystemServer进程启动。这里的<code>runtime</code>指的就是<code>AppRuntime</code>，<code>Appruntime</code>声明也在app_main.cpp中，它继承<code>AndroidRuntime</code>，所以调用<code>start</code>实际上就是调用<code>AndroidRuntime</code>的<code>start</code>函数：frameworks/base/core/jni/AndroidRuntime.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> AndroidRuntime::start(<span class="keyword">const</span> <span class="keyword">char</span>* className, <span class="keyword">const</span> Vector&lt;String8&gt;&amp; options, <span class="keyword">bool</span> zygote)&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* start the virtual machine */</span></span><br><span class="line">    JniInvocation jni_invocation;</span><br><span class="line">    jni_invocation.Init(<span class="literal">NULL</span>);</span><br><span class="line">    JNIEnv* env;</span><br><span class="line">    <span class="keyword">if</span> (startVm(&amp;mJavaVM, &amp;env, zygote) != <span class="number">0</span>) &#123;<span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    onVmCreated(env);</span><br><span class="line">    <span class="keyword">if</span> (startReg(env) &lt; <span class="number">0</span>) &#123;<span class="comment">// 2</span></span><br><span class="line">        ALOGE(<span class="string">"Unable to register all android natives\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    jclass stringClass;</span><br><span class="line">    jobjectArray strArray;</span><br><span class="line">    jstring classNameStr;</span><br><span class="line"></span><br><span class="line">    stringClass = env-&gt;FindClass(<span class="string">"java/lang/String"</span>);</span><br><span class="line">    assert(stringClass != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 创建数组</span></span><br><span class="line">    strArray = env-&gt;NewObjectArray(options.size() + <span class="number">1</span>, stringClass, <span class="literal">NULL</span>);</span><br><span class="line">    assert(strArray != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 从app_main的main函数得知className为com.android.internal.os.ZygoteInit</span></span><br><span class="line">    classNameStr = env-&gt;NewStringUTF(className);</span><br><span class="line">    assert(classNameStr != <span class="literal">NULL</span>);</span><br><span class="line">    env-&gt;SetObjectArrayElement(strArray, <span class="number">0</span>, classNameStr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; options.size(); ++i) &#123;</span><br><span class="line">        jstring optionsStr = env-&gt;NewStringUTF(options.itemAt(i).<span class="built_in">string</span>());</span><br><span class="line">        assert(optionsStr != <span class="literal">NULL</span>);</span><br><span class="line">        env-&gt;SetObjectArrayElement(strArray, i + <span class="number">1</span>, optionsStr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>* slashClassName = toSlashClassName(className);</span><br><span class="line">    jclass startClass = env-&gt;FindClass(slashClassName);</span><br><span class="line">    <span class="keyword">if</span> (startClass == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"JavaVM unable to locate class '%s'\n"</span>, slashClassName);</span><br><span class="line">        <span class="comment">/* keep going */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 找到ZygoteInit的main函数</span></span><br><span class="line">        jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, <span class="string">"main"</span>,</span><br><span class="line">            <span class="string">"([Ljava/lang/String;)V"</span>);<span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">if</span> (startMeth == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">"JavaVM unable to find main() in '%s'\n"</span>, className);</span><br><span class="line">            <span class="comment">/* keep going */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 通过JNI调用ZygoteInit的main函数</span></span><br><span class="line">            env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);<span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">            <span class="keyword">if</span> (env-&gt;ExceptionCheck())</span><br><span class="line">                threadExitUncaughtException(env);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，调用<code>startVm</code>创建JavaVM，即DVM。</p><p>注释2，调用<code>startReg</code>为DVM注册JNI。</p><p>注释3，用来找到<code>ZygoteInit</code>的<code>main</code>函数，其中<code>startClass</code>从app_main.cpp的<code>main</code>函数得知为<code>com.android.internal.os.ZygoteInit</code>。</p><p>注释4，通过JNIi调用<code>ZygoteInit</code>的<code>main</code>函数，因为<code>ZygoteInit</code>是用Java编写的，所以要通过JNI调用。</p><h1 id="3-ZygoteInit的Java框架层"><a href="#3-ZygoteInit的Java框架层" class="headerlink" title="3. ZygoteInit的Java框架层"></a>3. ZygoteInit的Java框架层</h1><p>frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">        ...       </span><br><span class="line">           <span class="comment">// 注册Zygote用的Socket</span></span><br><span class="line">           registerZygoteSocket(socketName);<span class="comment">// 1</span></span><br><span class="line">          ...</span><br><span class="line">          <span class="comment">// 预加载类和资源</span></span><br><span class="line">          preload();<span class="comment">// 2</span></span><br><span class="line">          ...</span><br><span class="line">           <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">               <span class="comment">// 启动SystemServer进程</span></span><br><span class="line">               startSystemServer(abiList, socketName);<span class="comment">// 3</span></span><br><span class="line">           &#125;</span><br><span class="line">           Log.i(TAG, <span class="string">"Accepting command socket connections"</span>);</span><br><span class="line">           <span class="comment">// 等待客户端请求</span></span><br><span class="line">           runSelectLoop(abiList);<span class="comment">// 4</span></span><br><span class="line">           closeServerSocket();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (MethodAndArgsCaller caller) &#123;</span><br><span class="line">           caller.run();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">           Log.e(TAG, <span class="string">"Zygote died with exception"</span>, ex);</span><br><span class="line">           closeServerSocket();</span><br><span class="line">           <span class="keyword">throw</span> ex;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>注释1，通过<code>registerSygoteSocket()</code>来创建一个Server端的<code>Socket</code>，这个<code>name</code>为<code>&quot;zygote&quot;</code>的<code>Socket</code>用来等待<code>ActivityManagerService</code>来请求<code>Zygote</code>来创建新的应用程序进程。</p><p>注释2，用来预加载类和资源。</p><p>注释3，启动SystemServer进程，这样系统的关键服务也会由SystemServer进程启动起来。</p><p>注释4，调用<code>runSelectLoop()</code>来等待客户端请求。</p><p>所以，<code>ZygoteInit</code>的<code>main</code>函数主要做了4件事，下面来一一分析。</p><h2 id="3-1-registerZygoteSocket"><a href="#3-1-registerZygoteSocket" class="headerlink" title="3.1 registerZygoteSocket"></a>3.1 registerZygoteSocket</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerZygoteSocket</span><span class="params">(String socketName)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (sServerSocket == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">int</span> fileDesc;</span><br><span class="line">         <span class="keyword">final</span> String fullSocketName = ANDROID_SOCKET_PREFIX + socketName;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             String env = System.getenv(fullSocketName);</span><br><span class="line">             fileDesc = Integer.parseInt(env);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(fullSocketName + <span class="string">" unset or invalid"</span>, ex);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             FileDescriptor fd = <span class="keyword">new</span> FileDescriptor();</span><br><span class="line">             fd.setInt$(fileDesc);</span><br><span class="line">             sServerSocket = <span class="keyword">new</span> LocalServerSocket(fd);<span class="comment">// 1</span></span><br><span class="line">         &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                     <span class="string">"Error binding to local socket '"</span> + fileDesc + <span class="string">"'"</span>, ex);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，创建<code>LocalServerStocket</code>，就是服务端的Stocke。当<code>Zygote</code>进程将SystemServer进程启动后，就会在这个服务端的Stocket上等待<code>ActivityManagerService</code>请求<code>Zygote</code>进程来创建新的应用程序进程。</p><h2 id="3-2-启动SystemServer进程"><a href="#3-2-启动SystemServer进程" class="headerlink" title="3.2 启动SystemServer进程"></a>3.2 启动SystemServer进程</h2><p>下面看看<code>startSystemServer()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">startSystemServer</span><span class="params">(String abiList, String socketName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> MethodAndArgsCaller, RuntimeException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Containers run without this capability, so avoid setting it in that case */</span></span><br><span class="line">    <span class="keyword">if</span> (!SystemProperties.getBoolean(PROPERTY_RUNNING_IN_CONTAINER, <span class="keyword">false</span>)) &#123;</span><br><span class="line">        capabilities |= posixCapabilitiesAsBits(OsConstants.CAP_BLOCK_SUSPEND);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Hardcoded command line to start the system server */</span></span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    String args[] = &#123;</span><br><span class="line">        <span class="string">"--setuid=1000"</span>,</span><br><span class="line">        <span class="string">"--setgid=1000"</span>,</span><br><span class="line">        <span class="string">"--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1032,3001,3002,3003,3006,3007,3009,3010"</span>,</span><br><span class="line">        <span class="string">"--capabilities="</span> + capabilities + <span class="string">","</span> + capabilities,</span><br><span class="line">        <span class="string">"--nice-name=system_server"</span>,</span><br><span class="line">        <span class="string">"--runtime-args"</span>,</span><br><span class="line">        <span class="string">"com.android.server.SystemServer"</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    ZygoteConnection.Arguments parsedArgs = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        parsedArgs = <span class="keyword">new</span> ZygoteConnection.Arguments(args);</span><br><span class="line">        ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);</span><br><span class="line">        ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Request to fork the system server process */</span></span><br><span class="line">        <span class="comment">// 3</span></span><br><span class="line">        pid = Zygote.forkSystemServer(</span><br><span class="line">                parsedArgs.uid, parsedArgs.gid,</span><br><span class="line">                parsedArgs.gids,</span><br><span class="line">                parsedArgs.debugFlags,</span><br><span class="line">                <span class="keyword">null</span>,</span><br><span class="line">                parsedArgs.permittedCapabilities,</span><br><span class="line">                parsedArgs.effectiveCapabilities);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* For child process */</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasSecondZygote(abiList)) &#123;</span><br><span class="line">            waitForSecondaryZygote(socketName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        handleSystemServerProcess(parsedArgs);<span class="comment">// 4</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，创建<code>args</code>数组，用来保存启动SystemServer的参数，可以看出SystemServer进程的用户id和用户组id被设置为1000；并且拥有用户组1001<del>1010，1018、1021、1032、3001</del>3010的权限；进程名为<code>system_server</code>；启动的类名为<code>com.android.server.SystemServer</code>。</p><p>注释2，将<code>args</code>数组封装成<code>Arguments</code>对象并供注释3的<code>forkSystemServer()</code>调用。</p><p>注释3，调用<code>Sygote</code>的<code>forkSystemServer()</code>，主要是通过<code>fork()</code>函数在当前进程创建一个子进程，如果返回的<code>pid</code>为0，表示在新创建的子进程中执行的，则会执行注释4处的<code>handleSystemServerProcess</code>来启动SystemServer进程。</p><h2 id="3-3-runSelectLoop"><a href="#3-3-runSelectLoop" class="headerlink" title="3.3 runSelectLoop"></a>3.3 runSelectLoop</h2><p>启动SystemServer进程后，最后进入<code>runSelectLoop()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runSelectLoop</span><span class="params">(String abiList)</span> <span class="keyword">throws</span> MethodAndArgsCaller </span>&#123;</span><br><span class="line">    ArrayList&lt;FileDescriptor&gt; fds = <span class="keyword">new</span> ArrayList&lt;FileDescriptor&gt;();</span><br><span class="line">    ArrayList&lt;ZygoteConnection&gt; peers = <span class="keyword">new</span> ArrayList&lt;ZygoteConnection&gt;();</span><br><span class="line"></span><br><span class="line">    fds.add(sServerSocket.getFileDescriptor()); <span class="comment">// 1</span></span><br><span class="line">    peers.add(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        StructPollfd[] pollFds = <span class="keyword">new</span> StructPollfd[fds.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pollFds.length; ++i) &#123; <span class="comment">// 2</span></span><br><span class="line">            pollFds[i] = <span class="keyword">new</span> StructPollfd();</span><br><span class="line">            pollFds[i].fd = fds.get(i);</span><br><span class="line">            pollFds[i].events = (<span class="keyword">short</span>) POLLIN;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Os.poll(pollFds, -<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"poll failed"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pollFds.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123; <span class="comment">// 3</span></span><br><span class="line">            <span class="keyword">if</span> ((pollFds[i].revents &amp; POLLIN) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                ZygoteConnection newPeer = acceptCommandPeer(abiList); <span class="comment">// 4</span></span><br><span class="line">                peers.add(newPeer);</span><br><span class="line">                fds.add(newPeer.getFileDesciptor());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">boolean</span> done = peers.get(i).runOnce();<span class="comment">// 5</span></span><br><span class="line">                <span class="keyword">if</span> (done) &#123;</span><br><span class="line">                    peers.remove(i);</span><br><span class="line">                    fds.remove(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，<code>sServerStocket</code>就是在<code>registerZygoteStocket()</code>中创建的服务端Stocket，调用<code>sServerStocket.getFileDescriptor()</code>用来获得该Stocket字段的值并添加到fd列表<code>fds</code>中。然后使用无限循环用来等待<code>ActivtiyManagerService</code>请求Zygote进程创建新的应用程序进程。</p><p>注释2，通过遍历将<code>fds</code>存储的信息转移到<code>pollFds</code>数组中。</p><p>注释3，遍历<code>pollFds</code>，如果<code>i == 0</code>，表示服务端Socket与客户端已经连上，即，当前Zygote进程与<code>ActivityManagerService</code>建立了连接。</p><p>注释4，通过<code>acceptCommabdPeer()</code>得到``ZygoteConnection<code>对象，并添加到Stocket连接列表</code>peer<code>中，接着将该</code>ZygoteConnection<code>添加到fd列表</code>fds<code>中，以便可以收到</code>ActivityManagerService<code>发送过来的请求。如果</code>i<code>的值大于0，说明</code>ActivityManagerService<code>向Zytoge进程发送了一个创建应用进程的请求，则在注释5调用</code>ZygoteConnection<code>的</code>runOnce()<code>创建一个新的应用程序进程。并在成功创建后，将这个连接从Socket连接列表</code>peers<code>和fd列表</code>fds`中清除。</p><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p>Zygote进程主要做了以下几件事：</p><ol><li>创建<code>AppRuntime</code>，并调用其<code>start()</code>，启动Zygote进程；</li><li>创建DVM并为DVM注册JNI；</li><li>通过JNI调用Zygote的<code>main()</code>，进入Zygote的Java框架层；</li><li>通过<code>registerZygoteSocket()</code>创建服务端Socket，并通过<code>runSelectLoop()</code>等待<code>ActivityManagerService</code>的请求来创建新的应用程序进程。</li><li>启动SystemServer进程。</li></ol><p>参考资料</p><ul><li>《Android系统源代码情景分析》</li><li>《深入理解Android卷1》</li><li>《深入理解Android系统》</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前面说到init进程的启动过程主要做了三件事，其中一件就是创建zygote进程，那么zygote进程做了什么？&lt;/p&gt;
&lt;h1 id=&quot;1-
      
    
    </summary>
    
      <category term="Android进阶" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
      <category term="框架层" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/"/>
    
      <category term="系统启动" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8/"/>
    
    
      <category term="Android系统启动" scheme="https://tylerLiu.top/tags/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>Android系统启动流程 01：init进程</title>
    <link href="https://tylerLiu.top/2019/08/24/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B01%EF%BC%9Ainit%E8%BF%9B%E7%A8%8B/"/>
    <id>https://tylerLiu.top/2019/08/24/Android系统启动流程01：init进程/</id>
    <published>2019-08-24T07:49:27.000Z</published>
    <updated>2019-09-11T08:04:01.235Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>init进程是Android系统中用户空间的第一个进程。有很多重要职责，如，创建zygote(孵化器)和属性服务等。</p><p>init进程由多个源文件共同组成，这些文件位于源码目录system/core/init中。 本文将基于Android 7.0分析init进程。</p><h1 id="2-引入init进程"><a href="#2-引入init进程" class="headerlink" title="2. 引入init进程"></a>2. 引入init进程</h1><p>Android系统启动流程：</p><ol><li>启动电源以及系统启动：当按下电源键时，引导芯片代码开始从预定义的地方（固化在ROM）开始执行。加载引导程序Bootloader到RAM，然后执行。</li><li>引导程序Bootloader：引导程序是在Android操作系统开始运行前的一个小程序，主要作用是把系统OS拉起并运行。</li><li>Linux内核启动：内核启动时，设置缓存、被保护存储器、计划列表，加载启动。当内核完成系统设置，首先在系统文件中寻找init文件，然后启动root进程或者系统的第一个进程。</li><li>init进程启动</li></ol><h1 id="3-init入口函数"><a href="#3-init入口函数" class="headerlink" title="3. init入口函数"></a>3. init入口函数</h1><p>iniy的入口函数为<code>main()</code>，代码如下：system/core/init/init.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(basename(argv[<span class="number">0</span>]), <span class="string">"ueventd"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ueventd_main(argc, argv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(basename(argv[<span class="number">0</span>]), <span class="string">"watchdogd"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> watchdogd_main(argc, argv);</span><br><span class="line">    &#125;</span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line">    add_environment(<span class="string">"PATH"</span>, _PATH_DEFPATH);</span><br><span class="line">    <span class="keyword">bool</span> is_first_stage = (argc == <span class="number">1</span>) || (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"--second-stage"</span>) != <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 创建文件并挂载</span></span><br><span class="line">    <span class="keyword">if</span> (is_first_stage) &#123;</span><br><span class="line">        mount(<span class="string">"tmpfs"</span>, <span class="string">"/dev"</span>, <span class="string">"tmpfs"</span>, MS_NOSUID, <span class="string">"mode=0755"</span>);</span><br><span class="line">        mkdir(<span class="string">"/dev/pts"</span>, <span class="number">0755</span>);</span><br><span class="line">        mkdir(<span class="string">"/dev/socket"</span>, <span class="number">0755</span>);</span><br><span class="line">        mount(<span class="string">"devpts"</span>, <span class="string">"/dev/pts"</span>, <span class="string">"devpts"</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> MAKE_STR(x) __STRING(x)</span></span><br><span class="line">        mount(<span class="string">"proc"</span>, <span class="string">"/proc"</span>, <span class="string">"proc"</span>, <span class="number">0</span>, <span class="string">"hidepid=2,gid="</span> MAKE_STR(AID_READPROC));</span><br><span class="line">        mount(<span class="string">"sysfs"</span>, <span class="string">"/sys"</span>, <span class="string">"sysfs"</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    open_devnull_stdio();</span><br><span class="line">    klog_init();</span><br><span class="line">    klog_set_level(KLOG_NOTICE_LEVEL);</span><br><span class="line">    NOTICE(<span class="string">"init %s started!\n"</span>, is_first_stage ? <span class="string">"first stage"</span> : <span class="string">"second stage"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!is_first_stage) &#123;</span><br><span class="line">        <span class="comment">// Indicate that booting is in progress to background fw loaders, etc.</span></span><br><span class="line">        close(open(<span class="string">"/dev/.booting"</span>, O_WRONLY | O_CREAT | O_CLOEXEC, <span class="number">0000</span>));</span><br><span class="line">        <span class="comment">// 初始化属性相关资源</span></span><br><span class="line">        property_init();<span class="comment">// 1</span></span><br><span class="line">        process_kernel_dt();</span><br><span class="line">        process_kernel_cmdline();</span><br><span class="line">        export_kernel_boot_props();</span><br><span class="line">    &#125;</span><br><span class="line"> ...</span><br><span class="line">    <span class="comment">// 启动属性服务</span></span><br><span class="line">    start_property_service();<span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">const</span> BuiltinFunctionMap function_map;</span><br><span class="line">    Action::set_function_map(&amp;function_map);</span><br><span class="line">    Parser&amp; parser = Parser::GetInstance();</span><br><span class="line">    parser.AddSectionParser(<span class="string">"service"</span>,<span class="built_in">std</span>::make_unique&lt;ServiceParser&gt;());</span><br><span class="line">    parser.AddSectionParser(<span class="string">"on"</span>, <span class="built_in">std</span>::make_unique&lt;ActionParser&gt;());</span><br><span class="line">    parser.AddSectionParser(<span class="string">"import"</span>, <span class="built_in">std</span>::make_unique&lt;ImportParser&gt;());</span><br><span class="line">    <span class="comment">// 解析init.rc配置文件</span></span><br><span class="line">    parser.ParseConfig(<span class="string">"/init.rc"</span>);<span class="comment">// 3</span></span><br><span class="line">   ...   </span><br><span class="line">       <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!waiting_for_exec) &#123;</span><br><span class="line">            am.ExecuteOneCommand();</span><br><span class="line">            restart_processes();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> timeout = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (process_needs_restart) &#123;</span><br><span class="line">            timeout = (process_needs_restart - gettime()) * <span class="number">1000</span>;</span><br><span class="line">            <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>)</span><br><span class="line">                timeout = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (am.HasMoreCommands()) &#123;</span><br><span class="line">            timeout = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bootchart_sample(&amp;timeout);</span><br><span class="line">        epoll_event ev;</span><br><span class="line">        <span class="keyword">int</span> nr = TEMP_FAILURE_RETRY(epoll_wait(epoll_fd, &amp;ev, <span class="number">1</span>, timeout));</span><br><span class="line">        <span class="keyword">if</span> (nr == <span class="number">-1</span>) &#123;</span><br><span class="line">            ERROR(<span class="string">"epoll_wait failed: %s\n"</span>, strerror(errno));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nr == <span class="number">1</span>) &#123;</span><br><span class="line">            ((<span class="keyword">void</span> (*)()) ev.data.ptr)();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>init的<code>main()</code>方法中做了很多事情，主要有以下几点：</p><ol><li>注释1调用<code>property_init()</code>对属性进行初始化</li><li>注释2调用<code>start_property_service()</code>启动属性服务</li><li>注释3使用<code>parser.ParserConfig(&quot;init.rc&quot;)</code>用来解析<code>init.rc</code>。解析<code>init.rc</code>的文件为system/core/init/init_parse.cpp。</li></ol><p>下面看看<code>init.rc</code>里面做了什么。</p><h1 id="4-init-rc"><a href="#4-init-rc" class="headerlink" title="4. init.rc"></a>4. init.rc</h1><p><code>init.rc</code>是一个配置文件，内部由Android初始化语言（Android Init Language）编写的脚本，主要包含五种类型语句：<code>Action</code>、<code>Commands</code>、<code>Services</code>、<code>Options</code>和<code>Inport</code>。</p><p><code>init.rc</code>配置代码如下：system/core/rootdir/init.rc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">on init</span><br><span class="line">    sysclktz 0</span><br><span class="line">    # Mix device-specific information into the entropy pool</span><br><span class="line">    copy /proc/cmdline /dev/urandom</span><br><span class="line">    copy /default.prop /dev/urandom</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">on boot</span><br><span class="line">    # basic network init</span><br><span class="line">    ifup lo</span><br><span class="line">    hostname localhost</span><br><span class="line">    domainname localdomain</span><br><span class="line">    # set RLIMIT_NICE to allow priorities from 19 to -20</span><br><span class="line">    setrlimit 13 40 40</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>on init</code>和<code>on boot</code>是<code>Action</code>语句，格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">on &lt;trigger&gt; [&amp;&amp; &lt;trigger&gt;]* // 设置触发器</span><br><span class="line">    &lt;command&gt;</span><br><span class="line">    &lt;command&gt; // 动作触发之后要执行的命令</span><br></pre></td></tr></table></figure><p>为了分析如何创建zygote，主要看<code>Services</code>类型的语句，格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service &lt;name&gt; &lt;pathname&gt; [&lt;argument&gt;]* // &lt;service的名字&gt;&lt;执行程序路径&gt;&lt;传递参数&gt;</span><br><span class="line">    &lt;option&gt; // option是service的修饰词，影响什么时候，如何启动services</span><br><span class="line">    &lt;option&gt;</span><br></pre></td></tr></table></figure><p>注意：Android 7.0中对<code>init.rc</code>进行了拆分，每个服务一个rc文件。要分析的zygote服务的启动脚本在init.zygoteXX.rc中，这里以64位处理器为例，init.zygote64.rc代码如下：system/core/rootdir/init.zygote64.rc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server</span><br><span class="line">    class main</span><br><span class="line">    socket zygote stream 660 root system</span><br><span class="line">    onrestart write /sys/android_power/request_state wake</span><br><span class="line">    onrestart write /sys/power/state on</span><br><span class="line">    onrestart restart audioserver</span><br><span class="line">    onrestart restart cameraserver</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart netd</span><br><span class="line">    writepid /dev/cpuset/foreground/tasks /dev/stune/foreground/tasks</span><br></pre></td></tr></table></figure><p>其中<code>service</code>用于通知init进程创建名为<code>zygote</code>的进程，这个<code>zygote</code>进程执行程序的路径为<code>/system/bin/app_process64</code>，后面的是要传给<code>app_process64</code>的参数。<code>class main</code>指<code>zygote</code>的<code>calss name</code>为<code>main</code>，后面会用到。</p><h1 id="5-解析service"><a href="#5-解析service" class="headerlink" title="5. 解析service"></a>5. 解析service</h1><p>解析<code>service</code>会用到两个函数：</p><ul><li><code>ParseSection</code>：解析<code>service</code>的rc文件，比如前面的init.zygote64.rc，主要用来搭建<code>service</code>的架子</li><li><code>ParselineSection</code>：用于解析子项</li></ul><p>代码如下：system/core/init/service.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> ServiceParser::ParseSection(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; args,</span><br><span class="line">                                 <span class="built_in">std</span>::<span class="built_in">string</span>* err) &#123;</span><br><span class="line">    <span class="keyword">if</span> (args.size() &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        *err = <span class="string">"services must have a name and a program"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name = args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (!IsValidName(name)) &#123;</span><br><span class="line">        *err = StringPrintf(<span class="string">"invalid service name '%s'"</span>, name.c_str());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; str_args(args.begin() + <span class="number">2</span>, args.end());</span><br><span class="line">    service_ = <span class="built_in">std</span>::make_unique&lt;Service&gt;(name, <span class="string">"default"</span>, str_args);<span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> ServiceParser::ParseLineSection(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; args,</span><br><span class="line">                                     <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename, <span class="keyword">int</span> line,</span><br><span class="line">                                     <span class="built_in">std</span>::<span class="built_in">string</span>* err) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> service_ ? service_-&gt;HandleLine(args, err) : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，根据参数构造出一个<code>service</code>对象，其<code>classname</code>为<code>&quot;default&quot;</code>。当解析完毕时会调用<code>EndSection()</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ServiceParser::EndSection() &#123;</span><br><span class="line">    <span class="keyword">if</span> (service_) &#123;</span><br><span class="line">        ServiceManager::GetInstance().AddService(<span class="built_in">std</span>::move(service_));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>AddService()</code>中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ServiceManager::AddService(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Service&gt; service) &#123;</span><br><span class="line">    Service* old_service = FindServiceByName(service-&gt;name());</span><br><span class="line">    <span class="keyword">if</span> (old_service) &#123;</span><br><span class="line">        ERROR(<span class="string">"ignored duplicate definition of service '%s'"</span>,</span><br><span class="line">              service-&gt;name().c_str());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    services_.emplace_back(<span class="built_in">std</span>::move(service));<span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，将<code>service</code>对象添加到<code>services</code>链表中。</p><p>总的来说就是根据参数创建出<code>service</code>对象，然后根据选项域的内容填充<code>service</code>对象，最后将<code>service</code>对象添加到<code>vector</code>类型的<code>services</code>链表中。</p><h1 id="6-init启动zygote"><a href="#6-init启动zygote" class="headerlink" title="6. init启动zygote"></a>6. init启动zygote</h1><p>了解完<code>service</code>，下面看看<code>init</code>是如何启动<code>service</code>，这里主要讲启动zygote的这个<code>service</code>。在zygote的启动脚本中得知zygote的class name为<code>main</code>，在init.rc有如下配置代码：system/core/rootdir/init.rc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">on nonencrypted    </span><br><span class="line">    # A/B update verifier that marks a successful boot.  </span><br><span class="line">    exec - root -- /system/bin/update_verifier nonencrypted  </span><br><span class="line">    class_start main         </span><br><span class="line">    class_start late_start </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>其中<code>class_start</code>是一个<code>COMMAND</code>，对应的函数为<code>do_class_start</code>。因为<code>main</code>指的是zygote，因此<code>class_start main</code>就是用来启动zygote。<code>do_class_start</code>是定义在builtins.cpp中的，如下：system/core/init/builtins.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_class_start</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* Starting a class does not start services</span></span><br><span class="line"><span class="comment">         * which are explicitly disabled.  They must</span></span><br><span class="line"><span class="comment">         * be started individually.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    ServiceManager::GetInstance().</span><br><span class="line">        ForEachServiceInClass(args[<span class="number">1</span>], [] (Service* s) &#123; s-&gt;StartIfNotDisabled(); &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在里面最终调用了<code>StartIfNotDisabled</code>：systme/core/init/service.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Service::StartIfNotDisabled() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(flags_ &amp; SVC_DISABLED)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Start();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        flags_ |= SVC_DISABLED_START;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看看里面的<code>Start()</code>方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Service::Start() &#123;</span><br><span class="line">    flags_ &amp;= (~(SVC_DISABLED|SVC_RESTARTING|SVC_RESET|SVC_RESTART|SVC_DISABLED_START));</span><br><span class="line">    time_started_ = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (flags_ &amp; SVC_RUNNING) &#123;<span class="comment">// 如果Service已经运行，则不启动</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> needs_console = (flags_ &amp; SVC_CONSOLE);</span><br><span class="line">    <span class="keyword">if</span> (needs_console &amp;&amp; !have_console) &#123;</span><br><span class="line">        ERROR(<span class="string">"service '%s' requires console\n"</span>, name_.c_str());</span><br><span class="line">        flags_ |= SVC_DISABLED;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断需要启动的Service的对应的执行文件是否存在，不存在则不启动该Service</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (stat(args_[<span class="number">0</span>].c_str(), &amp;sb) == <span class="number">-1</span>) &#123;</span><br><span class="line">        ERROR(<span class="string">"cannot find '%s' (%s), disabling '%s'\n"</span>,</span><br><span class="line">              args_[<span class="number">0</span>].c_str(), strerror(errno), name_.c_str());</span><br><span class="line">        flags_ |= SVC_DISABLED;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.fork函数创建子进程</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;<span class="comment">// 运行在子进程中</span></span><br><span class="line">        umask(<span class="number">077</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; ei : envvars_) &#123;</span><br><span class="line">            add_environment(ei.name.c_str(), ei.value.c_str());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; si : sockets_) &#123;</span><br><span class="line">            <span class="keyword">int</span> socket_type = ((si.type == <span class="string">"stream"</span> ? SOCK_STREAM :</span><br><span class="line">                                (si.type == <span class="string">"dgram"</span> ? SOCK_DGRAM :</span><br><span class="line">                                 SOCK_SEQPACKET)));</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span>* socketcon =</span><br><span class="line">                !si.socketcon.empty() ? si.socketcon.c_str() : scon.c_str();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> s = create_socket(si.name.c_str(), socket_type, si.perm,</span><br><span class="line">                                  si.uid, si.gid, socketcon);</span><br><span class="line">            <span class="keyword">if</span> (s &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                PublishSocket(si.name, s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">        <span class="comment">// 2.通过execve执行程序</span></span><br><span class="line">        <span class="keyword">if</span> (execve(args_[<span class="number">0</span>].c_str(), (<span class="keyword">char</span>**) &amp;strs[<span class="number">0</span>], (<span class="keyword">char</span>**) ENV) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ERROR(<span class="string">"cannot execve('%s'): %s\n"</span>, args_[<span class="number">0</span>].c_str(), strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _exit(<span class="number">127</span>);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过注释1和注释2的代码，得知在<code>Start()</code>方法中，调用<code>fork()</code>函数来创建子线程，并在子线程中调用<code>execve()</code>执行system/bin/app_process，这样就会进入frameworks/base/cmds/app_progress/app_main.cpp中的<code>main()</code>函数，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (zygote) &#123;</span><br><span class="line">        runtime.start(<span class="string">"com.android.internal.os.ZygoteInit"</span>, args, zygote);<span class="comment">// 1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className) &#123;</span><br><span class="line">        runtime.start(<span class="string">"com.android.internal.os.RuntimeInit"</span>, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error: no class name or --zygote supplied.\n"</span>);</span><br><span class="line">        app_usage();</span><br><span class="line">        LOG_ALWAYS_FATAL(<span class="string">"app_process: no class name or --zygote supplied."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1可以看到，调用<code>runntime(AppRuntime)</code>的<code>start()</code>来启动zygote。</p><h1 id="7-属性服务"><a href="#7-属性服务" class="headerlink" title="7. 属性服务"></a>7. 属性服务</h1><p>Windows上有一个注册管理表，注册管理表的内容是采用键值对的形式来记录用户、软件的一些使用信息。即使系统或者软件重启，它还是能根据之前在注册表中的记录，进行相应的初始化工作。</p><p>Android中也有一个类似的机制，叫做属性服务。</p><p>文章开始提到的在init.cpp代码中和属性服务相关的代码有：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化属性服务配置</span></span><br><span class="line">property_init();</span><br><span class="line"><span class="comment">// 启动属性服务</span></span><br><span class="line">start_property_service();</span><br></pre></td></tr></table></figure><h2 id="7-1-属性服务的初始化与启动"><a href="#7-1-属性服务的初始化与启动" class="headerlink" title="7.1 属性服务的初始化与启动"></a>7.1 属性服务的初始化与启动</h2><p><code>property_init()</code>具体实现如下：system/core/init/property_service.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">property_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (__system_property_area_init()) &#123;</span><br><span class="line">        ERROR(<span class="string">"Failed to initialize property area\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_system_property_are_init()</code>是用来初始化属性内存区域。</p><p>下面看看<code>start_property_service()</code>的具体实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start_property_service</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    property_set_fd = create_socket(PROP_SERVICE_NAME, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,</span><br><span class="line">                                    <span class="number">0666</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);<span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> (property_set_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        ERROR(<span class="string">"start_property_service socket creation failed: %s\n"</span>, strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    listen(property_set_fd, <span class="number">8</span>);<span class="comment">// 2</span></span><br><span class="line">    register_epoll_handler(property_set_fd, handle_property_set_fd);<span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，创建非阻塞的<code>socket</code>。</p><p>注释2，调用<code>listen()</code>对<code>property_set_fd</code>进行监听，这样创建的<code>socket</code>就成为了<code>server</code>，也就是属性服务；<code>listen()</code>函数的第二个参数设置成<code>8</code>，意味着属性服务最多可以同时为8个试图设置属性的用户提供服务。</p><p>注释3，将<code>property_set_fd</code>放到<code>epoll()</code>句柄中，用<code>epoll()</code>来监听<code>property_set_fd</code>：当<code>property_set_fd</code>中有数据到来时，init进程将用<code>handle_property_set_fd()</code>函数进行处理。</p><p>在linux新的内核中，<code>epoll()</code>用来替换<code>select()</code>，<code>epoll()</code>的最大好处是它不会随着监听<code>fd</code>数量的增加而降低效率。因为内核中<code>select()</code>的实现采用的是轮询处理，轮询的<code>fd</code>数量多了，耗时就多。</p><h2 id="7-2-属性服务处理请求"><a href="#7-2-属性服务处理请求" class="headerlink" title="7.2 属性服务处理请求"></a>7.2 属性服务处理请求</h2><p>从上文得知，属性服务接收到客户端的请求时，会调用<code>handle_property_set_fd</code>函数进行处理：system/core/init/property_service.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_property_set_fd</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">memcmp</span>(msg.name,<span class="string">"ctl."</span>,<span class="number">4</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            close(s);</span><br><span class="line">            <span class="keyword">if</span> (check_control_mac_perms(msg.value, source_ctx, &amp;cr)) &#123;</span><br><span class="line">                handle_control_message((<span class="keyword">char</span>*) msg.name + <span class="number">4</span>, (<span class="keyword">char</span>*) msg.value);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ERROR(<span class="string">"sys_prop: Unable to %s service ctl [%s] uid:%d gid:%d pid:%d\n"</span>,</span><br><span class="line">                        msg.name + <span class="number">4</span>, msg.value, cr.uid, cr.gid, cr.pid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 检查客户端进程权限</span></span><br><span class="line">            <span class="keyword">if</span> (check_mac_perms(msg.name, source_ctx, &amp;cr)) &#123;<span class="comment">// 1</span></span><br><span class="line">                property_set((<span class="keyword">char</span>*) msg.name, (<span class="keyword">char</span>*) msg.value);<span class="comment">// 2</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ERROR(<span class="string">"sys_prop: permission denied uid:%d  name:%s\n"</span>,</span><br><span class="line">                      cr.uid, msg.name);</span><br><span class="line">            &#125;</span><br><span class="line">            close(s);</span><br><span class="line">        &#125;</span><br><span class="line">        freecon(source_ctx);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        close(s);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1，用来检查客户端进程权限</p><p>注释2，调用<code>property_set</code>函数对属性进行修改，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">property_set</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> <span class="keyword">char</span>* value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rc = property_set_impl(name, value);</span><br><span class="line">    <span class="keyword">if</span> (rc == <span class="number">-1</span>) &#123;</span><br><span class="line">        ERROR(<span class="string">"property_set(\"%s\", \"%s\") failed\n"</span>, name, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>property_set</code>函数注意调用了<code>property_set_impl()</code>函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">property_set_impl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> <span class="keyword">char</span>* value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> namelen = <span class="built_in">strlen</span>(name);</span><br><span class="line">    <span class="keyword">size_t</span> valuelen = <span class="built_in">strlen</span>(value);</span><br><span class="line">    <span class="keyword">if</span> (!is_legal_property_name(name, namelen)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (valuelen &gt;= PROP_VALUE_MAX) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">"selinux.reload_policy"</span>, name) == <span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>(<span class="string">"1"</span>, value) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (selinux_reload_policy() != <span class="number">0</span>) &#123;</span><br><span class="line">            ERROR(<span class="string">"Failed to reload policy\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">"selinux.restorecon_recursive"</span>, name) == <span class="number">0</span> &amp;&amp; valuelen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (restorecon_recursive(value) != <span class="number">0</span>) &#123;</span><br><span class="line">            ERROR(<span class="string">"Failed to restorecon_recursive %s\n"</span>, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从属性存储空间查找该属性</span></span><br><span class="line">    prop_info* pi = (prop_info*) __system_property_find(name);</span><br><span class="line">    <span class="comment">// 如果属性存在</span></span><br><span class="line">    <span class="keyword">if</span>(pi != <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="comment">// 如果属性以"ro."开头，则表示是只读，不能修改，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strncmp</span>(name, <span class="string">"ro."</span>, <span class="number">3</span>)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">       <span class="comment">// 更新属性值</span></span><br><span class="line">        __system_property_update(pi, value, valuelen);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果属性不存在则添加该属性</span></span><br><span class="line">        <span class="keyword">int</span> rc = __system_property_add(name, namelen, value, valuelen);</span><br><span class="line">        <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> rc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* If name starts with "net." treat as a DNS property. */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strncmp</span>(<span class="string">"net."</span>, name, <span class="built_in">strlen</span>(<span class="string">"net."</span>)) == <span class="number">0</span>)  &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">"net.change"</span>, name) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 以net.开头的属性名称更新后，需要将属性名称写入net.change中</span></span><br><span class="line">        property_set(<span class="string">"net.change"</span>, name);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (persistent_properties_loaded &amp;&amp;</span><br><span class="line">            <span class="built_in">strncmp</span>(<span class="string">"persist."</span>, name, <span class="built_in">strlen</span>(<span class="string">"persist."</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Don't write properties to disk until after we have read all default properties</span></span><br><span class="line"><span class="comment">         * to prevent them from being overwritten by default values.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        write_persistent_property(name, value);</span><br><span class="line">    &#125;</span><br><span class="line">    property_changed(name, value);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>property_set_impl</code>函数主要用来对属性进行修改，并对<code>ro</code>、<code>net</code>和<code>persist</code>开头的属性进行相应的处理。</p><h1 id="8-init进程总结"><a href="#8-init进程总结" class="headerlink" title="8. init进程总结"></a>8. init进程总结</h1><p>init进程主要做了三件事：</p><ol><li>创建一些文件夹并挂载设备</li><li>初始化和启动属性服务</li><li>解析init.rc配置文件并启动zygote进程</li></ol><p>参考资料：</p><ul><li>《深入理解Android系统》</li><li>《深入理解Android卷I》</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h1&gt;&lt;p&gt;init进程是Android系统中用户空间的第一个进程。有很多重要职责，如，创建zygote(孵化器)和属性服务等。&lt;/
      
    
    </summary>
    
      <category term="Android进阶" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
      <category term="框架层" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/"/>
    
      <category term="系统启动" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8/"/>
    
    
      <category term="Android系统启动" scheme="https://tylerLiu.top/tags/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>Android系统架构与系统源码目录</title>
    <link href="https://tylerLiu.top/2019/08/24/Android%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E4%B8%8E%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%9B%AE%E5%BD%95/"/>
    <id>https://tylerLiu.top/2019/08/24/Android系统架构与系统源码目录/</id>
    <published>2019-08-24T02:19:25.000Z</published>
    <updated>2019-09-11T08:03:54.433Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Android系统架构"><a href="#1-Android系统架构" class="headerlink" title="1. Android系统架构"></a>1. Android系统架构</h1><p>Android系统架构分成五层，从上到下依次为：应用层、应用框架层、系统运行层、硬件抽象层和Linux内核层。</p><img src="/2019/08/24/Android系统架构与系统源码目录/15233854-1354887e982ab461.jpg"><h2 id="1-1-应用层"><a href="#1-1-应用层" class="headerlink" title="1.1 应用层"></a>1.1 应用层</h2><p>系统内置的应用程序以及非系统级的应用程序都属于应用层。负责与用户进行直接交互。该层主要由Java代码编写，现在已经扩充到Kotlin和Flutter。</p><h2 id="1-2-应用框架层"><a href="#1-2-应用框架层" class="headerlink" title="1.2 应用框架层"></a>1.2 应用框架层</h2><p>为开发者提供了可以开发应用程序所需的API，通常开发应用程序所调用的API都属于该层，也包括系统的应用。该层由Java编写，也称Java FragmeWork。该层的主要组件由：</p><table><thead><tr><th align="center">名称</th><th align="center">功能描述</th></tr></thead><tbody><tr><td align="center">Activity Manager 活动管理器</td><td align="center">管理各个应用程序生命周期以及通常的导航回退功能</td></tr><tr><td align="center">Location Manager 位置管理器</td><td align="center">提供地理位置以及定位功能服务</td></tr><tr><td align="center">Package Manager 包管理器</td><td align="center">管理所有安装在Android系统中的应用程序</td></tr><tr><td align="center">Notification Manager 通知管理器</td><td align="center">使得应用程序可以在状态栏中显示自定义的提示信息</td></tr><tr><td align="center">Resource Manager 资源管理器</td><td align="center">提供应用程序使用的各种非代码资源，如本地化字符串、图片、布局文件、颜色文件等</td></tr><tr><td align="center">Telephone Manager 电话管理器</td><td align="center">管理所有的移动设备功能</td></tr><tr><td align="center">Window Manager 窗口管理器</td><td align="center">管理所有开启的窗口程序</td></tr><tr><td align="center">Content Provider 内容提供器</td><td align="center">使得不同的应用程序之间可以共享数据</td></tr><tr><td align="center">View System 视图系统</td><td align="center">构建应用程序的基本组件</td></tr></tbody></table><h2 id="1-3-系统运行层（Native）"><a href="#1-3-系统运行层（Native）" class="headerlink" title="1.3 系统运行层（Native）"></a>1.3 系统运行层（Native）</h2><p>系统运行层分成两个部分：C/C++程序库、Android运行时库。</p><h3 id="1-3-1-C-C-程序库"><a href="#1-3-1-C-C-程序库" class="headerlink" title="1.3.1 C/C++程序库"></a>1.3.1 C/C++程序库</h3><p>C/C++程序库能被Android系统中的不同组件所使用，并通过应用程序框架为开发者提供服务，主要的C/C++程序库如下：</p><table><thead><tr><th align="center">名称</th><th align="center">功能描述</th></tr></thead><tbody><tr><td align="center">OpenGL ES</td><td align="center">3D绘图函数库</td></tr><tr><td align="center">Libc</td><td align="center">从BSD继承来的标准C系统函数库，专门为基于嵌入式Linux的设备定制</td></tr><tr><td align="center">Media Framework</td><td align="center">多媒体库，支持多种常用的音频，视频格式录制和回放</td></tr><tr><td align="center">SQLite</td><td align="center">轻型的关系型数据库引擎</td></tr><tr><td align="center">SGL</td><td align="center">底层的2D图形渲染引擎</td></tr><tr><td align="center">SSL</td><td align="center">安全嵌套层，是为了网络通信提供安全及数据完整性的一种安全协议</td></tr><tr><td align="center">FreeType</td><td align="center">可移植的字体引擎，提供了统一的接口来访问多种字体格式文件</td></tr></tbody></table><h3 id="1-3-2-Android运行时库"><a href="#1-3-2-Android运行时库" class="headerlink" title="1.3.2 Android运行时库"></a>1.3.2 Android运行时库</h3><p>分为核心库和ART。核心库提供Java语言核心库的大多数功能，这样就能使用Java编写Android应用。相较于JVM，Dalvik虚拟机是专门为移动设备定制的，允许在有限的内存中同时运行多个虚拟机的实例，并且每个Dalvik应用作为一个独立的Linux进程执行。</p><p>独立的进程可以防止在虚拟机崩溃时所有程序都关闭。而替代Dalvik虚拟机的ART的机制与Dalvik不同。</p><p>在Dalvik中，应用每次运行的时候，字节码都需要通过即时编译器转换为机器码，这样运行效率很慢，而在ART环境下，应用在第一次安装的时候，字节码就会预编译成机器码，使其成为真正的本地应用。</p><h2 id="1-4-硬件抽象层（HAL）"><a href="#1-4-硬件抽象层（HAL）" class="headerlink" title="1.4 硬件抽象层（HAL）"></a>1.4 硬件抽象层（HAL）</h2><p>HAL是位于操作系统内核与硬件电路之间的接口层，其目的在于将硬件抽象化，为了保护硬件厂商知识产权，它隐藏了特定平台的硬件接口细节，为操作系统提供虚拟的硬件平台，使其可以在多种平台上移植。</p><p>从软硬件测试的角度来看，软硬件的测试工作都可分别基于硬件抽象层来完成，使得软硬件测试工作的并行成为可能。通俗来讲，就是将控制硬件的工作放在硬件抽象层中。</p><h2 id="1-5-Linux内核层"><a href="#1-5-Linux内核层" class="headerlink" title="1.5 Linux内核层"></a>1.5 Linux内核层</h2><p>Android的核心系统服务是基于Linux内核，在此基础上添加了部分Android专用的驱动。系统的安全性、内存管理、进程管理、网络协议栈和驱动模型等都依赖于该内核。</p><h1 id="2-Android系统源码目录"><a href="#2-Android系统源码目录" class="headerlink" title="2. Android系统源码目录"></a>2. Android系统源码目录</h1><p>在线查看源码：<a href="http://androidxref.com/" target="_blank" rel="noopener">http://androidxref.com/</a></p><p>下载查看：<strong><font color="#FFFF00">源码的详细安装可以查看AOSP的内容</font></strong></p><p>谷歌下载网站：<a href="https://source.android.google.cn/source/downloading" target="_blank" rel="noopener">https://source.android.google.cn/source/downloading</a></p><p>清华大学镜像：<a href="https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/</a></p><h2 id="2-1-整体结构"><a href="#2-1-整体结构" class="headerlink" title="2.1 整体结构"></a>2.1 整体结构</h2><p>各个版本的源码结构类似，编译后会多出一个out文件夹，用来存储编译产生的文件。以Android 7.0为例，根目录结构如下：</p><table><thead><tr><th align="center">Android源码根目录</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">abi</td><td align="center">应用程序二进制接口</td></tr><tr><td align="center">art</td><td align="center">ART运行环境</td></tr><tr><td align="center">bionic</td><td align="center">系统C库</td></tr><tr><td align="center">bootable</td><td align="center">启动引导相关代码</td></tr><tr><td align="center">build</td><td align="center">存放系统编译规则以及generic等基础开发包设置</td></tr><tr><td align="center">cts</td><td align="center">Android兼容性测试套件标准</td></tr><tr><td align="center">dalvik</td><td align="center">Dalvik虚拟机</td></tr><tr><td align="center">developers</td><td align="center">开发者目录</td></tr><tr><td align="center">development</td><td align="center">应用程序开发相关</td></tr><tr><td align="center">devices</td><td align="center">设备相关配置</td></tr><tr><td align="center">docs</td><td align="center">参考文档目录</td></tr><tr><td align="center">external</td><td align="center">开源模组相关文件</td></tr><tr><td align="center">frameworks</td><td align="center">应用程序框架，Android系统核心部分，由Java和C++编写</td></tr><tr><td align="center">hardware</td><td align="center">主要是硬件抽象层的代码</td></tr><tr><td align="center">libcore</td><td align="center">核心库相关文件</td></tr><tr><td align="center">libnativehelper</td><td align="center">动态库，实现JNI库的基础</td></tr><tr><td align="center">ndk</td><td align="center">NDK相关代码，帮助开发者在应用程序中嵌入C/C++代码</td></tr><tr><td align="center">out</td><td align="center">编译完成后的代码存放的文件夹</td></tr><tr><td align="center">packages</td><td align="center">Plug Development Kit的缩写，本地开发套件</td></tr><tr><td align="center">platform_testing</td><td align="center">平台测试</td></tr><tr><td align="center">prebuilts</td><td align="center">X86和ARM架构下预编译的一些资源</td></tr><tr><td align="center">sdk</td><td align="center">SDK和模拟器</td></tr><tr><td align="center">system</td><td align="center">底层文件系统库、应用和组件</td></tr><tr><td align="center">toolchain</td><td align="center">工具链文件</td></tr><tr><td align="center">tools</td><td align="center">工具文件</td></tr><tr><td align="center">Makefile</td><td align="center">全局Makefile文件，用来定义编译规则</td></tr></tbody></table><h2 id="2-2-应用层部分：-packages文件夹"><a href="#2-2-应用层部分：-packages文件夹" class="headerlink" title="2.2 应用层部分：/packages文件夹"></a>2.2 应用层部分：/packages文件夹</h2><p>应用层位于整个Android系统的最上层，开发的应用程序和系统内置的应用程序都在应用层。源码根目录中的packages目录对应着系统的应用层。</p><table><thead><tr><th align="center">/packages目录</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">apps</td><td align="center">核心应用程序</td></tr><tr><td align="center">experimental</td><td align="center">第三方应用程序</td></tr><tr><td align="center">inputmethods</td><td align="center">输入法目录</td></tr><tr><td align="center">providers</td><td align="center">内容提供者目录</td></tr><tr><td align="center">screensavers</td><td align="center">屏幕保护</td></tr><tr><td align="center">services</td><td align="center">通信服务</td></tr><tr><td align="center">wallpapers</td><td align="center">壁纸</td></tr></tbody></table><h2 id="2-3-应用框架层部分：-frameworks文件夹"><a href="#2-3-应用框架层部分：-frameworks文件夹" class="headerlink" title="2.3 应用框架层部分：/frameworks文件夹"></a>2.3 应用框架层部分：/frameworks文件夹</h2><p>应用框架层，一方面向上提供接口给应用层调用，另一方面向下与C/C++程序库以及硬件抽象层等进行衔接。应用框架层的代码主要在/frameworks/base和/framework/av目录下。</p><table><thead><tr><th align="center">/frameworks/base目录</th><th align="center">描述</th><th align="center"></th><th align="center">/frameworks/base目录</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">api</td><td align="center">定义API</td><td align="center"></td><td align="center">cmds</td><td align="center">重要命令：am、app_proce等</td></tr><tr><td align="center">core</td><td align="center">核心库</td><td align="center"></td><td align="center">data</td><td align="center">字体和声音等数据文件</td></tr><tr><td align="center">docs</td><td align="center">文档</td><td align="center"></td><td align="center">graphics</td><td align="center">图形图像相关</td></tr><tr><td align="center">include</td><td align="center">头文件</td><td align="center"></td><td align="center">keystore</td><td align="center">和数字签名证书相关</td></tr><tr><td align="center">libs</td><td align="center">库</td><td align="center"></td><td align="center">location</td><td align="center">地理位置相关库</td></tr><tr><td align="center">media</td><td align="center">多媒体相关库</td><td align="center"></td><td align="center">native</td><td align="center">本地库</td></tr><tr><td align="center">nfc-extras</td><td align="center">NFC相关</td><td align="center"></td><td align="center">obex</td><td align="center">蓝牙传输</td></tr><tr><td align="center">opengl</td><td align="center">2D/3D图形API</td><td align="center"></td><td align="center">packages</td><td align="center">设置、TTS、VPN程序</td></tr><tr><td align="center">sax</td><td align="center">XML解析器</td><td align="center"></td><td align="center">services</td><td align="center">系统服务</td></tr><tr><td align="center">telephone</td><td align="center">电话通讯管理</td><td align="center"></td><td align="center">test-runner</td><td align="center">测试工具相关</td></tr><tr><td align="center">tests</td><td align="center">测试相关</td><td align="center"></td><td align="center">tools</td><td align="center">工具</td></tr><tr><td align="center">wifi</td><td align="center">WIFI无限网络</td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="2-4-系统运行层：C-C-程序库部分"><a href="#2-4-系统运行层：C-C-程序库部分" class="headerlink" title="2.4 系统运行层：C/C++程序库部分"></a>2.4 系统运行层：C/C++程序库部分</h2><p>系统运行层（Native）中的C/C++程序库的类型繁多，功能强大，C/C++程序库不在一个目录中，这里列举几个常用和重要的C/C++程序库所在的目录。</p><table><thead><tr><th align="center">目录位置</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">bionic/</td><td align="center">谷歌开发的系统C库，以BSD许可形式开源</td></tr><tr><td align="center">/frameworks/av/media</td><td align="center">系统媒体库</td></tr><tr><td align="center">/frameworks/native/opengl</td><td align="center">第三方图形渲染库</td></tr><tr><td align="center">/fframeorks/native/services/surfaceflinger</td><td align="center">图形显示库，主要负责图形的渲染、叠加和绘制等功能</td></tr><tr><td align="center">external/sqlite</td><td align="center">轻量型关系数据库SQLite的C++实现</td></tr></tbody></table><h2 id="2-5-其他"><a href="#2-5-其他" class="headerlink" title="2.5 其他"></a>2.5 其他</h2><p>Android运行时库就在根目录下的art文件夹中。</p><p>硬件抽象层在根目录下的hardware文件夹中，该部分是手机厂商改动最大的部分，根据手机终端所采用的硬件平台不同，会有不同的实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Android系统架构&quot;&gt;&lt;a href=&quot;#1-Android系统架构&quot; class=&quot;headerlink&quot; title=&quot;1. Android系统架构&quot;&gt;&lt;/a&gt;1. Android系统架构&lt;/h1&gt;&lt;p&gt;Android系统架构分成五层，从上到下依次为：
      
    
    </summary>
    
      <category term="Android进阶" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
      <category term="框架层" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/"/>
    
      <category term="系统启动" scheme="https://tylerLiu.top/categories/Android%E8%BF%9B%E9%98%B6/%E6%A1%86%E6%9E%B6%E5%B1%82/%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8/"/>
    
    
      <category term="Android系统启动" scheme="https://tylerLiu.top/tags/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>Android RxJava应用：联想搜索优化</title>
    <link href="https://tylerLiu.top/2019/08/23/Android-RxJava%E5%BA%94%E7%94%A8%EF%BC%9A%E8%81%94%E6%83%B3%E6%90%9C%E7%B4%A2%E4%BC%98%E5%8C%96/"/>
    <id>https://tylerLiu.top/2019/08/23/Android-RxJava应用：联想搜索优化/</id>
    <published>2019-08-23T08:07:12.000Z</published>
    <updated>2019-08-23T08:48:32.124Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-需求场景"><a href="#1-需求场景" class="headerlink" title="1. 需求场景"></a>1. 需求场景</h1><p>背景：每当用户输入一个字符，即显示与当前输入框内字符相关的搜索结果。</p><p>基本实现流程：</p><ol><li>通过<code>EditText.addTextChangedListener()</code>监听输入框的变化</li><li>当输入框发生变化后，回调<code>afterTextChanged()</code>，将当前输入框内的文字向服务器发送请求</li><li>服务器返回与该搜索文字关联的结果</li></ol><p>问题：当用户搜索需求明确的情况下（体现为连续输入），可能会发起不必要的请求。如</p><ul><li>用户搜索需求明确为abc，即连续输入abc</li><li>按照上面的逻辑，客户端会向服务器发起a、ab、abc三次请求</li><li>多发起了a、ab两次不必要的请求</li></ul><p>解决方案：通过根据时间过滤事件的过滤操作符<code>debounce()</code>实现。</p><h1 id="2-功能说明"><a href="#2-功能说明" class="headerlink" title="2. 功能说明"></a>2. 功能说明</h1><p>实现原理：通过根据指定时间过滤事件的过滤操作符<code>debounce()</code>实现，防止不必要的网络请求。</p><p>功能逻辑：当输入框发生变化时，不会立刻将当前输入框内的文字发送给服务器，而是等待一段时间，在这段时间内，如果输入框不再有文字输入（无变化），就发送输入框内的文字给服务器，如果有文字输入（有变化），则继续等待该段时间，循环该过程。</p><h1 id="3-Demo"><a href="#3-Demo" class="headerlink" title="3. Demo"></a>3. Demo</h1><p>布局文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:gravity</span>=<span class="string">"center"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/et"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:hint</span>=<span class="string">"输入搜索字段"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/tv"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterUsageActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"RxJava"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressLint</span>(<span class="string">"CheckResult"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_filter_usage);</span><br><span class="line"></span><br><span class="line">        EditText et = findViewById(R.id.et);</span><br><span class="line">        <span class="keyword">final</span> TextView tv = findViewById(R.id.tv);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 这里使用RxBinding：RxTextView.textChanges(name)对对控件数据变更进行监听（功能类似TextWatcher）</span></span><br><span class="line">        <span class="comment">// 2. 传入EditText控件，输入字符时都会发送数据事件（此处不会马上发送，因为使用了debounce()）</span></span><br><span class="line">        <span class="comment">// 3. 采用skip(1)原因：跳过第1次请求，即初始输入框的空字符状态</span></span><br><span class="line">        RxTextView.textChanges(et)</span><br><span class="line">                .debounce(<span class="number">1</span>, TimeUnit.SECONDS).skip(<span class="number">1</span>)</span><br><span class="line">                .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">                .subscribe(<span class="keyword">new</span> Consumer&lt;CharSequence&gt;() &#123;</span><br><span class="line">                    <span class="meta">@SuppressLint</span>(<span class="string">"SetTextI18n"</span>)</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(CharSequence charSequence)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        tv.setText(<span class="string">"发送给服务器的字符 = "</span> + charSequence.toString());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="keyword">new</span> Consumer&lt;Throwable&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Throwable throwable)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        Log.d(TAG, <span class="string">"对Error事件作出响应"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2019/08/23/Android-RxJava应用：联想搜索优化/企业微信截图_20190823164747.png"><p>Demo地址：<a href="https://gitee.com/QingFengBaiYu/Allen_Demo_Rx" target="_blank" rel="noopener">Allen_Demo_Rx</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-需求场景&quot;&gt;&lt;a href=&quot;#1-需求场景&quot; class=&quot;headerlink&quot; title=&quot;1. 需求场景&quot;&gt;&lt;/a&gt;1. 需求场景&lt;/h1&gt;&lt;p&gt;背景：每当用户输入一个字符，即显示与当前输入框内字符相关的搜索结果。&lt;/p&gt;
&lt;p&gt;基本实现流程：&lt;/p
      
    
    </summary>
    
      <category term="Android" scheme="https://tylerLiu.top/categories/Android/"/>
    
      <category term="RxJava" scheme="https://tylerLiu.top/categories/Android/RxJava/"/>
    
    
      <category term="RxJava" scheme="https://tylerLiu.top/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>Android RxJava应用：功能防抖</title>
    <link href="https://tylerLiu.top/2019/08/23/Android-RxJava%E5%BA%94%E7%94%A8%EF%BC%9A%E5%8A%9F%E8%83%BD%E9%98%B2%E6%8A%96/"/>
    <id>https://tylerLiu.top/2019/08/23/Android-RxJava应用：功能防抖/</id>
    <published>2019-08-23T07:33:33.000Z</published>
    <updated>2019-08-23T08:03:18.945Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-需求场景"><a href="#1-需求场景" class="headerlink" title="1. 需求场景"></a>1. 需求场景</h1><p>背景：用户只需要使用功能一次</p><p>问题：如果多次触发功能，就会导致出现冗余功能操作，如：</p><ul><li>用户只需要使用网络请求功能一次（点击按钮）</li><li>但由于网络不好，点击一次后，用户发现没有响应</li><li>于是就多次点击按钮，就会导致发送多次网络请求</li></ul><p>解决方法：功能防抖，通过根据指定时间过滤事件的过滤操作符实现，防止功能抖动</p><h1 id="2-功能说明"><a href="#2-功能说明" class="headerlink" title="2. 功能说明"></a>2. 功能说明</h1><p>功能防抖：即用户同规定时间内多次触发功能，仅会响应第一次的触发操作。</p><p>原理：使用根据指定时间过滤事件的过滤操作符实现，<code>throttleFirst()</code>操作符。</p><h1 id="3-Demo"><a href="#3-Demo" class="headerlink" title="3. Demo"></a>3. Demo</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AntiShakeActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"RxJava"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressLint</span>(<span class="string">"CheckResult"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_anti_shake);</span><br><span class="line"></span><br><span class="line">        Button button = findViewById(R.id.button);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 此处采用了RxBinding：RxView.clicks(button)控件点击进行监听，</span></span><br><span class="line">        <span class="comment">// 需要引入依赖：implementation 'com.jakewharton.rxbinding2:rxbinding:2.0.0'</span></span><br><span class="line">        <span class="comment">// 2. 传入Button控件，点击时，都会发送数据事件，</span></span><br><span class="line">        <span class="comment">// 但由于使用了throttleFirst()操作符，所以只会发送该段时间内的第1次点击事件</span></span><br><span class="line">        RxView.clicks(button)</span><br><span class="line">                <span class="comment">// 2s内第1次点击按钮的事件才发送</span></span><br><span class="line">                .throttleFirst(<span class="number">2</span>, TimeUnit.SECONDS)</span><br><span class="line">                .subscribe(<span class="keyword">new</span> Consumer&lt;Object&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Object o)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        Log.d(TAG, <span class="string">"发送了网络请求"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="keyword">new</span> Consumer&lt;Throwable&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Throwable throwable)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="comment">// 获取异常错误信息</span></span><br><span class="line">                        Log.d(TAG, <span class="string">"对Error事件作出响应"</span> + throwable.getMessage());</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Demo地址：<a href="https://gitee.com/QingFengBaiYu/Allen_Demo_Rx" target="_blank" rel="noopener">Allen_Demo_Rx</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-需求场景&quot;&gt;&lt;a href=&quot;#1-需求场景&quot; class=&quot;headerlink&quot; title=&quot;1. 需求场景&quot;&gt;&lt;/a&gt;1. 需求场景&lt;/h1&gt;&lt;p&gt;背景：用户只需要使用功能一次&lt;/p&gt;
&lt;p&gt;问题：如果多次触发功能，就会导致出现冗余功能操作，如：&lt;/p
      
    
    </summary>
    
      <category term="Android" scheme="https://tylerLiu.top/categories/Android/"/>
    
      <category term="RxJava" scheme="https://tylerLiu.top/categories/Android/RxJava/"/>
    
    
      <category term="RxJava" scheme="https://tylerLiu.top/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>Android RxJava应用：网络请求出错重连</title>
    <link href="https://tylerLiu.top/2019/08/23/Android-RxJava%E5%BA%94%E7%94%A8%EF%BC%9A%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%87%BA%E9%94%99%E9%87%8D%E8%BF%9E/"/>
    <id>https://tylerLiu.top/2019/08/23/Android-RxJava应用：网络请求出错重连/</id>
    <published>2019-08-23T06:54:33.000Z</published>
    <updated>2019-08-23T07:32:15.851Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-需求场景"><a href="#1-需求场景" class="headerlink" title="1. 需求场景"></a>1. 需求场景</h1><p>背景：发送网络请求<br>问题：发送网络请求过程中，出现错误时，导致该次网络请求不成功<br>解决方案：当发生错误使得网络请求不成功时，自动重新发送网络请求，即差错自动重试机制</p><h1 id="2-功能说明"><a href="#2-功能说明" class="headerlink" title="2. 功能说明"></a>2. 功能说明</h1><p>功能描述：当发送错误时，使得网络请求不成功时，自动重新发送网络请求<br>实现原理：采用<code>RxJava</code>中的<code>retryWhen()</code>操作符<br>具体说明：根据错误类型判断实现需要重连，所有网络错误异常都属于IOException，其余异常都不在重试范围内。若要重试，设置退避策略，即，为请求重试设置一个合理的退避算法，而不是一出现错误马上就重试。<br>合理的退避算法：</p><ol><li>遇到错误时，等待一段时间后再重试</li><li>若遇到的异常次数越多，等待时间应该越长</li></ol><ul><li>即，设置等待时间，会随着错误异常次数增多而可变</li></ul><ol start="3"><li>限制可重试次数，避免无限重试</li></ol><ul><li>即，设置重试次数</li></ul><img src="/2019/08/23/Android-RxJava应用：网络请求出错重连/944365-fd347a0ba6a54876.png"><h1 id="3-Demo"><a href="#3-Demo" class="headerlink" title="3. Demo"></a>3. Demo</h1><p>采用<code>GET</code>方法对金山词霸API进行网络请求：</p><ol><li>通过判断网络连接模拟网络异常错误（即回复网络即可发送请求）</li><li>限制重试次数为10次</li><li>采用<code>Gson</code>进行数据解析</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RxJavafixRxjavaActivity3</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"RxJava"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可重试次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mMaxConnectCount = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前已重试次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mCurrentRetryCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重试等待时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mWaitRetryTime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressLint</span>(<span class="string">"CheckResult"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_rx_javafix_rxjava3);</span><br><span class="line"></span><br><span class="line">        Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">                .baseUrl(<span class="string">"http://fy.iciba.com/"</span>)</span><br><span class="line">                .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">                .addCallAdapterFactory(RxJava2CallAdapterFactory.create())</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        GetRequest_Interface request = retrofit.create(GetRequest_Interface.class);</span><br><span class="line"></span><br><span class="line">        Observable&lt;Translation&gt; observable = request.getCall();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主要异常才会回调retryWhen()进行重试</span></span><br><span class="line">        observable.retryWhen(<span class="keyword">new</span> Function&lt;Observable&lt;Throwable&gt;, ObservableSource&lt;?&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ObservableSource&lt;?&gt; apply(Observable&lt;Throwable&gt; throwableObservable) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="comment">// Observable&lt;Throwable&gt;中的泛型为上游操作符抛出的异常，可以通过该条件判断异常的类型</span></span><br><span class="line">                <span class="keyword">return</span> throwableObservable.flatMap(<span class="keyword">new</span> Function&lt;Throwable, ObservableSource&lt;?&gt;&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> ObservableSource&lt;?&gt; apply(Throwable throwable) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        <span class="comment">// 输出异常信息</span></span><br><span class="line">                        Log.d(TAG, <span class="string">"发生异常 = "</span> + throwable.toString());</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 需求1：根据异常类型选择是否重试</span></span><br><span class="line">                        <span class="keyword">if</span> (throwable <span class="keyword">instanceof</span> IOException) &#123;</span><br><span class="line">                            Log.d(TAG, <span class="string">"属于IOException，需重试"</span>);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 需求2：设置重试次数</span></span><br><span class="line">                            <span class="keyword">if</span> (mCurrentRetryCount &lt; mMaxConnectCount) &#123;</span><br><span class="line">                                <span class="comment">// 记录重试次数</span></span><br><span class="line">                                mCurrentRetryCount++;</span><br><span class="line">                                Log.d(TAG, <span class="string">"重试次数 = "</span> + mCurrentRetryCount);</span><br><span class="line"></span><br><span class="line">                                <span class="comment">// 需求2：实现重试</span></span><br><span class="line">                                <span class="comment">// 通过返回的Observable发送的事件，即Next事件，使得retryWhen()重新订阅，实现重试功能</span></span><br><span class="line"></span><br><span class="line">                                <span class="comment">// 需求3：延迟重试</span></span><br><span class="line">                                <span class="comment">// 使用delay()操作符</span></span><br><span class="line"></span><br><span class="line">                                <span class="comment">// 需求4：遇到的异常次数越多，时间越长</span></span><br><span class="line">                                <span class="comment">// 设置delay()操作符的等待时间，每重试一次，增加延迟重试时间1s</span></span><br><span class="line"></span><br><span class="line">                                <span class="comment">// 设置等待时间</span></span><br><span class="line">                                mWaitRetryTime = <span class="number">1000</span> + mCurrentRetryCount * <span class="number">1000</span>;</span><br><span class="line">                                Log.d(TAG, <span class="string">"等待时间 ="</span> + mWaitRetryTime);</span><br><span class="line">                                <span class="keyword">return</span> Observable.just(<span class="number">1</span>).delay(mWaitRetryTime, TimeUnit.MILLISECONDS);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="comment">// 若重试次数已 ＞ 设置重试次数，则不重试</span></span><br><span class="line">                                <span class="comment">// 通过发送error来停止重试（可在观察者的onError()中获取信息）</span></span><br><span class="line">                                <span class="keyword">return</span> Observable.error(<span class="keyword">new</span> Throwable(<span class="string">"重试次数已超过设置次数 = "</span></span><br><span class="line">                                        + mCurrentRetryCount + <span class="string">"，即，不再重试"</span>));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 若发生的异常不属于I/O异常，则不重试</span></span><br><span class="line">                        <span class="comment">// 通过返回的Observable发送的Error事件，实现（可在观察者的onError()中获取信息）</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> Observable.error(<span class="keyword">new</span> Throwable(<span class="string">"发生了非网络异常（非I/O异常）"</span>));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribeOn(Schedulers.io())</span><br><span class="line">                .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">                .subscribe(<span class="keyword">new</span> Consumer&lt;Translation&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Translation translation)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="comment">// 接收服务器返回的数据</span></span><br><span class="line">                        Log.d(TAG, <span class="string">"发送成功"</span>);</span><br><span class="line">                        translation.show();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="keyword">new</span> Consumer&lt;Throwable&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Throwable throwable)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="comment">// 获取停止重试的信息</span></span><br><span class="line">                        Log.d(TAG, throwable.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">D/RxJava: 发生异常 = java.net.UnknownHostException: Unable to resolve host &quot;fy.iciba.com&quot;: No address associated with hostname</span><br><span class="line">D/RxJava: 属于IOException，需重试</span><br><span class="line">D/RxJava: 重试次数 = 1</span><br><span class="line">D/RxJava: 等待时间 =2000</span><br><span class="line">D/RxJava: 发生异常 = java.net.UnknownHostException: Unable to resolve host &quot;fy.iciba.com&quot;: No address associated with hostname</span><br><span class="line">D/RxJava: 属于IOException，需重试</span><br><span class="line">D/RxJava: 重试次数 = 2</span><br><span class="line">D/RxJava: 等待时间 =3000</span><br><span class="line">D/RxJava: 发生异常 = java.net.UnknownHostException: Unable to resolve host &quot;fy.iciba.com&quot;: No address associated with hostname</span><br><span class="line">D/RxJava: 属于IOException，需重试</span><br><span class="line">D/RxJava: 重试次数 = 3</span><br><span class="line">D/RxJava: 等待时间 =4000</span><br><span class="line">D/RxJava: 发生异常 = java.net.UnknownHostException: Unable to resolve host &quot;fy.iciba.com&quot;: No address associated with hostname</span><br><span class="line">D/RxJava: 属于IOException，需重试</span><br><span class="line">D/RxJava: 重试次数 = 4</span><br><span class="line">D/RxJava: 等待时间 =5000</span><br><span class="line">D/RxJava: 发送成功</span><br><span class="line">D/RxJava: 嗨世界</span><br></pre></td></tr></table></figure><p>Demo地址：<a href="https://gitee.com/QingFengBaiYu/Allen_Demo_Rx" target="_blank" rel="noopener">Allen_Demo_Rx</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-需求场景&quot;&gt;&lt;a href=&quot;#1-需求场景&quot; class=&quot;headerlink&quot; title=&quot;1. 需求场景&quot;&gt;&lt;/a&gt;1. 需求场景&lt;/h1&gt;&lt;p&gt;背景：发送网络请求&lt;br&gt;问题：发送网络请求过程中，出现错误时，导致该次网络请求不成功&lt;br&gt;解决方案：
      
    
    </summary>
    
      <category term="Android" scheme="https://tylerLiu.top/categories/Android/"/>
    
      <category term="RxJava" scheme="https://tylerLiu.top/categories/Android/RxJava/"/>
    
    
      <category term="RxJava" scheme="https://tylerLiu.top/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>Android RxJava应用：网络请求轮询（有条件）</title>
    <link href="https://tylerLiu.top/2019/08/23/Android-RxJava%E5%BA%94%E7%94%A8%EF%BC%9A%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E8%BD%AE%E8%AF%A2%EF%BC%88%E6%9C%89%E6%9D%A1%E4%BB%B6%EF%BC%89/"/>
    <id>https://tylerLiu.top/2019/08/23/Android-RxJava应用：网络请求轮询（有条件）/</id>
    <published>2019-08-23T05:01:55.000Z</published>
    <updated>2019-08-23T06:52:39.912Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-需求场景"><a href="#1-需求场景" class="headerlink" title="1. 需求场景"></a>1. 需求场景</h1><p>背景：实现轮询，也称pull。客户端隔固定时间主动向服务器发送请求获取信息，可根据服务器返回信息停止轮询，即，有条件轮询。<br>解决方案：使用<code>RxJava</code>的<code>repeatWhen()</code>操作符</p><h1 id="2-功能说明"><a href="#2-功能说明" class="headerlink" title="2. 功能说明"></a>2. 功能说明</h1><p>采用<code>GET</code>，对金山词霸API按规定时间重复发送网络请求，模拟轮询。</p><ol><li>停止轮询的条件：当轮询到第四次时</li><li>采用<code>Gson</code>解析数据</li></ol><h1 id="3-实现"><a href="#3-实现" class="headerlink" title="3. 实现"></a>3. 实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RxJavafixRxjavaActivity2</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"RxJava"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟轮询服务器次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_rx_javafix_rxjava2);</span><br><span class="line"></span><br><span class="line">        Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">                .baseUrl(<span class="string">"http://fy.iciba.com/"</span>)</span><br><span class="line">                .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">                .addCallAdapterFactory(RxJava2CallAdapterFactory.create())</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        GetRequest_Interface request = retrofit.create(GetRequest_Interface.class);</span><br><span class="line"></span><br><span class="line">        Observable&lt;Translation&gt; observable = request.getCall();</span><br><span class="line"></span><br><span class="line">        observable.repeatWhen(<span class="keyword">new</span> Function&lt;Observable&lt;Object&gt;, ObservableSource&lt;?&gt;&gt;() &#123;</span><br><span class="line">            <span class="comment">// 在Function函数中，必须对输入的 Observable&lt;Object&gt;进行处理，此处使用flatMap()操作符接收上游的数据</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ObservableSource&lt;?&gt; apply(Observable&lt;Object&gt; objectObservable) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="comment">// 将原始Observable停止发送事件的标识（Complete()/Error()）转换成一个Object类型数据传递给一个新的Observable，</span></span><br><span class="line">                <span class="comment">// 以此决定是否重新订阅并发送原来的Observable，即轮询</span></span><br><span class="line">                <span class="comment">// 此处由两种情况：</span></span><br><span class="line">                <span class="comment">// 1. 若返回一个Complete()/Error()事件，则不重新订阅并发送原来的Observable，即轮询结束</span></span><br><span class="line">                <span class="comment">// 2. 若返回其余事件，则重新订阅并发送原来的Observable，即继续轮询</span></span><br><span class="line">                <span class="keyword">return</span> objectObservable.flatMap(<span class="keyword">new</span> Function&lt;Object, ObservableSource&lt;?&gt;&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> ObservableSource&lt;?&gt; apply(Object o) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        <span class="comment">// 加入判断条件，当轮询次数为5次时，停止轮询</span></span><br><span class="line">                        <span class="keyword">if</span> (i &gt; <span class="number">3</span>) &#123;</span><br><span class="line">                            <span class="comment">// 此处选择发送onError()事件以结束轮询，因为可触发下游观察者的onError()方法回调</span></span><br><span class="line">                            <span class="keyword">return</span> Observable.error(<span class="keyword">new</span> Throwable(<span class="string">"轮询结束"</span>));</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 若轮询次数 ＜ 4，发送一个Next事件继续轮询</span></span><br><span class="line">                        <span class="keyword">return</span> Observable.just(<span class="number">1</span>).delay(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribeOn(Schedulers.io())</span><br><span class="line">                .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">                .subscribe(<span class="keyword">new</span> Observer&lt;Translation&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Translation translation)</span> </span>&#123;</span><br><span class="line">                        <span class="comment">// e.接收服务器返回的数据</span></span><br><span class="line">                        translation.show();</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                        <span class="comment">// 获取轮询结束信息</span></span><br><span class="line">                        Log.d(TAG, e.toString());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">14:46:35.250 3950-3950/com.ly.allendemorx D/RxJava: 嗨世界</span><br><span class="line">14:46:37.240 3950-3950/com.ly.allendemorx D/RxJava: 嗨世界</span><br><span class="line">14:46:39.554 3950-3950/com.ly.allendemorx D/RxJava: 嗨世界</span><br><span class="line">14:46:42.787 3950-3950/com.ly.allendemorx D/RxJava: 嗨世界</span><br><span class="line">14:46:44.929 3950-3950/com.ly.allendemorx D/RxJava: 嗨世界</span><br><span class="line">14:46:44.971 3950-3950/com.ly.allendemorx D/RxJava: java.lang.Throwable: 轮询结束</span><br></pre></td></tr></table></figure><p>Demo地址：<a href="https://gitee.com/QingFengBaiYu/Allen_Demo_Rx" target="_blank" rel="noopener">Allen_Demo_Rx</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-需求场景&quot;&gt;&lt;a href=&quot;#1-需求场景&quot; class=&quot;headerlink&quot; title=&quot;1. 需求场景&quot;&gt;&lt;/a&gt;1. 需求场景&lt;/h1&gt;&lt;p&gt;背景：实现轮询，也称pull。客户端隔固定时间主动向服务器发送请求获取信息，可根据服务器返回信息停止轮询
      
    
    </summary>
    
      <category term="Android" scheme="https://tylerLiu.top/categories/Android/"/>
    
      <category term="RxJava" scheme="https://tylerLiu.top/categories/Android/RxJava/"/>
    
    
      <category term="RxJava" scheme="https://tylerLiu.top/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>Android RxJava应用：联合判断多个事件</title>
    <link href="https://tylerLiu.top/2019/08/22/Android-RxJava%E5%BA%94%E7%94%A8%EF%BC%9A%E8%81%94%E5%90%88%E5%88%A4%E6%96%AD%E5%A4%9A%E4%B8%AA%E4%BA%8B%E4%BB%B6/"/>
    <id>https://tylerLiu.top/2019/08/22/Android-RxJava应用：联合判断多个事件/</id>
    <published>2019-08-22T08:46:29.000Z</published>
    <updated>2019-08-22T09:22:59.912Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-需求场景"><a href="#1-需求场景" class="headerlink" title="1. 需求场景"></a>1. 需求场景</h1><p>同时对多个事件进行联合判断。如，填写表单时，需要表里的所有信息（姓名、年龄、职业等）都被填写后，才能点击提交按钮。</p><h1 id="2-功能说明"><a href="#2-功能说明" class="headerlink" title="2. 功能说明"></a>2. 功能说明</h1><p>此处采用 填写表单 作为联合判断功能展示，即，表单里所有信息（姓名、年龄、职业等）都被填写后，才允许点击 “提交” 按钮。</p><h1 id="3-实现"><a href="#3-实现" class="headerlink" title="3. 实现"></a>3. 实现</h1><p>采用<code>combineLatest()</code>操作符。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/name"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:hint</span>=<span class="string">"请填写姓名"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/age"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:hint</span>=<span class="string">"请填写年龄"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/job"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:hint</span>=<span class="string">"请填写职业"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/list"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:enabled</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"提交"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CombineJudgeActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EditText mName, mAge, mJob;</span><br><span class="line">    <span class="keyword">private</span> Button mButton;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressLint</span>(<span class="string">"CheckResult"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_combine_judge);</span><br><span class="line">        mName = findViewById(R.id.name);</span><br><span class="line">        mAge = findViewById(R.id.age);</span><br><span class="line">        mJob = findViewById(R.id.job);</span><br><span class="line">        mButton = findViewById(R.id.list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为每个EditText设置被观察者，用于发送监听事件</span></span><br><span class="line">        <span class="comment">// 说明：</span></span><br><span class="line">        <span class="comment">// 1. 这里使用RxBinding的RxTextView.textChanges(name)是对对控件数据变更进行监听</span></span><br><span class="line">        <span class="comment">// （功能类似TextWatcher），需要引入依赖：implementation 'com.jakewharton.rxbinding2:rxbinding:2.0.0'</span></span><br><span class="line">        <span class="comment">// 2. 传入EditText控件，点击任一个EditText撰写时，都会发送数据事件 = Function3（）的返回值（下面会详细说明）</span></span><br><span class="line">        <span class="comment">// 3. 采用skip(1)原因：跳过 一开始EditText无任何输入时的空值</span></span><br><span class="line">        Observable&lt;CharSequence&gt; nameObservable = RxTextView.textChanges(mName).skip(<span class="number">1</span>);</span><br><span class="line">        Observable&lt;CharSequence&gt; ageObservable = RxTextView.textChanges(mAge).skip(<span class="number">1</span>);</span><br><span class="line">        Observable&lt;CharSequence&gt; jobObservable = RxTextView.textChanges(mJob).skip(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过combineLatest()合并事件并联合判断</span></span><br><span class="line">        Observable.combineLatest(nameObservable, ageObservable, jobObservable, <span class="keyword">new</span> Function3&lt;CharSequence,</span><br><span class="line">                CharSequence, CharSequence, Boolean&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Boolean <span class="title">apply</span><span class="params">(CharSequence charSequence, CharSequence charSequence2, CharSequence charSequence3)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="comment">// 规定表单输入信息不能为空</span></span><br><span class="line">                <span class="keyword">boolean</span> isNameEmpty = !TextUtils.isEmpty(mName.getText());</span><br><span class="line">                <span class="keyword">boolean</span> isAgeEmpty = !TextUtils.isEmpty(mAge.getText());</span><br><span class="line">                <span class="keyword">boolean</span> isJobEmpty = !TextUtils.isEmpty(mJob.getText());</span><br><span class="line">                <span class="keyword">return</span> isNameEmpty &amp;&amp; isAgeEmpty &amp;&amp; isJobEmpty;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(<span class="keyword">new</span> Consumer&lt;Boolean&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Boolean aBoolean)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="comment">// 返回结果 &amp; 设置按钮可点击样式</span></span><br><span class="line">                mButton.setEnabled(aBoolean);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Demo地址：<a href="https://gitee.com/QingFengBaiYu/Allen_Demo_Rx" target="_blank" rel="noopener">Allen_Demo_Rx</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-需求场景&quot;&gt;&lt;a href=&quot;#1-需求场景&quot; class=&quot;headerlink&quot; title=&quot;1. 需求场景&quot;&gt;&lt;/a&gt;1. 需求场景&lt;/h1&gt;&lt;p&gt;同时对多个事件进行联合判断。如，填写表单时，需要表里的所有信息（姓名、年龄、职业等）都被填写后，才能点击
      
    
    </summary>
    
      <category term="Android" scheme="https://tylerLiu.top/categories/Android/"/>
    
      <category term="RxJava" scheme="https://tylerLiu.top/categories/Android/RxJava/"/>
    
    
      <category term="RxJava" scheme="https://tylerLiu.top/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>Android RxJava应用：从磁盘/内存缓存中获取数据</title>
    <link href="https://tylerLiu.top/2019/08/22/Android-RxJava%E5%BA%94%E7%94%A8%EF%BC%9A%E4%BB%8E%E7%A3%81%E7%9B%98-%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98%E4%B8%AD%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE/"/>
    <id>https://tylerLiu.top/2019/08/22/Android-RxJava应用：从磁盘-内存缓存中获取数据/</id>
    <published>2019-08-22T08:13:41.000Z</published>
    <updated>2019-08-22T08:44:49.142Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-需求场景"><a href="#1-需求场景" class="headerlink" title="1. 需求场景"></a>1. 需求场景</h1><p>背景：从服务器获取数据<br>问题：每次获取数据都通过网络请求向服务器获取会浪费很多资源，包括流量和时间<br>解决方案：从缓存中读取数据，即，当需要获取数据时，先从本地的磁盘/内存缓存中获取所需数据，如果缓存中没有数据，再通过网络请求向服务器获取数据<br>实现原理：组合操作符<code>concat()</code>和过滤操作符<code>firstElement()</code></p><h1 id="2-功能说明"><a href="#2-功能说明" class="headerlink" title="2. 功能说明"></a>2. 功能说明</h1><img src="/2019/08/22/Android-RxJava应用：从磁盘-内存缓存中获取数据/944365-ac1bc26fa511c836.png"><h1 id="3-实现"><a href="#3-实现" class="headerlink" title="3. 实现"></a>3. 实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheDemoActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"RxJava"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟内存缓存和磁盘缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String memoryCache = <span class="keyword">null</span>;</span><br><span class="line">    String diskCache = <span class="string">"从磁盘缓存中获取的数据"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressLint</span>(<span class="string">"CheckResult"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_cache_demo);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置第一个Observable，检查内存缓存是否由该数据的缓存</span></span><br><span class="line">        Observable&lt;String&gt; memory = Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;String&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="comment">// 判断内存缓存有无数据</span></span><br><span class="line">                <span class="keyword">if</span> (memoryCache != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 若有该数据，则发送</span></span><br><span class="line">                    emitter.onNext(memoryCache);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 若没有，直接发送结束事件</span></span><br><span class="line">                    emitter.onComplete();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置第二个Observable，检查磁盘缓存是否由该数据的缓存</span></span><br><span class="line">        Observable&lt;String&gt; disk = Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;String&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="comment">// 判断磁盘缓存有无数据</span></span><br><span class="line">                <span class="keyword">if</span> (diskCache != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 若有该数据，则发送</span></span><br><span class="line">                    emitter.onNext(diskCache);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 若没有，直接发送结束事件</span></span><br><span class="line">                    emitter.onComplete();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置第三个Observable：通过网络获取数据</span></span><br><span class="line">        Observable&lt;String&gt; network = Observable.just(<span class="string">"从网络获取数据"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用concat()和firstElement()实现缓存功能</span></span><br><span class="line">        <span class="comment">// 1. 通过concat()合并三个被观察者的事件，并将它们按顺序串成队列</span></span><br><span class="line">        Observable.concat(memory, disk, network)</span><br><span class="line">                <span class="comment">// 通过firstElement()，从队列中取出并发送第一个有效事件，即依次判断检查三个Observable</span></span><br><span class="line">                <span class="comment">// 即本例的逻辑为：</span></span><br><span class="line">                <span class="comment">// a. firstElement()取出第一个事件memory，即先判断内存缓存中有无数据缓存；</span></span><br><span class="line">                <span class="comment">// 由于memoryCache = null，即内存缓存中无数据，所以发送结束事件（视为无效事件）</span></span><br><span class="line">                <span class="comment">// b. firstElement()继续取出第二个事件disk，即判断磁盘缓存中有无数据缓存：</span></span><br><span class="line">                <span class="comment">// 由于diskCache ≠ null，即磁盘缓存中有数据，所以发送Next事件（有效事件）</span></span><br><span class="line">                <span class="comment">// c. 即firstElement()已发出第一个有效事件（disk事件），所以停止判断。</span></span><br><span class="line">                .firstElement()</span><br><span class="line">                <span class="comment">// 3. 订阅</span></span><br><span class="line">                .subscribe(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        Log.d(TAG, <span class="string">"最终获取的数据来源 =  "</span> + s);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D/RxJava: 最终获取的数据来源 =  从磁盘缓存中获取的数据</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-需求场景&quot;&gt;&lt;a href=&quot;#1-需求场景&quot; class=&quot;headerlink&quot; title=&quot;1. 需求场景&quot;&gt;&lt;/a&gt;1. 需求场景&lt;/h1&gt;&lt;p&gt;背景：从服务器获取数据&lt;br&gt;问题：每次获取数据都通过网络请求向服务器获取会浪费很多资源，包括流量和时间
      
    
    </summary>
    
      <category term="Android" scheme="https://tylerLiu.top/categories/Android/"/>
    
      <category term="RxJava" scheme="https://tylerLiu.top/categories/Android/RxJava/"/>
    
    
      <category term="RxJava" scheme="https://tylerLiu.top/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>Android RxJava应用：合并数据源并展示</title>
    <link href="https://tylerLiu.top/2019/08/22/Android-RxJava%E5%BA%94%E7%94%A8%EF%BC%9A%E5%90%88%E5%B9%B6%E6%95%B0%E6%8D%AE%E6%BA%90%E5%B9%B6%E5%B1%95%E7%A4%BA/"/>
    <id>https://tylerLiu.top/2019/08/22/Android-RxJava应用：合并数据源并展示/</id>
    <published>2019-08-22T07:47:34.000Z</published>
    <updated>2019-08-22T08:12:03.604Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-需求场景"><a href="#1-需求场景" class="headerlink" title="1. 需求场景"></a>1. 需求场景</h1><p>背景：获取数据并统一展示到客户端<br>冲突：数据来源不同，网络和本地，即，数据源多样<br>解决方案：采用RxJava操作符，这里使用<code>merge()</code>和<code>zip()</code>演示。</p><h1 id="2-功能说明"><a href="#2-功能说明" class="headerlink" title="2. 功能说明"></a>2. 功能说明</h1><p>获取数据并统一展示到客户端</p><h1 id="3-实现"><a href="#3-实现" class="headerlink" title="3. 实现"></a>3. 实现</h1><ul><li><code>merge()</code>：实现从（网络和本地）获取数据并统一展示</li><li><code>zip()</code>：结合<code>Retrofit</code>和<code>RxJava</code>，实现合并两个网络请求，向两个服务器获取数据并统一展示。</li></ul><h2 id="3-1-merge"><a href="#3-1-merge" class="headerlink" title="3.1 merge()"></a>3.1 merge()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeDemoActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"RxJava"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于存放最终展示的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String result = <span class="string">"数据源来自 = "</span>;</span><br><span class="line"></span><br><span class="line">    Observable&lt;String&gt; network = Observable.just(<span class="string">"网络"</span>);</span><br><span class="line">    Observable&lt;String&gt; file = Observable.just(<span class="string">"本地文件"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressLint</span>(<span class="string">"CheckResult"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_merge_demo);</span><br><span class="line"></span><br><span class="line">        Observable.merge(network, file)</span><br><span class="line">                .subscribe(<span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">                        Log.d(TAG, <span class="string">"数据源有： "</span> + value);</span><br><span class="line">                        result += value + <span class="string">"+"</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                        Log.d(TAG, <span class="string">"对Error事件作出响应"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 接收合并事件后，统一展示</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        Log.d(TAG, <span class="string">"获取数据完成"</span>);</span><br><span class="line">                        Log.d(TAG, result);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D/RxJava: 数据源有： 网络</span><br><span class="line">D/RxJava: 数据源有： 本地文件</span><br><span class="line">D/RxJava: 获取数据完成</span><br><span class="line">D/RxJava: 数据源来自 = 网络+本地文件+</span><br></pre></td></tr></table></figure><h2 id="3-2-zip"><a href="#3-2-zip" class="headerlink" title="3.2 zip()"></a>3.2 zip()</h2><ol><li>从不同数据源（两个服务器）获取数据，并合并</li><li>统一显示结果</li></ol><p>两个接收服务器数据的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Translation1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">private</span> ContentBean content;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ContentBean</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String from;</span><br><span class="line">        <span class="keyword">private</span> String to;</span><br><span class="line">        <span class="keyword">private</span> String vendor;</span><br><span class="line">        <span class="keyword">private</span> String out;</span><br><span class="line">        <span class="keyword">private</span> String ciba_use;</span><br><span class="line">        <span class="keyword">private</span> String ciba_out;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> err_no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义输出返回数据的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">"第1次翻译="</span> + content.out);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Translation2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">private</span> ContentBean content;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ContentBean</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String from;</span><br><span class="line">        <span class="keyword">private</span> String to;</span><br><span class="line">        <span class="keyword">private</span> String vendor;</span><br><span class="line">        <span class="keyword">private</span> String out;</span><br><span class="line">        <span class="keyword">private</span> String ciba_use;</span><br><span class="line">        <span class="keyword">private</span> String ciba_out;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> err_no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义输出返回数据的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">"第2翻译="</span> + content.out);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>Activity</code>中的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZipDemoActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"Rxjava"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义Observable接口类型的网络请求对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Observable&lt;Translation1&gt; mObservable1;</span><br><span class="line">    Observable&lt;Translation2&gt; mObservable2;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressLint</span>(<span class="string">"CheckResult"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_zip_demo);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤1：创建Retrofit对象</span></span><br><span class="line">        Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">                .baseUrl(<span class="string">"http://fy.iciba.com/"</span>)</span><br><span class="line">                .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">                .addCallAdapterFactory(RxJava2CallAdapterFactory.create())</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤2：创建网络请求接口的实例</span></span><br><span class="line">        GetRequest_Interface request = retrofit.create(GetRequest_Interface.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤3：对两个网络请求进行封装</span></span><br><span class="line">        mObservable1 = request.getCall_1().subscribeOn(Schedulers.io());</span><br><span class="line">        mObservable2 = request.getCall_2().subscribeOn(Schedulers.io());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤4：通过使用zip()对两个网络请求进行合并再发送</span></span><br><span class="line">        Observable.zip(mObservable1, mObservable2, <span class="keyword">new</span> BiFunction&lt;Translation1, Translation2, String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(Translation1 translation1, Translation2 translation2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> translation1.show() + <span class="string">" &amp; "</span> + translation2.show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">                .subscribe(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="comment">// 结合显示2个网络请求的数据结果</span></span><br><span class="line">                        Log.d(TAG, <span class="string">"最终接收到的数据是："</span> + s);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="keyword">new</span> Consumer&lt;Throwable&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Throwable throwable)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        Log.d(TAG, <span class="string">"登录失败"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D/Rxjava: 最终接收到的数据是：第1次翻译=HI寄存器 &amp; 第2翻译=嗨登录</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-需求场景&quot;&gt;&lt;a href=&quot;#1-需求场景&quot; class=&quot;headerlink&quot; title=&quot;1. 需求场景&quot;&gt;&lt;/a&gt;1. 需求场景&lt;/h1&gt;&lt;p&gt;背景：获取数据并统一展示到客户端&lt;br&gt;冲突：数据来源不同，网络和本地，即，数据源多样&lt;br&gt;解决方案：
      
    
    </summary>
    
      <category term="Android" scheme="https://tylerLiu.top/categories/Android/"/>
    
      <category term="RxJava" scheme="https://tylerLiu.top/categories/Android/RxJava/"/>
    
    
      <category term="RxJava" scheme="https://tylerLiu.top/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>Android RxJava应用：网络请求嵌套回调</title>
    <link href="https://tylerLiu.top/2019/08/22/Android-RxJava%E5%BA%94%E7%94%A8%EF%BC%9A%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%B5%8C%E5%A5%97%E5%9B%9E%E8%B0%83/"/>
    <id>https://tylerLiu.top/2019/08/22/Android-RxJava应用：网络请求嵌套回调/</id>
    <published>2019-08-22T05:46:45.000Z</published>
    <updated>2019-08-22T07:38:19.517Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-需求场景"><a href="#1-需求场景" class="headerlink" title="1. 需求场景"></a>1. 需求场景</h1><h2 id="1-1-背景"><a href="#1-1-背景" class="headerlink" title="1.1 背景"></a>1.1 背景</h2><p>需要进行嵌套网络请求，即，在第一个网络请求成功后，再继续进行一次网络请求。</p><blockquote><p>如先进行注册的网路请求，等注册成功后，再进行登录的网路请求。</p></blockquote><h2 id="1-2-冲突"><a href="#1-2-冲突" class="headerlink" title="1.2 冲突"></a>1.2 冲突</h2><p>嵌套实现网路请求较为复杂。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送注册网络请求的函数方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    api.register(<span class="keyword">new</span> RegisterRequest())</span><br><span class="line">            <span class="comment">// 在IO线程进行网络请求</span></span><br><span class="line">            .subscribeOn(Schedulers.io()) </span><br><span class="line">            <span class="comment">// 回到主线程去处理请求结果</span></span><br><span class="line">            .observeOn(AndroidSchedulers.mainThread()) </span><br><span class="line">            .subscribe(<span class="keyword">new</span> Consumer&lt;RegisterResponse&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(RegisterResponse registerResponse)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"注册成功"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                    <span class="comment">// 注册成功, 调用登录的方法</span></span><br><span class="line">                    login();   </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="keyword">new</span> Consumer&lt;Throwable&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Throwable throwable)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"注册失败"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送登录网络请求的函数方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    api.login(<span class="keyword">new</span> LoginRequest())</span><br><span class="line">            .subscribeOn(Schedulers.io())           </span><br><span class="line">            .observeOn(AndroidSchedulers.mainThread()) </span><br><span class="line">            .subscribe(<span class="keyword">new</span> Consumer&lt;LoginResponse&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(LoginResponse loginResponse)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"登录成功"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="keyword">new</span> Consumer&lt;Throwable&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Throwable throwable)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"登录失败"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-解决方案"><a href="#1-3-解决方案" class="headerlink" title="1.3 解决方案"></a>1.3 解决方案</h2><p>结合<code>RxJava</code>中的变换操作符<code>flatMap()</code>实现嵌套网路请求。<br><a href="https://tylerliu.top/2019/08/15/Android-RxJava%EF%BC%9A变换操作符/">Android RxJava：变换操作符</a></p><h1 id="2-功能说明"><a href="#2-功能说明" class="headerlink" title="2. 功能说明"></a>2. 功能说明</h1><p>实现功能：发送嵌套网络请求（将英文翻译成中文，翻译两次）<br>Demo：先翻译注册，再翻译登录。</p><h1 id="3-具体实现"><a href="#3-具体实现" class="headerlink" title="3. 具体实现"></a>3. 具体实现</h1><p>步骤和前面的相同，这里列出不同的部分。</p><p>为了演示两个网络请求，这里设置两个接收服务器的数据类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Translation1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">private</span> ContentBean content;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ContentBean</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String from;</span><br><span class="line">        <span class="keyword">private</span> String to;</span><br><span class="line">        <span class="keyword">private</span> String vendor;</span><br><span class="line">        <span class="keyword">private</span> String out;</span><br><span class="line">        <span class="keyword">private</span> String ciba_use;</span><br><span class="line">        <span class="keyword">private</span> String ciba_out;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> err_no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义输出返回数据的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="string">"RxJava"</span>, <span class="string">"翻译内容 = "</span> + content.out);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Translation2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">private</span> ContentBean content;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ContentBean</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String from;</span><br><span class="line">        <span class="keyword">private</span> String to;</span><br><span class="line">        <span class="keyword">private</span> String vendor;</span><br><span class="line">        <span class="keyword">private</span> String out;</span><br><span class="line">        <span class="keyword">private</span> String ciba_use;</span><br><span class="line">        <span class="keyword">private</span> String ciba_out;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> err_no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义输出返回数据的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="string">"RxJava"</span>, <span class="string">"翻译内容 = "</span> + content.out);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>创建用于描述网络请求的接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GetRequest_Interface</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 网络请求1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"ajax.php?a=fy&amp;f=auto&amp;t=auto&amp;w=hi%20register"</span>)</span><br><span class="line">    <span class="function">Observable&lt;Translation1&gt; <span class="title">getCall_1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 网络请求2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"ajax.php?a=fy&amp;f=auto&amp;t=auto&amp;w=hi%20login"</span>)</span><br><span class="line">    <span class="function">Observable&lt;Translation2&gt; <span class="title">getCall_2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>Activity</code>中的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ly.allendemorx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.annotation.SuppressLint;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.jakewharton.retrofit2.adapter.rxjava2.RxJava2CallAdapterFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.reactivex.Observable;</span><br><span class="line"><span class="keyword">import</span> io.reactivex.ObservableSource;</span><br><span class="line"><span class="keyword">import</span> io.reactivex.android.schedulers.AndroidSchedulers;</span><br><span class="line"><span class="keyword">import</span> io.reactivex.functions.Consumer;</span><br><span class="line"><span class="keyword">import</span> io.reactivex.functions.Function;</span><br><span class="line"><span class="keyword">import</span> io.reactivex.schedulers.Schedulers;</span><br><span class="line"><span class="keyword">import</span> retrofit2.Retrofit;</span><br><span class="line"><span class="keyword">import</span> retrofit2.converter.gson.GsonConverterFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RxJava实现嵌套网络请求</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Liuyang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main8Activity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"Rxjava"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义Observable接口类型的网络请求对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Observable&lt;Translation1&gt; mObservable1;</span><br><span class="line">    Observable&lt;Translation2&gt; mObservable2;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressLint</span>(<span class="string">"CheckResult"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main8);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤1：创建Retrofit对象</span></span><br><span class="line">        Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">                .baseUrl(<span class="string">"http://fy.iciba.com/"</span>)</span><br><span class="line">                .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">                .addCallAdapterFactory(RxJava2CallAdapterFactory.create())</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤2：创建网络请求接口实例</span></span><br><span class="line">        GetRequest_Interface request = retrofit.create(GetRequest_Interface.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤3：对两个网络请求进行封装</span></span><br><span class="line">        mObservable1 = request.getCall_1();</span><br><span class="line">        mObservable2 = request.getCall_2();</span><br><span class="line"></span><br><span class="line">        mObservable1</span><br><span class="line">                <span class="comment">// 在IO线程进行第一次网络请求</span></span><br><span class="line">                .subscribeOn(Schedulers.io())</span><br><span class="line">                .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">                .doOnNext(<span class="keyword">new</span> Consumer&lt;Translation1&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Translation1 translation1)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        Log.d(TAG, <span class="string">"第1次网络请求成功"</span>);</span><br><span class="line">                        translation1.show();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">// 切换到IO线程进行第二次网络请求</span></span><br><span class="line">                <span class="comment">// 因为flatMap()是对初始被观察者作变换，所以对于旧的被观察者，它是新的观察者，</span></span><br><span class="line">                <span class="comment">// 所以使用observeOn()进行线程切换，但是对于初始观察者，它就是新的被观察者。</span></span><br><span class="line">                .observeOn(Schedulers.io())</span><br><span class="line">                .flatMap(<span class="keyword">new</span> Function&lt;Translation1, ObservableSource&lt;Translation2&gt;&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> ObservableSource&lt;Translation2&gt; <span class="title">apply</span><span class="params">(Translation1 translation1)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="comment">// 将网络请求1转换成网络请求2，即发送网络请求2</span></span><br><span class="line">                        <span class="keyword">return</span> mObservable2;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">// 初始观察者切换到主线程，处理网络请求2的结果</span></span><br><span class="line">                .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">                .subscribe(<span class="keyword">new</span> Consumer&lt;Translation2&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Translation2 translation2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        Log.d(TAG, <span class="string">"第2次网络请求成功"</span>);</span><br><span class="line">                        translation2.show();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="keyword">new</span> Consumer&lt;Throwable&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Throwable throwable)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        Log.d(TAG, <span class="string">"登录失败"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-需求场景&quot;&gt;&lt;a href=&quot;#1-需求场景&quot; class=&quot;headerlink&quot; title=&quot;1. 需求场景&quot;&gt;&lt;/a&gt;1. 需求场景&lt;/h1&gt;&lt;h2 id=&quot;1-1-背景&quot;&gt;&lt;a href=&quot;#1-1-背景&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="Android" scheme="https://tylerLiu.top/categories/Android/"/>
    
      <category term="RxJava" scheme="https://tylerLiu.top/categories/Android/RxJava/"/>
    
    
      <category term="RxJava" scheme="https://tylerLiu.top/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>Android RxJava应用：网络请求轮询（无条件）</title>
    <link href="https://tylerLiu.top/2019/08/22/Android-RxJava%E5%BA%94%E7%94%A8%EF%BC%9A%E7%BD%91%E7%BB%9C%E8%BD%AE%E8%AF%A2%E8%AF%B7%E6%B1%82/"/>
    <id>https://tylerLiu.top/2019/08/22/Android-RxJava应用：网络轮询请求/</id>
    <published>2019-08-22T03:17:01.000Z</published>
    <updated>2019-08-23T05:03:32.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-需求场景"><a href="#1-需求场景" class="headerlink" title="1. 需求场景"></a>1. 需求场景</h1><ol><li>背景：实现轮询请求，即，客户端固定时间主动向服务器发送请求，获取信息，也称pull。</li><li>冲突：通过<code>Handler</code>和<code>Timer</code>定时器 的实现方式较为复杂，可扩展性差。</li><li>解决方案：采用<code>RxJava</code>的延时创建操作符</li></ol><ul><li><code>interval()</code>：无限次轮询</li><li><code>intervalRange()</code>：有限次轮询</li></ul><h1 id="2-功能说明"><a href="#2-功能说明" class="headerlink" title="2. 功能说明"></a>2. 功能说明</h1><p>采用<code>GET</code>方法对金山词霸API按规定时间重复发送网络请求，模拟轮询需求。<br>采用<code>Gson</code>进行数据解析。</p><h1 id="3-具体实现"><a href="#3-具体实现" class="headerlink" title="3. 具体实现"></a>3. 具体实现</h1><h2 id="3-1-步骤说明"><a href="#3-1-步骤说明" class="headerlink" title="3.1 步骤说明"></a>3.1 步骤说明</h2><ol><li>添加依赖</li><li>创建接收服务器返回的数据的类</li><li>创建用于描述网络请求的接口</li><li>创建<code>Retrofit</code>实例</li><li>创建网络请求接口实例，配置网络请求参数</li><li>发送网络请求</li><li>对返回的数据进行处理</li></ol><p>前面的步骤在<a href="https://tylerliu.top/2019/08/17/Android-RxJava%EF%BC%9A线程控制/">Android RxJava：线程控制</a>中已经讲解，这里主要分析轮询部分的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RxJava实现轮询</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Liuyang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RxJavafixRxjavaActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"Rxjava"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressLint</span>(<span class="string">"CheckResult"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_rx_javafix_rxjava);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤1：采用interval()延迟发送</span></span><br><span class="line">        <span class="comment">// 注：此处主要展示无限轮询，要实现有限轮询，使用intervalRange()即可</span></span><br><span class="line">        Observable.interval(<span class="number">2</span>, <span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">                <span class="comment">// 步骤2：每次发送数字前发送一次网络请求（doOnNext()在执行Next事件前调用）</span></span><br><span class="line">                <span class="comment">// 即每隔1秒产生一个数字前，就发送一次网络请求，实现轮询</span></span><br><span class="line">                .doOnNext(<span class="keyword">new</span> Consumer&lt;Long&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Long aLong)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        Log.d(TAG, <span class="string">"第 "</span> + aLong + <span class="string">" 次轮询"</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 步骤3：通过Retrofit实现网络请求</span></span><br><span class="line">                        Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">                                .baseUrl(<span class="string">"http://fy.iciba.com/"</span>)</span><br><span class="line">                                .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">                                .addCallAdapterFactory(RxJava2CallAdapterFactory.create())</span><br><span class="line">                                .build();</span><br><span class="line"></span><br><span class="line">                        GetRequest_Interface request = retrofit.create(GetRequest_Interface.class);</span><br><span class="line"></span><br><span class="line">                        Observable&lt;Translation&gt; observable = request.getCall();</span><br><span class="line"></span><br><span class="line">                        observable.subscribeOn(Schedulers.io())</span><br><span class="line">                                .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">                                .subscribe(<span class="keyword">new</span> Consumer&lt;Translation&gt;() &#123;</span><br><span class="line">                                    <span class="meta">@Override</span></span><br><span class="line">                                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Translation translation)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                        <span class="keyword">if</span> (translation != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                            Log.d(TAG, <span class="string">"结果 from："</span> + translation.getContent().getFrom());</span><br><span class="line">                                            Log.d(TAG, <span class="string">"结果 to："</span> + translation.getContent().getTo());</span><br><span class="line">                                            Log.d(TAG, <span class="string">"结果 vendor："</span> + translation.getContent().getVendor());</span><br><span class="line">                                            Log.d(TAG, <span class="string">"结果 out："</span> + translation.getContent().getOut());</span><br><span class="line">                                            Log.d(TAG, <span class="string">"结果 ciba_use："</span> + translation.getContent().getCiba_use());</span><br><span class="line">                                            Log.d(TAG, <span class="string">"结果 ciba_out："</span> + translation.getContent().getCiba_out());</span><br><span class="line">                                            Log.d(TAG, <span class="string">"结果 err_no："</span> + translation.getContent().getErr_no());</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).subscribe(<span class="keyword">new</span> Consumer&lt;Long&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Long aLong)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"接收到的事件："</span> + aLong);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">new</span> Consumer&lt;Throwable&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Throwable throwable)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"对Error事件作出响应"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">D/Rxjava: 第 0 次轮询</span><br><span class="line">D/Rxjava: 接收到的事件：0</span><br><span class="line">D/Rxjava: 第 1 次轮询</span><br><span class="line">D/Rxjava: 接收到的事件：1</span><br><span class="line">D/Rxjava: 第 2 次轮询</span><br><span class="line">D/Rxjava: 接收到的事件：2</span><br><span class="line">D/Rxjava: 结果 from：en-EU</span><br><span class="line">D/Rxjava: 结果 to：zh-CN</span><br><span class="line">D/Rxjava: 结果 vendor：tencent</span><br><span class="line">D/Rxjava: 结果 out：嗨世界</span><br><span class="line">D/Rxjava: 结果 ciba_use：来自机器翻译。</span><br><span class="line">D/Rxjava: 结果 ciba_out：</span><br><span class="line">D/Rxjava: 结果 err_no：0</span><br><span class="line">D/Rxjava: 第 3 次轮询</span><br><span class="line">D/Rxjava: 接收到的事件：3</span><br><span class="line">D/Rxjava: 结果 from：en-EU</span><br><span class="line">D/Rxjava: 结果 to：zh-CN</span><br><span class="line">D/Rxjava: 结果 vendor：tencent</span><br><span class="line">D/Rxjava: 结果 out：嗨世界</span><br><span class="line">D/Rxjava: 结果 ciba_use：来自机器翻译。</span><br><span class="line">D/Rxjava: 结果 ciba_out：</span><br><span class="line">D/Rxjava: 结果 err_no：0</span><br><span class="line">D/Rxjava: 结果 from：en-EU</span><br><span class="line">D/Rxjava: 结果 to：zh-CN</span><br><span class="line">D/Rxjava: 结果 vendor：tencent</span><br><span class="line">D/Rxjava: 结果 out：嗨世界</span><br><span class="line">D/Rxjava: 结果 ciba_use：来自机器翻译。</span><br><span class="line">D/Rxjava: 结果 ciba_out：</span><br><span class="line">D/Rxjava: 结果 err_no：0</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-需求场景&quot;&gt;&lt;a href=&quot;#1-需求场景&quot; class=&quot;headerlink&quot; title=&quot;1. 需求场景&quot;&gt;&lt;/a&gt;1. 需求场景&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;背景：实现轮询请求，即，客户端固定时间主动向服务器发送请求，获取信息，也称pull。&lt;/li
      
    
    </summary>
    
      <category term="Android" scheme="https://tylerLiu.top/categories/Android/"/>
    
      <category term="RxJava" scheme="https://tylerLiu.top/categories/Android/RxJava/"/>
    
    
      <category term="RxJava" scheme="https://tylerLiu.top/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>Android RxJava：背压策略</title>
    <link href="https://tylerLiu.top/2019/08/20/Android-RxJava%EF%BC%9A%E8%83%8C%E5%8E%8B%E7%AD%96%E7%95%A5/"/>
    <id>https://tylerLiu.top/2019/08/20/Android-RxJava：背压策略/</id>
    <published>2019-08-20T02:43:13.000Z</published>
    <updated>2019-08-22T03:14:05.339Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h1><h2 id="1-1-背景"><a href="#1-1-背景" class="headerlink" title="1.1 背景"></a>1.1 背景</h2><p>观察者和被观察者之间存在两种订阅关系：同步、异步。</p><ol><li>同步订阅：</li></ol><ul><li>观察者和被观察者工作在同一个线程</li><li>被观察者每发送一个事件，必须等到观察者接收且处理后，才能继续发送下一个事件。</li></ul><img src="/2019/08/20/Android-RxJava：背压策略/微信截图_20190820105132.png"><ol start="2"><li>异步订阅</li></ol><ul><li>观察者和被观察者工作不在同一线程</li><li>被观察者不需要等待观察者接收和处理后才能继续发送下一个事件，而是不断发送，直到发送事件完毕</li><li>此时的事件并不会直接发送到观察者处，而是先发送到缓存区，等观察者从缓存区取出事件来处理</li></ul><img src="/2019/08/20/Android-RxJava：背压策略/微信截图_20190820134939.png"><p>对于异步订阅关系，存在<strong>被观察者发送事件的速度与观察者接收事件的速度不匹配的情况</strong>：</p><blockquote><ol><li>发送和接收事件速度就是单位时间内发送和接收事件的数量</li><li>大部分情况是，<strong>被观察者发送事件速度  &gt; 观察者接收事件速度</strong></li></ol></blockquote><h2 id="1-2-问题"><a href="#1-2-问题" class="headerlink" title="1.2 问题"></a>1.2 问题</h2><p>被观察者发送事件速度太快，观察者来不及接收所有事件，导致<strong>观察者无法及时响应/处理所有发送过来的事件，最终导致缓存区溢出、事件丢失或OOM问题</strong>。</p><blockquote><ol><li>点击按钮事件：连续快速点击按钮，则只会造成点击两次的效果。</li><li>原因：因为点击速度太快，按钮来不及响应。</li></ol></blockquote><p>例子：<br>被观察者发送事件速度为10ms/个，观察者接收事件速度为5s/个，即发送和接收速度严重不匹配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ; i++) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"发送了事件"</span> + i);</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            <span class="comment">// 发送事件速度：10ms / 个</span></span><br><span class="line">            emitter.onNext(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">        <span class="comment">// 设置被观察者在IO线程中进行</span></span><br><span class="line">        .subscribeOn(Schedulers.io())</span><br><span class="line">        <span class="comment">// 设置观察者在主线程中进行</span></span><br><span class="line">        .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 接收事件速度：5s / 个</span></span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    Log.d(TAG, <span class="string">"接收到了事件"</span> + integer);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><img src="/2019/08/20/Android-RxJava：背压策略/微信截图_20190820143554.png"><h2 id="1-3-解决方案"><a href="#1-3-解决方案" class="headerlink" title="1.3 解决方案"></a>1.3 解决方案</h2><p>背压策略。</p><h1 id="2-背压策略简介"><a href="#2-背压策略简介" class="headerlink" title="2. 背压策略简介"></a>2. 背压策略简介</h1><h2 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h2><p>一种<strong>控制事件流速</strong>的策略。</p><h2 id="2-2-作用"><a href="#2-2-作用" class="headerlink" title="2.2 作用"></a>2.2 作用</h2><p>在<strong>异步订阅关系</strong>中，<strong>控制事件发送和接收的速度</strong>。</p><h2 id="2-3-解决的问题"><a href="#2-3-解决的问题" class="headerlink" title="2.3 解决的问题"></a>2.3 解决的问题</h2><p>解决因为被观察者发送事件速度和观察者接收事件速度不匹配，导致的观察者无法及时响应/处理所有被观察者发送事件的问题。</p><h2 id="2-4-应用场景"><a href="#2-4-应用场景" class="headerlink" title="2.4 应用场景"></a>2.4 应用场景</h2><p>被观察者发送事件速度与观察者接收事件速度不匹配的场景。<br>具体场景取决于该事件的类型，如：网络请求，具体场景：有很多网络请求需要执行，但执行者的执行速度没有那么快，此时就需要使用背压策略来控制。</p><h1 id="3-背压策略的原理"><a href="#3-背压策略的原理" class="headerlink" title="3. 背压策略的原理"></a>3. 背压策略的原理</h1><p><code>RxJava</code>实现背压策略<code>Backpressure</code>的原理：</p><ol><li>避免出现事件发送和接收流速不匹配的情况：</li></ol><ul><li>a. 控制观察者接收事件的速度：响应式拉拉取，响应式拉取，即观察者根据自身实际情况按需接收事件</li><li>b. 控制被观察者发送事件的速度：反馈控制，即被观察者根据观察者接收事件能力l来控制发送事件的速度</li></ul><ol start="2"><li>当出现事件发送和接收流速不匹配时的解决方案：采用背压策略模式，使用缓存区，对超出缓存区大小的事件进行丢弃、保留和报错的措施</li></ol><p>示意图如下：</p><img src="/2019/08/20/Android-RxJava：背压策略/944365-d37b89b86aea104d.png"><p>与<code>RxJava 1.0</code> 中的<code>Observable</code>相比：</p><img src="/2019/08/20/Android-RxJava：背压策略/944365-c01363ed15386193.png"><p>在<code>RxJava 2.0</code>中的<code>Flowable</code>是什么呢？它其实是<code>RxJava 2.0</code>中被观察者的一种新的实现，同时也是背压策略实现的承载着。</p><h1 id="4-背压策略的具体实现：Flowable"><a href="#4-背压策略的具体实现：Flowable" class="headerlink" title="4. 背压策略的具体实现：Flowable"></a>4. 背压策略的具体实现：Flowable</h1><p>在<code>RxJava 2.0</code>中，采用<code>Flowable</code>来实现背压策略。</p><blockquote><p>准确来说，是<strong>非阻塞式背压</strong>策略</p></blockquote><h2 id="4-1-Flowable介绍"><a href="#4-1-Flowable介绍" class="headerlink" title="4.1 Flowable介绍"></a>4.1 Flowable介绍</h2><p>定义：在<code>RxJava 2.0</code>中，<code>Observable</code>的一种新实现。<br>作用：实现非阻塞式背压策略。</p><h2 id="4-2-Flowable特点"><a href="#4-2-Flowable特点" class="headerlink" title="4.2 Flowable特点"></a>4.2 Flowable特点</h2><ol><li>对应的<code>Observer</code>变为<code>Subscriber</code>：被观察者<code>Flowable</code>——观察者<code>Subscriber</code></li><li>所有的操作符强制支持背压：<code>Flowable</code>中的操作符大多与旧有的<code>Observable</code>类似</li><li>缓存区存放策略：按发送的顺序保存在缓存区：即先发送先进入缓存区，先进入缓存区的事件先取出</li><li>默认的缓存区（队列）大小为128</li></ol><p>下面是1.0与2.0观察者模型的对比图：实际上<code>RxJava 2.0</code>也保留了<code>Observable</code>——<code>Observer</code>的观察者模型。</p><img src="/2019/08/20/Android-RxJava：背压策略/944365-9c67239dfbc77eed.png"><h2 id="4-3-与RxJava-1-0中被观察者的旧实现Observable的关系"><a href="#4-3-与RxJava-1-0中被观察者的旧实现Observable的关系" class="headerlink" title="4.3 与RxJava 1.0中被观察者的旧实现Observable的关系"></a>4.3 与RxJava 1.0中被观察者的旧实现Observable的关系</h2><img src="/2019/08/20/Android-RxJava：背压策略/944365-025e8828a7dd1fd9.png"><p>为什么要采用<code>Flowable</code>实现背压，而不采用旧的<code>Observable</code>呢？<br><strong>原因：<code>Observable</code>无法很好解决背压问题</strong>。</p><ul><li>背景：在<code>RxJava 1.0</code>中，<code>Observable</code>内部采用队列存储事件，在Android中，默认缓存大小为16</li><li>冲突：若发送事件速度 &gt; 接收事件速度时，队列中的数目可能会超过16个，从而导致<code>Observable</code>有很多事件不能被正确背压，最终抛出<code>MissingBackpressureException</code>。在<code>RxJava 1.0</code>也有解决背压的方案：手动减少被观察者发送的事件，降低被观察者发送事件的速度（采用延迟方式），但效果并不好，还是会出现丢失的可能性。</li><li>解决方案：采用<code>RxJava 2.0</code>被观察者的新实现<code>Flowable</code>来实现背压。</li></ul><h2 id="4-4-Flowable的基础使用"><a href="#4-4-Flowable的基础使用" class="headerlink" title="4.4 Flowable的基础使用"></a>4.4 Flowable的基础使用</h2><p>使用方式类似于<code>Observable</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建被观察者Flowable</span></span><br><span class="line">Flowable&lt;Integer&gt; upstream = Flowable.create(<span class="keyword">new</span> FlowableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="comment">// 传入背压参数</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(FlowableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        emitter.onNext(<span class="number">1</span>);</span><br><span class="line">        emitter.onNext(<span class="number">2</span>);</span><br><span class="line">        emitter.onNext(<span class="number">3</span>);</span><br><span class="line">        emitter.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, BackpressureStrategy.ERROR);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建观察者Subscriber</span></span><br><span class="line">Subscriber&lt;Integer&gt; downstream = <span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对比Observable传入的Disposable参数，Subscriber这里传入的参数为Subscription</span></span><br><span class="line">        <span class="comment">// 相同点：Subscription具备Disposable参数的作用，可以通过调用Subscription.cancel()切断连接</span></span><br><span class="line">        <span class="comment">// 不同点：Subscription增加了void request(long n)</span></span><br><span class="line">        Log.d(TAG, <span class="string">"onSubscribe"</span>);</span><br><span class="line">        s.request(Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onNext: "</span> + integer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"onError: "</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onComplete"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立订阅关系</span></span><br><span class="line">upstream.subscribe(downstream);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">D/MainActivity6: onSubscribe</span><br><span class="line">D/MainActivity6: onNext: 1</span><br><span class="line">D/MainActivity6: onNext: 2</span><br><span class="line">D/MainActivity6: onNext: 3</span><br><span class="line">D/MainActivity6: onComplete</span><br></pre></td></tr></table></figure><p>更优雅的链式调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Flowable.create(<span class="keyword">new</span> FlowableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(FlowableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"发送事件 1"</span>);</span><br><span class="line">        emitter.onNext(<span class="number">1</span>);</span><br><span class="line">        Log.d(TAG, <span class="string">"发送事件 2"</span>);</span><br><span class="line">        emitter.onNext(<span class="number">2</span>);</span><br><span class="line">        Log.d(TAG, <span class="string">"发送事件 3"</span>);</span><br><span class="line">        emitter.onNext(<span class="number">3</span>);</span><br><span class="line">        Log.d(TAG, <span class="string">"发送完成"</span>);</span><br><span class="line">        emitter.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, BackpressureStrategy.ERROR).subscribe(<span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription s)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onSubscribe"</span>);</span><br><span class="line">        s.request(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"接收到了事件"</span> + integer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"onError: "</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onComplete"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="5-背压策略的使用"><a href="#5-背压策略的使用" class="headerlink" title="5. 背压策略的使用"></a>5. 背压策略的使用</h1><p>前面说到，<strong>使用背压的场景一般是在异步订阅关系下的</strong>，所以下面主要讲解异步订阅关系场景，即被观察者和观察者工作在不同线程，但是，<strong>由于在同步订阅场景中也有可能出现流速不匹配的问题</strong>，所以会以同讲解一下。</p><h2 id="5-1-控制观察者接收事件的速度"><a href="#5-1-控制观察者接收事件的速度" class="headerlink" title="5.1 控制观察者接收事件的速度"></a>5.1 控制观察者接收事件的速度</h2><h3 id="5-1-1-异步订阅情况"><a href="#5-1-1-异步订阅情况" class="headerlink" title="5.1.1 异步订阅情况"></a>5.1.1 异步订阅情况</h3><p>面向对象：观察者<br>原理：响应式拉取，观察者根据自身实际情况按需接收事件。虽然观察者是响应式拉取接收事件，但被观察者还是一次性发送完毕。<br>实现方式：<code>Subscriber.Subscription.request()</code>。</p><img src="/2019/08/20/Android-RxJava：背压策略/944365-3eebc18cf5bfe45b.png"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Flowable.create(<span class="keyword">new</span> FlowableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(FlowableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 一共发送4个事件</span></span><br><span class="line">        Log.d(TAG, <span class="string">"发送事件 1"</span>);</span><br><span class="line">        emitter.onNext(<span class="number">1</span>);</span><br><span class="line">        Log.d(TAG, <span class="string">"发送事件 2"</span>);</span><br><span class="line">        emitter.onNext(<span class="number">2</span>);</span><br><span class="line">        Log.d(TAG, <span class="string">"发送事件 3"</span>);</span><br><span class="line">        emitter.onNext(<span class="number">3</span>);</span><br><span class="line">        Log.d(TAG, <span class="string">"发送事件 4"</span>);</span><br><span class="line">        emitter.onNext(<span class="number">4</span>);</span><br><span class="line">        Log.d(TAG, <span class="string">"发送完成"</span>);</span><br><span class="line">        emitter.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, BackpressureStrategy.ERROR)</span><br><span class="line">        .subscribeOn(Schedulers.io())</span><br><span class="line">        .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription s)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 观察者能够接收多少个事件</span></span><br><span class="line">                <span class="comment">// 官方默认推荐使用Long.MAX_VALUE，即s.request(Long.MAX_VALUE);</span></span><br><span class="line">                s.request(<span class="number">3</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"接收到了事件"</span> + integer);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"onError: "</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"onComplete"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">D/MainActivity6: 发送事件 1</span><br><span class="line">D/MainActivity6: 发送事件 2</span><br><span class="line">D/MainActivity6: 发送事件 3</span><br><span class="line">D/MainActivity6: 发送事件 4</span><br><span class="line">D/MainActivity6: 发送完成</span><br><span class="line">D/MainActivity6: 接收到了事件1</span><br><span class="line">D/MainActivity6: 接收到了事件2</span><br><span class="line">D/MainActivity6: 接收到了事件3</span><br></pre></td></tr></table></figure><p>特别注意：</p><ol><li>结论：对于异步订阅情况，若观察者没有设置<code>Subscription.request(long n)</code>，说明观察者不接受事件。此时被观察者仍能继续发送事件（存放在缓存区），等观察者需要时再取出。</li><li>解释：不设置<code>Subscription.request(long n)</code>，观察者虽然不能接收事件，但是由于异步订阅关系中存在缓存区（大小为128），所以被观察者仍然能继续发送事件并暂时存放到缓存区。当缓存区满（128个事件）时，就会溢出报错。只有当观察者有需求时，才调用<code>request()</code>从缓存区按需取出事件。</li><li>额外：缓存区大小默认为128个事件，由<code>Flowable</code>的<code>bufferSize</code>决定。</li></ol><p>代码演示1：观察者不接收事件的情况下，被观察者继续发送事件并存到缓存区，再按需取出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main7Activity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MainActivity7"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该按钮用于调用Subscription.request()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Button btn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于保存Subscription对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Subscription mSubscription;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main7);</span><br><span class="line"></span><br><span class="line">        btn = findViewById(R.id.button);</span><br><span class="line">        btn.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                mSubscription.request(<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Flowable.create(<span class="keyword">new</span> FlowableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(FlowableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"发送事件 1"</span>);</span><br><span class="line">                emitter.onNext(<span class="number">1</span>);</span><br><span class="line">                Log.d(TAG, <span class="string">"发送事件 2"</span>);</span><br><span class="line">                emitter.onNext(<span class="number">2</span>);</span><br><span class="line">                Log.d(TAG, <span class="string">"发送事件 3"</span>);</span><br><span class="line">                emitter.onNext(<span class="number">3</span>);</span><br><span class="line">                Log.d(TAG, <span class="string">"发送事件 4"</span>);</span><br><span class="line">                emitter.onNext(<span class="number">4</span>);</span><br><span class="line">                Log.d(TAG, <span class="string">"发送完成"</span>);</span><br><span class="line">                emitter.onComplete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, BackpressureStrategy.ERROR)</span><br><span class="line">                .subscribeOn(Schedulers.io())</span><br><span class="line">                .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">                .subscribe(<span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription s)</span> </span>&#123;</span><br><span class="line">                        Log.d(TAG, <span class="string">"onSubscribe"</span>);</span><br><span class="line">                        <span class="comment">// 保存Subscription对象，等待点击按钮时（调用request(2)）观察者再接收事件</span></span><br><span class="line">                        mSubscription = s;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">                        Log.d(TAG, <span class="string">"接收到了事件"</span> + integer);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">                        Log.w(TAG, <span class="string">"onError: "</span>, t);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        Log.d(TAG, <span class="string">"onComplete"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">D/MainActivity7: onSubscribe</span><br><span class="line">D/MainActivity7: 发送事件 1</span><br><span class="line">D/MainActivity7: 发送事件 2</span><br><span class="line">D/MainActivity7: 发送事件 3</span><br><span class="line">D/MainActivity7: 发送事件 4</span><br><span class="line">D/MainActivity7: 发送完成</span><br><span class="line">D/MainActivity7: 接收到了事件1</span><br><span class="line">D/MainActivity7: 接收到了事件2</span><br></pre></td></tr></table></figure><p>代码演示2：观察者不接收事件的情况下，被观察者连续发送事件，直到超出缓存区大小（128）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Flowable.create(<span class="keyword">new</span> FlowableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(FlowableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 一共发送129个事件，即超出了缓存区的大小</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">129</span>; i++) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"发送了事件"</span> + i);</span><br><span class="line">            emitter.onNext(i);</span><br><span class="line">        &#125;</span><br><span class="line">        emitter.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, BackpressureStrategy.ERROR)</span><br><span class="line">        .subscribeOn(Schedulers.io())</span><br><span class="line">        .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription s)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"onSubscribe"</span>);</span><br><span class="line">                <span class="comment">// 默认不设置可接收事件大小</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"接收到了事件"</span> + integer);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"onError: "</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"onComplete"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">2019-08-21 15:43:16.479 4703-4703/com.ly.allendemorx W/MainActivity7: onError: </span><br><span class="line">    io.reactivex.exceptions.MissingBackpressureException: create: could not emit value due to lack of requests</span><br><span class="line">        at io.reactivex.internal.operators.flowable.FlowableCreate$ErrorAsyncEmitter.onOverflow(FlowableCreate.java:438)</span><br><span class="line">        at io.reactivex.internal.operators.flowable.FlowableCreate$NoOverflowBaseAsyncEmitter.onNext(FlowableCreate.java:406)</span><br><span class="line">        at com.ly.allendemorx.Main7Activity$3.subscribe(Main7Activity.java:55)</span><br><span class="line">        at io.reactivex.internal.operators.flowable.FlowableCreate.subscribeActual(FlowableCreate.java:71)</span><br><span class="line">        at io.reactivex.Flowable.subscribe(Flowable.java:14827)</span><br><span class="line">        at io.reactivex.Flowable.subscribe(Flowable.java:14774)</span><br><span class="line">        at io.reactivex.internal.operators.flowable.FlowableSubscribeOn$SubscribeOnSubscriber.run(FlowableSubscribeOn.java:82)</span><br><span class="line">        at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:66)</span><br><span class="line">        at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:57)</span><br><span class="line">        at java.util.concurrent.FutureTask.run(FutureTask.java:237)</span><br><span class="line">        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:272)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1133)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:607)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:761)</span><br></pre></td></tr></table></figure><h3 id="5-1-2-同步订阅情况"><a href="#5-1-2-同步订阅情况" class="headerlink" title="5.1.2 同步订阅情况"></a>5.1.2 同步订阅情况</h3><p>与异步订阅的区别：</p><ul><li>同步订阅中，被观察者和观察者工作于同一线程</li><li>同步订阅中，没有缓存区</li></ul><p>被观察者再发送一个事件后，必须等待观察者接收后，才能继续发送下一个事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Flowable.create(<span class="keyword">new</span> FlowableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(FlowableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 发送3个事件</span></span><br><span class="line">        Log.d(TAG, <span class="string">"发送了事件1"</span>);</span><br><span class="line">        emitter.onNext(<span class="number">1</span>);</span><br><span class="line">        Log.d(TAG, <span class="string">"发送了事件2"</span>);</span><br><span class="line">        emitter.onNext(<span class="number">2</span>);</span><br><span class="line">        Log.d(TAG, <span class="string">"发送了事件3"</span>);</span><br><span class="line">        emitter.onNext(<span class="number">3</span>);</span><br><span class="line">        emitter.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, BackpressureStrategy.ERROR)</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription s)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"onSubscribe"</span>);</span><br><span class="line">                s.request(<span class="number">3</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"接收到了事件"</span> + integer);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"onError: "</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"onComplete"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">D/MainActivity7: onSubscribe</span><br><span class="line">D/MainActivity7: 发送了事件1</span><br><span class="line">D/MainActivity7: 接收到了事件1</span><br><span class="line">D/MainActivity7: 发送了事件2</span><br><span class="line">D/MainActivity7: 接收到了事件2</span><br><span class="line">D/MainActivity7: 发送了事件3</span><br><span class="line">D/MainActivity7: 接收到了事件3</span><br><span class="line">D/MainActivity7: onComplete</span><br></pre></td></tr></table></figure><p>所以，同步订阅不会出现被观察者发送事件速度 ＞ 观察者接收事件速度的情况，而是会出现<strong>被观察者发送事件数量 ＞ 观察者接收事件数量的问题</strong>。</p><p>如：观察者子还能接收三个事件，被观察者发送了四个事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Flowable.create(<span class="keyword">new</span> FlowableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(FlowableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 被观察者发送事件数量 = 4个</span></span><br><span class="line">        Log.d(TAG, <span class="string">"发送了事件1"</span>);</span><br><span class="line">        emitter.onNext(<span class="number">1</span>);</span><br><span class="line">        Log.d(TAG, <span class="string">"发送了事件2"</span>);</span><br><span class="line">        emitter.onNext(<span class="number">2</span>);</span><br><span class="line">        Log.d(TAG, <span class="string">"发送了事件3"</span>);</span><br><span class="line">        emitter.onNext(<span class="number">3</span>);</span><br><span class="line">        Log.d(TAG, <span class="string">"发送了事件4"</span>);</span><br><span class="line">        emitter.onNext(<span class="number">4</span>);</span><br><span class="line">        emitter.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, BackpressureStrategy.ERROR)</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription s)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"onSubscribe"</span>);</span><br><span class="line">                s.request(<span class="number">3</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"接收到了事件"</span> + integer);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"onError: "</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"onComplete"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">2019-08-21 15:52:30.381 5179-5179/com.ly.allendemorx D/MainActivity7: onSubscribe</span><br><span class="line">2019-08-21 15:52:30.388 5179-5179/com.ly.allendemorx D/MainActivity7: 发送了事件1</span><br><span class="line">2019-08-21 15:52:30.388 5179-5179/com.ly.allendemorx D/MainActivity7: 接收到了事件1</span><br><span class="line">2019-08-21 15:52:30.388 5179-5179/com.ly.allendemorx D/MainActivity7: 发送了事件2</span><br><span class="line">2019-08-21 15:52:30.388 5179-5179/com.ly.allendemorx D/MainActivity7: 接收到了事件2</span><br><span class="line">2019-08-21 15:52:30.388 5179-5179/com.ly.allendemorx D/MainActivity7: 发送了事件3</span><br><span class="line">2019-08-21 15:52:30.388 5179-5179/com.ly.allendemorx D/MainActivity7: 接收到了事件3</span><br><span class="line">2019-08-21 15:52:30.388 5179-5179/com.ly.allendemorx D/MainActivity7: 发送了事件4</span><br><span class="line">2019-08-21 15:52:30.391 5179-5179/com.ly.allendemorx W/MainActivity7: onError: </span><br><span class="line">    io.reactivex.exceptions.MissingBackpressureException: create: could not emit value due to lack of requests</span><br><span class="line">        at io.reactivex.internal.operators.flowable.FlowableCreate$ErrorAsyncEmitter.onOverflow(FlowableCreate.java:438)</span><br><span class="line">        at io.reactivex.internal.operators.flowable.FlowableCreate$NoOverflowBaseAsyncEmitter.onNext(FlowableCreate.java:406)</span><br><span class="line">        at com.ly.allendemorx.Main7Activity$3.subscribe(Main7Activity.java:60)</span><br><span class="line">        at io.reactivex.internal.operators.flowable.FlowableCreate.subscribeActual(FlowableCreate.java:71)</span><br><span class="line">        at io.reactivex.Flowable.subscribe(Flowable.java:14827)</span><br><span class="line">        at io.reactivex.Flowable.subscribe(Flowable.java:14777)</span><br><span class="line">        at com.ly.allendemorx.Main7Activity.onCreate(Main7Activity.java:64)</span><br><span class="line">        at android.app.Activity.performCreate(Activity.java:6692)</span><br><span class="line">        at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1118)</span><br><span class="line">        at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2621)</span><br><span class="line">        at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2729)</span><br><span class="line">        at android.app.ActivityThread.-wrap12(ActivityThread.java)</span><br><span class="line">        at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1480)</span><br><span class="line">        at android.os.Handler.dispatchMessage(Handler.java:102)</span><br><span class="line">        at android.os.Looper.loop(Looper.java:154)</span><br><span class="line">        at android.app.ActivityThread.main(ActivityThread.java:6169)</span><br><span class="line">        at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">        at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:891)</span><br><span class="line">        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:781)</span><br></pre></td></tr></table></figure><h2 id="5-2-控制被观察者发送事件的速度"><a href="#5-2-控制被观察者发送事件的速度" class="headerlink" title="5.2 控制被观察者发送事件的速度"></a>5.2 控制被观察者发送事件的速度</h2><p>面向对象：被观察者<br>原理：反馈控制，被观察者根据观察者接收事件的能力控制发送事件的速度，观察者预先告知被观察者其事件接收的能力。<br>实现方式：<code>FlowableEmitter.requested()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FlowableEmitter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Emitter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">// FlowableEmitter = 1个接口，继承自Emitter</span></span><br><span class="line"><span class="comment">// Emitter接口方法包括：onNext(),onComplete() &amp; onError</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">requested</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 作用：返回当前线程中request（a）中的a值</span></span><br><span class="line">    <span class="comment">// 该request（a）则是措施1中讲解的方法，作用  = 设置</span></span><br><span class="line">   </span><br><span class="line">    ....<span class="comment">// 仅贴出关键代码</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个线程中的<code>requested()</code>的返回值为该线程中<code>request(a)</code>的<code>a</code>值。    </p><img src="/2019/08/20/Android-RxJava：背压策略/944365-88e1f3c641eb54e3.png"><h3 id="5-2-1-同步订阅情况"><a href="#5-2-1-同步订阅情况" class="headerlink" title="5.2.1  同步订阅情况"></a>5.2.1  同步订阅情况</h3><p>在同步订阅中，被观察者通过<code>FlowableEmitter.requested()</code>获得观察者自身接收事件能力，<strong>从而根据该信息控制事件发送速度，从而达到观察者反向控制被观察者的效果</strong>。</p><p>例子：被观察者根据观察者自身接收能力（10事件），从而进发送10个事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Flowable.create(<span class="keyword">new</span> FlowableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(FlowableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前观察者接收事件的能力</span></span><br><span class="line">        <span class="keyword">long</span> l = emitter.requested();</span><br><span class="line">        Log.d(TAG, <span class="string">"观察者可接收事件"</span> + l);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据获得的值，控制发送事件的数量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"发送了事件"</span> + i);</span><br><span class="line">            emitter.onNext(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, BackpressureStrategy.ERROR)</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription s)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"onSubscribe"</span>);</span><br><span class="line">                <span class="comment">// 设置观察者接收事件的能力</span></span><br><span class="line">                s.request(<span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"接收到了事件"</span> + integer);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"onError: "</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"onComplete"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">D/MainActivity7: onSubscribe</span><br><span class="line">D/MainActivity7: 观察者可接收事件10</span><br><span class="line">D/MainActivity7: 发送了事件0</span><br><span class="line">D/MainActivity7: 接收到了事件0</span><br><span class="line">D/MainActivity7: 发送了事件1</span><br><span class="line">D/MainActivity7: 接收到了事件1</span><br><span class="line">D/MainActivity7: 发送了事件2</span><br><span class="line">D/MainActivity7: 接收到了事件2</span><br><span class="line">D/MainActivity7: 发送了事件3</span><br><span class="line">D/MainActivity7: 接收到了事件3</span><br><span class="line">D/MainActivity7: 发送了事件4</span><br><span class="line">D/MainActivity7: 接收到了事件4</span><br><span class="line">D/MainActivity7: 发送了事件5</span><br><span class="line">D/MainActivity7: 接收到了事件5</span><br><span class="line">D/MainActivity7: 发送了事件6</span><br><span class="line">D/MainActivity7: 接收到了事件6</span><br><span class="line">D/MainActivity7: 发送了事件7</span><br><span class="line">D/MainActivity7: 接收到了事件7</span><br><span class="line">D/MainActivity7: 发送了事件8</span><br><span class="line">D/MainActivity7: 接收到了事件8</span><br><span class="line">D/MainActivity7: 发送了事件9</span><br><span class="line">D/MainActivity7: 接收到了事件9</span><br></pre></td></tr></table></figure><p>特别注意：在同步订阅时，使用<code>FlowableEmitter.requested()</code>时，要注意以下使用特性。</p><ol><li>可叠加性：观察者可连续要求接收事件，被观察者会进行叠加，一起发送。</li><li>实时更新性：每次发送事件后，<code>FlowableEmitter.requested()</code>的返回值会实时更新观察者能接收的事件。</li><li>异常：</li></ol><ul><li>当<code>FlowableEmitter.requested()</code>返回0时，代表观察者已经不能接收事件，此时被观察者若继续发送事件，会抛出<code>MissingBackpressureException</code></li><li>若观察者中没有设置可接收事件数量，即，没有调用<code>Subscription.request()</code>，那么被观察者默认观察者可接收事件为0，因为同步订阅中没有缓存区。</li></ul><h4 id="可叠加性"><a href="#可叠加性" class="headerlink" title="可叠加性"></a>可叠加性</h4><p>观察者可连续要求接收事件，被观察者会进行叠加，一起发送。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Subscription.request（a1）；</span><br><span class="line">Subscription.request（a2）；</span><br><span class="line"></span><br><span class="line">FlowableEmitter.requested()的返回值 = a1 + a2</span><br></pre></td></tr></table></figure><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Flowable.create(<span class="keyword">new</span> FlowableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(FlowableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 调用emitter.requested()获取当前观察者需要接收的事件数量</span></span><br><span class="line">        Log.d(TAG, <span class="string">"观察者可接收事件"</span> + emitter.requested());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, BackpressureStrategy.ERROR)</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription s)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"onSubscribe"</span>);</span><br><span class="line">                <span class="comment">// 第1次设置观察者每次能接受10个事件</span></span><br><span class="line">                s.request(<span class="number">10</span>);</span><br><span class="line">                <span class="comment">// 第2次设置观察者每次能接受20个事件</span></span><br><span class="line">                s.request(<span class="number">20</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"接收到了事件"</span> + integer);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"onError: "</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"onComplete"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D/MainActivity7: onSubscribe</span><br><span class="line">D/MainActivity7: 观察者可接收事件30</span><br></pre></td></tr></table></figure><h4 id="实时更新性"><a href="#实时更新性" class="headerlink" title="实时更新性"></a>实时更新性</h4><p>每次发送事件后，<code>FlowableEmitter.requested()</code>的返回值会实时更新观察者能接收的事件。</p><blockquote><ol><li>即一开始观察者可接收事件的数量为10，发送一个后，会实时更新为9。</li><li>仅计算<code>Next</code>事件，<code>Complete</code>和<code>Error</code>事件不算。</li></ol></blockquote><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Flowable.create(<span class="keyword">new</span> FlowableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(FlowableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 调用emitter.requested()获取当前观察者需要接收的事件数量</span></span><br><span class="line">        Log.d(TAG, <span class="string">"观察者可接收事件数量 = "</span> + emitter.requested());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 每次发送事件后，emitter.requested()会实时更新观察者能接受的事件</span></span><br><span class="line">        <span class="comment">// 即一开始观察者要接收10个事件，发送了1个后，会实时更新为9个</span></span><br><span class="line">        Log.d(TAG, <span class="string">"发送了事件 1"</span>);</span><br><span class="line">        emitter.onNext(<span class="number">1</span>);</span><br><span class="line">        Log.d(TAG, <span class="string">"发送了事件1后, 还需要发送事件数量 = "</span> + emitter.requested());</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, <span class="string">"发送了事件 2"</span>);</span><br><span class="line">        emitter.onNext(<span class="number">2</span>);</span><br><span class="line">        Log.d(TAG, <span class="string">"发送事件2后, 还需要发送事件数量 = "</span> + emitter.requested());</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, <span class="string">"发送了事件 3"</span>);</span><br><span class="line">        emitter.onNext(<span class="number">3</span>);</span><br><span class="line">        Log.d(TAG, <span class="string">"发送事件3后, 还需要发送事件数量 = "</span> + emitter.requested());</span><br><span class="line"></span><br><span class="line">        emitter.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, BackpressureStrategy.ERROR)</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription s)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"onSubscribe"</span>);</span><br><span class="line">                s.request(<span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"接收到了事件"</span> + integer);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"onError: "</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"onComplete"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">D/MainActivity7: onSubscribe</span><br><span class="line">D/MainActivity7: 观察者可接收事件数量 = 10</span><br><span class="line">D/MainActivity7: 发送了事件 1</span><br><span class="line">D/MainActivity7: 接收到了事件1</span><br><span class="line">D/MainActivity7: 发送了事件1后, 还需要发送事件数量 = 9</span><br><span class="line">D/MainActivity7: 发送了事件 2</span><br><span class="line">D/MainActivity7: 接收到了事件2</span><br><span class="line">D/MainActivity7: 发送事件2后, 还需要发送事件数量 = 8</span><br><span class="line">D/MainActivity7: 发送了事件 3</span><br><span class="line">D/MainActivity7: 接收到了事件3</span><br><span class="line">D/MainActivity7: 发送事件3后, 还需要发送事件数量 = 7</span><br><span class="line">D/MainActivity7: onComplete</span><br></pre></td></tr></table></figure><h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p>当<code>FlowableEmitter.requested()</code>减到0时，则代表观察者已经不可接收事件，此时被观察者若继续发送事件，则会抛出<code>MissingBackpressureException</code>。<br>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Flowable.create(<span class="keyword">new</span> FlowableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(FlowableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 调用emitter.requested()获取当前观察者需要接收的事件数量</span></span><br><span class="line">        Log.d(TAG, <span class="string">"观察者可接收事件数量 = "</span> + emitter.requested());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 每次发送事件后，emitter.requested()会实时更新观察者能接受的事件</span></span><br><span class="line">        <span class="comment">// 即一开始观察者要接收10个事件，发送了1个后，会实时更新为9个</span></span><br><span class="line">        Log.d(TAG, <span class="string">"发送了事件 1"</span>);</span><br><span class="line">        emitter.onNext(<span class="number">1</span>);</span><br><span class="line">        Log.d(TAG, <span class="string">"发送了事件1后, 还需要发送事件数量 = "</span> + emitter.requested());</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, <span class="string">"发送了事件 2"</span>);</span><br><span class="line">        emitter.onNext(<span class="number">2</span>);</span><br><span class="line">        Log.d(TAG, <span class="string">"发送事件2后, 还需要发送事件数量 = "</span> + emitter.requested());</span><br><span class="line"></span><br><span class="line">        emitter.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, BackpressureStrategy.ERROR)</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription s)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"onSubscribe"</span>);</span><br><span class="line">                s.request(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"接收到了事件"</span> + integer);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"onError: "</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"onComplete"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">2019-08-21 17:23:57.540 6023-6023/com.ly.allendemorx D/MainActivity7: onSubscribe</span><br><span class="line">2019-08-21 17:23:57.547 6023-6023/com.ly.allendemorx D/MainActivity7: 观察者可接收事件数量 = 1</span><br><span class="line">2019-08-21 17:23:57.547 6023-6023/com.ly.allendemorx D/MainActivity7: 发送了事件 1</span><br><span class="line">2019-08-21 17:23:57.547 6023-6023/com.ly.allendemorx D/MainActivity7: 接收到了事件1</span><br><span class="line">2019-08-21 17:23:57.547 6023-6023/com.ly.allendemorx D/MainActivity7: 发送了事件1后, 还需要发送事件数量 = 0</span><br><span class="line">2019-08-21 17:23:57.547 6023-6023/com.ly.allendemorx D/MainActivity7: 发送了事件 2</span><br><span class="line">2019-08-21 17:23:57.551 6023-6023/com.ly.allendemorx W/MainActivity7: onError: </span><br><span class="line">    io.reactivex.exceptions.MissingBackpressureException: create: could not emit value due to lack of requests</span><br><span class="line">        at io.reactivex.internal.operators.flowable.FlowableCreate$ErrorAsyncEmitter.onOverflow(FlowableCreate.java:438)</span><br><span class="line">        at io.reactivex.internal.operators.flowable.FlowableCreate$NoOverflowBaseAsyncEmitter.onNext(FlowableCreate.java:406)</span><br><span class="line">        at com.ly.allendemorx.Main7Activity$3.subscribe(Main7Activity.java:62)</span><br><span class="line">        at io.reactivex.internal.operators.flowable.FlowableCreate.subscribeActual(FlowableCreate.java:71)</span><br><span class="line">        at io.reactivex.Flowable.subscribe(Flowable.java:14827)</span><br><span class="line">        at io.reactivex.Flowable.subscribe(Flowable.java:14777)</span><br><span class="line">        at com.ly.allendemorx.Main7Activity.onCreate(Main7Activity.java:68)</span><br><span class="line">        at android.app.Activity.performCreate(Activity.java:6692)</span><br><span class="line">        at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1118)</span><br><span class="line">        at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2621)</span><br><span class="line">        at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2729)</span><br><span class="line">        at android.app.ActivityThread.-wrap12(ActivityThread.java)</span><br><span class="line">        at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1480)</span><br><span class="line">        at android.os.Handler.dispatchMessage(Handler.java:102)</span><br><span class="line">        at android.os.Looper.loop(Looper.java:154)</span><br><span class="line">        at android.app.ActivityThread.main(ActivityThread.java:6169)</span><br><span class="line">        at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">        at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:891)</span><br><span class="line">        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:781)</span><br><span class="line">2019-08-21 17:23:57.551 6023-6023/com.ly.allendemorx D/MainActivity7: 发送事件2后, 还需要发送事件数量 = 0</span><br></pre></td></tr></table></figure><h3 id="5-2-2-异步订阅情况"><a href="#5-2-2-异步订阅情况" class="headerlink" title="5.2.2 异步订阅情况"></a>5.2.2 异步订阅情况</h3><p>由于二者不在同一线程，所以被观察者无法通过<code>FlowableEmitter.requested()</code>获取观察者接收事件的能力。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Flowable.create(<span class="keyword">new</span> FlowableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(FlowableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"观察者可接收事件数量 = "</span> + emitter.requested());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, BackpressureStrategy.ERROR)</span><br><span class="line">        .subscribeOn(Schedulers.io())</span><br><span class="line">        .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription s)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"onSubscribe"</span>);</span><br><span class="line">                <span class="comment">// 该设置仅影响观察者线程中的requested，却不会影响的被观察者中的FlowableEmitter.requested()的返回值</span></span><br><span class="line">                <span class="comment">// 因为FlowableEmitter.requested()的返回值 取决于RxJava内部调用request(n)，而该内部调用会在一开始就调用request(128)</span></span><br><span class="line">                s.request(<span class="number">150</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"接收到了事件"</span> + integer);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"onError: "</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"onComplete"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D/MainActivity7: onSubscribe</span><br><span class="line">D/MainActivity7: 观察者可接收事件数量 = 128</span><br></pre></td></tr></table></figure><p><strong>在异步订阅中，反向控制的原理是：通过<code>RxJava</code>内部固定调用被观察者线程中的<code>request(n)</code>，从而方向控制被观察者的发送事件速度。</strong></p><p>那么该在什么时候调用被观察者线程中的<code>request(n)</code>，<code>n</code>的值该是多少呢？</p><p>关于<code>RxJava</code>内部调用<code>request(n)（n = 128、96、0）</code>的逻辑如下：</p><img src="/2019/08/20/Android-RxJava：背压策略/944365-f6314aba60c08455.png"><blockquote><p>至于为什么调用<code>request(128)</code>、<code>request(96)</code>、<code>request(0)</code>，可以查看<code>Flowable</code>的源码</p></blockquote><p>代码演示：被观察者一共需要发送500个事件，但真正开始发送事件的前提为<code>FlowableEmtter.requested()</code>的返回值不为0；观察者每次接收48个事件（点击按钮接收事件）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main7Activity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MainActivity7"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该按钮用于调用Subscription.request()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Button btn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于保存Subscription对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Subscription mSubscription;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main7);</span><br><span class="line"></span><br><span class="line">        btn = findViewById(R.id.button);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 点击按钮接收事件，每次接收48个事件</span></span><br><span class="line">        btn.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                mSubscription.request(<span class="number">48</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Flowable.create(<span class="keyword">new</span> FlowableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(FlowableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"观察者可接收事件数量 = "</span> + emitter.requested());</span><br><span class="line">                <span class="comment">//设置标记位控制</span></span><br><span class="line">                <span class="keyword">boolean</span> flag;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 被观察者一共需要发送500个事件</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 若requested() == 0，则不发送</span></span><br><span class="line">                    <span class="keyword">while</span> (emitter.requested() == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                            Log.d(TAG, <span class="string">"不再发送"</span>);</span><br><span class="line">                            flag = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// requested() ≠ 0 才发送</span></span><br><span class="line">                    Log.d(TAG, <span class="string">"发送了事件"</span> + i + <span class="string">"，观察者可接收事件数量 = "</span> + emitter.requested());</span><br><span class="line">                    emitter.onNext(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, BackpressureStrategy.ERROR)</span><br><span class="line">                .subscribeOn(Schedulers.io())</span><br><span class="line">                .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">                .subscribe(<span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription s)</span> </span>&#123;</span><br><span class="line">                        Log.d(TAG, <span class="string">"onSubscribe"</span>);</span><br><span class="line">                        <span class="comment">// 初始状态 = 不接收事件；通过点击按钮接收事件</span></span><br><span class="line">                        mSubscription = s;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">                        Log.d(TAG, <span class="string">"接收到了事件"</span> + integer);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">                        Log.w(TAG, <span class="string">"onError: "</span>, t);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        Log.d(TAG, <span class="string">"onComplete"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line">D/MainActivity7: onSubscribe</span><br><span class="line">D/MainActivity7: 观察者可接收事件数量 = 128</span><br><span class="line">D/MainActivity7: 发送了事件0，观察者可接收事件数量 = 128</span><br><span class="line">D/MainActivity7: 发送了事件1，观察者可接收事件数量 = 127</span><br><span class="line">D/MainActivity7: 发送了事件2，观察者可接收事件数量 = 126</span><br><span class="line">D/MainActivity7: 发送了事件3，观察者可接收事件数量 = 125</span><br><span class="line">D/MainActivity7: 发送了事件4，观察者可接收事件数量 = 124</span><br><span class="line">D/MainActivity7: 发送了事件5，观察者可接收事件数量 = 123</span><br><span class="line">D/MainActivity7: 发送了事件6，观察者可接收事件数量 = 122</span><br><span class="line">D/MainActivity7: 发送了事件7，观察者可接收事件数量 = 121</span><br><span class="line">D/MainActivity7: 发送了事件8，观察者可接收事件数量 = 120</span><br><span class="line">D/MainActivity7: 发送了事件9，观察者可接收事件数量 = 119</span><br><span class="line">D/MainActivity7: 发送了事件10，观察者可接收事件数量 = 118</span><br><span class="line">D/MainActivity7: 发送了事件11，观察者可接收事件数量 = 117</span><br><span class="line">D/MainActivity7: 发送了事件12，观察者可接收事件数量 = 116</span><br><span class="line">D/MainActivity7: 发送了事件13，观察者可接收事件数量 = 115</span><br><span class="line">D/MainActivity7: 发送了事件14，观察者可接收事件数量 = 114</span><br><span class="line">D/MainActivity7: 发送了事件15，观察者可接收事件数量 = 113</span><br><span class="line">D/MainActivity7: 发送了事件16，观察者可接收事件数量 = 112</span><br><span class="line">D/MainActivity7: 发送了事件17，观察者可接收事件数量 = 111</span><br><span class="line">D/MainActivity7: 发送了事件18，观察者可接收事件数量 = 110</span><br><span class="line">D/MainActivity7: 发送了事件19，观察者可接收事件数量 = 109</span><br><span class="line">D/MainActivity7: 发送了事件20，观察者可接收事件数量 = 108</span><br><span class="line">D/MainActivity7: 发送了事件21，观察者可接收事件数量 = 107</span><br><span class="line">D/MainActivity7: 发送了事件22，观察者可接收事件数量 = 106</span><br><span class="line">D/MainActivity7: 发送了事件23，观察者可接收事件数量 = 105</span><br><span class="line">D/MainActivity7: 发送了事件24，观察者可接收事件数量 = 104</span><br><span class="line">D/MainActivity7: 发送了事件25，观察者可接收事件数量 = 103</span><br><span class="line">D/MainActivity7: 发送了事件26，观察者可接收事件数量 = 102</span><br><span class="line">D/MainActivity7: 发送了事件27，观察者可接收事件数量 = 101</span><br><span class="line">D/MainActivity7: 发送了事件28，观察者可接收事件数量 = 100</span><br><span class="line">D/MainActivity7: 发送了事件29，观察者可接收事件数量 = 99</span><br><span class="line">D/MainActivity7: 发送了事件30，观察者可接收事件数量 = 98</span><br><span class="line">D/MainActivity7: 发送了事件31，观察者可接收事件数量 = 97</span><br><span class="line">D/MainActivity7: 发送了事件32，观察者可接收事件数量 = 96</span><br><span class="line">D/MainActivity7: 发送了事件33，观察者可接收事件数量 = 95</span><br><span class="line">D/MainActivity7: 发送了事件34，观察者可接收事件数量 = 94</span><br><span class="line">D/MainActivity7: 发送了事件35，观察者可接收事件数量 = 93</span><br><span class="line">D/MainActivity7: 发送了事件36，观察者可接收事件数量 = 92</span><br><span class="line">D/MainActivity7: 发送了事件37，观察者可接收事件数量 = 91</span><br><span class="line">D/MainActivity7: 发送了事件38，观察者可接收事件数量 = 90</span><br><span class="line">D/MainActivity7: 发送了事件39，观察者可接收事件数量 = 89</span><br><span class="line">D/MainActivity7: 发送了事件40，观察者可接收事件数量 = 88</span><br><span class="line">D/MainActivity7: 发送了事件41，观察者可接收事件数量 = 87</span><br><span class="line">D/MainActivity7: 发送了事件42，观察者可接收事件数量 = 86</span><br><span class="line">D/MainActivity7: 发送了事件43，观察者可接收事件数量 = 85</span><br><span class="line">D/MainActivity7: 发送了事件44，观察者可接收事件数量 = 84</span><br><span class="line">D/MainActivity7: 发送了事件45，观察者可接收事件数量 = 83</span><br><span class="line">D/MainActivity7: 发送了事件46，观察者可接收事件数量 = 82</span><br><span class="line">D/MainActivity7: 发送了事件47，观察者可接收事件数量 = 81</span><br><span class="line">D/MainActivity7: 发送了事件48，观察者可接收事件数量 = 80</span><br><span class="line">D/MainActivity7: 发送了事件49，观察者可接收事件数量 = 79</span><br><span class="line">D/MainActivity7: 发送了事件50，观察者可接收事件数量 = 78</span><br><span class="line">D/MainActivity7: 发送了事件51，观察者可接收事件数量 = 77</span><br><span class="line">D/MainActivity7: 发送了事件52，观察者可接收事件数量 = 76</span><br><span class="line">D/MainActivity7: 发送了事件53，观察者可接收事件数量 = 75</span><br><span class="line">D/MainActivity7: 发送了事件54，观察者可接收事件数量 = 74</span><br><span class="line">D/MainActivity7: 发送了事件55，观察者可接收事件数量 = 73</span><br><span class="line">D/MainActivity7: 发送了事件56，观察者可接收事件数量 = 72</span><br><span class="line">D/MainActivity7: 发送了事件57，观察者可接收事件数量 = 71</span><br><span class="line">D/MainActivity7: 发送了事件58，观察者可接收事件数量 = 70</span><br><span class="line">D/MainActivity7: 发送了事件59，观察者可接收事件数量 = 69</span><br><span class="line">D/MainActivity7: 发送了事件60，观察者可接收事件数量 = 68</span><br><span class="line">D/MainActivity7: 发送了事件61，观察者可接收事件数量 = 67</span><br><span class="line">D/MainActivity7: 发送了事件62，观察者可接收事件数量 = 66</span><br><span class="line">D/MainActivity7: 发送了事件63，观察者可接收事件数量 = 65</span><br><span class="line">D/MainActivity7: 发送了事件64，观察者可接收事件数量 = 64</span><br><span class="line">D/MainActivity7: 发送了事件65，观察者可接收事件数量 = 63</span><br><span class="line">D/MainActivity7: 发送了事件66，观察者可接收事件数量 = 62</span><br><span class="line">D/MainActivity7: 发送了事件67，观察者可接收事件数量 = 61</span><br><span class="line">D/MainActivity7: 发送了事件68，观察者可接收事件数量 = 60</span><br><span class="line">D/MainActivity7: 发送了事件69，观察者可接收事件数量 = 59</span><br><span class="line">D/MainActivity7: 发送了事件70，观察者可接收事件数量 = 58</span><br><span class="line">D/MainActivity7: 发送了事件71，观察者可接收事件数量 = 57</span><br><span class="line">D/MainActivity7: 发送了事件72，观察者可接收事件数量 = 56</span><br><span class="line">D/MainActivity7: 发送了事件73，观察者可接收事件数量 = 55</span><br><span class="line">D/MainActivity7: 发送了事件74，观察者可接收事件数量 = 54</span><br><span class="line">D/MainActivity7: 发送了事件75，观察者可接收事件数量 = 53</span><br><span class="line">D/MainActivity7: 发送了事件76，观察者可接收事件数量 = 52</span><br><span class="line">D/MainActivity7: 发送了事件77，观察者可接收事件数量 = 51</span><br><span class="line">D/MainActivity7: 发送了事件78，观察者可接收事件数量 = 50</span><br><span class="line">D/MainActivity7: 发送了事件79，观察者可接收事件数量 = 49</span><br><span class="line">D/MainActivity7: 发送了事件80，观察者可接收事件数量 = 48</span><br><span class="line">D/MainActivity7: 发送了事件81，观察者可接收事件数量 = 47</span><br><span class="line">D/MainActivity7: 发送了事件82，观察者可接收事件数量 = 46</span><br><span class="line">D/MainActivity7: 发送了事件83，观察者可接收事件数量 = 45</span><br><span class="line">D/MainActivity7: 发送了事件84，观察者可接收事件数量 = 44</span><br><span class="line">D/MainActivity7: 发送了事件85，观察者可接收事件数量 = 43</span><br><span class="line">D/MainActivity7: 发送了事件86，观察者可接收事件数量 = 42</span><br><span class="line">D/MainActivity7: 发送了事件87，观察者可接收事件数量 = 41</span><br><span class="line">D/MainActivity7: 发送了事件88，观察者可接收事件数量 = 40</span><br><span class="line">D/MainActivity7: 发送了事件89，观察者可接收事件数量 = 39</span><br><span class="line">D/MainActivity7: 发送了事件90，观察者可接收事件数量 = 38</span><br><span class="line">D/MainActivity7: 发送了事件91，观察者可接收事件数量 = 37</span><br><span class="line">D/MainActivity7: 发送了事件92，观察者可接收事件数量 = 36</span><br><span class="line">D/MainActivity7: 发送了事件93，观察者可接收事件数量 = 35</span><br><span class="line">D/MainActivity7: 发送了事件94，观察者可接收事件数量 = 34</span><br><span class="line">D/MainActivity7: 发送了事件95，观察者可接收事件数量 = 33</span><br><span class="line">D/MainActivity7: 发送了事件96，观察者可接收事件数量 = 32</span><br><span class="line">D/MainActivity7: 发送了事件97，观察者可接收事件数量 = 31</span><br><span class="line">D/MainActivity7: 发送了事件98，观察者可接收事件数量 = 30</span><br><span class="line">D/MainActivity7: 发送了事件99，观察者可接收事件数量 = 29</span><br><span class="line">D/MainActivity7: 发送了事件100，观察者可接收事件数量 = 28</span><br><span class="line">D/MainActivity7: 发送了事件101，观察者可接收事件数量 = 27</span><br><span class="line">D/MainActivity7: 发送了事件102，观察者可接收事件数量 = 26</span><br><span class="line">D/MainActivity7: 发送了事件103，观察者可接收事件数量 = 25</span><br><span class="line">D/MainActivity7: 发送了事件104，观察者可接收事件数量 = 24</span><br><span class="line">D/MainActivity7: 发送了事件105，观察者可接收事件数量 = 23</span><br><span class="line">D/MainActivity7: 发送了事件106，观察者可接收事件数量 = 22</span><br><span class="line">D/MainActivity7: 发送了事件107，观察者可接收事件数量 = 21</span><br><span class="line">D/MainActivity7: 发送了事件108，观察者可接收事件数量 = 20</span><br><span class="line">D/MainActivity7: 发送了事件109，观察者可接收事件数量 = 19</span><br><span class="line">D/MainActivity7: 发送了事件110，观察者可接收事件数量 = 18</span><br><span class="line">D/MainActivity7: 发送了事件111，观察者可接收事件数量 = 17</span><br><span class="line">D/MainActivity7: 发送了事件112，观察者可接收事件数量 = 16</span><br><span class="line">D/MainActivity7: 发送了事件113，观察者可接收事件数量 = 15</span><br><span class="line">D/MainActivity7: 发送了事件114，观察者可接收事件数量 = 14</span><br><span class="line">D/MainActivity7: 发送了事件115，观察者可接收事件数量 = 13</span><br><span class="line">D/MainActivity7: 发送了事件116，观察者可接收事件数量 = 12</span><br><span class="line">D/MainActivity7: 发送了事件117，观察者可接收事件数量 = 11</span><br><span class="line">D/MainActivity7: 发送了事件118，观察者可接收事件数量 = 10</span><br><span class="line">D/MainActivity7: 发送了事件119，观察者可接收事件数量 = 9</span><br><span class="line">D/MainActivity7: 发送了事件120，观察者可接收事件数量 = 8</span><br><span class="line">D/MainActivity7: 发送了事件121，观察者可接收事件数量 = 7</span><br><span class="line">D/MainActivity7: 发送了事件122，观察者可接收事件数量 = 6</span><br><span class="line">D/MainActivity7: 发送了事件123，观察者可接收事件数量 = 5</span><br><span class="line">D/MainActivity7: 发送了事件124，观察者可接收事件数量 = 4</span><br><span class="line">D/MainActivity7: 发送了事件125，观察者可接收事件数量 = 3</span><br><span class="line">D/MainActivity7: 发送了事件126，观察者可接收事件数量 = 2</span><br><span class="line">D/MainActivity7: 发送了事件127，观察者可接收事件数量 = 1</span><br><span class="line">D/MainActivity7: 不再发送</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">D/MainActivity7: 接收到了事件0</span><br><span class="line">D/MainActivity7: 接收到了事件1</span><br><span class="line">D/MainActivity7: 接收到了事件2</span><br><span class="line">D/MainActivity7: 接收到了事件3</span><br><span class="line">D/MainActivity7: 接收到了事件4</span><br><span class="line">D/MainActivity7: 接收到了事件5</span><br><span class="line">D/MainActivity7: 接收到了事件6</span><br><span class="line">D/MainActivity7: 接收到了事件7</span><br><span class="line">D/MainActivity7: 接收到了事件8</span><br><span class="line">D/MainActivity7: 接收到了事件9</span><br><span class="line">D/MainActivity7: 接收到了事件10</span><br><span class="line">D/MainActivity7: 接收到了事件11</span><br><span class="line">D/MainActivity7: 接收到了事件12</span><br><span class="line">D/MainActivity7: 接收到了事件13</span><br><span class="line">D/MainActivity7: 接收到了事件14</span><br><span class="line">D/MainActivity7: 接收到了事件15</span><br><span class="line">D/MainActivity7: 接收到了事件16</span><br><span class="line">D/MainActivity7: 接收到了事件17</span><br><span class="line">D/MainActivity7: 接收到了事件18</span><br><span class="line">D/MainActivity7: 接收到了事件19</span><br><span class="line">D/MainActivity7: 接收到了事件20</span><br><span class="line">D/MainActivity7: 接收到了事件21</span><br><span class="line">D/MainActivity7: 接收到了事件22</span><br><span class="line">D/MainActivity7: 接收到了事件23</span><br><span class="line">D/MainActivity7: 接收到了事件24</span><br><span class="line">D/MainActivity7: 接收到了事件25</span><br><span class="line">D/MainActivity7: 接收到了事件26</span><br><span class="line">D/MainActivity7: 接收到了事件27</span><br><span class="line">D/MainActivity7: 接收到了事件28</span><br><span class="line">D/MainActivity7: 接收到了事件29</span><br><span class="line">D/MainActivity7: 接收到了事件30</span><br><span class="line">D/MainActivity7: 接收到了事件31</span><br><span class="line">D/MainActivity7: 接收到了事件32</span><br><span class="line">D/MainActivity7: 接收到了事件33</span><br><span class="line">D/MainActivity7: 接收到了事件34</span><br><span class="line">D/MainActivity7: 接收到了事件35</span><br><span class="line">D/MainActivity7: 接收到了事件36</span><br><span class="line">D/MainActivity7: 接收到了事件37</span><br><span class="line">D/MainActivity7: 接收到了事件38</span><br><span class="line">D/MainActivity7: 接收到了事件39</span><br><span class="line">D/MainActivity7: 接收到了事件40</span><br><span class="line">D/MainActivity7: 接收到了事件41</span><br><span class="line">D/MainActivity7: 接收到了事件42</span><br><span class="line">D/MainActivity7: 接收到了事件43</span><br><span class="line">D/MainActivity7: 接收到了事件44</span><br><span class="line">D/MainActivity7: 接收到了事件45</span><br><span class="line">D/MainActivity7: 接收到了事件46</span><br><span class="line">D/MainActivity7: 接收到了事件47</span><br></pre></td></tr></table></figure><img src="/2019/08/20/Android-RxJava：背压策略/944365-c3c362cd8e101867.png"><h2 id="5-3-采用背压策略模式：BackpressureStrategy"><a href="#5-3-采用背压策略模式：BackpressureStrategy" class="headerlink" title="5.3 采用背压策略模式：BackpressureStrategy"></a>5.3 采用背压策略模式：BackpressureStrategy</h2><h3 id="5-3-1-背压模式介绍"><a href="#5-3-1-背压模式介绍" class="headerlink" title="5.3.1 背压模式介绍"></a>5.3.1 背压模式介绍</h3><p>在<code>Flowable</code>中要求传入背压模式参数。</p><p>面向对象：针对缓存区。<br>作用：当缓存区存满、被观察者仍然继续发送下一个事件时，如何处理的策略方式。</p><h3 id="5-3-2-背压模式类型："><a href="#5-3-2-背压模式类型：" class="headerlink" title="5.3.2 背压模式类型："></a>5.3.2 背压模式类型：</h3><ol><li>需要解决的问题：流速不匹配，发送事件速度 ＞ 接收事件速度，具体表现为当缓存区存满时，被观察者仍然继续发送下一个事件。</li><li>类型：</li></ol><ul><li><code>BackpressureStrategy.ERROR</code>：直接抛出异常<code>MissingBackpressureException</code></li><li><code>BackpressureStrategy.MISSING</code>：友好提示，缓存区满了</li><li><code>BackpressureStrategy.BUFFER</code>：将缓存区大小设置成无限大，即，被观察者可以无限发送事件到缓存区</li><li><code>BackpressureStrategy.DROP</code>：超过缓存区大小（128）的事件丢弃</li><li><code>BackpressureStrategy.LATEST</code>：只保存最新（最后）事件，超过缓存区大小（128）的事件丢弃</li></ul><h3 id="5-3-3-特别注意"><a href="#5-3-3-特别注意" class="headerlink" title="5.3.3 特别注意"></a>5.3.3 特别注意</h3><p>使用背压策略模式时，有一点要注意：</p><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p><code>Flowable</code>可以通过自己创建，或者通过其他方式自动创建，如<code>interval</code>操作符。</p><blockquote><p><code>interval</code>操作符简介</p><ol><li>作用：每间隔一段时间产生一个数字（<code>Long</code>类型），从0开始、一次递增1，直至无穷大</li><li>默认运行在一个新的线程上</li><li>与<code>timer()</code>操作符区别：<code>timer()</code>操作符可结束发送</li></ol></blockquote><h4 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h4><p>对于手动创建<code>Flowable</code>的情况，可以通过传入背压模式参数选择背压策略，但是对于自动创建<code>Flowable</code>，就无法手动传入背压模式参数，这时，出现流速不匹配的情况，该如何处理？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过interval自动创建被观察者Flowable</span></span><br><span class="line"><span class="comment">// 每隔1ms将当前数字（从0开始）加1，并发送出去</span></span><br><span class="line"><span class="comment">// interval操作符会默认开启一个新的工作线程</span></span><br><span class="line">Flowable.interval(<span class="number">1</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">        <span class="comment">// 观察者同样工作在一个新的线程</span></span><br><span class="line">        .observeOn(Schedulers.newThread())</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Subscriber&lt;Long&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription s)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"onSubscribe"</span>);</span><br><span class="line">                mSubscription = s;</span><br><span class="line">                <span class="comment">// 默认可以接收Long.MAX_VALUE个事件</span></span><br><span class="line">                s.request(Long.MAX_VALUE);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Long aLong)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"onNext: "</span> + aLong);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 每延迟一秒再接收事件</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    <span class="comment">// 因为发送事件为延时1ms，接收事件为延时1s，出现了发送速度与接收速度不匹配的问题</span></span><br><span class="line">                    <span class="comment">// 缓存区很快就存满了128个事件，从而抛出MissingBackpressureException</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"onError: "</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"onComplete"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p><code>RxJava 2.0</code>内部提供了封装背压策略模式的方法：</p><ul><li><code>onBackpressureBuffer()</code></li><li><code>onBackpressureDrop()</code></li><li><code>onBackpressureLatest()</code></li></ul><blockquote><p>默认采用了<code>BackpressureStrategy.ERROR</code>模式。</p></blockquote><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Flowable.interval(<span class="number">1</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">        <span class="comment">// 添加背压策略模式</span></span><br><span class="line">        .onBackpressureBuffer()</span><br><span class="line">        <span class="comment">// 观察者同样工作在一个新的线程</span></span><br><span class="line">        .observeOn(Schedulers.newThread())</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Subscriber&lt;Long&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription s)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"onSubscribe"</span>);</span><br><span class="line">                mSubscription = s;</span><br><span class="line">                <span class="comment">// 默认可以接收Long.MAX_VALUE个事件</span></span><br><span class="line">                s.request(Long.MAX_VALUE);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Long aLong)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"onNext: "</span> + aLong);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 每延迟一秒再接收事件</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"onError: "</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"onComplete"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>Demo地址：<a href="https://gitee.com/QingFengBaiYu/Allen_Demo_Rx" target="_blank" rel="noopener">Allen_Demo_Rx</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-引言&quot;&gt;&lt;a href=&quot;#1-引言&quot; class=&quot;headerlink&quot; title=&quot;1. 引言&quot;&gt;&lt;/a&gt;1. 引言&lt;/h1&gt;&lt;h2 id=&quot;1-1-背景&quot;&gt;&lt;a href=&quot;#1-1-背景&quot; class=&quot;headerlink&quot; title=&quot;1.1
      
    
    </summary>
    
      <category term="Android" scheme="https://tylerLiu.top/categories/Android/"/>
    
      <category term="RxJava" scheme="https://tylerLiu.top/categories/Android/RxJava/"/>
    
    
      <category term="RxJava" scheme="https://tylerLiu.top/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>Android RxJava：条件/布尔操作符</title>
    <link href="https://tylerLiu.top/2019/08/20/Android-RxJava%EF%BC%9A%E6%9D%A1%E4%BB%B6-%E5%B8%83%E5%B0%94%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    <id>https://tylerLiu.top/2019/08/20/Android-RxJava：条件-布尔操作符/</id>
    <published>2019-08-20T00:36:27.000Z</published>
    <updated>2019-08-22T03:14:24.539Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h1><p>通过设置函数，判断<code>Obsevable</code>发送的事件是否符合条件。</p><h1 id="2-类型"><a href="#2-类型" class="headerlink" title="2. 类型"></a>2. 类型</h1><img src="/2019/08/20/Android-RxJava：条件-布尔操作符/944365-f97310ceaf53f94f.png"><h1 id="3-详解"><a href="#3-详解" class="headerlink" title="3. 详解"></a>3. 详解</h1><h2 id="3-1-all"><a href="#3-1-all" class="headerlink" title="3.1 all()"></a>3.1 all()</h2><p>作用：判断发送的每项数据是否都满足设置的函数条件。若满足，返回<code>true</code>；否则，返回<code>false</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">        .all(<span class="keyword">new</span> Predicate&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="comment">// 判断发送的所有数据是否都≤10</span></span><br><span class="line">                <span class="keyword">return</span> integer &lt;= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(<span class="keyword">new</span> Consumer&lt;Boolean&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Boolean aBoolean)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"result is "</span> + aBoolean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D/MainActivity5: result is true</span><br></pre></td></tr></table></figure><h2 id="3-2-takeWhile"><a href="#3-2-takeWhile" class="headerlink" title="3.2 takeWhile()"></a>3.2 takeWhile()</h2><p>作用：判断发送的每项数据是否满足设置函数的条件。若发送的数据满足条件，则发送该项数据，否则不发送。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Observable.interval(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">        .takeWhile(<span class="keyword">new</span> Predicate&lt;Long&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Long aLong)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> aLong &lt;= <span class="number">5</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(<span class="keyword">new</span> Consumer&lt;Long&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Long aLong)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"发送了事件 "</span> + aLong);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">D/MainActivity5: 发送了事件 0</span><br><span class="line">D/MainActivity5: 发送了事件 1</span><br><span class="line">D/MainActivity5: 发送了事件 2</span><br><span class="line">D/MainActivity5: 发送了事件 3</span><br><span class="line">D/MainActivity5: 发送了事件 4</span><br><span class="line">D/MainActivity5: 发送了事件 5</span><br></pre></td></tr></table></figure><h2 id="3-3-skipWhile"><a href="#3-3-skipWhile" class="headerlink" title="3.3 skipWhile()"></a>3.3 skipWhile()</h2><p>作用：判断发送的每项数据是否满足设置的函数条件。直到该判断条件为<code>false</code>时，才开始发送<code>Observable</code>的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Observable.interval(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">        .skipWhile(<span class="keyword">new</span> Predicate&lt;Long&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Long aLong)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="comment">// 直到发射的数据≥5时，才开始发送</span></span><br><span class="line">                <span class="keyword">return</span> aLong &lt; <span class="number">5</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(<span class="keyword">new</span> Consumer&lt;Long&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Long aLong)</span> <span class="keyword">throws</span> Excaeption </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"发送了事件 "</span> + aLong);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">D/MainActivity5: 发送了事件 5</span><br><span class="line">D/MainActivity5: 发送了事件 6</span><br><span class="line">D/MainActivity5: 发送了事件 7</span><br><span class="line">D/MainActivity5: 发送了事件 8</span><br><span class="line">D/MainActivity5: 发送了事件 9</span><br><span class="line">D/MainActivity5: 发送了事件 10</span><br><span class="line">D/MainActivity5: 发送了事件 11</span><br></pre></td></tr></table></figure><h2 id="3-4-takeUtil"><a href="#3-4-takeUtil" class="headerlink" title="3.4 takeUtil()"></a>3.4 takeUtil()</h2><p>作用：执行到某个条件时，停止发送事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Observable.interval(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">        .takeUntil(<span class="keyword">new</span> Predicate&lt;Long&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Long aLong)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="comment">// 直到发射的数据＞3时，停止发送事件</span></span><br><span class="line">                <span class="keyword">return</span> aLong &gt; <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(<span class="keyword">new</span> Consumer&lt;Long&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Long aLong)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"发送了事件 "</span> + aLong);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">D/MainActivity5: 发送了事件 0</span><br><span class="line">D/MainActivity5: 发送了事件 1</span><br><span class="line">D/MainActivity5: 发送了事件 2</span><br><span class="line">D/MainActivity5: 发送了事件 3</span><br><span class="line">D/MainActivity5: 发送了事件 4</span><br></pre></td></tr></table></figure><p>该判断条件也可以是<code>Observable</code>，<strong>即等到<code>takeUtil()</code>传入的<code>Observable</code>开始发送函数，（原始）第一个<code>Observable</code>的数据停止发送数据。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始第一个Observable，每个1s发送一个数据</span></span><br><span class="line">Observable.interval(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">        <span class="comment">// 第二个Observable，延迟5s后开始发送第一个数据</span></span><br><span class="line">        .takeUntil(Observable.timer(<span class="number">5</span>, TimeUnit.SECONDS))</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Observer&lt;Long&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"开始采用subscribe连接"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Long aLong)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"接收到了事件"</span> + aLong);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"对Error事件作出响应"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"对Complete事件作出响应"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>当第5s时，第二个<code>Observable</code>开始发送数据，于是（原始）第一个<code>Observable</code>停止发送数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">D/MainActivity5: 开始采用subscribe连接</span><br><span class="line">D/MainActivity5: 接收到了事件0</span><br><span class="line">D/MainActivity5: 接收到了事件1</span><br><span class="line">D/MainActivity5: 接收到了事件2</span><br><span class="line">D/MainActivity5: 接收到了事件3</span><br><span class="line">D/MainActivity5: 对Complete事件作出响应</span><br></pre></td></tr></table></figure><h2 id="3-5-skipUtil"><a href="#3-5-skipUtil" class="headerlink" title="3.5 skipUtil()"></a>3.5 skipUtil()</h2><p>作用：等到<code>skipUtil()</code>传入的<code>Observable</code>开始发送数据，（原始）第一个<code>Observable</code>才开始发送数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （原始）第1个Observable</span></span><br><span class="line">Observable.interval(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">        <span class="comment">// 第2个Observable，延迟5s后开始发送型数据</span></span><br><span class="line">        .skipUntil(Observable.timer(<span class="number">5</span>, TimeUnit.SECONDS))</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Consumer&lt;Long&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Long aLong)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"接收到了事件"</span> + aLong);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">D/MainActivity5: 接收到了事件4</span><br><span class="line">D/MainActivity5: 接收到了事件5</span><br><span class="line">D/MainActivity5: 接收到了事件6</span><br><span class="line">D/MainActivity5: 接收到了事件7</span><br><span class="line">D/MainActivity5: 接收到了事件8</span><br><span class="line">D/MainActivity5: 接收到了事件9</span><br><span class="line">D/MainActivity5: 接收到了事件10</span><br></pre></td></tr></table></figure><h2 id="3-6-sequenceEqual"><a href="#3-6-sequenceEqual" class="headerlink" title="3.6 sequenceEqual()"></a>3.6 sequenceEqual()</h2><p>作用：判断两个<code>Observable</code>需要发送的数据是否相同。若相同，返回<code>true</code>，反之，返回<code>false</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Observable.sequenceEqual(</span><br><span class="line">        Observable.just(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>),</span><br><span class="line">        Observable.just(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">).subscribe(<span class="keyword">new</span> Consumer&lt;Boolean&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Boolean aBoolean)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"2个Observable是否相同："</span> + aBoolean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D/MainActivity5: 2个Observable是否相同：true</span><br></pre></td></tr></table></figure><h2 id="3-7-contains"><a href="#3-7-contains" class="headerlink" title="3.7 contains()"></a>3.7 contains()</h2><p>作用：判断发送的数据中是否包含指定数据。若包含，返回<code>true</code>，反之，返回<code>false</code>。在其内部实现了<code>exists()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .contains(<span class="number">3</span>)</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Consumer&lt;Boolean&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Boolean aBoolean)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"result is "</span> + aBoolean);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D/MainActivity5: result is true</span><br></pre></td></tr></table></figure><h2 id="3-8-isEmpty"><a href="#3-8-isEmpty" class="headerlink" title="3.8 isEmpty()"></a>3.8 isEmpty()</h2><p>作用：判断发送的数据是否为空。若为空，返回<code>true</code>，反之，返回<code>false</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .isEmpty()</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Consumer&lt;Boolean&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Boolean aBoolean)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"result is "</span> + aBoolean);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D/MainActivity5: result is false</span><br></pre></td></tr></table></figure><h2 id="3-9-amb"><a href="#3-9-amb" class="headerlink" title="3.9 amb()"></a>3.9 amb()</h2><p>作用：当需要发送多个<code>Observable</code>时，只发送<strong>先发送数据的<code>Observable</code>的数据</strong>，而其余<code>Observable</code>则被丢弃。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置两个需要发送的Observable，并放到集合中</span></span><br><span class="line">List&lt;ObservableSource&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// 第一个Observable，延迟一秒发送数据</span></span><br><span class="line">list.add(Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).delay(<span class="number">1</span>, TimeUnit.SECONDS));</span><br><span class="line"><span class="comment">// 第二个Observable，正常发送数据</span></span><br><span class="line">list.add(Observable.just(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用amba()，这样仅发送先发送数据的Observable，即第二个Observable，第一个因为延迟，被丢弃</span></span><br><span class="line">Observable.amb(list)</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"接收到了事件 "</span> + integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D/MainActivity5: 接收到了事件 4</span><br><span class="line">D/MainActivity5: 接收到了事件 5</span><br><span class="line">D/MainActivity5: 接收到了事件 6</span><br></pre></td></tr></table></figure><h2 id="3-10-defaultEmpty"><a href="#3-10-defaultEmpty" class="headerlink" title="3.10 defaultEmpty()"></a>3.10 defaultEmpty()</h2><p>作用：在不发送任何有效事件（<code>Next</code>事件）、仅发送<code>Complete</code>事件的前提下，发送一个默认值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 不发送任何事件，仅发送Complete事件</span></span><br><span class="line">        emitter.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">        <span class="comment">// 仅发送Complete事件时，默认发送10</span></span><br><span class="line">        .defaultIfEmpty(<span class="number">10</span>)</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"接收到了事件"</span> + integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D/MainActivity5: 接收到了事件10</span><br></pre></td></tr></table></figure><p>Demo地址：<a href="https://gitee.com/QingFengBaiYu/Allen_Demo_Rx" target="_blank" rel="noopener">Allen_Demo_Rx</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-作用&quot;&gt;&lt;a href=&quot;#1-作用&quot; class=&quot;headerlink&quot; title=&quot;1. 作用&quot;&gt;&lt;/a&gt;1. 作用&lt;/h1&gt;&lt;p&gt;通过设置函数，判断&lt;code&gt;Obsevable&lt;/code&gt;发送的事件是否符合条件。&lt;/p&gt;
&lt;h1 id=&quot;2-类型
      
    
    </summary>
    
      <category term="Android" scheme="https://tylerLiu.top/categories/Android/"/>
    
      <category term="RxJava" scheme="https://tylerLiu.top/categories/Android/RxJava/"/>
    
    
      <category term="RxJava" scheme="https://tylerLiu.top/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>Android RxJava：过滤操作符</title>
    <link href="https://tylerLiu.top/2019/08/19/Android-RxJava%EF%BC%9A%E8%BF%87%E6%BB%A4%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    <id>https://tylerLiu.top/2019/08/19/Android-RxJava：过滤操作符/</id>
    <published>2019-08-19T03:27:09.000Z</published>
    <updated>2019-08-22T03:14:18.537Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h1><p>过滤/筛选<code>Observable</code>发送的事件和<code>Observer</code>接收的事件。</p><h1 id="2-类型"><a href="#2-类型" class="headerlink" title="2. 类型"></a>2. 类型</h1><p><code>RxJava</code>中，过滤操作符的类型包括：</p><ol><li>根据指定条件过滤事件：<code>Filter()</code>、<code>ofType()</code>、<code>skip()</code>、<code>skipLast()</code>、<code>distinct()</code>、<code>distinctUntilChanged()</code></li><li>根据指定事件数量过滤事件：<code>take()</code>、<code>takeLast()</code></li><li>根据指定事件过滤：<code>throttleFirst()</code>、<code>throttleLast()</code>、<code>sample()</code>、<code>throttleWithTimeout()</code>、<code>debounce()</code></li><li>根据指定事件位置过滤事件：<code>firstElement()</code>、<code>lastElement()</code>、<code>elementAt()</code>、<code>emelentAtOrErorr()</code></li></ol><h1 id="3-讲解"><a href="#3-讲解" class="headerlink" title="3. 讲解"></a>3. 讲解</h1><h2 id="3-1-根据指定条件过滤"><a href="#3-1-根据指定条件过滤" class="headerlink" title="3.1 根据指定条件过滤"></a>3.1 根据指定条件过滤</h2><p>作用：通过设置指定的过滤条件，当且仅当该事件满足条件时，就将该事件过滤（即不发送）。</p><p><strong>操作符：<code>Filter()</code></strong><br>作用：过滤特定条件的事件。</p><p>原理：</p><img src="/2019/08/19/Android-RxJava：过滤操作符/944365-cbec5a5b97682ed6.png"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 发送5个事件</span></span><br><span class="line">        emitter.onNext(<span class="number">1</span>);</span><br><span class="line">        emitter.onNext(<span class="number">2</span>);</span><br><span class="line">        emitter.onNext(<span class="number">3</span>);</span><br><span class="line">        emitter.onNext(<span class="number">4</span>);</span><br><span class="line">        emitter.onNext(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">        <span class="comment">// 采用filter()变换操作符</span></span><br><span class="line">        .filter(<span class="keyword">new</span> Predicate&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="comment">// 根据test()的返回值，对被观察者发送的事件进行过滤并筛选</span></span><br><span class="line">            <span class="comment">// a. 返回true，则继续发送</span></span><br><span class="line">            <span class="comment">// b. 返回false，则不发送（过滤）</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="comment">// 过滤≤3的事件</span></span><br><span class="line">                <span class="keyword">return</span> integer &gt; <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(<span class="keyword">new</span> Observer&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"开始采用subscribe连接"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"过滤后得到的事件是："</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"对Error事件作出响应"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"对Complete事件作出响应"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D/MainActivity4: 开始采用subscribe连接</span><br><span class="line">D/MainActivity4: 过滤后得到的事件是：4</span><br><span class="line">D/MainActivity4: 过滤后得到的事件是：5</span><br></pre></td></tr></table></figure><p><strong>操作符：<code>ofType()</code></strong><br>作用：过滤特定数据类型的事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>, <span class="string">"Allen"</span>, <span class="number">3</span>, <span class="string">"liu"</span>, <span class="number">5</span>)</span><br><span class="line">        <span class="comment">// 筛选出整型</span></span><br><span class="line">        .ofType(Integer.class)</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"获取到的整型事件元素是： "</span> + integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D/MainActivity4: 获取到的整型事件元素是： 1</span><br><span class="line">D/MainActivity4: 获取到的整型事件元素是： 3</span><br><span class="line">D/MainActivity4: 获取到的整型事件元素是： 5</span><br></pre></td></tr></table></figure><p><strong>操作符：<code>skip()</code>和<code>skipLast()</code></strong><br>作用：跳过某个事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用1：根据顺序跳过数据项</span></span><br><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        <span class="comment">// 跳过正序的前一项</span></span><br><span class="line">        .skip(<span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 跳过正序的后两项</span></span><br><span class="line">        .skipLast(<span class="number">2</span>)</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"获取到的整型事件元素是： "</span> + integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用2：根据时间跳过数据项</span></span><br><span class="line"><span class="comment">// 发送数据0-5，每间隔1s发送一次，每次递增1，第一次发送延迟0s</span></span><br><span class="line">Observable.intervalRange(<span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">        <span class="comment">// 跳过第1s发送的数据</span></span><br><span class="line">        .skip(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">        <span class="comment">// 跳过最后1s发送的数据</span></span><br><span class="line">        .skipLast(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Consumer&lt;Long&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Long aLong)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"获取到的整型事件元素是： "</span> + aLong);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">D/MainActivity4: 获取到的整型事件元素是： 2</span><br><span class="line">D/MainActivity4: 获取到的整型事件元素是： 3</span><br><span class="line">D/MainActivity4: 获取到的整型事件元素是： 1</span><br><span class="line">D/MainActivity4: 获取到的整型事件元素是： 2</span><br><span class="line">D/MainActivity4: 获取到的整型事件元素是： 3</span><br></pre></td></tr></table></figure><p><strong>操作符：<code>distinct()</code>和<code>distinctUntilChanged()</code></strong><br>作用：过滤事件序列中重复的事件/连续重复的事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用1：过滤事件序列中重复的事件</span></span><br><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">        .distinct()</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"不重复的整型事件元素是： "</span> + integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用2：过滤事件序列中 连续重复的事件</span></span><br><span class="line"><span class="comment">// 下面序列中，连续重复的事件 = 3、4</span></span><br><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line">        .distinctUntilChanged()</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"不连续重复的整型事件元素是： "</span> + integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">D/MainActivity4: 不重复的整型事件元素是： 1</span><br><span class="line">D/MainActivity4: 不重复的整型事件元素是： 2</span><br><span class="line">D/MainActivity4: 不重复的整型事件元素是： 3</span><br><span class="line">D/MainActivity4: 不连续重复的整型事件元素是： 1</span><br><span class="line">D/MainActivity4: 不连续重复的整型事件元素是： 2</span><br><span class="line">D/MainActivity4: 不连续重复的整型事件元素是： 3</span><br><span class="line">D/MainActivity4: 不连续重复的整型事件元素是： 1</span><br><span class="line">D/MainActivity4: 不连续重复的整型事件元素是： 2</span><br><span class="line">D/MainActivity4: 不连续重复的整型事件元素是： 3</span><br><span class="line">D/MainActivity4: 不连续重复的整型事件元素是： 4</span><br></pre></td></tr></table></figure><h2 id="3-2-根据指定事件数量过滤事件"><a href="#3-2-根据指定事件数量过滤事件" class="headerlink" title="3.2 根据指定事件数量过滤事件"></a>3.2 根据指定事件数量过滤事件</h2><p>作用：通过设置指定的事件数量，仅发送特定数量的事件。</p><p><strong>操作符：<code>take()</code></strong><br>作用：指定观察者最多能接收到的事件数量<br>原理：</p><img src="/2019/08/19/Android-RxJava：过滤操作符/944365-0ce65f078ec3d259.png"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 发送5个事件</span></span><br><span class="line">        emitter.onNext(<span class="number">1</span>);</span><br><span class="line">        emitter.onNext(<span class="number">2</span>);</span><br><span class="line">        emitter.onNext(<span class="number">3</span>);</span><br><span class="line">        emitter.onNext(<span class="number">4</span>);</span><br><span class="line">        emitter.onNext(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">        <span class="comment">// 采用take()操作符，指定观察者只能接收2个事件</span></span><br><span class="line">        .take(<span class="number">2</span>).subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"过滤后得到的事件是："</span> + integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>实际上，被观察者还是发送了5个事件，只是因为操作符的存在，拦截了3个事件，最终， 观察者只接收到了2个事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D/MainActivity4: 过滤后得到的事件是：1</span><br><span class="line">D/MainActivity4: 过滤后得到的事件是：2</span><br></pre></td></tr></table></figure><p><strong>操作符：<code>takeLast()</code></strong><br>作用：指定观察者只能接收到被观察者发送的最后几个事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        <span class="comment">//指定观察者只能接受被观察者发送的3个事件</span></span><br><span class="line">        .takeLast(<span class="number">3</span>)</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"过滤后得到的事件是："</span> + integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D/MainActivity4: 过滤后得到的事件是：3</span><br><span class="line">D/MainActivity4: 过滤后得到的事件是：4</span><br><span class="line">D/MainActivity4: 过滤后得到的事件是：5</span><br></pre></td></tr></table></figure><h2 id="3-3-根据指定事件过滤事件"><a href="#3-3-根据指定事件过滤事件" class="headerlink" title="3.3 根据指定事件过滤事件"></a>3.3 根据指定事件过滤事件</h2><p>作用：通过设置指定的时间，仅发送在该时间内的事件。</p><p><strong>操作符：<code>throttleFirst()</code>和<code>throttlelast()</code></strong><br>作用：在某段时间内，只发送该段时间内第一次事件/最后一次事件。如，一段时间内连续点击按钮，但只执行第一次的点击事件。<br>原理：</p><img src="/2019/08/19/Android-RxJava：过滤操作符/944365-1f42132c7350bd79.png"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在某段时间内，只发送该段时间内第1次事件</span></span><br><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 隔段事件发送时间</span></span><br><span class="line">        e.onNext(<span class="number">1</span>);</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">        e.onNext(<span class="number">2</span>);</span><br><span class="line">        Thread.sleep(<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">        e.onNext(<span class="number">3</span>);</span><br><span class="line">        Thread.sleep(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">        e.onNext(<span class="number">4</span>);</span><br><span class="line">        Thread.sleep(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">        e.onNext(<span class="number">5</span>);</span><br><span class="line">        Thread.sleep(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">        e.onNext(<span class="number">6</span>);</span><br><span class="line">        Thread.sleep(<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">        e.onNext(<span class="number">7</span>);</span><br><span class="line">        Thread.sleep(<span class="number">300</span>);</span><br><span class="line">        e.onNext(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">300</span>);</span><br><span class="line">        e.onNext(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">300</span>);</span><br><span class="line">        e.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">        <span class="comment">//每1秒中采用数据</span></span><br><span class="line">        .throttleFirst(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"接收到了事件"</span> + integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在某段时间内，只发送该段时间内最后1次事件</span></span><br><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 隔段事件发送时间</span></span><br><span class="line">        e.onNext(<span class="number">1</span>);</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">        e.onNext(<span class="number">2</span>);</span><br><span class="line">        Thread.sleep(<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">        e.onNext(<span class="number">3</span>);</span><br><span class="line">        Thread.sleep(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">        e.onNext(<span class="number">4</span>);</span><br><span class="line">        Thread.sleep(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">        e.onNext(<span class="number">5</span>);</span><br><span class="line">        Thread.sleep(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">        e.onNext(<span class="number">6</span>);</span><br><span class="line">        Thread.sleep(<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">        e.onNext(<span class="number">7</span>);</span><br><span class="line">        Thread.sleep(<span class="number">300</span>);</span><br><span class="line">        e.onNext(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">300</span>);</span><br><span class="line">        e.onNext(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">300</span>);</span><br><span class="line">        e.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">        <span class="comment">// 每1秒中采用数据</span></span><br><span class="line">        .throttleLast(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"接收到了事件"</span> + integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">D/MainActivity4: 接收到了事件throttleFirst = 1</span><br><span class="line">D/MainActivity4: 接收到了事件throttleFirst = 4</span><br><span class="line">D/MainActivity4: 接收到了事件throttleFirst = 7</span><br><span class="line">D/MainActivity4: 接收到了事件throttleLast = 3</span><br><span class="line">D/MainActivity4: 接收到了事件throttleLast = 6</span><br><span class="line">D/MainActivity4: 接收到了事件throttleLast = 9</span><br></pre></td></tr></table></figure><p><strong>操作符：<code>sample()</code></strong><br>作用：在某段时间内，只发送该段时间内最新一次事件，与<code>throttleLast()</code>操作符类似。<br>使用方法就是把上文的<code>throttleLast()</code>改成<code>sample()</code>操作符即可。</p><p><strong>操作符：<code>throttleWithTimeOut()</code>/<code>debounce()</code></strong><br>作用：发送数据事件时，若2次发送事件的间隔 &lt; 指定时间，就会丢弃前一次的数据，直到指定时间内都没有新数据发射时才会发送后一次的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 隔段事件发送时间</span></span><br><span class="line">        emitter.onNext(<span class="number">1</span>);</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="comment">// 1和2之间的间隔小于指定时间1s，所以前1次数据（1）会被抛弃，2会被保留</span></span><br><span class="line">        emitter.onNext(<span class="number">2</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">        <span class="comment">// 因为2和3之间的间隔大于指定时间1s，所以之前被保留的2事件将发出</span></span><br><span class="line">        emitter.onNext(<span class="number">3</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">        <span class="comment">// 因为3和4之间的间隔大于指定时间1s，所以3事件将发出</span></span><br><span class="line">        emitter.onNext(<span class="number">4</span>);</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="comment">// 因为4和5之间的间隔小于指定时间1s，所以前1次数据（4）会被抛弃，5会被保留</span></span><br><span class="line">        emitter.onNext(<span class="number">5</span>);</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="comment">// 因为5和6之间的间隔小于指定时间1s，所以前1次数据（5）会被抛弃，6会被保留</span></span><br><span class="line">        emitter.onNext(<span class="number">6</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">        <span class="comment">// 因为6和Complete实践之间的间隔大于指定时间1s，所以之前被保留的6事件将发出</span></span><br><span class="line"></span><br><span class="line">        emitter.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">        <span class="comment">// 每1秒采用数据</span></span><br><span class="line">        .throttleWithTimeout(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"接收到了事件"</span> + integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D/MainActivity4: 接收到了事件2</span><br><span class="line">D/MainActivity4: 接收到了事件3</span><br><span class="line">D/MainActivity4: 接收到了事件6</span><br></pre></td></tr></table></figure><h2 id="3-4-根据指定事件位置过滤事件"><a href="#3-4-根据指定事件位置过滤事件" class="headerlink" title="3.4 根据指定事件位置过滤事件"></a>3.4 根据指定事件位置过滤事件</h2><p>作用：通过设置指定的位置，过滤在该位置的事件。</p><p><strong>操作符：<code>firstElement()</code>/<code>lastElement()</code></strong><br>作用：仅选取第一个元素/最后一个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取第1个元素</span></span><br><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .firstElement()</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"获取到的第一个事件是： "</span> + integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取最后1个元素</span></span><br><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .lastElement()</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"获取到的最后1个事件是： "</span> + integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D/MainActivity4: 获取到的第一个事件： 1</span><br><span class="line">D/MainActivity4: 获取到的最后一个事件： 5</span><br></pre></td></tr></table></figure><p><strong>操作符：<code>elementAt()</code></strong><br>作用：指定接收某个元素（通过索引值确定）。</p><blockquote><p>允许越界，即获取的位置索引 &gt; 发送事件序列长度</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用1：获取位置索引为2的元素</span></span><br><span class="line"><span class="comment">// 位置索引从0开始</span></span><br><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .elementAt(<span class="number">2</span>)</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"使用1获取到的事件元素是： "</span> + integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用2：获取的位置索引 ＞ 发送事件序列长度时，设置默认参数</span></span><br><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .elementAt(<span class="number">6</span>, <span class="number">10</span>)</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"使用2获取到的事件元素是： "</span> + integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D/MainActivity4: 使用1获取到的事件元素是： 3</span><br><span class="line">D/MainActivity4: 使用2获取到的事件元素是： 10</span><br></pre></td></tr></table></figure><p><strong>操作符：<code>elementAtOrError()</code></strong><br>作用：在<code>elementAt()</code>的基础上，当出现越界情况（即获取的位置索引 &gt; 发送事件序列长度）时，抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .elementAtOrError(<span class="number">6</span>)</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">( Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(TAG,<span class="string">"获取到的事件元素是： "</span>+ integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><h1 id="4-实际开发需求"><a href="#4-实际开发需求" class="headerlink" title="4. 实际开发需求"></a>4. 实际开发需求</h1><p>在实际开发中，常见的过滤操作符实际需求场景有：功能防抖和联想搜索请求优化</p><h2 id="4-1-功能防抖"><a href="#4-1-功能防抖" class="headerlink" title="4.1 功能防抖"></a>4.1 功能防抖</h2><ol><li>背景：用户只需要使用功能1次</li><li>冲突：由于外部原因，多次触发了功能，导致出现冗余功能操作。</li></ol><ul><li>用户只需要使用网络请求功能一次（点击按钮），</li><li>但由于外部网络不好，点击一次后用户发现无响应，</li><li>于是多次点击按钮，最终导致发出了多个网络请求。</li></ul><ol start="3"><li>解决方案：功能防抖，通过根据指定时间过滤事件的过滤操作符实现，防止功能的抖动。</li></ol><p>具体使用可以看看后面的实例详解。</p><h2 id="4-2-联想搜索优化"><a href="#4-2-联想搜索优化" class="headerlink" title="4.2 联想搜索优化"></a>4.2 联想搜索优化</h2><ol><li>背景：实现联想搜索功能，即每当用户输入一个字符，即显示与当前输入框内字符相关的搜索结果。最基本的实现流程：</li></ol><ul><li>通过<code>EditText.addTextChangedListener()</code>监听输入框变化</li><li>当输入框发生变化后，回调<code>afterTextChanged()</code>将当前输入框的文字像服务器发起请求</li><li>服务器返回与该搜索文字关联的结果</li></ul><ol start="2"><li>冲突：在用户搜索需求明确的情况下（体现为连续输入），可能会发起一些不必要的网络请求。例子：</li></ol><ul><li>用户搜索需求明确 = abc，即连续输入了abc</li><li>按上面的实现，客户端会向服务器发起a、ab、abc三个网络请求</li><li>即，多发起了a、ab两个不必要的网络请求</li></ul><ol start="3"><li>解决方案：通过根据指定时间过滤事件的过滤操作符（<code>debounce</code>）实现，防止不必要的网络请求。原理：</li></ol><ul><li>当输入框发生变化时，不会立刻将当前输入框内的文字发送给服务器，而是等待一段时间；</li><li>若在这段时间内，输入框不再有文字输入（无发生变化），那么才发送输入框内的文字给服务器；</li><li>若在这段时间内，输入框有文字输入（有变化），则继续等待该段时间，循环上述过程。</li></ul><p>具体使用可以看看后面的实例详解。</p><p>Demo地址：<a href="https://gitee.com/QingFengBaiYu/Allen_Demo_Rx" target="_blank" rel="noopener">Allen_Demo_Rx</a></p><img src="/2019/08/19/Android-RxJava：过滤操作符/944365-19889e9538498010.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-作用&quot;&gt;&lt;a href=&quot;#1-作用&quot; class=&quot;headerlink&quot; title=&quot;1. 作用&quot;&gt;&lt;/a&gt;1. 作用&lt;/h1&gt;&lt;p&gt;过滤/筛选&lt;code&gt;Observable&lt;/code&gt;发送的事件和&lt;code&gt;Observer&lt;/code&gt;接收的事件
      
    
    </summary>
    
      <category term="Android" scheme="https://tylerLiu.top/categories/Android/"/>
    
      <category term="RxJava" scheme="https://tylerLiu.top/categories/Android/RxJava/"/>
    
    
      <category term="RxJava" scheme="https://tylerLiu.top/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>Android RxJava：线程控制</title>
    <link href="https://tylerLiu.top/2019/08/17/Android-RxJava%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <id>https://tylerLiu.top/2019/08/17/Android-RxJava：线程控制/</id>
    <published>2019-08-17T09:23:39.000Z</published>
    <updated>2019-08-22T03:14:28.843Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h1><p>指定<code>Observable</code>/<code>Observer</code>的工作线程类型。</p><h1 id="2-原因"><a href="#2-原因" class="headerlink" title="2. 原因"></a>2. 原因</h1><h2 id="2-1-背景"><a href="#2-1-背景" class="headerlink" title="2.1 背景"></a>2.1 背景</h2><p>在<code>RxJava</code>模型中，<strong><code>Observable</code>/<code>Observer</code>的工作线程就是创建时所在的线程</strong>。<br>如果创建<code>Observable</code>/<code>Observer</code>在主线程，则生产事件/接收和响应事件都发生在主线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"Rxjava"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="comment">// 步骤1：创建被观察者 Observable &amp; 发送事件</span></span><br><span class="line">        <span class="comment">// 在主线程创建被观察者 Observable 对象</span></span><br><span class="line">        <span class="comment">// 所以生产事件的线程是：主线程</span></span><br><span class="line"></span><br><span class="line">        Observable&lt;Integer&gt; observable = Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">" 被观察者 Observable的工作线程是: "</span> + Thread.currentThread().getName());</span><br><span class="line">                <span class="comment">// 打印验证</span></span><br><span class="line">                emitter.onNext(<span class="number">1</span>);</span><br><span class="line">                emitter.onComplete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤2：创建观察者 Observer 并 定义响应事件行为</span></span><br><span class="line">        <span class="comment">// 在主线程创建观察者 Observer 对象</span></span><br><span class="line">        <span class="comment">// 所以接收 &amp; 响应事件的线程是：主线程</span></span><br><span class="line">        Observer&lt;Integer&gt; observer = <span class="keyword">new</span> Observer&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"开始采用subscribe连接"</span>);</span><br><span class="line">                Log.d(TAG, <span class="string">" 观察者 Observer的工作线程是: "</span> + Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"对Next事件"</span>+ value +<span class="string">"作出响应"</span>  );</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"对Error事件作出响应"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"对Complete事件作出响应"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤3：通过订阅（subscribe）连接观察者和被观察者</span></span><br><span class="line">        observable.subscribe(observer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2019/08/17/Android-RxJava：线程控制/944365-a9feda6734592987.png"><h2 id="2-2-冲突"><a href="#2-2-冲突" class="headerlink" title="2.2 冲突"></a>2.2 冲突</h2><p>一般情况下，需要在子线程中去实现耗时操作，然后回到主线程实现UI操作。<br>对应<code>RxJava</code>，可以理解为：</p><ul><li><code>Observable</code>要在子线程中生产事件（如实现耗时操作等）</li><li><code>Observer</code>在主线程接收和响应事件（如实现UI操作）</li></ul><h2 id="2-3-解决方法"><a href="#2-3-解决方法" class="headerlink" title="2.3 解决方法"></a>2.3 解决方法</h2><p>为了解决上面的冲突，实现异步操作，就需要对<code>RxJava</code>进行线程控制（切换/调度）</p><h1 id="3-实现方式"><a href="#3-实现方式" class="headerlink" title="3. 实现方式"></a>3. 实现方式</h1><p>采用<code>RxJava</code>内置的线程调度器<code>Scheduler</code>，即通过功能型操作符<code>subscribeOn()</code>和<code>observeOn()</code>来实现。</p><h2 id="3-1-subscribeOn和observeOn简介"><a href="#3-1-subscribeOn和observeOn简介" class="headerlink" title="3.1 subscribeOn和observeOn简介"></a>3.1 subscribeOn和observeOn简介</h2><p>作用：线程控制，即指定被观察者<code>Obserable</code>和观察者<code>Observer</code>的工作线程类型</p><p>线程类型：</p><table><thead><tr><th align="left">类型</th><th align="left">含义</th><th align="left">应用场景</th></tr></thead><tbody><tr><td align="left">Schedulers.immediate()</td><td align="left">当前线程，不指定线程</td><td align="left">默认</td></tr><tr><td align="left">AndroidSchedulers.mainThread()</td><td align="left">Android主线程</td><td align="left">操作UI</td></tr><tr><td align="left">Schedulers.newThread()</td><td align="left">常规新线程</td><td align="left">耗时等操作</td></tr><tr><td align="left">Schedulers.io()</td><td align="left">IO操作线程</td><td align="left">网络请求、读写文件等UI密集型操作</td></tr><tr><td align="left">Schedulers.computation()</td><td align="left">CPU计算操作线程</td><td align="left">大量计算操作</td></tr></tbody></table><p>注：<code>RxJava</code>内部使用<strong>线程池</strong>来维护这些线程，所以线程的调度效率非常高。</p><h2 id="3-2-具体使用"><a href="#3-2-具体使用" class="headerlink" title="3.2 具体使用"></a>3.2 具体使用</h2><p>具体是在（上面步骤3）<strong>通过订阅<code>subscribe</code>连接观察者和被观察者</strong>中实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用说明</span></span><br><span class="line"><span class="comment">// Observable.subscribeOn（Schedulers.Thread）：指定被观察者 发送事件的线程（传入RxJava内置的线程类型）</span></span><br><span class="line"><span class="comment">// Observable.observeOn（Schedulers.Thread）：指定观察者 接收 &amp; 响应事件的线程（传入RxJava内置的线程类型）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例使用</span></span><br><span class="line"><span class="comment">// 步骤3：通过订阅（subscribe）连接观察者和被观察者</span></span><br><span class="line"><span class="comment">// 1. 指定被观察者 生产事件的线程</span></span><br><span class="line">observable.subscribeOn(Schedulers.newThread())</span><br><span class="line">    <span class="comment">// 2. 指定观察者接收和响应事件的线程</span></span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())  </span><br><span class="line">    <span class="comment">// 3. 最后再通过订阅（subscribe）连接观察者和被观察者</span></span><br><span class="line">    .subscribe(observer);</span><br></pre></td></tr></table></figure><p>特别注意：</p><ol><li><p>若<code>Observable.subscribeOn()</code>多次指定被观察者生产事件的线程，则只有第一次指定有效，其余的指定线程无效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">observable</span><br><span class="line">    <span class="comment">// 第一次指定被观察者线程为新线程，有效</span></span><br><span class="line">    .subscribeOn(Schedulers.newThread()) </span><br><span class="line">    <span class="comment">// 第二次指定被观察者线程为主线程，无效</span></span><br><span class="line">    .subscribeOn(AndroidSchedulers.mainThread()) </span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe(observer);</span><br></pre></td></tr></table></figure></li><li><p>若<code>Observable.observeOn()</code>多次指定<code>Observer</code>接收和响应事件的线程，则每次指定均有效，即没指定一次，就进行一次线程切换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">observable.subscribeOn(Schedulers.newThread())</span><br><span class="line">    <span class="comment">// 第一次指定观察者线程为主线程</span></span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    <span class="comment">// 生产事件</span></span><br><span class="line">    .doOnNext(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123; </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"第一次观察者Observer的工作线程是： "</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;)</span><br><span class="line">    <span class="comment">// 第二次指定观察者线程为新的工作线程</span></span><br><span class="line">    .observeOn(Schedulers.newThread()) </span><br><span class="line">    <span class="comment">// 生产事件</span></span><br><span class="line">    .subscribe(observer);</span><br></pre></td></tr></table></figure></li></ol><p>注：</p><ul><li>整体方法调用顺序：<code>观察者.onSubscribe()</code> &gt; <code>被观察者.subscribe()</code> &gt; <code>观察者.doOnNext()</code></li><li><code>观察者.onSubscribe()</code>固定在主线程进行</li></ul><img src="/2019/08/17/Android-RxJava：线程控制/944365-61c84ec87fc621e4.png"><h1 id="4-Demo"><a href="#4-Demo" class="headerlink" title="4. Demo"></a>4. Demo</h1><p>下面，采用<code>Retrofit</code> + <code>RxJava</code>实现网络请求功能，说明<code>RxJava</code>的线程控制的具体应用。</p><h2 id="4-1-功能说明"><a href="#4-1-功能说明" class="headerlink" title="4.1 功能说明"></a>4.1 功能说明</h2><p>实现功能：将中文翻译成英文，并显示到界面<br>实现方案：采用<code>GET</code>方法对金山词霸API发送网络请求</p><h2 id="4-2-步骤说明"><a href="#4-2-步骤说明" class="headerlink" title="4.2 步骤说明"></a>4.2 步骤说明</h2><ol><li>添加依赖</li><li>创建接收服务器返回数据的类</li><li>创建用于描述网络请求的接口（区别于传统形式）</li><li>创建<code>Retrofit</code>实例</li><li>创建网络请求接口实例并配置网络请求参数（区别于传统形式）</li><li>发送网络请求（区别于传统形式）</li><li>对返回数据进行处理</li></ol><h2 id="4-3-具体实现"><a href="#4-3-具体实现" class="headerlink" title="4.3 具体实现"></a>4.3 具体实现</h2><h3 id="4-3-1-添加依赖"><a href="#4-3-1-添加依赖" class="headerlink" title="4.3.1 添加依赖"></a>4.3.1 添加依赖</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Android 支持 RxJava</span></span><br><span class="line"><span class="comment">// 此处一定要注意使用RxJava2的版本</span></span><br><span class="line">implementation <span class="string">'io.reactivex.rxjava2:rxjava:2.2.7'</span></span><br><span class="line">implementation <span class="string">'io.reactivex.rxjava2:rxandroid:2.1.0'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Android 支持 Retrofit</span></span><br><span class="line">implementation <span class="string">'com.squareup.retrofit2:retrofit:2.5.0'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 衔接 Retrofit &amp; RxJava</span></span><br><span class="line"><span class="comment">// 此处一定要注意使用RxJava2的版本</span></span><br><span class="line">implementation <span class="string">'com.jakewharton.retrofit:retrofit2-rxjava2-adapter:1.0.0'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持Gson解析</span></span><br><span class="line">implementation <span class="string">'com.squareup.retrofit2:converter-gson:2.5.0'</span></span><br></pre></td></tr></table></figure><p>权限：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.INTERNET"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-3-2-创建接收服务器返回数据的类"><a href="#4-3-2-创建接收服务器返回数据的类" class="headerlink" title="4.3.2 创建接收服务器返回数据的类"></a>4.3.2 创建接收服务器返回数据的类</h3><p>金山词霸API数据格式说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// URL模板</span><br><span class="line">http://fy.iciba.com/ajax.php</span><br><span class="line"></span><br><span class="line">// URL实例</span><br><span class="line">http://fy.iciba.com/ajax.php?a=fy&amp;f=auto&amp;t=auto&amp;w=hello%20world</span><br><span class="line"></span><br><span class="line">// 参数说明：</span><br><span class="line">// a：固定值 fy</span><br><span class="line">// f：原文内容类型，日语取 ja，中文取 zh，英语取 en，韩语取 ko，德语取 de，西班牙语取 es，法语取 fr，自动则取 auto</span><br><span class="line">// t：译文内容类型，日语取 ja，中文取 zh，英语取 en，韩语取 ko，德语取 de，西班牙语取 es，法语取 fr，自动则取 auto</span><br><span class="line">// w：查询内容</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"status"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">"content"</span>: &#123;</span><br><span class="line"><span class="attr">"from"</span>: <span class="string">"en-EU"</span>,</span><br><span class="line"><span class="attr">"to"</span>: <span class="string">"zh-CN"</span>,</span><br><span class="line"><span class="attr">"vendor"</span>: <span class="string">"ciba_cnn"</span>,</span><br><span class="line"><span class="attr">"out"</span>: <span class="string">"\u4f60\u597d\u4e16\u754c"</span>,</span><br><span class="line"><span class="attr">"ciba_use"</span>: <span class="string">"\u6765\u81ea\u673a\u5668\u7ffb\u8bd1\u3002"</span>,</span><br><span class="line"><span class="attr">"ciba_out"</span>: <span class="string">""</span>,</span><br><span class="line"><span class="attr">"err_no"</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ly.allendemorx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Translation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * status : 1</span></span><br><span class="line"><span class="comment">     * content : &#123;"from":"en-EU","to":"zh-CN","vendor":"ciba_cnn","out":"你好世界","ciba_use":"来自机器翻译。","ciba_out":"",</span></span><br><span class="line"><span class="comment">     * "err_no":0&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">private</span> ContentBean content;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStatus</span><span class="params">(<span class="keyword">int</span> status)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ContentBean <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(ContentBean content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ContentBean</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * from : en-EU</span></span><br><span class="line"><span class="comment">         * to : zh-CN</span></span><br><span class="line"><span class="comment">         * vendor : ciba_cnn</span></span><br><span class="line"><span class="comment">         * out : 你好世界</span></span><br><span class="line"><span class="comment">         * ciba_use : 来自机器翻译。</span></span><br><span class="line"><span class="comment">         * ciba_out :</span></span><br><span class="line"><span class="comment">         * err_no : 0</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String from;</span><br><span class="line">        <span class="keyword">private</span> String to;</span><br><span class="line">        <span class="keyword">private</span> String vendor;</span><br><span class="line">        <span class="keyword">private</span> String out;</span><br><span class="line">        <span class="keyword">private</span> String ciba_use;</span><br><span class="line">        <span class="keyword">private</span> String ciba_out;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> err_no;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getFrom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> from;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFrom</span><span class="params">(String from)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.from = from;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getTo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> to;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTo</span><span class="params">(String to)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.to = to;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getVendor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> vendor;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVendor</span><span class="params">(String vendor)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.vendor = vendor;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getOut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> out;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOut</span><span class="params">(String out)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.out = out;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getCiba_use</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ciba_use;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCiba_use</span><span class="params">(String ciba_use)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.ciba_use = ciba_use;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getCiba_out</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ciba_out;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCiba_out</span><span class="params">(String ciba_out)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.ciba_out = ciba_out;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getErr_no</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> err_no;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setErr_no</span><span class="params">(<span class="keyword">int</span> err_no)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.err_no = err_no;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-3-创建用于描述网络请求的接口"><a href="#4-3-3-创建用于描述网络请求的接口" class="headerlink" title="4.3.3 创建用于描述网络请求的接口"></a>4.3.3 创建用于描述网络请求的接口</h3><p>采用<strong>注解 + Observable</strong>接口描述网络请求参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ly.allendemorx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.reactivex.Observable;</span><br><span class="line"><span class="keyword">import</span> retrofit2.http.GET;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GetRequest_Interface</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注解中传入网络请求部分的URL地址</span></span><br><span class="line"><span class="comment">     * Retrofit将网络请求的URL分成两个部分：一是放在Retrofit对象里，另一是放在网络请求接口里</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"ajax.php?a=fy&amp;f=auto&amp;t=auto&amp;w=hi%20world"</span>)</span><br><span class="line">    <span class="function">Observable&lt;Translation&gt; <span class="title">getCall</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-4-后面的步骤均可在Activity中实现，详见代码"><a href="#4-3-4-后面的步骤均可在Activity中实现，详见代码" class="headerlink" title="4.3.4 后面的步骤均可在Activity中实现，详见代码"></a>4.3.4 后面的步骤均可在Activity中实现，详见代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ly.allendemorx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.jakewharton.retrofit2.adapter.rxjava2.RxJava2CallAdapterFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.reactivex.Observable;</span><br><span class="line"><span class="keyword">import</span> io.reactivex.Observer;</span><br><span class="line"><span class="keyword">import</span> io.reactivex.android.schedulers.AndroidSchedulers;</span><br><span class="line"><span class="keyword">import</span> io.reactivex.disposables.Disposable;</span><br><span class="line"><span class="keyword">import</span> io.reactivex.schedulers.Schedulers;</span><br><span class="line"><span class="keyword">import</span> retrofit2.Retrofit;</span><br><span class="line"><span class="keyword">import</span> retrofit2.converter.gson.GsonConverterFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Liuyang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main3Activity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"Allen"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤4：创建Retrofit对象</span></span><br><span class="line">        Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">                <span class="comment">// 设置网络请求URL</span></span><br><span class="line">                .baseUrl(<span class="string">"http://fy.iciba.com/"</span>)</span><br><span class="line">                <span class="comment">// 设置使用GSON解析</span></span><br><span class="line">                .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">                <span class="comment">// 设置支持RxJava</span></span><br><span class="line">                .addCallAdapterFactory(RxJava2CallAdapterFactory.create())</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤5：创建网络请求接口实例</span></span><br><span class="line">        <span class="keyword">final</span> GetRequest_Interface request = retrofit.create(GetRequest_Interface.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤6：采用Observable&lt;...&gt;形式对网络请求进行封装</span></span><br><span class="line">        Observable&lt;Translation&gt; observable = request.getCall();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤7：发送网络请求</span></span><br><span class="line">        observable</span><br><span class="line">                <span class="comment">// 在IO线程进行网络请求</span></span><br><span class="line">                .subscribeOn(Schedulers.io())</span><br><span class="line">                <span class="comment">// 回到主线程 处理请求结果</span></span><br><span class="line">                .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">                .subscribe(<span class="keyword">new</span> Observer&lt;Translation&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">                        Log.d(TAG, <span class="string">"开始采用subscribe连接"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Translation translation)</span> </span>&#123;</span><br><span class="line">                        <span class="comment">// 步骤8：对返回的数据进行处理</span></span><br><span class="line">                        <span class="keyword">if</span> (translation != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            Log.d(TAG, <span class="string">"结果 from："</span> + translation.getContent().getFrom());</span><br><span class="line">                            Log.d(TAG, <span class="string">"结果 to："</span> + translation.getContent().getTo());</span><br><span class="line">                            Log.d(TAG, <span class="string">"结果 vendor："</span> + translation.getContent().getVendor());</span><br><span class="line">                            Log.d(TAG, <span class="string">"结果 out："</span> + translation.getContent().getOut());</span><br><span class="line">                            Log.d(TAG, <span class="string">"结果 ciba_use："</span> + translation.getContent().getCiba_use());</span><br><span class="line">                            Log.d(TAG, <span class="string">"结果 ciba_out："</span> + translation.getContent().getCiba_out());</span><br><span class="line">                            Log.d(TAG, <span class="string">"结果 err_no："</span> + translation.getContent().getErr_no());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                        Log.d(TAG, <span class="string">"请求失败"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        Log.d(TAG, <span class="string">"请求成功"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">D/Allen: 开始采用subscribe连接</span><br><span class="line">D/Allen: 结果 from：en-EU</span><br><span class="line">D/Allen: 结果 to：zh-CN</span><br><span class="line">D/Allen: 结果 vendor：tencent</span><br><span class="line">D/Allen: 结果 out：嗨世界</span><br><span class="line">D/Allen: 结果 ciba_use：来自机器翻译。</span><br><span class="line">D/Allen: 结果 ciba_out：</span><br><span class="line">D/Allen: 结果 err_no：0</span><br><span class="line">D/Allen: 请求成功</span><br></pre></td></tr></table></figure><p>地址：<a href="https://gitee.com/QingFengBaiYu/Allen_Demo_Rx" target="_blank" rel="noopener">Allen_Demo_Rx</a></p><h1 id="5-程序崩溃问题"><a href="#5-程序崩溃问题" class="headerlink" title="5. 程序崩溃问题"></a>5. 程序崩溃问题</h1><p>背景：在发送网络请求时，退出当前Activity。<br>冲突：此时如果回到主线程更新UI，APP会崩溃<br>解决方案：当Activity退出时，调用<code>Disposiable.dispose()</code>切断观察者和被观察者之间的订阅，使得观察者无法接收到事件和响应事件。</p><blockquote><p>当出现多个<code>Disposiable</code>时，可以采用<code>RxJava</code>内置容器<code>CompositeDisposable</code>进行统一管理。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加Disposable到CompositeDisposable容器</span></span><br><span class="line">CompositeDisposable.add()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空CompositeDisposable容器</span></span><br><span class="line">CompositeDisposable.clear()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-作用&quot;&gt;&lt;a href=&quot;#1-作用&quot; class=&quot;headerlink&quot; title=&quot;1. 作用&quot;&gt;&lt;/a&gt;1. 作用&lt;/h1&gt;&lt;p&gt;指定&lt;code&gt;Observable&lt;/code&gt;/&lt;code&gt;Observer&lt;/code&gt;的工作线程类型。&lt;/p&gt;

      
    
    </summary>
    
      <category term="Android" scheme="https://tylerLiu.top/categories/Android/"/>
    
      <category term="RxJava" scheme="https://tylerLiu.top/categories/Android/RxJava/"/>
    
    
      <category term="RxJava" scheme="https://tylerLiu.top/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>Android RxJava：功能性操作符</title>
    <link href="https://tylerLiu.top/2019/08/16/Android-RxJava%EF%BC%9A%E5%8A%9F%E8%83%BD%E6%80%A7%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    <id>https://tylerLiu.top/2019/08/16/Android-RxJava：功能性操作符/</id>
    <published>2019-08-16T06:48:26.000Z</published>
    <updated>2019-08-22T03:14:14.587Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h1><p>辅助被观察者<code>Observable</code>在发送事件时实现一些功能性需求，如错误处理、线程调度等。</p><h1 id="2-类型"><a href="#2-类型" class="headerlink" title="2. 类型"></a>2. 类型</h1><p>常用的功能性操作符：</p><ol><li>连接被观察者和观察者：<code>subscribe()</code>，订阅</li><li>线程调度：<code>subscribeOn()</code>、<code>observeOn()</code></li><li>延迟操作：<code>delay()</code></li><li>在事件的生命周期中操作：<code>do()</code></li><li>错误处理：即遇到错误时的机制，<code>onErrorReturn()</code>、<code>onErrorResumeNext()</code>、<code>onExceptionResumeNext()</code>、<code>retry()</code>、<code>retryUntil()</code>、<code>retryWhen()</code></li><li>重复发起操作：<code>repeat()</code>、<code>repeatWhen()</code></li></ol><h1 id="3-详细说明"><a href="#3-详细说明" class="headerlink" title="3. 详细说明"></a>3. 详细说明</h1><h2 id="3-1-连接被观察者和观察者"><a href="#3-1-连接被观察者和观察者" class="headerlink" title="3.1 连接被观察者和观察者"></a>3.1 连接被观察者和观察者</h2><p>作用：使被观察者和观察者形成订阅关系。</p><p><strong>操作符：<code>subscribe()</code></strong><br>具体例子看前面的就可以了。</p><h2 id="3-2-线程调度"><a href="#3-2-线程调度" class="headerlink" title="3.2 线程调度"></a>3.2 线程调度</h2><p>作用：快速、方便指定和控制被观察者及观察者的工作线程。<br>该部分在下一篇详细看看。</p><h2 id="3-3-延迟操作："><a href="#3-3-延迟操作：" class="headerlink" title="3.3 延迟操作："></a>3.3 延迟操作：</h2><p>作用：使得被观察者延迟一段时间再发送事件。<br>里面有多个重载方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定延迟时间</span></span><br><span class="line"><span class="comment">// @param delay 时间</span></span><br><span class="line"><span class="comment">// @param unit 时间单位</span></span><br><span class="line">delay(<span class="keyword">long</span> delay, TimeUnit unit)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定延迟时间和错误延迟</span></span><br><span class="line"><span class="comment">// 如果出现Error事件，则先正常执行，执行结束之后，再抛出异常</span></span><br><span class="line"><span class="comment">// @param delayError 错误延迟参数</span></span><br><span class="line">delay(<span class="keyword">long</span> delay, TimeUnit unit, <span class="keyword">boolean</span> delayError)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定延迟时间和调度器</span></span><br><span class="line"><span class="comment">// @param scheduler 线程调度器</span></span><br><span class="line">delay(<span class="keyword">long</span> delay, TimeUnit unit, Scheduler scheduler)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定延迟时间、调度器和错误延迟参数</span></span><br><span class="line">delay(<span class="keyword">long</span> delay, TimeUnit unit, Scheduler scheduler, <span class="keyword">boolean</span> delayError)</span><br></pre></td></tr></table></figure><h2 id="3-4-在事件的生命周期中操作"><a href="#3-4-在事件的生命周期中操作" class="headerlink" title="3.4 在事件的生命周期中操作"></a>3.4 在事件的生命周期中操作</h2><p>作用：在事件发送和接收的整个生命周期过程中进行操作。如发送事件前的初始化、发送事件后的回调请求等。</p><p><strong>操作符：<code>do()</code></strong><br>作用：在某个事件的生命周期中调用。<br><code>do()</code>操作符包含以下：</p><ol><li>当<code>Observable</code>每发送一次数据事件，就会调用一次。<code>doOnEach()</code>，含<code>onNext()</code>、<code>onError()</code>和<code>onComplete()</code></li><li><code>Next</code>事件</li></ol><ul><li>执行<code>Next</code>事件前调用：<code>doOnNext()</code></li><li>执行<code>Next</code>事件后调用：<code>doAfterNext()</code></li></ul><ol start="3"><li>发送事件完毕后调用</li></ol><ul><li>发送错误事件时：<code>doOnError()</code></li><li>正常发送事件完毕后：<code>doOnCompleted()</code></li><li>无论正常发送/异常终止：<code>doOnTeriminate()</code></li><li>最后执行：<code>doFinaly()</code></li></ul><ol start="4"><li>订阅相关</li></ol><ul><li>观察者订阅时调用：<code>doOnSubscribe()</code></li><li>观察者取消订阅时调用：<code>doOnUnsubscribe()</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        emitter.onNext(<span class="number">1</span>);</span><br><span class="line">        emitter.onNext(<span class="number">2</span>);</span><br><span class="line">        emitter.onNext(<span class="number">3</span>);</span><br><span class="line">        emitter.onError(<span class="keyword">new</span> Throwable(<span class="string">"发生错误"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">        <span class="comment">// 当Observable每发送一次数据事件，就调用一次</span></span><br><span class="line">        .doOnEach(<span class="keyword">new</span> Consumer&lt;Notification&lt;Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Notification&lt;Integer&gt; integerNotification)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"doOnEach: "</span> + integerNotification.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// 执行Next事件前执行</span></span><br><span class="line">        .doOnNext(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"doOnNext: "</span> + integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// 执行Next事件后执行</span></span><br><span class="line">        .doAfterNext(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"doAfterNext: "</span> + integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// Observable正常发送事件结束后调用</span></span><br><span class="line">        .doOnComplete(<span class="keyword">new</span> Action() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"doOnComplete: "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// Observable发送错误事件时调用</span></span><br><span class="line">        .doOnError(<span class="keyword">new</span> Consumer&lt;Throwable&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Throwable throwable)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"doOnError: "</span> + throwable.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// 观察者订阅时调用</span></span><br><span class="line">        .doOnSubscribe(<span class="keyword">new</span> Consumer&lt;Disposable&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Disposable disposable)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"doOnSubscribe: "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// Observable发送事件结束后调用，无论正常发送完毕还是异常终止</span></span><br><span class="line">        .doAfterTerminate(<span class="keyword">new</span> Action() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"doAfterTerminate: "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// 最后执行</span></span><br><span class="line">        .doFinally(<span class="keyword">new</span> Action() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"doFinally: "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(<span class="keyword">new</span> Observer&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"接收到了事件"</span> + integer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"对Error事件作出响应"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"对Complete事件作出响应"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="3-5-错误处理"><a href="#3-5-错误处理" class="headerlink" title="3.5 错误处理"></a>3.5 错误处理</h2><p>作用：发送事件过程中，遇到错误时的处理机制。</p><p>常用的操作符：</p><ol><li>发送数据</li></ol><ul><li>发送一个特殊的事件并正常终止：<code>onErrorReturn()</code></li><li>发送一个新的<code>Observable</code>：<code>onErrorResumeNext()</code>、<code>onExceptionResumeNext()</code></li></ul><ol start="2"><li>重试</li></ol><ul><li>重试：<code>retry()</code></li><li>让<code>Observable</code>重新订阅：<code>retryUntil()</code></li><li>将错误传递给另一个<code>Observable</code>，来决定是否要重新订阅该<code>Observable</code>：<code>retryWhen()</code></li></ul><p><strong>操作符：<code>onErrorReturn()</code></strong><br>作用：遇到错误时，发送一个特殊事件并正常终止，可以捕获在它之前发生的异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        emitter.onNext(<span class="number">1</span>);</span><br><span class="line">        emitter.onNext(<span class="number">2</span>);</span><br><span class="line">        emitter.onError(<span class="keyword">new</span> Throwable(<span class="string">"发生错误了"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).onErrorReturn(<span class="keyword">new</span> Function&lt;Throwable, Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">apply</span><span class="params">(Throwable throwable)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 捕捉错误异常</span></span><br><span class="line">        Log.e(TAG, <span class="string">"在onErrorReturn处理了错误: "</span> + throwable.toString());</span><br><span class="line">        <span class="comment">// 发生错误事件后，发送一个"666"事件，最终正常结束</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">666</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(<span class="keyword">new</span> Observer&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"接收到了事件"</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"对Error事件作出响应"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"对Complete事件作出响应"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><img src="/2019/08/16/Android-RxJava：功能性操作符/944365-53f108767f179f0b.png"><p><strong>操作符：<code>onErrorResumeNext()</code></strong><br>作用：遇到错误时，发送一个新的<code>Observable</code>。</p><p>注：</p><ol><li><code>onErrorResumeNext()</code>拦截的错误为<code>Throwable</code>；若需拦截<code>Exception</code>，要用<code>onExceptionResumeNext()</code></li><li>若<code>onErrorResumeNext()</code>拦截的错误为<code>Exception</code>，则会将错误传递给观察者的<code>onError()</code>方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        e.onNext(<span class="number">1</span>);</span><br><span class="line">        e.onNext(<span class="number">2</span>);</span><br><span class="line">        e.onError(<span class="keyword">new</span> Throwable(<span class="string">"发生错误了"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).onErrorResumeNext(<span class="keyword">new</span> Function&lt;Throwable, ObservableSource&lt;? extends Integer&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ObservableSource&lt;? extends Integer&gt; apply(<span class="meta">@NonNull</span> Throwable throwable) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 捕捉错误异常</span></span><br><span class="line">        Log.e(TAG, <span class="string">"在onErrorReturn处理了错误: "</span> + throwable.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 发生错误事件后，发送一个新的被观察者 &amp; 发送事件序列</span></span><br><span class="line">        <span class="keyword">return</span> Observable.just(<span class="number">11</span>, <span class="number">22</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(<span class="keyword">new</span> Observer&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"接收到了事件"</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"对Error事件作出响应"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"对Complete事件作出响应"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><img src="/2019/08/16/Android-RxJava：功能性操作符/944365-ceec6fa2c9385811.png"><p><strong>操作符：<code>onExceptionResumeNext()</code></strong><br>作用：遇到错误时，发送一个新的<code>Observable</code>。</p><p>注：</p><ol><li><code>onExceptionResumeNext()</code>拦截的错误为<code>Exception</code>；若需拦截<code>Throwable</code>，要用<code>onErrorResumeNext()</code></li><li>若<code>onExceptionResumeNext()</code>拦截的错误为<code>Throwable</code>，则会将错误传递给观察者的<code>onError()</code>方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        e.onNext(<span class="number">1</span>);</span><br><span class="line">        e.onNext(<span class="number">2</span>);</span><br><span class="line">        e.onError(<span class="keyword">new</span> Exception(<span class="string">"发生错误了"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).onExceptionResumeNext(<span class="keyword">new</span> Observable&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> Integer&gt; observer)</span> </span>&#123;</span><br><span class="line">        observer.onNext(<span class="number">11</span>);</span><br><span class="line">        observer.onNext(<span class="number">22</span>);</span><br><span class="line">        observer.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(<span class="keyword">new</span> Observer&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"接收到了事件"</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"对Error事件作出响应"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"对Complete事件作出响应"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><img src="/2019/08/16/Android-RxJava：功能性操作符/944365-fb80cd4732481f41.png"><p><strong>操作符：<code>retry()</code></strong><br>作用：重试，当出现错误时，让被观察者<code>oBservable</code>重新发送数据</p><ol><li>接收到<code>onError()</code>时，重新订阅并发送事件</li><li><code>Throwable</code>和<code>Exception</code>都可拦截</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 出现错误时，让被观察者重新发送数据，若一直出现错误，就一直重新发送</span></span><br><span class="line">retry()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出现错误时，让被观察者重新发送数据，有重试次数限制</span></span><br><span class="line"><span class="comment">// @param times 重试次数</span></span><br><span class="line">retry(<span class="keyword">long</span> times)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出现错误时，判断是否需要重新发送数据，若需要重新发送，且持续遇到错误，则持续重试</span></span><br><span class="line"><span class="comment">// @param predicate 判断逻辑</span></span><br><span class="line">retry(Predicate&lt;? <span class="keyword">super</span> Throwable&gt; predicate)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出现错误时，判断是否需要重新发送数据，若需要重新发送，且持续遇到错误，则持续重试</span></span><br><span class="line"><span class="comment">// @param predicate 判断逻辑，传入当前重试次数和异常错误信息</span></span><br><span class="line">retry(BiPredicate&lt;? <span class="keyword">super</span> Integer, ? <span class="keyword">super</span> Throwable&gt; predicate)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出现错误时，判断是否需要重新发送数据，若需要重新发送，且持续遇到错误，则持续重试</span></span><br><span class="line"><span class="comment">// @param times 重试次数</span></span><br><span class="line"><span class="comment">// @param predicate 判断逻辑</span></span><br><span class="line">retry(<span class="keyword">long</span> times, Predicate&lt;? <span class="keyword">super</span> Throwable&gt; predicate)</span><br></pre></td></tr></table></figure><p>前面的三个方法很简单，看看后面两个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        emitter.onNext(<span class="number">1</span>);</span><br><span class="line">        emitter.onNext(<span class="number">2</span>);</span><br><span class="line">        emitter.onError(<span class="keyword">new</span> Exception(<span class="string">"发生错误了"</span>));</span><br><span class="line">        emitter.onNext(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">        <span class="comment">// 拦截错误后，判断是否需要重新发送请求</span></span><br><span class="line">        .retry(<span class="keyword">new</span> BiPredicate&lt;Integer, Throwable&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Integer integer, Throwable throwable)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="comment">// 捕获异常</span></span><br><span class="line">                Log.e(TAG, <span class="string">"异常错误 =  "</span> + throwable.toString());</span><br><span class="line">                <span class="comment">// 获取当前重试次数</span></span><br><span class="line">                Log.e(TAG, <span class="string">"当前重试次数 =  "</span> + integer);</span><br><span class="line">                <span class="comment">//返回false：不重新重新发送数据 &amp; 调用观察者的onError结束</span></span><br><span class="line">                <span class="comment">//返回true：重新发送请求（若持续遇到错误，就持续重新发送）</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(<span class="keyword">new</span> Observer&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"接收到了事件"</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"对Error事件作出响应"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"对Complete事件作出响应"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        e.onNext(<span class="number">1</span>);</span><br><span class="line">        e.onNext(<span class="number">2</span>);</span><br><span class="line">        e.onError(<span class="keyword">new</span> Exception(<span class="string">"发生错误了"</span>));</span><br><span class="line">        e.onNext(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">        <span class="comment">// 拦截错误后，判断是否需要重新发送请求</span></span><br><span class="line">        .retry(<span class="number">3</span>, <span class="keyword">new</span> Predicate&lt;Throwable&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(@NonNull Throwable throwable)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="comment">// 捕获异常</span></span><br><span class="line">                Log.e(TAG, <span class="string">"retry错误: "</span> + throwable.toString());</span><br><span class="line"></span><br><span class="line">                <span class="comment">//返回false：不重新重新发送数据 &amp; 调用观察者的onError（）结束</span></span><br><span class="line">                <span class="comment">//返回true：重新发送请求（最多重新发送3次）</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(<span class="keyword">new</span> Observer&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"接收到了事件"</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"对Error事件作出响应"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"对Complete事件作出响应"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>操作符：<code>retryUntil()</code></strong><br>作用：出现错误后，判断是否需要重新发送数据</p><ol><li>若需要重新发送，且持续遇到错误，则持续重试</li><li>作用类似于：<code>retry(Predicate predicate)</code></li></ol><p>具体使用类似于<code>retry(Predicate predicate)</code>，唯一区别是：返回<code>true</code>，则不重新发送数据事件。</p><p><strong>操作符：<code>retryWhen()</code></strong><br>作用：遇到错误时，将发生的错误传递给一个新的被观察者<code>Observable</code>，并决定是否需要重新订阅原始被观察者并发送事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        e.onNext(<span class="number">1</span>);</span><br><span class="line">        e.onNext(<span class="number">2</span>);</span><br><span class="line">        e.onError(<span class="keyword">new</span> Exception(<span class="string">"发生错误了"</span>));</span><br><span class="line">        e.onNext(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遇到Error事件才会回调</span></span><br><span class="line">        .retryWhen(<span class="keyword">new</span> Function&lt;Observable&lt;Throwable&gt;, ObservableSource&lt;?&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ObservableSource&lt;?&gt; apply(Observable&lt;Throwable&gt; throwableObservable) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="comment">// 参数Observable&lt;Throwable&gt;中的泛型为上游操作抛出的异常，可通过该条件来判断异常的类型</span></span><br><span class="line">                <span class="comment">// 返回ObservableSource&lt;?&gt;，为新的被观察者Observable，可以是任意类型的</span></span><br><span class="line">                <span class="comment">// 这里有两种处理方式：</span></span><br><span class="line">                <span class="comment">// 1. 若新的Observable发送的事件为Error事件，那么原始Observable则不重新发送事件</span></span><br><span class="line">                <span class="comment">// 2. 若新的Observable发送的事件为Next事件，那么原始Observable则重新发送事件</span></span><br><span class="line">                <span class="keyword">return</span> throwableObservable.flatMap(<span class="keyword">new</span> Function&lt;Throwable, ObservableSource&lt;?&gt;&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> ObservableSource&lt;?&gt; apply(Throwable throwable) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        <span class="comment">// 1. 若返回的Observable发送事件为Error事件，那么原始的Observable则不重新发送事件.</span></span><br><span class="line">                        <span class="comment">// 该异常错误信息可以在观察者中的onError()中获得</span></span><br><span class="line">                        <span class="keyword">return</span> Observable.error(<span class="keyword">new</span> Throwable(<span class="string">"retryWhen终止"</span>));</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 2. 若新的Observable发送的事件为Next事件，那么原始Observable则重新发送事件，</span></span><br><span class="line">                        <span class="comment">// 若持续遇到错误，则持续重试</span></span><br><span class="line">                        <span class="comment">// return Observable.just(1);</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(<span class="keyword">new</span> Observer&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"接收到了事件"</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"对Error事件作出响应"</span> + e.toString());</span><br><span class="line">        <span class="comment">// 获取异常错误信息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"对Complete事件作出响应"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>情况1：</p><img src="/2019/08/16/Android-RxJava：功能性操作符/944365-85824e55f933b3de.png"><p>情况2：</p><img src="/2019/08/16/Android-RxJava：功能性操作符/944365-875063c39c5f5ef3.png"><h2 id="3-6-重复发送"><a href="#3-6-重复发送" class="headerlink" title="3.6 重复发送"></a>3.6 重复发送</h2><p>作用：重复不断地发送被观察者事件<br>操作符：<code>repeat</code>和<code>repeatWhen()</code></p><p><strong>操作符：<code>repeat()</code></strong><br>作用：无条件、重复发送被观察者事件，具备重载方法，可设置重复创建次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="comment">// 重复创建3次</span></span><br><span class="line">    .repeat(<span class="number">3</span>)</span><br><span class="line">    .subscribe(<span class="keyword">new</span> Observer&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"开始采用subscribe连接"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"接收到了事件"</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"对Error事件作出响应"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"对Complete事件作出响应"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>注：</p><ol><li>接收到<code>onComplete(0</code>事件后，触发重新订阅和发送</li><li>默认运行在一个新的线程上</li></ol><img src="/2019/08/16/Android-RxJava：功能性操作符/944365-c15424be47abd373.png"><p><strong>操作符：<code>repeatWhen()</code></strong><br>作用：有条件地、重复发送被观察者事件<br>原理：将原始<code>Observable</code>停止发送事件的标识（<code>Complete()</code>/<code>Error()</code>）转换成一个<code>Object</code>类型数据传递给一个新的<code>Observable</code>，以此决定是否重新订阅和发送原来的<code>Observable</code>。</p><ol><li>如果新的<code>Observable</code>返回一个<code>Complete</code>/<code>Error</code>事件，则不重新订阅和发送原来的<code>Observable</code></li><li>如果新的<code>Observable</code>返回其余事件时，则重新订阅并发送原来的<code>Observable</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>).repeatWhen(<span class="keyword">new</span> Function&lt;Observable&lt;Object&gt;, ObservableSource&lt;?&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 在Function函数中，必须对输入的 Observable&lt;Object&gt;进行处理，这里使用的是flatMap操作符接收上游的数据</span></span><br><span class="line">    <span class="keyword">public</span> ObservableSource&lt;?&gt; apply(<span class="meta">@NonNull</span> Observable&lt;Object&gt; objectObservable) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 将原始Observable停止发送事件的标识（Complete()/Error()）转换成一个Object类型数据传递给一个新的Observable</span></span><br><span class="line">        <span class="comment">// 以此决定是否重新订阅和发送原来的Observable</span></span><br><span class="line">        <span class="comment">// 此处有2种情况：</span></span><br><span class="line">        <span class="comment">// 1. 若新的Observable返回一个Complete()/Error()事件，则不重新订阅和发送原来的Observable</span></span><br><span class="line">        <span class="comment">// 2. 若新的Observable返回其余事件，则重新订阅并发送原来的Observable</span></span><br><span class="line">        <span class="keyword">return</span> objectObservable.flatMap(<span class="keyword">new</span> Function&lt;Object, ObservableSource&lt;?&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ObservableSource&lt;?&gt; apply(<span class="meta">@NonNull</span> Object throwable) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 1. 若新的Observable返回一个Complete()/Error()事件，则不重新订阅和发送原来的Observable</span></span><br><span class="line">                <span class="comment">// Observable.empty()则发送Complete事件，但不会回调观察者的onComplete()</span></span><br><span class="line">                <span class="keyword">return</span> Observable.empty();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 返回Error事件则回调onError()事件，并接收传过去的错误信息</span></span><br><span class="line">                <span class="comment">// return Observable.error(new Throwable("不再重新订阅事件"));</span></span><br><span class="line">                </span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2. 若新的Observable返回其余事件，则重新订阅并发送原来的Observable</span></span><br><span class="line">                <span class="comment">// 仅仅是作为一个触发重新订阅被观察者的通知，发送的是什么数据并不重要，只要不是Complete()/Error()事件</span></span><br><span class="line">                <span class="comment">// return Observable.just(1);</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(<span class="keyword">new</span> Observer&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"开始采用subscribe连接"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"接收到了事件"</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"对Error事件作出响应："</span> + e.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"对Complete事件作出响应"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><img src="/2019/08/16/Android-RxJava：功能性操作符/944365-c1cc930094f20122.png"><img src="/2019/08/16/Android-RxJava：功能性操作符/944365-5e15f379883fbf0e.png"><img src="/2019/08/16/Android-RxJava：功能性操作符/944365-69b7e611a6a21499.png"><h1 id="4-实际开发需求"><a href="#4-实际开发需求" class="headerlink" title="4. 实际开发需求"></a>4. 实际开发需求</h1><ol><li>线程操作，如切换/调度/控制</li><li>轮询</li><li>发送网络请求时的差错重试机制</li></ol><h2 id="4-1-线程操作"><a href="#4-1-线程操作" class="headerlink" title="4.1 线程操作"></a>4.1 线程操作</h2><p>详细请看下一篇。</p><h2 id="4-2-轮询"><a href="#4-2-轮询" class="headerlink" title="4.2 轮询"></a>4.2 轮询</h2><p>实例讲解中会有一篇结合<code>Retrofit</code>，实现轮询。</p><h2 id="4-3-发送网络请求时的差错重试机制"><a href="#4-3-发送网络请求时的差错重试机制" class="headerlink" title="4.3 发送网络请求时的差错重试机制"></a>4.3 发送网络请求时的差错重试机制</h2><p>实例讲解中会有一篇结合<code>Retrofit</code>，实现该功能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-作用&quot;&gt;&lt;a href=&quot;#1-作用&quot; class=&quot;headerlink&quot; title=&quot;1. 作用&quot;&gt;&lt;/a&gt;1. 作用&lt;/h1&gt;&lt;p&gt;辅助被观察者&lt;code&gt;Observable&lt;/code&gt;在发送事件时实现一些功能性需求，如错误处理、线程调度等。&lt;/p
      
    
    </summary>
    
      <category term="Android" scheme="https://tylerLiu.top/categories/Android/"/>
    
      <category term="RxJava" scheme="https://tylerLiu.top/categories/Android/RxJava/"/>
    
    
      <category term="RxJava" scheme="https://tylerLiu.top/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>Android RxJava：组合/合并操作符</title>
    <link href="https://tylerLiu.top/2019/08/15/Android-RxJava%EF%BC%9A%E7%BB%84%E5%90%88-%E5%90%88%E5%B9%B6%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    <id>https://tylerLiu.top/2019/08/15/Android-RxJava：组合-合并操作符/</id>
    <published>2019-08-15T07:51:51.000Z</published>
    <updated>2019-08-22T03:14:33.096Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h1><p>组合多个被观察者<code>Observable</code>，合并需要发送的事件。</p><h1 id="2-类型"><a href="#2-类型" class="headerlink" title="2. 类型"></a>2. 类型</h1><p><code>RxJava</code>中常见的组合/合并操作符：</p><ol><li>组合多个被观察者</li></ol><ul><li>按发送顺序：<code>concat()</code>、<code>concatArray()</code></li><li>按时间：<code>merge()</code>、<code>mergeArray()</code></li><li>错误处理：<code>concatDelatError()</code>、<code>mergeDelayError()</code></li></ul><ol start="2"><li>合并多个事件</li></ol><ul><li>按数量：<code>zip()</code></li><li>按时间：<code>combineLatest()</code>、<code>combineLatestError()</code></li><li>合并成一个事件发送：<code>reduce()</code>、<code>collect()</code></li></ul><ol start="3"><li>发送事件前追加发送事件：<code>startWith()</code>、<code>startWithArray()</code></li><li>统计发送事件数量：<code>count()</code></li></ol><h1 id="3-详细说明"><a href="#3-详细说明" class="headerlink" title="3. 详细说明"></a>3. 详细说明</h1><h2 id="3-1-组合多个被观察者"><a href="#3-1-组合多个被观察者" class="headerlink" title="3.1 组合多个被观察者"></a>3.1 组合多个被观察者</h2><p>该类型操作符的作用：组合多个被观察者。</p><p><strong><code>concat()/concatArray()</code></strong><br>作用：组合多个被观察者一起发送数据，合并后<strong>按发送顺序串行执行</strong>。<br>二者区别：组合被观察者的数量不同，<code>concat()</code>为≤4和，<code>concatArray()</code>为＞4个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">Observable.concat(Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line">        Observable.just(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>),</span><br><span class="line">        Observable.just(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>),</span><br><span class="line">        Observable.just(<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>))</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Observer&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"接收到了事件"</span> + value);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"对Error事件作出响应"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"对Complete事件作出响应"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">Observable.concatArray(Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line">        Observable.just(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>),</span><br><span class="line">        Observable.just(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>),</span><br><span class="line">        Observable.just(<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>),</span><br><span class="line">        Observable.just(<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>))</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Observer&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"接收到了事件"</span> + value);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"对Error事件作出响应"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"对Complete事件作出响应"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p><strong><code>merge()/mergeArray()</code></strong><br>作用：组合多个被观察者一起发送数据，合并后<strong>按时间线并行执行</strong>。<br>二者区别：组合被观察者的数量不同，<code>merge()</code>为≤4和，<code>mergeArray()</code>为＞4个。<br>与<code>concat()</code>的区别：合并后执行的方式不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Observable.merge(</span><br><span class="line">        Observable.intervalRange(<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS),</span><br><span class="line">        Observable.intervalRange(<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">).subscribe(<span class="keyword">new</span> Observer&lt;Long&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Long value)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"接收到了事件"</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"对Error事件作出响应"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"对Complete事件作出响应"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>操作符：<code>concatDelayError()/megerDelayError()</code></strong><br>作用：</p><ul><li>背景：使用<code>concat()</code>和<code>meger()</code>操作符时，若其中一个b被观察者发出<code>onError()</code>事件，则会马上终止其他被观察者继续发送事件，造成冲突。</li><li>解决方案：若希望<code>onError()</code>事件推迟到其他被观察者发送事件结束之后触发，需要使用对用的<code>concatDelayError()</code>或<code>megerDelayError()</code>。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">Observable.concat(</span><br><span class="line">        Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                emitter.onNext(<span class="number">1</span>);</span><br><span class="line">                emitter.onNext(<span class="number">2</span>);</span><br><span class="line">                emitter.onNext(<span class="number">3</span>);</span><br><span class="line">                <span class="comment">// 发送Error事件，因为无使用concatDelayError，所以第2个Observable将不会发送事件</span></span><br><span class="line">                emitter.onError(<span class="keyword">new</span> NullPointerException());</span><br><span class="line">                emitter.onComplete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;),</span><br><span class="line">        Observable.just(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>))</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Observer&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"接收到了事件"</span> + value);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"对Error事件作出响应"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"对Complete事件作出响应"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">Observable.concatArrayDelayError(</span><br><span class="line">        Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">                emitter.onNext(<span class="number">1</span>);</span><br><span class="line">                emitter.onNext(<span class="number">2</span>);</span><br><span class="line">                emitter.onNext(<span class="number">3</span>);</span><br><span class="line">                <span class="comment">// 发送Error事件，因为使用了concatDelayError，所以第2个Observable将会发送事件，等发送完毕后，再发送错误事件</span></span><br><span class="line">                emitter.onError(<span class="keyword">new</span> NullPointerException());</span><br><span class="line">                emitter.onComplete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;),</span><br><span class="line">        Observable.just(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>))</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Observer&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"接收到了事件"</span> + value);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"对Error事件作出响应"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"对Complete事件作出响应"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></li></ul><img src="/2019/08/15/Android-RxJava：组合-合并操作符/944365-0c907ffaeb2fd449.png"><img src="/2019/08/15/Android-RxJava：组合-合并操作符/944365-804c8472fc60eb6a.png"><h2 id="3-2-合并多个事件"><a href="#3-2-合并多个事件" class="headerlink" title="3.2 合并多个事件"></a>3.2 合并多个事件</h2><p>该类型的操作符主要是对多个被观察者中的事件进行合并处理。</p><p><strong>操作符：<code>zip()</code></strong><br>作用：合并多个被观察者<code>Observable</code>发送的事件，生成一个新的事件序列（即组合之后的事件序列），并发送。</p><p>原理：</p><img src="/2019/08/15/Android-RxJava：组合-合并操作符/944365-3fa4b1fd4f561820.png"><p>特别注意：</p><ol><li>事件组合方式：严格按照原先事件序列进行对位合并</li><li>最终合并的事件数量：多个被观察者<code>Observable</code>中数量最少的数量</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建1个被观察者</span></span><br><span class="line">Observable&lt;Integer&gt; observable1 = Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"被观察者1发送了事件1"</span>);</span><br><span class="line">        emitter.onNext(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 为了方便展示效果，所以在发送事件后加入2s的延迟</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, <span class="string">"被观察者1发送了事件2"</span>);</span><br><span class="line">        emitter.onNext(<span class="number">2</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, <span class="string">"被观察者1发送了事件3"</span>);</span><br><span class="line">        emitter.onNext(<span class="number">3</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        emitter.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">        <span class="comment">// 设置被观察者1在工作线程1中工作</span></span><br><span class="line">        .subscribeOn(Schedulers.io());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建第2个被观察者</span></span><br><span class="line">Observable&lt;String&gt; observable2 = Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;String&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"被观察者2发送了事件A"</span>);</span><br><span class="line">        emitter.onNext(<span class="string">"A"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, <span class="string">"被观察者2发送了事件B"</span>);</span><br><span class="line">        emitter.onNext(<span class="string">"B"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, <span class="string">"被观察者2发送了事件C"</span>);</span><br><span class="line">        emitter.onNext(<span class="string">"C"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, <span class="string">"被观察者2发送了事件D"</span>);</span><br><span class="line">        emitter.onNext(<span class="string">"D"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        emitter.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">        <span class="comment">// 设置被观察者2在工作线程2中工作</span></span><br><span class="line">        .subscribeOn(Schedulers.newThread());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不做线程控制，两个被观察者会在同一个线程上工作，即发送事件存在先后顺序，而不是通同时发送。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用zip操作符进行事件合并</span></span><br><span class="line"><span class="comment">// 创建BiFunction对象传入的第三个参数为合并后数据的数据类型</span></span><br><span class="line">Observable.zip(observable1, observable2, <span class="keyword">new</span> BiFunction&lt;Integer, String, String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(Integer integer, String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> integer + s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(<span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onSubscribe"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"最终接收到的事件 =  "</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onError"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onComplete"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><img src="/2019/08/15/Android-RxJava：组合-合并操作符/944365-8986cf9178060877.png"><p>特别注意：</p><ol><li>尽管被观察者2的事件<code>D</code>没有合并，但是还是会继续发送；</li><li>如果在被观察者1和被观察者2的事件序列最后发送<code>onComplete()</code>事件，则被观察者2的事件<code>D</code>也不会发送。</li></ol><img src="/2019/08/15/Android-RxJava：组合-合并操作符/944365-7b241e653250b906.png"><p><code>zip()</code>总结：</p><ol><li>定义：属于<code>RxJava2</code>中的组合/合并操作符</li><li>作用：</li></ol><ul><li>合并多个被观察者<code>Observable</code>发送的事件</li><li>生成一个新的事件序列，并发送</li></ul><ol start="3"><li>原理：</li></ol><ul><li>事件组合方式：严格按照原先事件序列进行对位合并</li><li>最终合并的事件数量：多个被观察者<code>Observable</code>中数量最少的数量</li></ul><ol start="4"><li>应用场景：</li></ol><ul><li>当需要展示的信息需要从多个地方获取，且要统一结合后再展示</li><li>如合并互联网请求的发送，并统一显示结果：<code>Retrofit</code>结合<code>RxJava</code></li></ul><p><strong>操作符：combineLatest()</strong><br>作用：当两个<code>Observable</code>中的任何一个发送数据之后，将先发送数据的<code>Observable</code>的最新（最后）一个数据与另一个<code>Observable</code>发送的每个数据结合，最后基于该函数的结果发送数据。</p><blockquote><p>与<code>zip()</code>的区别：<code>zip()</code>是按个数合并，一对一的合并；<code>combineLatest()</code>是按时间合并，即再同一个时间点上合并。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Observable.combineLatest(Observable.just(<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">3L</span>),</span><br><span class="line">        Observable.intervalRange(<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS),</span><br><span class="line">        <span class="keyword">new</span> BiFunction&lt;Long, Long, Long&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Long <span class="title">apply</span><span class="params">(Long aLong1, Long aLong2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="comment">// aLong1：第1个Observable发送的最新（最后）1个数据</span></span><br><span class="line">                <span class="comment">// aLong2：第2个Observable发送的每1个数据</span></span><br><span class="line">                Log.e(TAG, <span class="string">"合并的数据是： "</span> + aLong1 + <span class="string">" "</span> + aLong2);</span><br><span class="line">                <span class="comment">// 合并的逻辑：相加</span></span><br><span class="line">                <span class="comment">// 即第一个Observable发送的最后一个数据与第二个Observable发送的每个数据相加</span></span><br><span class="line">                <span class="keyword">return</span> aLong1 + aLong2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(<span class="keyword">new</span> Consumer&lt;Long&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Long s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"合并的结果是： "</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>操作符：<code>combingLatestDelayError()</code></strong><br>类似<code>concatDelayError()</code>和<code>mergeDelayError()</code>，即错误处理，这里不再多做讲解。</p><p><strong>操作符：<code>reduce()</code></strong><br>作用：将被观察者需要发送的事件聚合成一个事件发送。</p><blockquote><p>聚合的逻辑根据需求编写，但本质都是前两个数据聚合，然后与后一个数据继续进行聚合，依次类推。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">        .reduce(<span class="keyword">new</span> BiFunction&lt;Integer, Integer, Integer&gt;() &#123;</span><br><span class="line">            <span class="comment">// 在复写方法中加入聚合逻辑</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">apply</span><span class="params">(Integer integer1, Integer integer2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.e(TAG, <span class="string">"本次计算的数据是： "</span> + integer1 + <span class="string">" 乘 "</span> + integer2);</span><br><span class="line">                <span class="comment">// 本次聚合的逻辑是：全部数据相乘起来</span></span><br><span class="line">                <span class="comment">// 原理：第1次取前2个数据相乘，之后每次获取到的数据 = 返回的数据x原始下1个数据每</span></span><br><span class="line">                <span class="keyword">return</span> integer1 * integer2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"最终计算的结果是： "</span> + integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>操作符：<code>collect()</code></strong><br>作用：将被观察者<code>Observable</code>发送的数据事件收集到一个数据结构里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>).collect(</span><br><span class="line">        <span class="comment">// 创建数据结构（容器），用于收集被观察者发送的数据</span></span><br><span class="line">        <span class="keyword">new</span> Callable&lt;ArrayList&lt;Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 对发送的数据进行收集</span></span><br><span class="line">        <span class="keyword">new</span> BiConsumer&lt;ArrayList&lt;Integer&gt;, Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(ArrayList&lt;Integer&gt; integers, Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                integers.add(integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(<span class="keyword">new</span> Consumer&lt;ArrayList&lt;Integer&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(ArrayList&lt;Integer&gt; integers)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"本次发送的数据是： "</span> + integers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><img src="/2019/08/15/Android-RxJava：组合-合并操作符/944365-ab51b84d6a373330.png"><h2 id="3-3-发送事件前追加发送事件"><a href="#3-3-发送事件前追加发送事件" class="headerlink" title="3.3 发送事件前追加发送事件"></a>3.3 发送事件前追加发送事件</h2><p><strong>操作符：<code>startWith()/startWithArray()</code></strong><br>作用：在一个被观察者发送事件之前，追加发送一些数据或者一个新的被观察者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在一个被观察者发送事件之前，追加发送一些数据</span></span><br><span class="line"><span class="comment">// 注：追加数据顺序为后调用先追加</span></span><br><span class="line">Observable.just(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">        .startWith(<span class="number">0</span>)</span><br><span class="line">        .startWithArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Observer&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"接收到了事件"</span> + value);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"对Error事件作出响应"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"对Complete事件作出响应"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在一个被观察者发送事件之前，追加发送一个被观察者并发送</span></span><br><span class="line">Observable.just(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">        .startWith(Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Observer&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"接收到了事件"</span> + value);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"对Error事件作出响应"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"对Complete事件作出响应"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><img src="/2019/08/15/Android-RxJava：组合-合并操作符/944365-1fabfa60e8535de2.png"><img src="/2019/08/15/Android-RxJava：组合-合并操作符/944365-23567e0cd790417c.png"><h2 id="3-4-统计发送事件数量"><a href="#3-4-统计发送事件数量" class="headerlink" title="3.4 统计发送事件数量"></a>3.4 统计发送事件数量</h2><p><strong>操作符：<code>count()</code></strong><br>作用：统计被观察者发送事件的数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注：返回结果 = Long类型</span></span><br><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">     .count()</span><br><span class="line">     .subscribe(<span class="keyword">new</span> Consumer&lt;Long&gt;() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Long aLong)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">             Log.e(TAG, <span class="string">"发送的事件数量 =  "</span> + aLong);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br></pre></td></tr></table></figure><img src="/2019/08/15/Android-RxJava：组合-合并操作符/944365-214478680237ffb8.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-作用&quot;&gt;&lt;a href=&quot;#1-作用&quot; class=&quot;headerlink&quot; title=&quot;1. 作用&quot;&gt;&lt;/a&gt;1. 作用&lt;/h1&gt;&lt;p&gt;组合多个被观察者&lt;code&gt;Observable&lt;/code&gt;，合并需要发送的事件。&lt;/p&gt;
&lt;h1 id=&quot;2-类型&quot;
      
    
    </summary>
    
      <category term="Android" scheme="https://tylerLiu.top/categories/Android/"/>
    
      <category term="RxJava" scheme="https://tylerLiu.top/categories/Android/RxJava/"/>
    
    
      <category term="RxJava" scheme="https://tylerLiu.top/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>Android RxJava：变换操作符</title>
    <link href="https://tylerLiu.top/2019/08/15/Android-RxJava%EF%BC%9A%E5%8F%98%E6%8D%A2%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    <id>https://tylerLiu.top/2019/08/15/Android-RxJava：变换操作符/</id>
    <published>2019-08-15T03:06:52.000Z</published>
    <updated>2019-08-22T03:14:09.001Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h1><p>对事件序列中的事件/整个事件序列进行<strong>加工处理</strong>（即变换），使得其转变成不同的事件/整个事件序列。</p><p>基础原理：</p><img src="/2019/08/15/Android-RxJava：变换操作符/微信图片_20190815131846.png"><p>使用变换操作符（针对事件）：</p><img src="/2019/08/15/Android-RxJava：变换操作符/微信图片_20190815132123.png"><p>使用变换操作符（针对事件序列）：</p><img src="/2019/08/15/Android-RxJava：变换操作符/微信图片_20190815132305.png"><h1 id="2-类型"><a href="#2-类型" class="headerlink" title="2. 类型"></a>2. 类型</h1><p>常见的变换操作符：</p><ul><li><code>Map()</code></li><li><code>FlatMap()</code></li><li><code>ContactMap()</code></li><li><code>Buffer()</code></li></ul><h1 id="3-详细说明"><a href="#3-详细说明" class="headerlink" title="3. 详细说明"></a>3. 详细说明</h1><h2 id="3-1-Map"><a href="#3-1-Map" class="headerlink" title="3.1 Map()"></a>3.1 Map()</h2><p>作用：对被观察者发送的每个事件都通过<strong>指定函数</strong>处理，从而变成另一个事件。即，<strong>将被观察者发送的事件转换为任意类型的事件</strong>。</p><img src="/2019/08/15/Android-RxJava：变换操作符/944365-a9c0b5eb2cc573d6.png"><p>应用场景：数据类型转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 被观察者发送事件：整型</span></span><br><span class="line">        emitter.onNext(<span class="number">1</span>);</span><br><span class="line">        emitter.onNext(<span class="number">2</span>);</span><br><span class="line">        emitter.onNext(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">        <span class="comment">// 使用Mapj变换操作符中的Function函数，对被观察者发送的事件进行统一变换，整型变成字符串类型</span></span><br><span class="line">        .map(<span class="keyword">new</span> Function&lt;Integer, String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"使用Map变换操作符，将事件"</span> + integer + <span class="string">"的参数从整型"</span> + integer + <span class="string">" 变换成字符串类型"</span> + integer;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 被观察者接收事件时，是接收到变换后的事件</span></span><br><span class="line">        Log.i(TAG, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="3-2-FlatMap"><a href="#3-2-FlatMap" class="headerlink" title="3.2 FlatMap()"></a>3.2 FlatMap()</h2><p>作用：将被观察者发送的事件序列进行<strong>拆分和单独转换</strong>，再合并成一个新的事件序列，最后再进行发送。</p><p>原理：</p><ol><li>为事件序列中的每个事件都创建一个<code>Observable</code>对象</li><li>将对每个原始事件转换后的新事件都放入到对应的<code>Observable</code>对象</li><li>将新建的每个<code>Observable</code>都合并到一个新建的、总的<code>Observable</code>对象</li><li>新建的、总的<code>Observable</code>对象将新合并的事件序列发送给观察者<code>Observer</code></li></ol><img src="/2019/08/15/Android-RxJava：变换操作符/944365-a6f852c071db2f15.png"><p>应用场景：无序的将被观察者发送的整个事件序列进行变换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        emitter.onNext(<span class="number">1</span>);</span><br><span class="line">        emitter.onNext(<span class="number">2</span>);</span><br><span class="line">        emitter.onNext(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">        <span class="comment">// 采用flatMap（）变换操作符</span></span><br><span class="line">        .flatMap(<span class="keyword">new</span> Function&lt;Integer, ObservableSource&lt;String&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ObservableSource&lt;String&gt; <span class="title">apply</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                    <span class="comment">// 通过flatMap中将被观察者生成的事件序列先进行拆分，再将每个事件转换为一个新的发送三个String事件</span></span><br><span class="line">                    <span class="comment">// 最终合并，再发送给被观察者</span></span><br><span class="line">                    list.add(<span class="string">"我是事件 "</span> + integer + <span class="string">"拆分后的子事件"</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> Observable.fromIterable(list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Log.d(TAG, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注：新合并的事件序列顺序是无序的，与旧序列发送事件的顺序无关。</p><h2 id="3-3-ContactMap"><a href="#3-3-ContactMap" class="headerlink" title="3.3 ContactMap()"></a>3.3 ContactMap()</h2><p>作用：与<code>FlatMap()</code>类似，区别在于：<strong>拆分及重新合并生成的事件序列的顺序就是被观察者旧序列生产的序列</strong>。</p><img src="/2019/08/15/Android-RxJava：变换操作符/944365-f4340f283e5a954d.png"><p>应用场景：有序的将被观察者发送的整个事件序列进行变换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        emitter.onNext(<span class="number">1</span>);</span><br><span class="line">        emitter.onNext(<span class="number">2</span>);</span><br><span class="line">        emitter.onNext(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">        <span class="comment">// 采用concatMap()变换操作符</span></span><br><span class="line">        .concatMap(<span class="keyword">new</span> Function&lt;Integer, ObservableSource&lt;String&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ObservableSource&lt;String&gt; <span class="title">apply</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">final</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                    <span class="comment">// 通过concatMap中将被观察者生产的事件序列先进行拆分，再将每个事件转换为一个新的发送三个String事件</span></span><br><span class="line">                    <span class="comment">// 最终合并，再发送给被观察者</span></span><br><span class="line">                    list.add(<span class="string">"我是事件 "</span> + integer + <span class="string">"拆分后的子事件"</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> Observable.fromIterable(list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Log.d(TAG, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注：新合并的事件序列顺序是有序的，即严格按照旧序列发送事件的顺序。</p><h2 id="3-4-Buffer"><a href="#3-4-Buffer" class="headerlink" title="3.4 Buffer()"></a>3.4 Buffer()</h2><p>作用：定期从被观察者<code>Observable</code>需要发送的事件中获取一定数量的事件并放到缓存区中，最终发送。</p><p>原理：</p><img src="/2019/08/15/Android-RxJava：变换操作符/944365-5278a339e4337494.png"><p>应用场景：缓存被观察者发送的事件</p><p><code>Bufer()</code>每次获取多少个事件放到缓存区中呢？下面看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被观察者需要发送5个数字</span></span><br><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        <span class="comment">// 设置缓存区大小和步长</span></span><br><span class="line">        <span class="comment">// 缓存区大小：每次从被观察者中获取的事件数量</span></span><br><span class="line">        <span class="comment">// 步长：每次获取新事件的数量</span></span><br><span class="line">        .buffer(<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Observer&lt;List&lt;Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(List&lt;Integer&gt; stringList)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                Log.d(TAG, <span class="string">" 缓存区里的事件数量 = "</span> + stringList.size());</span><br><span class="line">                <span class="keyword">for</span> (Integer value : stringList) &#123;</span><br><span class="line">                    Log.d(TAG, <span class="string">" 事件 = "</span> + value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"对Error事件作出响应"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"对Complete事件作出响应"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><img src="/2019/08/15/Android-RxJava：变换操作符/944365-f1d4e320b7c62dd9.png"><p>过程解释：</p><img src="/2019/08/15/Android-RxJava：变换操作符/944365-33a49ffd2ec60794.png"><p>Demo地址：<a href="https://gitee.com/QingFengBaiYu/Allen_Demo_Rx" target="_blank" rel="noopener">Allen_Demo_Rx</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-作用&quot;&gt;&lt;a href=&quot;#1-作用&quot; class=&quot;headerlink&quot; title=&quot;1. 作用&quot;&gt;&lt;/a&gt;1. 作用&lt;/h1&gt;&lt;p&gt;对事件序列中的事件/整个事件序列进行&lt;strong&gt;加工处理&lt;/strong&gt;（即变换），使得其转变成不同的事件/整个事
      
    
    </summary>
    
      <category term="Android" scheme="https://tylerLiu.top/categories/Android/"/>
    
      <category term="RxJava" scheme="https://tylerLiu.top/categories/Android/RxJava/"/>
    
    
      <category term="RxJava" scheme="https://tylerLiu.top/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>香煎土豆片</title>
    <link href="https://tylerLiu.top/2019/08/13/%E9%A6%99%E7%85%8E%E5%9C%9F%E8%B1%86%E7%89%87/"/>
    <id>https://tylerLiu.top/2019/08/13/香煎土豆片/</id>
    <published>2019-08-13T03:11:28.000Z</published>
    <updated>2019-08-13T03:14:07.585Z</updated>
    
    <content type="html"><![CDATA[<h1 id="食材"><a href="#食材" class="headerlink" title="食材"></a>食材</h1><p>土豆一个、豆瓣酱一勺、食用盐少许、生抽一勺、白芝麻一勺、孜然粉少许、香菜一根、小葱一根、蒜3瓣</p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ol><li>土豆削皮洗净，切成均匀的片，不要太薄</li><li>把切好的土豆片放在清水中泡一下，去掉一部分淀粉，热量更低，将泡好的土豆片水沥干，或者用厨房用纸擦去表面的水分</li><li>将蒜、香菜切碎</li><li>锅里放油，把土豆片两面煎黄</li><li>将煎好的土豆片盛出备用</li><li>锅里留少许油，放入辣椒酱、大蒜爆炒出香味</li><li>加入土豆片</li><li>加入生抽、加适量清水焖煮土豆片能使其嫩香、熟透，并且稀释残留淀粉</li><li>最后加入孜然粉、白芝麻，小葱、香菜翻炒均匀</li><li>喜欢吃麻辣的，多加一些辣椒和花椒，鲜香麻辣，非常下饭</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;食材&quot;&gt;&lt;a href=&quot;#食材&quot; class=&quot;headerlink&quot; title=&quot;食材&quot;&gt;&lt;/a&gt;食材&lt;/h1&gt;&lt;p&gt;土豆一个、豆瓣酱一勺、食用盐少许、生抽一勺、白芝麻一勺、孜然粉少许、香菜一根、小葱一根、蒜3瓣&lt;/p&gt;
&lt;h1 id=&quot;步骤&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="美食" scheme="https://tylerLiu.top/categories/%E7%BE%8E%E9%A3%9F/"/>
    
    
      <category term="美食" scheme="https://tylerLiu.top/tags/%E7%BE%8E%E9%A3%9F/"/>
    
  </entry>
  
  <entry>
    <title>绝味手撕鸡</title>
    <link href="https://tylerLiu.top/2019/08/13/%E7%BB%9D%E5%91%B3%E6%89%8B%E6%92%95%E9%B8%A1/"/>
    <id>https://tylerLiu.top/2019/08/13/绝味手撕鸡/</id>
    <published>2019-08-13T03:06:42.000Z</published>
    <updated>2019-08-13T03:10:10.845Z</updated>
    
    <content type="html"><![CDATA[<h1 id="食材"><a href="#食材" class="headerlink" title="食材"></a>食材</h1><p>三黄鸡、香菜、小葱、大蒜、生姜、小米椒、麻油、生抽、豉油</p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ol><li>将生姜切片，小葱洗净打结放入盘底</li><li>鸡清洗干净沥干放上盘，如果能放下整只鸡就不用切块，直接将生姜片和葱结放入鸡肚子就好</li><li>锅里放水，放上蒸架后，将整盘鸡放入锅中蒸30分钟左右</li><li>在蒸制的时候开始准备调料，将小米椒切圈，香菜切碎，蒜姜切末备用</li><li>倒入生抽、豉油、糖、香油，搅拌均匀</li><li>热锅入油，将蒜姜末和辣椒放入锅中煎至飘香</li><li>将煎好的蒜姜辣椒，趁烫倒入调好的酱汁中搅拌均匀</li><li>等鸡蒸好后从锅里拿出，用凉水冲去浮末，之后用厨房纸擦干，开始手撕鸡的过程，最好是连皮带肉地撕</li><li>最后将调好的酱汁，倒入撕好的鸡肉中搅拌均匀，在现有调料的基础上，还可以倒点香醋</li></ol><img src="/2019/08/13/绝味手撕鸡/6994716-e70594833273d29d.jpg">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;食材&quot;&gt;&lt;a href=&quot;#食材&quot; class=&quot;headerlink&quot; title=&quot;食材&quot;&gt;&lt;/a&gt;食材&lt;/h1&gt;&lt;p&gt;三黄鸡、香菜、小葱、大蒜、生姜、小米椒、麻油、生抽、豉油&lt;/p&gt;
&lt;h1 id=&quot;步骤&quot;&gt;&lt;a href=&quot;#步骤&quot; class=&quot;head
      
    
    </summary>
    
      <category term="美食" scheme="https://tylerLiu.top/categories/%E7%BE%8E%E9%A3%9F/"/>
    
    
      <category term="美食" scheme="https://tylerLiu.top/tags/%E7%BE%8E%E9%A3%9F/"/>
    
  </entry>
  
  <entry>
    <title>芋头焖排骨</title>
    <link href="https://tylerLiu.top/2019/08/13/%E8%8A%8B%E5%A4%B4%E7%84%96%E6%8E%92%E9%AA%A8/"/>
    <id>https://tylerLiu.top/2019/08/13/芋头焖排骨/</id>
    <published>2019-08-13T02:58:22.000Z</published>
    <updated>2019-08-13T03:03:21.745Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/08/13/芋头焖排骨/6994716-994622acd22be768.jpg"><h1 id="1-材料"><a href="#1-材料" class="headerlink" title="1. 材料"></a>1. 材料</h1><p>排骨、芋头、葱、蒜、盐、糖、料酒、酱油、油</p><h1 id="2-步骤"><a href="#2-步骤" class="headerlink" title="2. 步骤"></a>2. 步骤</h1><ol><li>排骨切块，加盐、糖、料酒、酱油，腌制1小时。</li></ol><img src="/2019/08/13/芋头焖排骨/6994716-60d5d60ffd4dad40.jpg"><ol start="2"><li>芋头切块，放入炒锅，煎至表面金黄，然后盛起备用。</li></ol><img src="/2019/08/13/芋头焖排骨/6994716-714f0a43ed0ee424.jpg"><ol start="3"><li>热锅入油，加入蒜爆炒，再加入排骨炒至上色，加入清水烧开。</li></ol><img src="/2019/08/13/芋头焖排骨/6994716-4c38d86744a52fe4.jpg"><ol start="4"><li>加入芋头、酱油和盐，焖30分钟。</li><li>大火收汁</li></ol><img src="/2019/08/13/芋头焖排骨/6994716-cb8bf8a4837c8bbe.jpg">]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/08/13/芋头焖排骨/6994716-994622acd22be768.jpg&quot;&gt;

&lt;h1 id=&quot;1-材料&quot;&gt;&lt;a href=&quot;#1-材料&quot; class=&quot;headerlink&quot; title=&quot;1. 材料&quot;&gt;&lt;/a&gt;1. 材料&lt;/h1&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="美食" scheme="https://tylerLiu.top/categories/%E7%BE%8E%E9%A3%9F/"/>
    
    
      <category term="美食" scheme="https://tylerLiu.top/tags/%E7%BE%8E%E9%A3%9F/"/>
    
  </entry>
  
  <entry>
    <title>Android RxJava：创建操作符</title>
    <link href="https://tylerLiu.top/2019/08/12/Android-RxJava%EF%BC%9A%E5%88%9B%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    <id>https://tylerLiu.top/2019/08/12/Android-RxJava：创建操作符/</id>
    <published>2019-08-12T07:40:55.000Z</published>
    <updated>2019-08-15T03:04:22.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h1><p>创建被观察者<code>Observable</code>对象，发送事件。</p><h1 id="2-类型"><a href="#2-类型" class="headerlink" title="2. 类型"></a>2. 类型</h1><p>创建操作符包括：</p><img src="/2019/08/12/Android-RxJava：创建操作符/944365-b02adb46075329b0.png"><h1 id="3-介绍及应用场景"><a href="#3-介绍及应用场景" class="headerlink" title="3. 介绍及应用场景"></a>3. 介绍及应用场景</h1><h2 id="3-1-基本创建"><a href="#3-1-基本创建" class="headerlink" title="3.1 基本创建"></a>3.1 基本创建</h2><p><strong>操作符：<code>create()</code></strong><br>场景：完整的创建被观察者对象，<code>RxJava</code>中创建被观察者对象最基本的操作符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建被观察者Observable对象</span></span><br><span class="line">Observable&lt;Integer&gt; observable1 = Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="comment">// create()是RxJava最基本的创建事件序列的方法</span></span><br><span class="line">    <span class="comment">// 此处传入一个OnSubscribe对象参数</span></span><br><span class="line">    <span class="comment">// 当observable被订阅时，OnSubscribe的call()方法会自动被调用，即事件序列就会按照设定次序依次被触发</span></span><br><span class="line">    <span class="comment">// 即观察者会依次调用对应事件的复写方法从而响应事件</span></span><br><span class="line">    <span class="comment">// 从而实现被观察者调用了观察者的回调方法并由被观察者向观察者的事件传递，即观察者模式</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 在复写的subscribe()中定义需要发送的事件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 通过ObservableEmitter类对象产生事件并通知观察者</span></span><br><span class="line">        <span class="comment">// ObservableEmitter类介绍：</span></span><br><span class="line">        <span class="comment">// a. 定义：事件发射器</span></span><br><span class="line">        <span class="comment">// b. 作用：定义需要发送的事件，并向观察者发送事件</span></span><br><span class="line">        emitter.onNext(<span class="number">1</span>);</span><br><span class="line">        emitter.onNext(<span class="number">2</span>);</span><br><span class="line">        emitter.onNext(<span class="number">3</span>);</span><br><span class="line">        emitter.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>采用链式调用：在<a href>补充示例地址</a>中也可以看到示例。</p><h2 id="3-2-快速创建和发送事件"><a href="#3-2-快速创建和发送事件" class="headerlink" title="3.2 快速创建和发送事件"></a>3.2 快速创建和发送事件</h2><p><strong>操作符：<code>just()</code></strong><br>场景：快速的创建被观察者对象，发送事件的特点为直接发送传入的事件，最多只能发送10个参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建时传入整型1,2,3,4</span></span><br><span class="line"><span class="comment">// 在创建后就会发送这些对象，相当于执行了onNext(1)、onNext(2)、onNext(3)、onNext(4)</span></span><br><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">        <span class="comment">// 至此，已经创建一个完整的Observable对象</span></span><br><span class="line">        <span class="comment">// 2. 通过通过订阅（subscribe）连接观察者和被观察者</span></span><br><span class="line">        <span class="comment">// 3. 创建观察者，定义响应事件的行为</span></span><br><span class="line">        .subscribe(<span class="keyword">new</span> Observer&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"开始采用subscribe连接"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"接收到了事件"</span> + value);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"对Error事件作出响应"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"对Complete事件作出响应"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p><strong>操作符：<code>fromArray()</code></strong><br>场景：快速创建被观察者<code>Observable</code>对象，以数组形式发送10个以上的事件，通过数组遍历元素。特点是直接发送传入的数组数据，在数组元素遍历时，会将数组中的数据转成<code>Observable</code>对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 设置需要传入的数组</span></span><br><span class="line">Integer[] items = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">// 2. 创建被观察者对象时传入数组</span></span><br><span class="line"><span class="comment">// 在创建后会将该数组中的元素转成Observable对象，并发送对象中的所有数据</span></span><br><span class="line">Observable.fromArray(items)</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Observer&lt;Integer&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">                        Log.d(TAG, <span class="string">"开始采用subscribe连接"</span>);</span><br><span class="line">                        Log.d(TAG, <span class="string">"数组遍历"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">                        Log.d(TAG, <span class="string">"接收到了事件"</span> + integer);</span><br><span class="line">                        Log.d(TAG, <span class="string">"数组中的元素 = "</span>+ integer  );</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                        Log.d(TAG, <span class="string">"对Error事件作出响应"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        Log.d(TAG, <span class="string">"对Complete事件作出响应"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure><p><strong>操作符：<code>fromIterable()</code></strong><br>场景：快速创建被观察者<code>Observable</code>对象，并以集合的形式发送10以上事件。特点是直接发送集合<code>list</code>数据，通过集合元素遍历，会将集合中的数据转成<code>Observable</code>对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 设置一个集合</span></span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="number">0</span>);</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 通过fromIterable()将集合中的对象/数据发送出去</span></span><br><span class="line">Observable.fromIterable(list)</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Observer&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"开始采用subscribe连接"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"接收到了事件"</span> + integer);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"对Error事件作出响应"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"对Complete事件作出响应"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>其他方法：以下方法一般用于测试：</p><ul><li><code>empty()</code>：该方法创建的被观察者对象发送事件的特点：仅发送<code>Complete</code>事件，即观察者接收后直接调用<code>onComplete()</code>。</li><li><code>error()</code>：特点是仅发送<code>Error</code>事件，直接通知异常，可以自定义异常，即观察者接收后直接调用<code>onError()</code>。</li><li><code>never()</code>：特点是不发送任何事件，即观察者接收后什么都不调用。</li></ul><h2 id="3-3-延迟创建"><a href="#3-3-延迟创建" class="headerlink" title="3.3 延迟创建"></a>3.3 延迟创建</h2><p><strong>操作符：<code>defer()</code></strong><br>场景：定时操作，在经过x秒后，自动执行y操作；周期性操作，每隔x秒后，自动执行y操作。</p><p>直到有观察者<code>Observer</code>订阅时，才动态创建被观察者对象<code>Observable</code>，并发送事件。</p><ol><li>通过<code>Osbervable</code>工厂方法创建被观察者对象<code>Observable</code></li><li>每次订阅后，都会得到一个刚创建的最新的<code>Observable</code>对象，这可以确保<code>Observable</code>对象里的数据是最新的。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次对i赋值</span></span><br><span class="line">Integer i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dodefer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过defer()定义被观察者对象</span></span><br><span class="line">    <span class="comment">// 注：此时被观察者还未被创建</span></span><br><span class="line">    Observable&lt;Integer&gt; observable = Observable.defer(<span class="keyword">new</span> Callable&lt;ObservableSource&lt;? extends Integer&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> ObservableSource&lt;? extends Integer&gt; call() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">return</span> Observable.just(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二次对i赋值</span></span><br><span class="line">    i = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 观察者开始订阅</span></span><br><span class="line">    <span class="comment">// 此时，才会调用defer()创建被观察者对象</span></span><br><span class="line">    observable.subscribe(<span class="keyword">new</span> Observer&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"开始采用subscribe连接"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"接收到的整数是"</span> + integer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"对Error事件作出响应"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"对Complete事件作出响应"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为在订阅时<code>Observable</code>才创建，所以<code>i</code>只会取第二次的赋值。</p><p><strong>操作符：<code>timer()</code></strong><br>场景：延迟指定时间，发送一个0，一般用于检测。快速创建一个<code>Observable</code>，特点是延迟指定时间后，发送一个数值0（<code>Long</code>类型），其本质就是延迟指定时间后，调用一次<code>onNext(0)</code>。</p><p>延迟指定事件，发送一个0，一般用于检测。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 延迟2秒后，发送一个long类型数值</span></span><br><span class="line">Observable.timer(<span class="number">2</span>, TimeUnit.SECONDS)</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Observer&lt;Long&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"开始采用subscribe连接"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Long aLong)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"接收到了事件"</span> + aLong);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"对Error事件作出响应"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"对Complete事件作出响应"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p><strong>操作符：<code>interval()</code></strong><br>场景：快速创建一个被观察者对象<code>Observable</code>，发送事件的特点：每隔指定时间就发送事件。发送事件的序列为，从0开始，无限递增1的整数序列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数说明：</span></span><br><span class="line"><span class="comment">// 参数1：第1次延迟时间</span></span><br><span class="line"><span class="comment">// 参数2：间隔时间数字</span></span><br><span class="line"><span class="comment">// 参数3：时间单位</span></span><br><span class="line">Observable.interval(<span class="number">3</span>, <span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">        <span class="comment">// 该例子发送的事件序列特点：延迟3s后发送事件，每隔1秒产生1个数字（从0开始递增1，无限个）</span></span><br><span class="line">        .subscribe(<span class="keyword">new</span> Observer&lt;Long&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"开始采用subscribe连接"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 默认最先调用复写的 onSubscribe（）</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Long aLong)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"接收到了事件"</span> + aLong);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"对Error事件作出响应"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"对Complete事件作出响应"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>注：<code>interval</code>默认在computation调度器上执行，也可以自定义指定线程调度器（第三个参数）：<code>interval(long, TimeUnit, Scheduler)</code>。</p><p><strong>操作符：<code>intervalRange()</code></strong><br>场景：快速创建一个被观察者对象<code>Observable</code>，发送事件的特点：每隔指定时间就发送事件，可指定发送的数据的数量。发送的事件序列为从0开始，无限递增1的整数序列，作用类似<code>interval()</code>，不同的是<code>intervalRange()</code>可以指定发送数据的数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数说明：</span></span><br><span class="line"><span class="comment">// 参数1:事件序列起始点</span></span><br><span class="line"><span class="comment">// 参数2:事件数量</span></span><br><span class="line"><span class="comment">// 参数3:第1次事件延迟发送时间</span></span><br><span class="line"><span class="comment">// 参数4:间隔时间数字</span></span><br><span class="line"><span class="comment">// 参数5:时间单位</span></span><br><span class="line">Observable.intervalRange(<span class="number">3</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">        <span class="comment">// 该例子发送的事件序列特点：</span></span><br><span class="line">        <span class="comment">// 1. 从3开始，一共发送10个事件；</span></span><br><span class="line">        <span class="comment">// 2. 第1次延迟2s发送，之后每隔2秒产生1个数字（从0开始递增1，无限个）</span></span><br><span class="line">        .subscribe(<span class="keyword">new</span> Observer&lt;Long&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"开始采用subscribe连接"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 默认最先调用复写的 onSubscribe（）</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Long value)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"接收到了事件"</span> + value);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"对Error事件作出响应"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"对Complete事件作出响应"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p><strong>操作符：<code>range()</code></strong><br>场景：快速创建一个被观察者对象<code>Observable</code>，发送事件的特点：连续发送一个事件序列，可指定范围。发送的事件序列为从0开始、无限递增1的的整数序列，作用类似于<code>intervalRange()</code>，区别在于，无延迟发送事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数说明：</span></span><br><span class="line"><span class="comment">// 参数1：事件序列起始点</span></span><br><span class="line"><span class="comment">// 参数2：事件数量</span></span><br><span class="line"><span class="comment">// 注：若设置为负数，则会抛出异常</span></span><br><span class="line">Observable.range(<span class="number">3</span>, <span class="number">10</span>)</span><br><span class="line">        <span class="comment">// 该例子发送的事件序列特点：从3开始发送，每次发送事件递增1，一共发送10个事件</span></span><br><span class="line">        .subscribe(<span class="keyword">new</span> Observer&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"开始采用subscribe连接"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 默认最先调用复写的 onSubscribe（）</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"接收到了事件"</span> + value);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"对Error事件作出响应"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"对Complete事件作出响应"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p><strong>操作符：<code>rangeLong()</code></strong><br>场景：作用类似于<code>range()</code>，区别在于该方法支持数据类型<code>Long</code>。使用与<code>range()</code>类似。</p><p>Demo地址：<a href="https://gitee.com/QingFengBaiYu/Allen_Demo_Rx" target="_blank" rel="noopener">Allen_Demo_Rx</a></p><img src="/2019/08/12/Android-RxJava：创建操作符/944365-101f852f6f0cd618.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-作用&quot;&gt;&lt;a href=&quot;#1-作用&quot; class=&quot;headerlink&quot; title=&quot;1. 作用&quot;&gt;&lt;/a&gt;1. 作用&lt;/h1&gt;&lt;p&gt;创建被观察者&lt;code&gt;Observable&lt;/code&gt;对象，发送事件。&lt;/p&gt;
&lt;h1 id=&quot;2-类型&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="Android" scheme="https://tylerLiu.top/categories/Android/"/>
    
      <category term="RxJava" scheme="https://tylerLiu.top/categories/Android/RxJava/"/>
    
    
      <category term="RxJava" scheme="https://tylerLiu.top/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>Android RxJava：入门</title>
    <link href="https://tylerLiu.top/2019/08/12/Android-RxJava%EF%BC%9A%E5%85%A5%E9%97%A8/"/>
    <id>https://tylerLiu.top/2019/08/12/Android-RxJava：入门/</id>
    <published>2019-08-12T01:43:32.000Z</published>
    <updated>2019-08-12T07:38:50.264Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>RxJava</code>是<strong>基于事件流的链式调用、逻辑简单且使用简单</strong>。</p><p>GitHub链接：</p><ul><li><a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="noopener">RxJava</a></li><li><a href="https://github.com/ReactiveX/RxAndroid" target="_blank" rel="noopener">RxAndroid</a></li></ul><ol><li>基于RxJava 2.0</li><li>在xJava 1.0上增加了一些新特性，基本原理和使用基本相同</li><li>后面还会介绍原理、操作符、应用场景、背压等</li></ol><img src="/2019/08/12/Android-RxJava：入门/944365-ecd603e8f8a76fa9.png"><h1 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h1><p>在GitHub上的介绍：</p><blockquote><p>RxJava – Reactive Extensions for the JVM – a library for composing asynchronous and event-based programs using observable sequences for the Java VM.<br>一个在Java JVM上使用可观测的序列来组成异步的、基于事件的程度的库。</p></blockquote><p>总结：<code>RxJava</code>是<strong>基于事件流、实现异步操作</strong>的库</p><h1 id="2-作用"><a href="#2-作用" class="headerlink" title="2. 作用"></a>2. 作用</h1><p>实现异步操作，类似Andorid中的<code>AsyncTask</code>、<code>Handler</code>的作用。</p><h1 id="3-特点"><a href="#3-特点" class="headerlink" title="3. 特点"></a>3. 特点</h1><p>由于<code>RxJava</code>的使用方式是<strong>基于事件流的链式调用</strong>，所以<code>RxJava</code>：</p><ul><li>逻辑简洁</li><li>实现优雅</li><li>使用简单</li></ul><h1 id="4-原理"><a href="#4-原理" class="headerlink" title="4. 原理"></a>4. 原理</h1><p>顾客到饭店点菜吃饭：</p><img src="/2019/08/12/Android-RxJava：入门/944365-4b85ca4862cd598b.png"><img src="/2019/08/12/Android-RxJava：入门/944365-07f12da4616b2b68.png"><p><code>RxJava</code>原理基于<strong>一种扩展的观察者模式</strong>，其中包含四个角色：</p><table><thead><tr><th align="center">角色</th><th align="center">作用</th><th align="center">类比</th></tr></thead><tbody><tr><td align="center">被观察者<code>Observable</code></td><td align="center">产生事件</td><td align="center">顾客</td></tr><tr><td align="center">观察者<code>Observer</code></td><td align="center">接收事件并给出响应动作</td><td align="center">厨房</td></tr><tr><td align="center">订阅<code>Subscribe</code></td><td align="center">连接被观察者和观察者</td><td align="center">服务员</td></tr><tr><td align="center">事件<code>Event</code></td><td align="center">被观察者和观察者沟通的载体</td><td align="center">菜式</td></tr></tbody></table><img src="/2019/08/12/Android-RxJava：入门/944365-5b6e7c8a3bb55f39.png"><img src="/2019/08/12/Android-RxJava：入门/944365-fc3b7eb5a0ad28d0.png"><p>总结：被观察者<code>Observable</code>通过订阅<code>Subscribe</code><strong>按顺序发送事件<code>Event</code></strong>给观察者<code>Observer</code>，观察者<code>Observer</code><strong>按顺序接收事件</strong>并作出对应的响应。</p><img src="/2019/08/12/Android-RxJava：入门/944365-98ec92df0a4d7e0b.png"><h1 id="5-基本使用"><a href="#5-基本使用" class="headerlink" title="5. 基本使用"></a>5. 基本使用</h1><p>使用方式有两种：</p><ol><li>分步骤实现：该方法主要是为了深入说明<code>RxJava</code>的原理和使用，用于演示</li><li>基于事件流的链式调用，用于实际开发</li></ol><h2 id="5-1-分步骤实现"><a href="#5-1-分步骤实现" class="headerlink" title="5.1 分步骤实现"></a>5.1 分步骤实现</h2><h3 id="5-1-1-使用步骤"><a href="#5-1-1-使用步骤" class="headerlink" title="5.1.1 使用步骤"></a>5.1.1 使用步骤</h3><ol><li>创建被观察者<code>Observable</code>并生产事件，对应顾客进入饭店-坐下-点菜</li><li>创建观察者<code>Observer</code>并定义响应事件的行为，即厨房确定对应菜式</li><li>通过订阅<code>Subscribe</code>连接观察者和被观察者，即顾客找到服务员-服务员下单到厨房-厨房烹制</li></ol><h3 id="5-1-2-步骤详解"><a href="#5-1-2-步骤详解" class="headerlink" title="5.1.2 步骤详解"></a>5.1.2 步骤详解</h3><h4 id="步骤1：创建被观察者Observable并生产事件"><a href="#步骤1：创建被观察者Observable并生产事件" class="headerlink" title="步骤1：创建被观察者Observable并生产事件"></a>步骤1：创建被观察者Observable并生产事件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RxJavaActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_rx_java);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 创建被观察者Observable对象</span></span><br><span class="line">        Observable&lt;Integer&gt; observable1 = Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="comment">// create()是RxJava最基本的创建事件序列的方法</span></span><br><span class="line">            <span class="comment">// 此处传入一个OnSubscribe对象参数</span></span><br><span class="line">            <span class="comment">// 当observable被订阅时，OnSubscribe的call()方法会自动被调用，即事件序列就会按照设定次序依次被触发</span></span><br><span class="line">            <span class="comment">// 即观察者会依次调用对应事件的复写方法从而响应事件</span></span><br><span class="line">            <span class="comment">// 从而实现被观察者调用了观察者的回调方法并由被观察者向观察者的事件传递，即观察者模式</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 在复写的subscribe()中定义需要发送的事件</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="comment">// 通过ObservableEmitter类对象产生事件并通知观察者</span></span><br><span class="line">                <span class="comment">// ObservableEmitter类介绍：</span></span><br><span class="line">                <span class="comment">// a. 定义：事件发射器</span></span><br><span class="line">                <span class="comment">// b. 作用：定义需要发送的事件，并向观察者发送事件</span></span><br><span class="line">                emitter.onNext(<span class="number">1</span>);</span><br><span class="line">                emitter.onNext(<span class="number">2</span>);</span><br><span class="line">                emitter.onNext(<span class="number">3</span>);</span><br><span class="line">                emitter.onComplete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 扩展：RxJava提供了其他方法用于创建被观察者Observable</span></span><br><span class="line">        <span class="comment">// 方法1：just()：直接将传入的参数依次发送出来</span></span><br><span class="line">        Observable observable2 = Observable.just(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>);</span><br><span class="line">        <span class="comment">// 将会依次调用：</span></span><br><span class="line">        <span class="comment">// onNext("A");</span></span><br><span class="line">        <span class="comment">// onNext("B");</span></span><br><span class="line">        <span class="comment">// onNext("C");</span></span><br><span class="line">        <span class="comment">// onCompleted();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法2：from(T []) / from(Iterable&lt;? extends T&gt;)：将传入的数组 / Iterable拆分成具体对象后，依次发送出来</span></span><br><span class="line">        String[] words = &#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>&#125;;</span><br><span class="line">        Observable observable3 = Observable.fromArray(words);</span><br><span class="line">        <span class="comment">// 将会依次调用：</span></span><br><span class="line">        <span class="comment">// onNext("A");</span></span><br><span class="line">        <span class="comment">// onNext("B");</span></span><br><span class="line">        <span class="comment">// onNext("C");</span></span><br><span class="line">        <span class="comment">// onCompleted();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="步骤2：创建观察者Observer并定义响应事件的行为"><a href="#步骤2：创建观察者Observer并定义响应事件的行为" class="headerlink" title="步骤2：创建观察者Observer并定义响应事件的行为"></a>步骤2：创建观察者Observer并定义响应事件的行为</h4><p>发生的事件类型包括：<code>Next</code>事件、<code>Complete</code>事件、<code>Error</code>事件。</p><ul><li><code>Next</code>：<code>onNext()</code>，普通事件，用于向观察者发送需要响应事件的信号，被观察者可发送无限个<code>Next</code>事件，观察者可以接收无限个<code>Next</code>事件。</li><li><code>Complete</code>：<code>onCompleted()</code>，事件队列完结事件，<code>RxJava</code>把所有事件当做队列处理，标志被观察者不再发送普通事件<code>Next</code>。当被观察者发送一个<code>Complete</code>事件后，被观察者在<code>Complete</code>事件后的事件将会继续发送，但观察者收到<code>Complete</code>之后将不会再接收任何事件；被观察者可以不发送<code>Complete</code>事件。</li><li><code>Error</code>：<code>onError()</code>，事件队列异常事件，标志事件处理过程中出现异常，此时队列自动终止，不允许事件发出。当被观察者发送一个<code>Error</code>事件后，被观察者在<code>Error</code>事件后的事件将会继续发送，但观察者收到<code>Error</code>事件后将不再继续接收任何事件；被观察者可以不发送<code>Error</code>事件。</li><li>在一个正确运行的事件序列中，<code>onCompleted()</code>和<code>onError()</code>互斥，二者只能有一个。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1：采用Observer接口</span></span><br><span class="line"><span class="comment">// 1. 创建观察者Observer对象</span></span><br><span class="line">Observer&lt;Integer&gt; observer1 = <span class="keyword">new</span> Observer&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="comment">// 2. 创建对象时通过对应复写对应事件方法 从而 响应对应事件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 观察者接收事件前，默认最先调用复写onSubscribe()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"开始采用subscribe连接"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当被观察者生产Next事件，观察者接收到时，会调用该复写方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"对Next事件作出响应"</span> + integer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当被观察者生产Error事件，观察者接收到时，会调用该复写方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"对Error事件作出响应"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当被观察者生产Complete事件，观察者接收到时，会调用该复写方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"对Complete事件作出响应"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2：采用Subscriber抽象类，没有找到，可能已经删除</span></span><br><span class="line"><span class="comment">// Subscriber类是RxJava内置的一个实现了Observer的抽象类，对Observer接口进行了扩展</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 创建观察者Observer对象</span></span><br><span class="line">Subscriber&lt;Integer&gt; observer2 = <span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="comment">// 2. 创建对象时通过对应复写对应事件方法，从而响应对应事件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription s)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"开始采用subscribe连接"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"对Next事件作出响应"</span> + integer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"对Error事件作出响应"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"对Complete事件作出响应"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>两种方式的对比：<br>相同点：</p><ul><li>使用方式完全一致，实际上，在<code>RxJava</code>的<code>subscribe()</code>中，<code>Observer</code>会先转换成<code>Subscriber</code>后再使用。</li></ul><p>不同点：<code>Subscriber</code>抽象类对<code>Observer</code>接口进行了扩展，新增了两个方法，</p><ul><li><code>onStart()</code>：在还未响应事件前调用，用于做一些初始化操作</li><li><code>unsubscribe()</code>：取消订阅、该方法被调用后，观察者将不再接收和响应事件。调用前，先使用<code>isUnsubscribed()</code>判断状态，确定被观察者<code>Observable</code>是否还持有观察者<code>Subscriber</code>的引用，如果引用不能及时释放，会造成内存泄露。</li></ul><h4 id="步骤3：通过订阅Subscribe连接观察者和被观察者"><a href="#步骤3：通过订阅Subscribe连接观察者和被观察者" class="headerlink" title="步骤3：通过订阅Subscribe连接观察者和被观察者"></a>步骤3：通过订阅Subscribe连接观察者和被观察者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">observable.subscribe(observer);</span><br></pre></td></tr></table></figure><h2 id="5-2-基于事件流的链式调用"><a href="#5-2-基于事件流的链式调用" class="headerlink" title="5.2 基于事件流的链式调用"></a>5.2 基于事件流的链式调用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RxJava的链式操作</span></span><br><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="comment">// 1. 创建被观察者，生产事件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        emitter.onNext(<span class="number">1</span>);</span><br><span class="line">        emitter.onNext(<span class="number">2</span>);</span><br><span class="line">        emitter.onNext(<span class="number">3</span>);</span><br><span class="line">        emitter.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(<span class="keyword">new</span> Observer&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="comment">// 2. 通过订阅subscribe连接观察者和被观察者</span></span><br><span class="line">    <span class="comment">// 3. 创建观察者，定义响应事件的行为</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"开始采用subscribe连接"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"对Next事件"</span> + integer + <span class="string">"作出响应"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"对Error事件作出响应"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"对Complete事件作出响应"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>整体方法调用顺序：<code>观察者.onSubscribe()</code> -&gt; <code>被观察者.subscribe()</code> -&gt; <code>观察者.onNext()</code> -&gt; <code>观察者.onComplete()</code>。</p><p><code>RxJava 2.X</code>提供了多个函数式接口，用于实现观察者模式：</p><img src="/2019/08/12/Android-RxJava：入门/944365-abda1c2bef8681f3.png"><p>以<code>Customer</code>为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="string">"hello"</span>).subscribe(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">        <span class="comment">// 每次接收到Observable的事件都会调用Consumer.accept（）</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Log.d(TAG, s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h1 id="6-额外说明"><a href="#6-额外说明" class="headerlink" title="6. 额外说明"></a>6. 额外说明</h1><p>使用<code>Disposable.dispose()</code>切断观察者和被观察者之间的连接，即观察者无法继续接收被观察者的事件，但被观察者可以继续发送事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Observer&lt;Integer&gt; observer = <span class="keyword">new</span> Observer&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="comment">// 定义Disposable</span></span><br><span class="line">        <span class="keyword">private</span> Disposable mDisposable;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"开始采用subscribe连接"</span>);</span><br><span class="line">            <span class="comment">// 对disposable赋值</span></span><br><span class="line">            mDisposable = d;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"对Next事件"</span> + integer + <span class="string">"作出响应"</span>);</span><br><span class="line">            <span class="keyword">if</span> (integer == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">// 设置在接收到第二个事件后切换观察者和被观察者的连接</span></span><br><span class="line">                mDisposable.dispose();</span><br><span class="line">                Log.d(TAG, <span class="string">"已经切断了连接："</span> + mDisposable.isDisposed());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"对Error事件作出响应"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"对Complete事件作出响应"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;RxJava&lt;/code&gt;是&lt;strong&gt;基于事件流的链式调用、逻辑简单且使用简单&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;GitH
      
    
    </summary>
    
      <category term="Android" scheme="https://tylerLiu.top/categories/Android/"/>
    
      <category term="RxJava" scheme="https://tylerLiu.top/categories/Android/RxJava/"/>
    
    
      <category term="RxJava" scheme="https://tylerLiu.top/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>Android Jetpack：WorkManager</title>
    <link href="https://tylerLiu.top/2019/08/09/Android-Jetpack-WorkManager/"/>
    <id>https://tylerLiu.top/2019/08/09/Android-Jetpack-WorkManager/</id>
    <published>2019-08-09T00:45:17.000Z</published>
    <updated>2019-08-22T03:14:00.492Z</updated>
    
    <content type="html"><![CDATA[<p>这里的数据不是从网络请求获取的，而是从assets目录下的json读取出来的，通常，从文件读取数据不会放在主线程中执行，这里使用了<code>WorkManager</code>，使能够在后台线程进行数据初始化。</p><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><p>官方文档：<a href="https://developer.android.google.cn/topic/libraries/architecture/workmanager" target="_blank" rel="noopener">WorkManger</a><br>WorkManger介绍视频：<a href="https://www.bilibili.com/video/av56276889/" target="_blank" rel="noopener">中文官方介绍视频</a></p><h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h2><p>官方介绍：</p><blockquote><p>The WorkManager API makes it easy to schedule deferrable, asynchronous tasks that are expected to run even if the app exits or device restarts.<br>直译：WorkManager API使调度可延迟的异步任务变得很容易，即使应用程序退出或设备重启，这些任务也会运行。</p></blockquote><h2 id="1-2-选择WorkManager的理由"><a href="#1-2-选择WorkManager的理由" class="headerlink" title="1.2 选择WorkManager的理由"></a>1.2 选择WorkManager的理由</h2><p>Android中处理后台任务的选择很多，如<code>Service</code>、<code>DownloadManager</code>、<code>AlarmManager</code>、<code>JobScheduler</code>等， 为什么还要有<code>WorkManager</code>？</p><ol><li>兼容性更强，可以兼容到API 14</li><li>可以指定约束条件，比如可以选择必须在有网络的条件下执行</li><li>可以定时执行，也可以单次执行</li><li>监听和管理任务状态</li><li>多个任务可以使用任务链</li><li>保证任务执行，如当前执行条件不满足或者APP进程被杀死，它会等到下次条件满足或者APP进行打开后执行</li><li>支持省电模式</li></ol><h2 id="1-3-多线程任务如何选择？"><a href="#1-3-多线程任务如何选择？" class="headerlink" title="1.3 多线程任务如何选择？"></a>1.3 多线程任务如何选择？</h2><p>后台任务会消耗设备的系统资源，若处理不当，可能会造成设备电量的消耗，给用户带来不好的体验。所以，选择正确的后台处理方式很重要，下面是官方给出的选择方式：</p><img src="/2019/08/09/Android-Jetpack-WorkManager/9271486-08aecd36506de3e3.webp"><p>关于后台的的知识，需要补充阅读：<a href="https://juejin.im/post/5b04d064f265da0b80711759#heading-3" target="_blank" rel="noopener">[译]从Service到WorkManager</a>。</p><h1 id="2-Demo"><a href="#2-Demo" class="headerlink" title="2. Demo"></a>2. Demo</h1><p>实现：选取一张图片，做模糊处理，然后显示在头像上。</p><h2 id="2-1-添加依赖"><a href="#2-1-添加依赖" class="headerlink" title="2.1 添加依赖"></a>2.1 添加依赖</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">"androidx.work:work-runtime-ktx:2.2.0-rc01"</span></span><br></pre></td></tr></table></figure><h2 id="2-2-自定义Worker"><a href="#2-2-自定义Worker" class="headerlink" title="2.2 自定义Worker"></a>2.2 自定义Worker</h2><p>自定义<code>worker</code>之前，先看看<code>WorkerManager</code>中几个重要的类：</p><ul><li><code>Worker</code>：需要继承<code>Worker</code>，并复写<code>doWork()</code>方法，在里面写入需要在后台执行的代码</li><li><code>WorkRequest</code>：指后台工作的请求，可以在后台工作的请求中添加约束条件</li><li><code>WorkManager</code>：真正让<code>Worker</code>在后台执行的类</li></ul><p><code>WorkerManager</code>的执行流程：</p><img src="/2019/08/09/Android-Jetpack-WorkManager/9271486-89d8c86a5d8a4395.webp"><ol><li><code>WorkRequest</code>生成以后，<code>Internal TaskExecutor</code>将它存入<code>WorkManager</code>的数据库中，这也是为什么即使在程序退出之后，<code>WorkManager</code>也能保证后台任务在下次启动后条件满足的情况下执行。</li><li>当约束条件满足的情况下，<code>Internal TaskExecutor</code>告诉<code>WorkFactory</code>生成<code>Worker</code>。</li><li>后台执行<code>Worker</code>任务。</li></ol><p>下面自定义一个<code>Worker</code>，目标是生成一张模糊图片，包含：清除之前的缓存路径，、图片模糊处理和图片的生成。将这三个步骤分成三个后台任务，三个后台任务分别涉及到无变量的情况、往外传参数和读取参数三种情况。</p><h3 id="2-2-1-清除缓存路径：无变量情况（通常情况）"><a href="#2-2-1-清除缓存路径：无变量情况（通常情况）" class="headerlink" title="2.2.1 清除缓存路径：无变量情况（通常情况）"></a>2.2.1 清除缓存路径：无变量情况（通常情况）</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清理临时文件的Worker</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Liuyang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CleanUpWorker</span></span>(context: Context, params: WorkerParameters) : Worker(context, params) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> TAG <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        <span class="keyword">this</span>::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>.<span class="title">simpleName</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWork</span><span class="params">()</span></span>: Result &#123;</span><br><span class="line">        <span class="comment">// Makes a notification when the work starts and slows down the work so that</span></span><br><span class="line">        <span class="comment">// it's easier to see each WorkRequest start, even on emulated devices</span></span><br><span class="line">        makeStatusNotification(<span class="string">"Cleaning up old temporary files"</span>, applicationContext)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// sleep()</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 删除逻辑</span></span><br><span class="line">            <span class="keyword">val</span> outputDir = File(applicationContext.filesDir, BaseConstant.OUTPUT_PATH)</span><br><span class="line">            <span class="keyword">if</span> (outputDir.exists()) &#123;</span><br><span class="line">                <span class="keyword">val</span> entries = outputDir.listFiles()</span><br><span class="line">                <span class="keyword">if</span> (entries != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (entry <span class="keyword">in</span> entries) &#123;</span><br><span class="line">                        <span class="keyword">val</span> name = entry.name</span><br><span class="line">                        <span class="keyword">if</span> (name.isNotEmpty() &amp;&amp; name.endsWith(<span class="string">".png"</span>)) &#123;</span><br><span class="line">                            <span class="keyword">val</span> deleted = entry.delete()</span><br><span class="line">                            Log.i(TAG, String.format(<span class="string">"Deleted %s - %s"</span>, name, deleted))</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 成功</span></span><br><span class="line">            Result.success()</span><br><span class="line">        &#125; <span class="keyword">catch</span> (exception: Exception) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"Error cleaning up"</span>, exception)</span><br><span class="line">            <span class="comment">// 失败</span></span><br><span class="line">            Result.failure()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-2-图片模糊处理：往外传参数（输出参数）"><a href="#2-2-2-图片模糊处理：往外传参数（输出参数）" class="headerlink" title="2.2.2 图片模糊处理：往外传参数（输出参数）"></a>2.2.2 图片模糊处理：往外传参数（输出参数）</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模糊处理的worker</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Liuyang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlurWorker</span></span>(context: Context, params: WorkerParameters) : Worker(context, params) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> TAG: String = <span class="keyword">this</span>::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>.<span class="title">simpleName</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWork</span><span class="params">()</span></span>: Result &#123;</span><br><span class="line">        <span class="keyword">val</span> context = applicationContext</span><br><span class="line">        <span class="keyword">val</span> resultUri = inputData.getString(BaseConstant.KEY_IMAGE_URI)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知开始处理图片</span></span><br><span class="line">        makeStatusNotification(<span class="string">"Blurring image"</span>, context)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 图片处理逻辑</span></span><br><span class="line">            <span class="keyword">if</span> (TextUtils.isEmpty(resultUri)) &#123;</span><br><span class="line">                Log.e(TAG, <span class="string">"Invalid input uri"</span>)</span><br><span class="line">                <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"Invalid input uri"</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> resolver = context.contentResolver</span><br><span class="line">            <span class="keyword">val</span> picture = BitmapFactory.decodeStream(resolver.openInputStream(Uri.parse(resultUri)))</span><br><span class="line">            <span class="comment">// 创建Bitmap文件</span></span><br><span class="line">            <span class="keyword">val</span> output = blurBitmap(picture, context)</span><br><span class="line">            <span class="comment">// 存入路径</span></span><br><span class="line">            <span class="keyword">val</span> outputUri = writeBitmapToFile(context, output)</span><br><span class="line">            <span class="comment">// 输出路径</span></span><br><span class="line">            <span class="keyword">val</span> outputData = workDataOf(BaseConstant.KEY_IMAGE_URI to outputUri.toString())</span><br><span class="line">            makeStatusNotification(<span class="string">"Output is <span class="variable">$outputUri</span>"</span>, context)</span><br><span class="line">            Result.success(outputData)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (throwable: Throwable) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"Error applying blur"</span>, throwable)</span><br><span class="line">            Result.failure()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-3-图片生成：读取参数"><a href="#2-2-3-图片生成：读取参数" class="headerlink" title="2.2.3 图片生成：读取参数"></a>2.2.3 图片生成：读取参数</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存储照片的worker</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Liuyang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SaveImageToFileWorker</span></span>(context: Context, parameters: WorkerParameters) : Worker(context, parameters) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> TAG <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        SaveImageToFileWorker::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>.<span class="title">simpleName</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> title = <span class="string">"Blurred Image"</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> dateFormatter = SimpleDateFormat(<span class="string">"yyyy.MM.dd 'at' HH:mm:ss z"</span>, Locale.getDefault())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWork</span><span class="params">()</span></span>: Result &#123;</span><br><span class="line">        <span class="comment">// Makes a notification when the work starts and slows down the work so that</span></span><br><span class="line">        <span class="comment">// it's easier to see each WorkRequest start, even on emulated devices</span></span><br><span class="line">        makeStatusNotification(<span class="string">"Saving image"</span>, applicationContext)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// sleep()</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> resolver = applicationContext.contentResolver</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取从外部传入的参数</span></span><br><span class="line">            <span class="keyword">val</span> resourceUri = inputData.getString(BaseConstant.KEY_IMAGE_URI)</span><br><span class="line">            <span class="keyword">val</span> bitmap = BitmapFactory.decodeStream(resolver.openInputStream(Uri.parse(resourceUri)))</span><br><span class="line">            <span class="keyword">val</span> imageUrl = MediaStore.Images.Media.insertImage(resolver, bitmap, title, dateFormatter.format(Date()))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!imageUrl.isNullOrEmpty()) &#123;</span><br><span class="line">                <span class="keyword">val</span> output = workDataOf(BaseConstant.KEY_IMAGE_URI to imageUrl)</span><br><span class="line">                Result.success()</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Log.e(TAG, <span class="string">"Writing to MediaStore failed"</span>)</span><br><span class="line">                Result.failure()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (exception: Exception) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"Unable to save image to Gallery"</span>, exception)</span><br><span class="line">            Result.failure()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-创建WorkManager"><a href="#2-3-创建WorkManager" class="headerlink" title="2.3 创建WorkManager"></a>2.3 创建WorkManager</h2><p>在model中单例获取：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MeModel</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> userRepository: UserRepository) : ViewModel() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> workManager = WorkManager.getInstance()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-构建WorkRequest"><a href="#2-4-构建WorkRequest" class="headerlink" title="2.4 构建WorkRequest"></a>2.4 构建WorkRequest</h2><p><code>WorkRequest</code>可以分为两类：</p><ul><li><code>PeriodicWorkRequest</code>：Periodic，周期；多次、定时执行任务请求，不支持任务链</li><li><code>OneTimeWorkRequest</code>：只执行一次的任务请求，支持任务链</li></ul><ol><li><p>执行一个任务<br>以<code>OneTimeWorkRequest</code>为例，如果只有一个任务请求：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> request = OneTimeWorkRequest.from(CleanUpWorker::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">workManager.enqueue(request)</span><br></pre></td></tr></table></figure></li><li><p>执行多个任务<br>例子中有三个<code>Worker</code>，并且里面有先后执行的顺序，所以可以使用任务链：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多任务按顺序执行</span></span><br><span class="line">workManager.beginWith(</span><br><span class="line">    mutableListOf(</span><br><span class="line">        OneTimeWorkRequest.from(CleanUpWorker::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">    ))</span><br><span class="line">    .then(OneTimeWorkRequestBuilder&lt;BlurWorker&gt;().setInputData(createInputDataForUri()).build())</span><br><span class="line">    .then(OneTimeWorkRequestBuilder&lt;SaveImageToFileWorker&gt;().build())</span><br><span class="line">    .enqueue()</span><br></pre></td></tr></table></figure></li></ol><p>假设多次点击图片更换头像，提交多次请求，由于网络原因（Demo中没有网络请求部分），最后返回的很可能不是最后一次请求的图片，这显然是有问题的，<code>WorkManager</code>可能满足这样的需求，保证任务的唯一性：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多任务按顺序执行</span></span><br><span class="line">workManager.beginUniqueWork(</span><br><span class="line">    IMAGE_MANIPULATION_WORK_NAME, <span class="comment">// 任务名称</span></span><br><span class="line">    ExistingWorkPolicy.REPLACE, <span class="comment">// 任务相同的执行策略 分为REPLACE，KEEP，APPEND</span></span><br><span class="line">    mutableListOf(</span><br><span class="line">        OneTimeWorkRequest.from(CleanUpWorker::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>) </span></span><br><span class="line">    ))</span><br><span class="line">    .then(OneTimeWorkRequestBuilder&lt;BlurWorker&gt;().setInputData(createInputDataForUri()).build())</span><br><span class="line">    .then(OneTimeWorkRequestBuilder&lt;SaveImageToFileWorker&gt;().build())</span><br><span class="line">    .enqueue()</span><br></pre></td></tr></table></figure><p><strong>无顺序多任务</strong></p><p>如果并行执行没有顺序的多个任务，无论是<code>beginUniqueWork</code>还是<code>beginWith</code>方法都可以接收一个<code>List&lt;OneTimeWorkRequest&gt;</code>。</p><ol start="3"><li>使用约束<br>假设需要将生成的图片上传到服务器，并且需要将图片同时保存到本地，这是就需要设备联网并且由足够的存储空间，这时，就可以给<code>WorkRequest</code>指明约束条件：<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建约束条件</span></span><br><span class="line"><span class="keyword">val</span> constraints = Constraints.Builder()</span><br><span class="line">    .setRequiresBatteryNotLow(<span class="literal">true</span>)<span class="comment">// 非电池低电量</span></span><br><span class="line">    .setRequiredNetworkType(NetworkType.CONNECTED)<span class="comment">// 网络连接的情况</span></span><br><span class="line">    .setRequiresStorageNotLow(<span class="literal">true</span>)<span class="comment">// 存储空间充足</span></span><br><span class="line">    .build()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储照片</span></span><br><span class="line"><span class="keyword">val</span> save = OneTimeWorkRequestBuilder&lt;SaveImageToFileWorker&gt;()</span><br><span class="line">    .setConstraints(constraints)</span><br><span class="line">    .addTag(BaseConstant.TAG_OUTPUT)</span><br><span class="line">    .build()</span><br><span class="line">continuation = continuation.then(save)</span><br></pre></td></tr></table></figure></li></ol><p>可以指明的约束条件有：电池电量、充电、网络、存储和延迟等。</p><p>下面是Demo中的具体使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MeModel</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> userRepository: UserRepository) : ViewModel() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> imageUri: Uri? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> outPutUri: Uri? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> outPutWorkInfo: LiveData&lt;List&lt;WorkInfo&gt;&gt;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> workManager = WorkManager.getInstance()</span><br><span class="line">    <span class="keyword">val</span> use = userRepository.findUserById(AppPrefsUtils.getLong(BaseConstant.SP_USER_ID))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        outPutWorkInfo = workManager.getWorkInfosByTagLiveData(BaseConstant.TAG_OUTPUT)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">applyBlur</span><span class="params">(blurLevel: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> continuation = workManager.beginUniqueWork(</span><br><span class="line">            BaseConstant.IMAGE_MANIPULATION_WORK_NAME,</span><br><span class="line">            ExistingWorkPolicy.REPLACE,</span><br><span class="line">            OneTimeWorkRequest.from(CleanUpWorker::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until blurLevel) &#123;</span><br><span class="line">            <span class="keyword">val</span> builder = OneTimeWorkRequestBuilder&lt;BlurWorker&gt;()</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                builder.setInputData(createInputDataForUri())</span><br><span class="line">            &#125;</span><br><span class="line">            continuation = continuation.then(builder.build())</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建约束条件</span></span><br><span class="line">        <span class="keyword">val</span> constraints = Constraints.Builder()</span><br><span class="line">            .setRequiresBatteryNotLow(<span class="literal">true</span>)<span class="comment">// 非电池低电量</span></span><br><span class="line">            .setRequiredNetworkType(NetworkType.CONNECTED)<span class="comment">// 网络连接的情况</span></span><br><span class="line">            .setRequiresStorageNotLow(<span class="literal">true</span>)<span class="comment">// 存储空间充足</span></span><br><span class="line">            .build()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储照片</span></span><br><span class="line">        <span class="keyword">val</span> save = OneTimeWorkRequestBuilder&lt;SaveImageToFileWorker&gt;()</span><br><span class="line">            .setConstraints(constraints)</span><br><span class="line">            .addTag(BaseConstant.TAG_OUTPUT)</span><br><span class="line">            .build()</span><br><span class="line">        continuation = continuation.then(save)</span><br><span class="line"></span><br><span class="line">        continuation.enqueue()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">createInputDataForUri</span><span class="params">()</span></span>: Data &#123;</span><br><span class="line">        <span class="keyword">val</span> builder = Data.Builder()</span><br><span class="line">        imageUri?.let &#123;</span><br><span class="line">            builder.putString(BaseConstant.KEY_IMAGE_URI, imageUri.toString())</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> builder.build()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">uriOrNull</span><span class="params">(uriString: <span class="type">String</span>?)</span></span>: Uri? &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (!uriString.isNullOrEmpty()) &#123;</span><br><span class="line">            Uri.parse(uriString)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">setImageUri</span><span class="params">(uri: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">        imageUri = uriOrNull(uri)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">setOutputUri</span><span class="params">(uri: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">        outPutUri = uriOrNull(uri)</span><br><span class="line">        <span class="keyword">val</span> value = use.value</span><br><span class="line">        value?.headImage = uri!!</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">            viewModelScope.launch &#123;</span><br><span class="line">                userRepository.updateUser(value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">cancelWork</span><span class="params">()</span></span> &#123;</span><br><span class="line">        workManager.cancelUniqueWork(BaseConstant.IMAGE_MANIPULATION_WORK_NAME)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-取消任务"><a href="#2-5-取消任务" class="headerlink" title="2.5 取消任务"></a>2.5 取消任务</h2><p>如果要取消任务<code>workManager.cancelAllWork()</code>，如果要取消上面执行的唯一任务，需要上面唯一的任务名：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">cancelWork</span><span class="params">()</span></span> &#123;</span><br><span class="line">    workManager.cancelUniqueWork(BaseConstant.IMAGE_MANIPULATION_WORK_NAME)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-6-观察任务状态"><a href="#2-6-观察任务状态" class="headerlink" title="2.6 观察任务状态"></a>2.6 观察任务状态</h2><p>任务状态的变化过程：</p><img src="/2019/08/09/Android-Jetpack-WorkManager/9271486-76a29dfd83e152e0.webp"><p>其中，<code>SUCCESS</code>、<code>FAILED</code>、<code>CALCELLED</code>都属于任务已经完成。观察任务状态需要使用到<code>LiveData</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class MeModel(private val userRepository: UserRepository) : ViewModel() &#123;</span><br><span class="line">    private var imageUri: Uri? = null</span><br><span class="line">    private var outPutUri: Uri? = null</span><br><span class="line">    var outPutWorkInfo: LiveData&lt;List&lt;WorkInfo&gt;&gt;</span><br><span class="line">    private val workManager = WorkManager.getInstance()</span><br><span class="line">    val use = userRepository.findUserById(AppPrefsUtils.getLong(BaseConstant.SP_USER_ID))</span><br><span class="line"></span><br><span class="line">    init &#123;</span><br><span class="line">        outPutWorkInfo = workManager.getWorkInfosByTagLiveData(BaseConstant.TAG_OUTPUT)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当图片处理时，程序弹出加载框，图片处理完成，程序会将图片路径保存到<code>User</code>里的<code>headImage</code>并存储到数据库中，任务状态观测参见<code>MeFragment</code>中的<code>onSubscribeUi()</code>中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 我的界面</span><br><span class="line"> *</span><br><span class="line"> * @author Liuyang</span><br><span class="line"> * @date 2019/8/11</span><br><span class="line"> */</span><br><span class="line">class MeFragment : Fragment() &#123;</span><br><span class="line">    private val TAG by lazy &#123; MeFragment::class.java.simpleName &#125;</span><br><span class="line"></span><br><span class="line">    // Model懒加载</span><br><span class="line">    private val meModel: MeModel by viewModels &#123;</span><br><span class="line">        CustomViewModelProvider.providerMeModel(requireContext())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 选择图片的标识</span><br><span class="line">    private val REQUEST_CODE_IMAGE = 100</span><br><span class="line"></span><br><span class="line">    // 加载框</span><br><span class="line">    private val sweetAlertDialog: SweetAlertDialog by lazy &#123;</span><br><span class="line">        SweetAlertDialog(requireContext(), SweetAlertDialog.PROGRESS_TYPE)</span><br><span class="line">            .setTitleText(&quot;头像&quot;)</span><br><span class="line">            .setContentText(&quot;更新中......&quot;)</span><br><span class="line">//            .setCancelButton(&quot;取消&quot;) &#123;</span><br><span class="line">//                meModel.cancelWork()</span><br><span class="line">//                sweetAlertDialog.dismiss()</span><br><span class="line">//            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? &#123;</span><br><span class="line">        val binding: FragmentMeBinding = FragmentMeBinding.inflate(inflater, container, false)</span><br><span class="line">        initListener(binding)</span><br><span class="line">        onSubscribeUi(binding)</span><br><span class="line">        return binding.root</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 初始化监听器</span><br><span class="line">     */</span><br><span class="line">    private fun initListener(binding: FragmentMeBinding) &#123;</span><br><span class="line">        binding.ivHead.setOnClickListener &#123;</span><br><span class="line">            // 选择处理的图片</span><br><span class="line">            val chooseIntent = Intent(Intent.ACTION_PICK, MediaStore.Images.Media.EXTERNAL_CONTENT_URI)</span><br><span class="line">            startActivityForResult(chooseIntent, REQUEST_CODE_IMAGE)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * binding绑定</span><br><span class="line">     */</span><br><span class="line">    private fun onSubscribeUi(binding: FragmentMeBinding) &#123;</span><br><span class="line">        meModel.use.observe(this, Observer &#123;</span><br><span class="line">            binding.user = it</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        // 任务状态的监测</span><br><span class="line">        meModel.outPutWorkInfo.observe(this, Observer &#123;</span><br><span class="line">            if (it.isNullOrEmpty())</span><br><span class="line">                return@Observer</span><br><span class="line"></span><br><span class="line">            val state = it[0]</span><br><span class="line">            if (state.state.isFinished) &#123;</span><br><span class="line">                // 更新头像</span><br><span class="line">                val outputImageUri = state.outputData.getString(BaseConstant.KEY_IMAGE_URI)</span><br><span class="line">                if (!outputImageUri.isNullOrEmpty()) &#123;</span><br><span class="line">                    meModel.setOutputUri(outputImageUri)</span><br><span class="line">                &#125;</span><br><span class="line">                sweetAlertDialog.dismiss()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 图片选择完成的回调</span><br><span class="line">     */</span><br><span class="line">    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) &#123;</span><br><span class="line">        if (resultCode == Activity.RESULT_OK) &#123;</span><br><span class="line">            when (requestCode) &#123;</span><br><span class="line">                REQUEST_CODE_IMAGE -&gt; data?.let &#123;</span><br><span class="line">                    handleImageRequestResult(data)</span><br><span class="line">                &#125;</span><br><span class="line">                else -&gt; Log.d(TAG, &quot;Unknown request code.&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Log.e(TAG, String.format(&quot;Unexpected Result code %s&quot;, resultCode))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 图片处理</span><br><span class="line">     */</span><br><span class="line">    private fun handleImageRequestResult(data: Intent) &#123;</span><br><span class="line">        val imageUri: Uri? = data.clipData?.let &#123;</span><br><span class="line">            it.getItemAt(0).uri</span><br><span class="line">        &#125; ?: data.data</span><br><span class="line"></span><br><span class="line">        if (imageUri == null) &#123;</span><br><span class="line">            Log.e(TAG, &quot;Invalid input image Uri.&quot;)</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sweetAlertDialog.dismiss()</span><br><span class="line"></span><br><span class="line">        // 图片模糊处理</span><br><span class="line">        meModel.setImageUri(imageUri.toString())</span><br><span class="line">        meModel.applyBlur(3)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-其他"><a href="#3-其他" class="headerlink" title="3. 其他"></a>3. 其他</h1><p><strong>选择适合的Worker</strong></p><p>谷歌提供了四种<code>Worker</code>：</p><ul><li>自动运行在后台线程的<code>Worker</code></li><li>结合协程的<code>CoroutineWorker</code></li><li>结合RxJava的<code>RxWorker</code></li><li>以上三个类的基类<code>ListenableWorker</code></li></ul><p>这里以<code>CoroutineWorker</code>为例，简单介绍，使用<code>ShoeWorker</code>从文中读取鞋子的数据并完成数据库的插入工作：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoeWorker</span></span>(context: Context, workerParameters: WorkerParameters) : CoroutineWorker(context, workerParameters) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> TAG <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        ShoeWorker::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>.<span class="title">simpleName</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定Dispatchers</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> coroutineContext: CoroutineDispatcher</span><br><span class="line">        <span class="keyword">get</span>() = Dispatchers.IO</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWork</span><span class="params">()</span></span>: Result = coroutineScope &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            applicationContext.assets.<span class="keyword">open</span>(<span class="string">"shoes.json"</span>).use &#123;</span><br><span class="line">                JsonReader(it.reader()).use &#123;</span><br><span class="line">                    <span class="keyword">val</span> shoeType = <span class="keyword">object</span> : TypeToken&lt;List&lt;Shoe&gt;&gt;() &#123;&#125;.type</span><br><span class="line">                    <span class="keyword">val</span> shoeList: List&lt;Shoe&gt; = Gson().fromJson(it, shoeType)</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">val</span> shoeDao = RepositoryProvider.providerShoeRepository(applicationContext)</span><br><span class="line">                    shoeDao.insertShoes(shoeList)</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">2</span>) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (shoe <span class="keyword">in</span> shoeList) &#123;</span><br><span class="line">                            shoe.id += shoeList.size</span><br><span class="line">                        &#125;</span><br><span class="line">                        shoeDao.insertShoes(shoeList)</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    Result.success()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"Error seeding database"</span>, e)</span><br><span class="line">            Result.failure()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>延伸：<br><a href="https://juejin.im/post/5b37620be51d4558b4668210" target="_blank" rel="noopener">Android Jetpack - 使用 WorkManager 管理后台任务</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里的数据不是从网络请求获取的，而是从assets目录下的json读取出来的，通常，从文件读取数据不会放在主线程中执行，这里使用了&lt;code&gt;WorkManager&lt;/code&gt;，使能够在后台线程进行数据初始化。&lt;/p&gt;
&lt;h1 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-
      
    
    </summary>
    
      <category term="Android" scheme="https://tylerLiu.top/categories/Android/"/>
    
      <category term="Jetpack" scheme="https://tylerLiu.top/categories/Android/Jetpack/"/>
    
    
      <category term="Jetpack" scheme="https://tylerLiu.top/tags/Jetpack/"/>
    
  </entry>
  
  <entry>
    <title>你的儿女</title>
    <link href="https://tylerLiu.top/2019/08/08/%E4%BD%A0%E7%9A%84%E5%84%BF%E5%A5%B3/"/>
    <id>https://tylerLiu.top/2019/08/08/你的儿女/</id>
    <published>2019-08-08T06:22:49.000Z</published>
    <updated>2019-08-08T06:27:27.318Z</updated>
    
    <content type="html"><![CDATA[<h1 id="你的儿女"><a href="#你的儿女" class="headerlink" title="你的儿女"></a>你的儿女</h1><pre><code>———— 纪伯伦（Khalil Gibran）</code></pre><p>Your children are not your children.<br>你的子女，其实不是你的子女。</p><p>They are the sons and daughters of Life’s longing for itself.<br>他们是生命对于自身渴望而诞生的孩子。</p><p>They come through you but not from you,<br>他们借助你来到这个世界，却非因你而来，</p><p>And though they are with you, yet they belong not to you.<br>他们陪伴你，却并不属于你。</p><p>You may give them your love but not your thoughts,<br>你可以给予他们你的爱，却不是你的想法，</p><p>For they have their own thoughts.<br>因为他们有自己的思想。</p><p>You may house their bodies but not their souls,<br>你可以庇护的是他们的身体，却不是他们的灵魂，</p><p>For their souls dwell in the house of tomorrow, which you cannot visit, not even in your dreams.<br>因为他们的灵魂属于明天，属于你在梦境中也无法达到的明天。</p><p>You may strive to be like them, but seek not to make them like you,<br>你可以拼尽全力，变得像他们一样，却不要让他们变得和你一样，</p><p>For life goes not backward nor tarries with yesterday.<br>因为生命不会后退，也不在过去停留。</p><p>You are the bows from which your children as living arrows are sent forth.<br>你是弓，儿女是从你那里射出的箭。</p><p>The archer sees the mark upon the path of the infinite,<br>弓箭手遥望未来之路上的箭靶，</p><p>and He bends you with His might that His arrows may go swift and far.<br>用尽力气将你拉开，使箭射得又快又远。</p><p>Let your bending in the archer’s hand be for gladness,<br>怀着快乐的心情，在弓箭手的手中弯曲吧，</p><p>For even as he loves the arrow that flies, so He loves also the bow that is stable.<br>因为他爱一路飞翔的箭，也爱无比稳定的弓。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;你的儿女&quot;&gt;&lt;a href=&quot;#你的儿女&quot; class=&quot;headerlink&quot; title=&quot;你的儿女&quot;&gt;&lt;/a&gt;你的儿女&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;———— 纪伯伦（Khalil Gibran）&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Your children a
      
    
    </summary>
    
      <category term="美文" scheme="https://tylerLiu.top/categories/%E7%BE%8E%E6%96%87/"/>
    
    
      <category term="美文" scheme="https://tylerLiu.top/tags/%E7%BE%8E%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>Android Jetpack：Paging</title>
    <link href="https://tylerLiu.top/2019/08/05/Android-Jetpack-Paging/"/>
    <id>https://tylerLiu.top/2019/08/05/Android-Jetpack-Paging/</id>
    <published>2019-08-05T08:43:24.000Z</published>
    <updated>2019-08-22T03:13:38.094Z</updated>
    
    <content type="html"><![CDATA[<p>在遇到<code>RecyclerView</code>加载大量数据的情况，如果是在数据库请求，需要消耗数据库资源并且需要花费较多的时间，同意，如果是发送网络请求，则需要消耗宽带和更多的时间，无论哪种情形，对于用户的体验都是糟糕的。这时，可以采用分段加载来缩短时间，给带来良好的体验，目前，对于加载大量数据的处理方式有两种：</p><ol><li>借助刷新控件来实现用户手动请求数据</li><li>数据达到边界自动请求加载</li></ol><p>谷歌的Android Jetpack也实现了自己的分页库——<code>Paging</code>。</p><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><p>官方文档：<a href="https://developer.android.google.cn/topic/libraries/architecture/paging/" target="_blank" rel="noopener">Paging</a><br>官方Demo：<a href="https://github.com/googlesamples/android-architecture-components/tree/master/PagingWithNetworkSample" target="_blank" rel="noopener">网络方式</a>，<a href="https://github.com/googlesamples/android-architecture-components/tree/master/PagingSample" target="_blank" rel="noopener">数据库方式</a></p><p>官方介绍：</p><blockquote><p>The Paging Library helps you load and display small chunks of data at a time. Loading partial data on demand reduces usage of network bandwidth and system resources.<br>直译：分页库帮助您每次加载和显示小块数据。按需加载部分数据会减少网络带宽和系统资源的使用。</p></blockquote><p><code>Paging</code>架构：</p><img src="/2019/08/05/Android-Jetpack-Paging/9271486-9e49790f92f2ff1f.png"><ul><li><code>PagedList</code>：一个可以以分页形式异步加载数据的容器，可以跟<code>RecyclerView</code>结合</li><li><code>DataSource</code>或<code>DataSource.Factory</code>：数据源，<code>DataSource</code>将数据转变成<code>PagedList</code>，<code>DataSource.Factory</code>则用来创建<code>DataSource</code></li><li><code>LivePagedListBuilder</code>：用来生成<code>LiveData&lt;PagedList&gt;</code>，需要<code>DataSource.Factory</code>参数</li><li><code>BoundaryCallback</code>：数据达到边界的回调</li><li><code>PagedListAdapter</code>：一种<code>RecyclerView</code>适配器</li></ul><p>优点：</p><ol><li><code>RxJava</code>以及Android Jetpack的支持，如<code>LiveData</code>、<code>Room</code>等</li><li>自定义分页策略</li><li>异步处理数据</li><li>结合<code>RecyclerView</code>等</li></ol><h1 id="2-Demo"><a href="#2-Demo" class="headerlink" title="2. Demo"></a>2. Demo</h1><h2 id="2-1-添加依赖："><a href="#2-1-添加依赖：" class="headerlink" title="2.1 添加依赖："></a>2.1 添加依赖：</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="comment">// paging</span></span><br><span class="line">    implementation <span class="string">"androidx.paging:paging-runtime:2.1.0"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-创建数据源"><a href="#2-2-创建数据源" class="headerlink" title="2.2 创建数据源"></a>2.2 创建数据源</h2><ol><li>非<code>Room</code>数据库<br>如果没有使用<code>Room</code>数据库，就需要自定义实现<code>DataSource</code>，通常实现<code>DataSource</code>有三种方式，分别继承三种抽象类，它们分别是：</li></ol><table><thead><tr><th align="left">名称</th><th align="left">使用场景</th></tr></thead><tbody><tr><td align="left"><code>PageKeyedDataSource&lt;Key, Value&gt;</code></td><td align="left">分页请求数据的场景</td></tr><tr><td align="left"><code>ItemKeyedDataSource&lt;Key, Value&gt;</code></td><td align="left">以表的某个列为Key，加载其后的N个数据</td></tr><tr><td align="left"><code>PositionalDataSource&lt;T&gt;</code></td><td align="left">当数据源总数特定，根据指定位置请求数据的场景</td></tr></tbody></table><p>这里以<code>PageKeyedDataSource&lt;Key, Value&gt;</code>为例，虽然这里的数据库使用的是<code>Room</code>，但查询数据以返回<code>List</code>代表着通常数据库的使用方式：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ly.allendemojetpack.db.repository</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoeRepository</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> shoeDao: ShoeDao) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getPageShoes</span><span class="params">(startIndex: <span class="type">Long</span>, endIndex: <span class="type">Long</span>)</span></span>: List&lt;Shoe&gt; = shoeDao.findShoesByIndexRange(startIndex, endIndex)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ly.allendemojetpack.db.datasource</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"><span class="keyword">import</span> androidx.paging.PageKeyedDataSource</span><br><span class="line"><span class="keyword">import</span> com.ly.allendemojetpack.common.BaseConstant</span><br><span class="line"><span class="keyword">import</span> com.ly.allendemojetpack.db.<span class="keyword">data</span>.Shoe</span><br><span class="line"><span class="keyword">import</span> com.ly.allendemojetpack.db.repository.ShoeRepository</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义PageKeyedDataSource</span></span><br><span class="line"><span class="comment"> * 演示Paging库的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomPageDataSource</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> shoeRepository: ShoeRepository) : PageKeyedDataSource&lt;<span class="built_in">Int</span>, Shoe&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> TAG: String <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        <span class="keyword">this</span>::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>.<span class="title">simpleName</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第一次加载时调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">loadInitial</span><span class="params">(params: <span class="type">LoadInitialParams</span>&lt;<span class="type">Int</span>&gt;, callback: <span class="type">LoadInitialCallback</span>&lt;<span class="type">Int</span>, Shoe&gt;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> startIndex = <span class="number">0L</span></span><br><span class="line">        <span class="keyword">val</span> endIndex: <span class="built_in">Long</span> = <span class="number">0L</span> + params.requestedLoadSize</span><br><span class="line">        <span class="keyword">val</span> shoe = shoeRepository.getPageShoes(startIndex, endIndex)</span><br><span class="line"></span><br><span class="line">        callback.onResult(shoe, <span class="literal">null</span>, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每次分页加载时调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">loadAfter</span><span class="params">(params: <span class="type">LoadParams</span>&lt;<span class="type">Int</span>&gt;, callback: <span class="type">LoadCallback</span>&lt;<span class="type">Int</span>, Shoe&gt;)</span></span> &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"startPage:<span class="subst">$&#123;params.key&#125;</span>, size:<span class="subst">$&#123;params.requestedLoadSize&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> startPage = params.key</span><br><span class="line">        <span class="keyword">val</span> startIndex = ((startPage - <span class="number">1</span>) * BaseConstant.SINGLE_PAGE_SIZE).toLong() + <span class="number">1</span></span><br><span class="line">        <span class="keyword">val</span> endIndex = startIndex + params.requestedLoadSize - <span class="number">1</span></span><br><span class="line">        <span class="keyword">val</span> shoes = shoeRepository.getPageShoes(startIndex, endIndex)</span><br><span class="line"></span><br><span class="line">        callback.onResult(shoes, params.key + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">loadBefore</span><span class="params">(params: <span class="type">LoadParams</span>&lt;<span class="type">Int</span>&gt;, callback: <span class="type">LoadCallback</span>&lt;<span class="type">Int</span>, Shoe&gt;)</span></span> &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"endPage:<span class="subst">$&#123;params.key&#125;</span>, size:<span class="subst">$&#123;params.requestedLoadSize&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> endPage = params.key</span><br><span class="line">        <span class="keyword">val</span> endIndex = ((endPage - <span class="number">1</span>) * BaseConstant.SINGLE_PAGE_SIZE).toLong() + <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> startIndex = endIndex - params.requestedLoadSize</span><br><span class="line">        startIndex = <span class="keyword">if</span> (startIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="number">0L</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            startIndex</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> shoe = shoeRepository.getPageShoes(startIndex, endIndex)</span><br><span class="line"></span><br><span class="line">        callback.onResult(shoe, params.key + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DataSource</code>创建好了，再创建一个<code>DataSource.Factory</code>，返回对应的<code>DataSource</code>实例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ly.allendemojetpack.db.datasource</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.paging.DataSource</span><br><span class="line"><span class="keyword">import</span> com.ly.allendemojetpack.db.<span class="keyword">data</span>.Shoe</span><br><span class="line"><span class="keyword">import</span> com.ly.allendemojetpack.db.repository.ShoeRepository</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建CustomPageDataSource的工厂类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomPageDataSourceFactory</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> shoeRepository: ShoeRepository) : DataSource.Factory&lt;<span class="built_in">Int</span>, Shoe&gt;() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">()</span></span>: DataSource&lt;<span class="built_in">Int</span>, Shoe&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> CustomPageDataSource(shoeRepository)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>Room</code>数据库<br>如果使用<code>Room</code>与<code>Paging</code>结合使用，可以直接在<code>Room</code>的<code>Dao</code>层使用：<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ShoeDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">"SELECT * FROM shoe"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getAllShoesLD</span><span class="params">()</span></span>: DataSource.Factory&lt;<span class="built_in">Int</span>, Shoe&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>使用起来简单很多。</p><h2 id="2-3-构建LiveData-lt-PagedList-gt"><a href="#2-3-构建LiveData-lt-PagedList-gt" class="headerlink" title="2.3 构建LiveData &lt;PagedList&gt;"></a>2.3 构建LiveData &lt;PagedList&gt;</h2><p>要想获得<code>LiveData&lt;PagedList&gt;</code>，需要先创建<code>LivePagedListBuilder</code>，<code>LivePagedListbuilder</code>有设分页数量和配置参数两种构造方法，设置分页数量比较简单，直接查看API即可，下面看看配置参数使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoeModel</span> <span class="keyword">constructor</span></span>(repository: ShoeRepository) : ViewModel() &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 鞋子集合的观察类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> shoes: LiveData&lt;PagedList&lt;Shoe&gt;&gt; = LivePagedListBuilder&lt;<span class="built_in">Int</span>, Shoe&gt;(</span><br><span class="line">        CustomPageDataSourceFactory(repository),</span><br><span class="line">        PagedList.Config.Builder()</span><br><span class="line">            .setPageSize(<span class="number">10</span>)</span><br><span class="line">            .setEnablePlaceholders(<span class="literal">false</span>)</span><br><span class="line">            .setInitialLoadSizeHint(<span class="number">10</span>)</span><br><span class="line">            .build()</span><br><span class="line">    ).build()</span><br></pre></td></tr></table></figure><h2 id="2-4-创建PagedListAdapter"><a href="#2-4-创建PagedListAdapter" class="headerlink" title="2.4 创建PagedListAdapter"></a>2.4 创建PagedListAdapter</h2><p><code>PagedListAdapter</code>是一个特殊的<code>RecyclerView</code>的<code>RecyclerAdapter</code>，使用方法类似，这里使用Data Binding：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ly.allendemojetpack.ui.adapter</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> android.content.Intent</span><br><span class="line"><span class="keyword">import</span> android.view.LayoutInflater</span><br><span class="line"><span class="keyword">import</span> android.view.View</span><br><span class="line"><span class="keyword">import</span> android.view.ViewGroup</span><br><span class="line"><span class="keyword">import</span> androidx.paging.PagedListAdapter</span><br><span class="line"><span class="keyword">import</span> androidx.recyclerview.widget.RecyclerView</span><br><span class="line"><span class="keyword">import</span> com.ly.allendemojetpack.common.BaseConstant</span><br><span class="line"><span class="keyword">import</span> com.ly.allendemojetpack.databinding.ItemShoeBinding</span><br><span class="line"><span class="keyword">import</span> com.ly.allendemojetpack.db.<span class="keyword">data</span>.Shoe</span><br><span class="line"><span class="keyword">import</span> com.ly.allendemojetpack.ui.activity.DetailActivity</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 鞋子的适配器，配合Data Binding使用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Liuyang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoeAdapter</span> <span class="keyword">constructor</span></span>(<span class="keyword">val</span> context: Context) :</span><br><span class="line">    PagedListAdapter&lt;Shoe, ShoeAdapter.ViewHolder&gt;(ShoeDiffCallback()) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateViewHolder</span><span class="params">(parent: <span class="type">ViewGroup</span>, viewType: <span class="type">Int</span>)</span></span>: ViewHolder &#123;</span><br><span class="line">        <span class="keyword">return</span> ViewHolder(ItemShoeBinding.inflate(LayoutInflater.from(parent.context), parent, <span class="literal">false</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">ViewHolder</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> shoe = getItem(position)</span><br><span class="line">        holder.apply &#123;</span><br><span class="line">            bind(onCreateListener(shoe!!.id), shoe)</span><br><span class="line">            itemView.tag = shoe</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Holder的点击事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateListener</span><span class="params">(id: <span class="type">Long</span>)</span></span>: View.OnClickListener &#123;</span><br><span class="line">        <span class="keyword">return</span> View.OnClickListener &#123;</span><br><span class="line">            <span class="keyword">val</span> intent = Intent(context, DetailActivity::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">            intent.putExtra(BaseConstant.DETAIL_SHOE_ID, id)</span><br><span class="line">            context.startActivity(intent)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> binding: ItemShoeBinding) : RecyclerView.ViewHolder(binding.root) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">bind</span><span class="params">(listener: <span class="type">View</span>.<span class="type">OnClickListener</span>, item: <span class="type">Shoe</span>)</span></span> &#123;</span><br><span class="line">            binding.apply &#123;</span><br><span class="line">                <span class="keyword">this</span>.listener = listener</span><br><span class="line">                <span class="keyword">this</span>.shoe = item</span><br><span class="line">                executePendingBindings()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ly.allendemojetpack.ui.adapter</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.recyclerview.widget.DiffUtil</span><br><span class="line"><span class="keyword">import</span> com.ly.allendemojetpack.db.<span class="keyword">data</span>.Shoe</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoeDiffCallback</span> : <span class="type">DiffUtil.ItemCallback</span>&lt;<span class="type">Shoe</span>&gt;</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">areItemsTheSame</span><span class="params">(oldItem: <span class="type">Shoe</span>, newItem: <span class="type">Shoe</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> oldItem.id == newItem.id</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">areContentsTheSame</span><span class="params">(oldItem: <span class="type">Shoe</span>, newItem: <span class="type">Shoe</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> oldItem == newItem</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-监听数据"><a href="#2-5-监听数据" class="headerlink" title="2.5 监听数据"></a>2.5 监听数据</h2><p>同样使用Data Binding，<code>ShoeFragment</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ly.allendemojetpack.ui.fragment.main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.view.LayoutInflater</span><br><span class="line"><span class="keyword">import</span> android.view.View</span><br><span class="line"><span class="keyword">import</span> android.view.ViewGroup</span><br><span class="line"><span class="keyword">import</span> androidx.fragment.app.Fragment</span><br><span class="line"><span class="keyword">import</span> androidx.fragment.app.viewModels</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.Observer</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.ViewModelProviders</span><br><span class="line"><span class="keyword">import</span> com.ly.allendemojetpack.databinding.FragmentShoeBinding</span><br><span class="line"><span class="keyword">import</span> com.ly.allendemojetpack.ui.adapter.ShoeAdapter</span><br><span class="line"><span class="keyword">import</span> com.ly.allendemojetpack.viewmodel.CustomViewModelProvider</span><br><span class="line"><span class="keyword">import</span> com.ly.allendemojetpack.viewmodel.ShoeModel</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 鞋子的Fragment</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Liuyang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoeFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line">    <span class="comment">// by viewModels 需要依赖 "androidx.navigation:navigation-ui-ktx:$rootProject.navigationVersion"</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> viewModel: ShoeModel <span class="keyword">by</span> viewModels &#123;</span><br><span class="line">        CustomViewModelProvider.providerShoeModel(requireContext())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(inflater: <span class="type">LayoutInflater</span>, container: <span class="type">ViewGroup</span>?, savedInstanceState: <span class="type">Bundle</span>?)</span></span>: View? &#123;</span><br><span class="line">        <span class="keyword">val</span> binding: FragmentShoeBinding = FragmentShoeBinding.inflate(inflater, container, <span class="literal">false</span>)</span><br><span class="line">        context ?: <span class="keyword">return</span> binding.root</span><br><span class="line">        <span class="comment">// 适配器</span></span><br><span class="line">        <span class="keyword">val</span> adapter = ShoeAdapter(context!!)</span><br><span class="line">        binding.recycler.adapter = adapter</span><br><span class="line">        onSubscribeUi(adapter)</span><br><span class="line">        <span class="keyword">return</span> binding.root</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 鞋子数据更新的通知</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSubscribeUi</span><span class="params">(adapter: <span class="type">ShoeAdapter</span>)</span></span> &#123;</span><br><span class="line">        viewModel.shoes.observe(viewLifecycleOwner, Observer &#123;</span><br><span class="line">            <span class="keyword">if</span> (it != <span class="literal">null</span>) &#123;</span><br><span class="line">                adapter.submitList(it)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在遇到&lt;code&gt;RecyclerView&lt;/code&gt;加载大量数据的情况，如果是在数据库请求，需要消耗数据库资源并且需要花费较多的时间，同意，如果是发送网络请求，则需要消耗宽带和更多的时间，无论哪种情形，对于用户的体验都是糟糕的。这时，可以采用分段加载来缩短时间，给带来良
      
    
    </summary>
    
      <category term="Android" scheme="https://tylerLiu.top/categories/Android/"/>
    
      <category term="Jetpack" scheme="https://tylerLiu.top/categories/Android/Jetpack/"/>
    
    
      <category term="Jetpack" scheme="https://tylerLiu.top/tags/Jetpack/"/>
    
  </entry>
  
  <entry>
    <title>Android Jetpack：Room</title>
    <link href="https://tylerLiu.top/2019/08/05/Android-Jetpack-Room/"/>
    <id>https://tylerLiu.top/2019/08/05/Android-Jetpack-Room/</id>
    <published>2019-08-05T03:27:04.000Z</published>
    <updated>2019-08-22T03:13:47.387Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><p>官方网址：<a href="https://developer.android.google.cn/topic/libraries/architecture/room" target="_blank" rel="noopener">Room</a></p><p>官方介绍：</p><blockquote><p>The Room persistence library provides an abstraction layer over SQLite to allow for more robust database access while harnessing the full power of SQLite.</p></blockquote><p>简单来说，Room是一个基于SQLite的强大数据库框架。</p><p>优点：</p><ol><li>使用编译时注解，能够对<code>@Query</code>和<code>@Entity</code>里面的SQL语句进行验证</li><li>与SQL语句的使用更加贴近，能够降低学习成本</li><li>对RxJava2支持，对<code>LiveData</code>支持</li><li><code>@Embedded</code>能减少表的创建</li></ol><h1 id="2-Demo"><a href="#2-Demo" class="headerlink" title="2. Demo"></a>2. Demo</h1><p>目标结构：</p><img src="/2019/08/05/Android-Jetpack-Room/1564982411.jpg"><p>三张表：用户表、鞋表和收藏记录表，用户表和鞋表存在多对多的关系。</p><h2 id="2-1-步骤1：添加依赖"><a href="#2-1-步骤1：添加依赖" class="headerlink" title="2.1 步骤1：添加依赖"></a>2.1 步骤1：添加依赖</h2><p>在model的<code>build.gradel</code>添加：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">'kotlin-kapt'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// room</span></span><br><span class="line">    implementation <span class="string">"androidx.room:room-runtime:2.2.0-alpha01"</span></span><br><span class="line">    implementation <span class="string">"androidx.room:room-ktx:2.2.0-alpha01"</span></span><br><span class="line">    kapt <span class="string">"androidx.room:room-compiler:2.2.0-alpha01"</span></span><br><span class="line">    androidTestImplementation <span class="string">"androidx.room:room-testing:2.2.0-alpha01"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-步骤2：创建表（实体）"><a href="#2-2-步骤2：创建表（实体）" class="headerlink" title="2.2 步骤2：创建表（实体）"></a>2.2 步骤2：创建表（实体）</h2><p>用户表：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ly.allendemojetpack.db.<span class="keyword">data</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.location.Address</span><br><span class="line"><span class="keyword">import</span> androidx.room.*</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Liuyang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Entity(tableName = <span class="meta-string">"user"</span>)</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(</span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="meta-string">"user_account"</span>)</span> <span class="keyword">val</span> account: String,<span class="comment">// 账号</span></span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="meta-string">"user_pwd"</span>)</span> <span class="keyword">val</span> pwd: String,<span class="comment">// 摩玛</span></span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="meta-string">"user_name"</span>)</span> <span class="keyword">val</span> name: String,</span><br><span class="line">    <span class="meta">@Embedded</span> <span class="keyword">val</span> address: Address,<span class="comment">// 地址</span></span><br><span class="line">    <span class="meta">@Ignore</span> <span class="keyword">val</span> state: <span class="built_in">Int</span></span><br><span class="line">) &#123;</span><br><span class="line">    <span class="meta">@PrimaryKey(autoGenerate = true)</span></span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="meta-string">"id"</span>)</span></span><br><span class="line">    <span class="keyword">var</span> id: <span class="built_in">Long</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>收藏记录表：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ly.allendemojetpack.db.<span class="keyword">data</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.room.ColumnInfo</span><br><span class="line"><span class="keyword">import</span> androidx.room.Entity</span><br><span class="line"><span class="keyword">import</span> androidx.room.ForeignKey</span><br><span class="line"><span class="keyword">import</span> androidx.room.PrimaryKey</span><br><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 喜欢的鞋 表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Liuyang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Entity(</span></span><br><span class="line"><span class="meta">    tableName = <span class="meta-string">"fav_shoe"</span>,</span></span><br><span class="line"><span class="meta">    foreignKeys = [ForeignKey(entity = Shoe::class, parentColumns = [<span class="meta-string">"id"</span>], childColumns = [<span class="meta-string">"shoe_id"</span>])</span>,</span><br><span class="line">        ForeignKey(entity = User::<span class="class"><span class="keyword">class</span>, <span class="type">parentColumns = ["id"]</span>, <span class="type">childColumns = ["user_id"])]</span></span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">FavouriteShoe</span></span>(</span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="meta-string">"shoe_id"</span>)</span> <span class="keyword">val</span> shoeId: <span class="built_in">Long</span>,<span class="comment">// 外键 鞋子的id</span></span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="meta-string">"user_id"</span>)</span> <span class="keyword">val</span> userId: <span class="built_in">Long</span>,<span class="comment">// 外键 用户的id</span></span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="meta-string">"fav_date"</span>)</span> <span class="keyword">val</span> date: Date<span class="comment">// 创建日期</span></span><br><span class="line">) &#123;</span><br><span class="line">    <span class="meta">@PrimaryKey(autoGenerate = true)</span></span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="meta-string">"id"</span>)</span></span><br><span class="line">    <span class="keyword">var</span> id: <span class="built_in">Long</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于其中注解的解释：</p><ul><li><code>@Entity</code>：声明这是一个表（实体），主要参数：<code>tableName</code>表名、<code>foreignKeys</code>外键、<code>indices</code>索引</li><li><code>ColumnInfo</code>：主要用来修改在数据库中的字段名</li><li><code>PrimaryKey</code>：声明该字段为主键，可以声明是否自动创建</li><li><code>Ignore</code>：声明某个字段只是临时用，不存储在数据库中</li><li><code>Embedded</code>：用于嵌套，里面的字段同样会存储在数据库中</li></ul><p>最后一个，在<code>User</code>表中有一个变量<code>address</code>，它是一个<code>Address</code>类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ly.allendemojetpack.db.<span class="keyword">data</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span></span>(</span><br><span class="line">    <span class="keyword">val</span> street: String, <span class="keyword">val</span> state: String, <span class="keyword">val</span> city: String, <span class="keyword">val</span> postCode: String</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>通常，如果想这些字段存储在数据库中，有两种方法：</p><ol><li>重新创建一个表，进行一对一的关联，但是多创建一个表显得麻烦</li><li>在用户表中增加字段，但是这样映射出来的对象显得 不面向对象</li></ol><p><code>@Embedded</code>就是为了解决上面你的第2个问题，即不多创建一个表，又能将数据库中映射的对象看上去面向对象。</p><p><code>Shoe</code>表：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ly.allendemojetpack.db.<span class="keyword">data</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.room.ColumnInfo</span><br><span class="line"><span class="keyword">import</span> androidx.room.Entity</span><br><span class="line"><span class="keyword">import</span> androidx.room.PrimaryKey</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 鞋子表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Liuyang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Entity(tableName = <span class="meta-string">"shoe"</span>)</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Shoe</span></span>(</span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="meta-string">"shoe_name"</span>)</span> <span class="keyword">val</span> name: String,</span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="meta-string">"shoe_description"</span>)</span> <span class="keyword">val</span> description: String,</span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="meta-string">"shoe_price"</span>)</span> <span class="keyword">val</span> price: <span class="built_in">Float</span>,</span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="meta-string">"shoe_brand"</span>)</span> <span class="keyword">val</span> brand: String,</span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="meta-string">"shoe_imgUrl"</span>)</span> <span class="keyword">val</span> imgUrl: String</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="meta">@PrimaryKey(autoGenerate = true)</span></span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="meta-string">"id"</span>)</span></span><br><span class="line">    <span class="keyword">var</span> id: <span class="built_in">Long</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-步骤3：创建Dao"><a href="#2-3-步骤3：创建Dao" class="headerlink" title="2.3 步骤3：创建Dao"></a>2.3 步骤3：创建Dao</h2><p>数据处理的方法，就是数据的增删改查。在抽象类或接口加一个<code>@Dao</code>注解即可。</p><h3 id="2-3-1-增"><a href="#2-3-1-增" class="headerlink" title="2.3.1 增"></a>2.3.1 增</h3><p><code>@Insert</code>注解，声明当前的方法为新增的方法，并且可以设置当<strong>新增冲突</strong>的时候处理的方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 鞋子表的方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Liuyang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ShoeDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 选择所有的鞋</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">"SELECT * FROM shoe"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getAllShoes</span><span class="params">()</span></span>: LiveData&lt;List&lt;Shoe&gt;&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过id查找鞋子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">"SELECT * FROM shoe WHERE id = :id"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findShoeById</span><span class="params">(id: <span class="type">Long</span>)</span></span>: LiveData&lt;Shoe&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过品牌找鞋子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">"SELECT * FROM shoe WHERE shoe_brand = :brand"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findShoeByBrand</span><span class="params">(brand: <span class="type">String</span>)</span></span>: LiveData&lt;List&lt;Shoe&gt;&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入一种鞋子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Insert(onConflict = OnConflictStrategy.REPLACE)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">insertShoe</span><span class="params">(shoe: <span class="type">Shoe</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入多种鞋子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Insert(onConflict = OnConflictStrategy.REPLACE)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">insertShoe</span><span class="params">(shoes: <span class="type">List</span>&lt;<span class="type">Shoe</span>&gt;)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-2-删"><a href="#2-3-2-删" class="headerlink" title="2.3.2 删"></a>2.3.2 删</h3><p><code>@Delete</code>注解，声明当前的方法是一个删除方法。</p><h3 id="2-3-3-改"><a href="#2-3-3-改" class="headerlink" title="2.3.3 改"></a>2.3.3 改</h3><p><code>@Update</code>注解，声明当前方法是一个更新方法</p><h3 id="2-3-4-查"><a href="#2-3-4-查" class="headerlink" title="2.3.4 查"></a>2.3.4 查</h3><p><code>@Query</code>注解，不仅可以声明这是一个查询语句，也能用来删除和修改，不能用来新增。</p><ol><li>简单查询<br>除了简单查询，还能配合<code>LiveData</code>和<code>RxJava</code>。这里使用的是<code>implementation &#39;io.reactivex.rxjava2:rxjava:2.2.3&#39;</code><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ly.allendemojetpack.db.dao</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.LiveData</span><br><span class="line"><span class="keyword">import</span> androidx.room.Dao</span><br><span class="line"><span class="keyword">import</span> androidx.room.Insert</span><br><span class="line"><span class="keyword">import</span> androidx.room.OnConflictStrategy</span><br><span class="line"><span class="keyword">import</span> androidx.room.Query</span><br><span class="line"><span class="keyword">import</span> com.ly.allendemojetpack.db.<span class="keyword">data</span>.Shoe</span><br><span class="line"><span class="keyword">import</span> io.reactivex.Flowable</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 鞋子表的方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Liuyang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ShoeDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过id查找鞋子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">"SELECT * FROM shoe WHERE id = :id"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findShoeById</span><span class="params">(id: <span class="type">Long</span>)</span></span>: Shoe?</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过品牌找鞋子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">"SELECT * FROM shoe WHERE shoe_brand = :brand"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findShoeByBrand</span><span class="params">(brand: <span class="type">String</span>)</span></span>: List&lt;Shoe&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模糊查询 排序 同名鞋名查询鞋</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">"SELECT * FROM shoe WHERE shoe_name LIKE :name ORDER BY shoe_brand ASC"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findShoesByName</span><span class="params">(name: <span class="type">String</span>)</span></span>: List&lt;Shoe&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配合LiveData，返回所有鞋子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">"SELECT * FROM shoe"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getAllShoesLD</span><span class="params">()</span></span>: LiveData&lt;List&lt;Shoe&gt;&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配合LiveData，通过id查找鞋子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">"SELECT * FROM shoe WHERE id = :id"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findShoeByIdLD</span><span class="params">(id: <span class="type">Long</span>)</span></span>: LiveData&lt;Shoe&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配合RxJava，通过id查询单款鞋子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">"SELECT * FROM shoe WHERE id=:id"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findShoeByIdRx</span><span class="params">(id: <span class="type">Long</span>)</span></span>: Flowable&lt;Shoe&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>查询多个的时候，可以返回<code>List</code>和数组，还可以配合<code>LiveData</code>和<code>RxJava</code>。</p><ol start="2"><li>复合查询<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据收藏结合，查询用户喜欢的鞋的集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Query(</span></span><br><span class="line"><span class="meta">    <span class="meta-string">"SELECT shoe.id,shoe.shoe_name,shoe.shoe_description,shoe.shoe_price,shoe.shoe_brand,shoe.shoe_imgUrl "</span> +</span></span><br><span class="line"><span class="meta">            <span class="meta-string">"FROM shoe "</span> +</span></span><br><span class="line"><span class="meta">            <span class="meta-string">"INNER JOIN fav_shoe ON fav_shoe.shoe_id = shoe.id "</span> +</span></span><br><span class="line"><span class="meta">            <span class="meta-string">"WHERE fav_shoe.user_id = :userId"</span></span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findShoesByUserId</span><span class="params">(userId: <span class="type">Long</span>)</span></span>: LiveData&lt;List&lt;Shoe&gt;&gt;</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-4-步骤4：创建数据库"><a href="#2-4-步骤4：创建数据库" class="headerlink" title="2.4 步骤4：创建数据库"></a>2.4 步骤4：创建数据库</h2><p>创建一个数据库对象非常消耗资源，使用单例模式可以避免更多的资源消耗。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ly.allendemojetpack.db</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> androidx.room.Database</span><br><span class="line"><span class="keyword">import</span> androidx.room.Room</span><br><span class="line"><span class="keyword">import</span> androidx.room.RoomDatabase</span><br><span class="line"><span class="keyword">import</span> androidx.sqlite.db.SupportSQLiteDatabase</span><br><span class="line"><span class="keyword">import</span> androidx.work.OneTimeWorkRequestBuilder</span><br><span class="line"><span class="keyword">import</span> androidx.work.WorkManager</span><br><span class="line"><span class="keyword">import</span> com.ly.allendemojetpack.db.dao.FavouriteShoeDao</span><br><span class="line"><span class="keyword">import</span> com.ly.allendemojetpack.db.dao.ShoeDao</span><br><span class="line"><span class="keyword">import</span> com.ly.allendemojetpack.db.dao.UserDao</span><br><span class="line"><span class="keyword">import</span> com.ly.allendemojetpack.db.<span class="keyword">data</span>.Shoe</span><br><span class="line"><span class="keyword">import</span> com.ly.allendemojetpack.db.<span class="keyword">data</span>.User</span><br><span class="line"><span class="keyword">import</span> com.ly.allendemojetpack.utils.ShoeWorker</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据库文件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Liuyang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Database(entities = [User::class, Shoe::class], version = 1, exportSchema = false)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AppDataBase</span> : <span class="type">RoomDatabase</span></span>() &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">userDao</span><span class="params">()</span></span>: UserDao</span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">shoeDao</span><span class="params">()</span></span>: ShoeDao</span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">favouriteShoeDao</span><span class="params">()</span></span>: FavouriteShoeDao</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="meta">@Volatile</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> instance: AppDataBase? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getInstance</span><span class="params">(context: <span class="type">Context</span>)</span></span>: AppDataBase &#123;</span><br><span class="line">            <span class="keyword">return</span> instance ?: synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">                instance ?: buildDataBase(context)</span><br><span class="line">                    .also &#123;</span><br><span class="line">                        instance = it</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">buildDataBase</span><span class="params">(context: <span class="type">Context</span>)</span></span>: AppDataBase &#123;</span><br><span class="line">            <span class="keyword">return</span> Room.databaseBuilder(context, AppDataBase::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>, <span class="type">"jetpack_db")</span></span></span><br><span class="line">                .addCallback(<span class="keyword">object</span> : RoomDatabase.Callback() &#123;</span><br><span class="line">                    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(db: <span class="type">SupportSQLiteDatabase</span>)</span></span> &#123;</span><br><span class="line">                        <span class="keyword">super</span>.onCreate(db)</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 读取鞋的集合</span></span><br><span class="line">                        <span class="keyword">val</span> request = OneTimeWorkRequestBuilder&lt;ShoeWorker&gt;().build()</span><br><span class="line">                        WorkManager.getInstance(context).enqueue(request)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                )</span><br><span class="line">                .build()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Database</code>注解声明当前是一个数据库文件，注解中<code>entities</code>变量声明数据库中的表（实体），以及版本等变量。同时，获取的<code>Dao</code>也必须在数据库类中。完成之后，make project一下工程，系统后自动创建<code>AppDataBase</code>和<code>xxxDao</code>的实现类。</p><h2 id="2-5-步骤5：简单封装"><a href="#2-5-步骤5：简单封装" class="headerlink" title="2.5 步骤5：简单封装"></a>2.5 步骤5：简单封装</h2><p>在不使用<code>LiveData</code>和<code>RxJava</code>前提下，<code>Room</code>的操作不能放在主线程中。这里看看<code>UserRepository</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ly.allendemojetpack.db.repository</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.ly.allendemojetpack.db.dao.UserDao</span><br><span class="line"><span class="keyword">import</span> com.ly.allendemojetpack.db.<span class="keyword">data</span>.User</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.Dispatchers.IO</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.withContext</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserRepository</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> userDao: UserDao) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *用户登录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">login</span><span class="params">(account: <span class="type">String</span>, pwd: <span class="type">String</span>)</span></span> = userDao.login(account, pwd)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户注册</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">register</span><span class="params">(email: <span class="type">String</span>, account: <span class="type">String</span>, pwd: <span class="type">String</span>)</span></span>: <span class="built_in">Long</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> withContext(IO) &#123;</span><br><span class="line">            userDao.insertUser(User(account, pwd, email))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取所有用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getAllUsers</span><span class="params">()</span></span> = userDao.getAllUsers()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过id获取用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findUserById</span><span class="params">(id: <span class="type">Long</span>)</span></span> = userDao.findUserById(id)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="meta">@Volatile</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> instance: UserRepository? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getInstance</span><span class="params">(userDao: <span class="type">UserDao</span>)</span></span>: UserRepository =</span><br><span class="line">            instance ?: synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">                instance</span><br><span class="line">                    ?: UserRepository(userDao).also &#123;</span><br><span class="line">                        instance = it</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>register()</code>是一个普通方法，所以需要在子线程中使用，这里通过协程实现。<code>login()</code>是配合<code>LiveData</code>使用的， 不需要额外创建子线程，但是其核心数据库操作还在子线程中实现的。</p><p>这时，就可以操作本地数据库了。</p><h1 id="3-其他"><a href="#3-其他" class="headerlink" title="3. 其他"></a>3. 其他</h1><h2 id="3-1-类型转换器"><a href="#3-1-类型转换器" class="headerlink" title="3.1 类型转换器"></a>3.1 类型转换器</h2><p>SQLite支持的类型有：NULL、INTEGER、REAL、TEXT和BLOB，对于<code>Data</code>类，SQLite还可以将其转化为TEXT、REAL或者INTEGER，如果是<code>Calendar</code>类呢？<code>Room</code>提供了这一解决方法，使用<code>@TypeConverter</code>注解，谷歌官方示例：<a href="https://github.com/googlesamples/android-sunflower" target="_blank" rel="noopener">android-sunflower</a>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Converters</span> </span>&#123;</span><br><span class="line">    <span class="meta">@TypeConverter</span> <span class="function"><span class="keyword">fun</span> <span class="title">calendarToDatestamp</span><span class="params">(calendar: <span class="type">Calendar</span>)</span></span>: <span class="built_in">Long</span> = calendar.timeInMillis</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TypeConverter</span> <span class="function"><span class="keyword">fun</span> <span class="title">datestampToCalendar</span><span class="params">(value: <span class="type">Long</span>)</span></span>: Calendar =</span><br><span class="line">            Calendar.getInstance().apply &#123; timeInMillis = value &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在数据库声明的时候，加上<code>@TypeConverter(COnverter::class)</code>即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Database(...)</span></span><br><span class="line"><span class="meta">@TypeConverters(Converters::class)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AppDatabase</span> : <span class="type">RoomDatabase</span></span>() &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-数据库迁移：这个还需要查找资料"><a href="#3-2-数据库迁移：这个还需要查找资料" class="headerlink" title="3.2 数据库迁移：这个还需要查找资料"></a>3.2 数据库迁移：这个还需要查找资料</h2><p><a href="https://www.jianshu.com/p/3e358eb9ac43" target="_blank" rel="noopener">Android Room 框架学习</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1. 介绍&quot;&gt;&lt;/a&gt;1. 介绍&lt;/h1&gt;&lt;p&gt;官方网址：&lt;a href=&quot;https://developer.android.google.cn/topic/libr
      
    
    </summary>
    
      <category term="Android" scheme="https://tylerLiu.top/categories/Android/"/>
    
      <category term="Jetpack" scheme="https://tylerLiu.top/categories/Android/Jetpack/"/>
    
    
      <category term="Jetpack" scheme="https://tylerLiu.top/tags/Jetpack/"/>
    
  </entry>
  
  <entry>
    <title>Android Jetpack：ViewModel&amp;LiveData</title>
    <link href="https://tylerLiu.top/2019/08/02/Android-Jetpack-ViewModel-LiveData/"/>
    <id>https://tylerLiu.top/2019/08/02/Android-Jetpack-ViewModel-LiveData/</id>
    <published>2019-08-02T05:40:06.000Z</published>
    <updated>2019-08-22T03:13:54.375Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="https://tylerliu.top/2019/07/31/Android-Jetpack-DataBinding/">Android-Jetpack-DataBinding</a>中，讨论了MVVM模式和Data Binding组件，这里继续学习跟MVVM有关的Android Jetpack组件——<code>ViewModel</code>和<code>LiveData</code>。</p><h1 id="1-LiveData"><a href="#1-LiveData" class="headerlink" title="1. LiveData"></a>1. LiveData</h1><p>官方文档：<a href="https://developer.android.google.cn/topic/libraries/architecture/livedata" target="_blank" rel="noopener">LiveData</a></p><p>先来看看<code>LiveData</code>和<code>ViewMOdel</code>的作用：</p><img src="/2019/08/02/Android-Jetpack-ViewModel-LiveData/9271486-93980cb4a2458d6d.webp"><p>从上图可以看出，<code>LiveData</code>和<code>ViewModel</code>在整个MVVM中担任数据驱动的职责，这也是MVVM中ViewMoel层的作用。</p><h2 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h2><p>官网介绍：</p><blockquote><p>LiveData is an observable data holder class. Unlike a regular observable, LiveData is lifecycle-aware, meaning it respects the lifecycle of other app components, such as activities, fragments, or services. This awareness ensures LiveData only updates app component observers that are in an active lifecycle state.<br>直译：LiveData是一个可观察的数据持有者类。与常规的可观察对象不同，LiveData是生命周期感知的，这意味着它尊重其他应用程序组件的生命周期，比如活动、片段或服务。这种意识确保LiveData只更新处于活动生命周期状态的应用程序组件观察者。</p></blockquote><p>可以看出<code>LiveData</code>作用和<code>RxJava</code>类似，是观察数据的类，相比<code>RxJava</code>，<code>LiveData</code>能在Activity、Fragment和Service中正确处理声明周期。<br><code>LiveData</code>的优点：</p><ul><li>数据变更时更新UI</li><li>没有内存泄露</li><li>不会因为停止Activity崩溃</li><li>无需手动处理生命周期</li><li>共享资源</li></ul><h2 id="1-2-使用方式"><a href="#1-2-使用方式" class="headerlink" title="1.2 使用方式"></a>1.2 使用方式</h2><p>常用的API：</p><ul><li><code>observe(@NotNull LifeCycleOwner owner, @NotNull Observe&lt;? super T&gt; observer)</code>：最常用的方法，需要提供<code>Observer</code>数据变更后的处理。<code>LifeCycleOwner</code>是能够正确处理生命周期的关键</li><li><code>setValue(T value)</code>：设置数据</li><li><code>getValue():T</code>：获取数据</li><li><code>postValue(T value)</code>：在主线程更新数据</li></ul><h2 id="1-3-使用场景"><a href="#1-3-使用场景" class="headerlink" title="1.3 使用场景"></a>1.3 使用场景</h2><p>配合Android Jetpack的其他组件使用，如<code>ViewModel</code>和<code>Room</code>。</p><h1 id="2-ViewModel"><a href="#2-ViewModel" class="headerlink" title="2. ViewModel"></a>2. ViewModel</h1><p>官方文档：<a href="https://developer.android.google.cn/topic/libraries/architecture/viewmodel" target="_blank" rel="noopener"><code>ViewModel</code></a></p><p>MVVM中ViewModel层是用来逻辑处理的，Android Jetpack中的<code>ViewModel</code>是否一样呢？</p><h2 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h2><p>官网介绍：</p><blockquote><p>The ViewModel class is designed to store and manage UI-related data in a lifecycle conscious way. The ViewModel class allows data to survive configuration changes such as screen rotations.</p></blockquote><p><code>ViewModel</code>同样具有生命周期，用来处理跟UI相关的数据，并且，当设备的一些<strong>配置信息改变</strong>（如屏幕旋转）时，它的数据不会消失。<br>通常，如果不做特殊处理，当屏幕旋转时，数据会消失，<code>ViewModel</code>管理数据为什么不会消失？因为<code>ViewModel</code>的生命周期：</p><img src="/2019/08/02/Android-Jetpack-ViewModel-LiveData/20190802160842.png"><p><code>ViewModel</code>的另一个特点就是实现<code>Actiivty</code>和<code>Framgent</code>之间的数据共享。</p><h2 id="2-2-使用方法"><a href="#2-2-使用方法" class="headerlink" title="2.2 使用方法"></a>2.2 使用方法</h2><p>继承<code>ViewMoel</code>即可。</p><h2 id="2-3-Demo"><a href="#2-3-Demo" class="headerlink" title="2.3 Demo"></a>2.3 Demo</h2><h3 id="2-3-1-步骤1：添加依赖"><a href="#2-3-1-步骤1：添加依赖" class="headerlink" title="2.3.1 步骤1：添加依赖"></a>2.3.1 步骤1：添加依赖</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// liveData</span></span><br><span class="line">implementation <span class="string">"androidx.lifecycle:lifecycle-livedata-ktx:2.2.0-alpha02"</span></span><br><span class="line"><span class="comment">// viewModel</span></span><br><span class="line">implementation <span class="string">"androidx.lifecycle:lifecycle-viewmodel-ktx:2.2.0-alpha02"</span></span><br><span class="line">implementation <span class="string">"androidx.lifecycle:lifecycle-extensions:2.2.0-alpha02"</span></span><br></pre></td></tr></table></figure><h3 id="2-3-2-步骤2：创建Model"><a href="#2-3-2-步骤2：创建Model" class="headerlink" title="2.3.2 步骤2：创建Model"></a>2.3.2 步骤2：创建Model</h3><p>继承<code>ViewModel</code>，分别创建品牌名的观察对象<code>brand:MutableliveData&lt;String&gt;</code>和对鞋子集合的观察对象<code>shose:LiveData&lt;List&lt;Shoe&gt;&gt;</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ly.allendemojetpack.viewmodel</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.*</span><br><span class="line"><span class="keyword">import</span> com.ly.allendemojetpack.db.<span class="keyword">data</span>.Shoe</span><br><span class="line"><span class="keyword">import</span> com.ly.allendemojetpack.db.repository.ShoeRepository</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoeModel</span> <span class="keyword">constructor</span></span>(repository: ShoeRepository) : ViewModel() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> ALL = <span class="string">"所有"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 品牌的观察对象，默认观察所有的品牌</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> brand = MutableLiveData&lt;String&gt;().apply &#123;</span><br><span class="line">        value = ALL</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 鞋子集合的观察类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> shoes: LiveData&lt;List&lt;Shoe&gt;&gt; = brand.switchMap &#123;</span><br><span class="line">        <span class="comment">// Room数据库查询，只要知道返回的是LiveData&lt;List&lt;Shoe&gt;&gt;即可</span></span><br><span class="line">        <span class="keyword">if</span> (it == ALL) &#123;</span><br><span class="line">            repository.getAllShoes()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            repository.getShoeByBrand(it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-3-步骤3：获取ViewModel"><a href="#2-3-3-步骤3：获取ViewModel" class="headerlink" title="2.3.3 步骤3：获取ViewModel"></a>2.3.3 步骤3：获取ViewModel</h3><ol><li>无构造参数获取：构造函数没有参数的情况下，获取<code>ShoeModel</code>很简单，<code>ViewModelProvider.of(this).get(ShoeModel::class.java)</code>就能返回需要的<code>ShoeModel</code>。</li><li>有构造参数获取：上面的<code>ShoeModel</code>需要传入一个参数<code>ShoeRepository</code>，这时，就需要自定义实现<code>Factory</code>：<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ly.allendemojetpack.viewmodel.factory</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.ViewModel</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.ViewModelProvider</span><br><span class="line"><span class="keyword">import</span> com.ly.allendemojetpack.db.repository.ShoeRepository</span><br><span class="line"><span class="keyword">import</span> com.ly.allendemojetpack.viewmodel.ShoeModel</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoeModelFactory</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> repository: ShoeRepository</span><br><span class="line">) : ViewModelProvider.NewInstanceFactory() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ViewModel?&gt;</span> <span class="title">create</span><span class="params">(modelClass: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">return</span> ShoeModel(repository) <span class="keyword">as</span> T</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>为了方便使用，这里写了一个统一的工具类<code>CustomViewModelProvider</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ly.allendemojetpack.viewmodel</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> androidx.navigation.NavController</span><br><span class="line"><span class="keyword">import</span> com.ly.allendemojetpack.db.RepositoryProvider</span><br><span class="line"><span class="keyword">import</span> com.ly.allendemojetpack.db.repository.ShoeRepository</span><br><span class="line"><span class="keyword">import</span> com.ly.allendemojetpack.db.repository.UserRepository</span><br><span class="line"><span class="keyword">import</span> com.ly.allendemojetpack.viewmodel.factory.LoginModelFactory</span><br><span class="line"><span class="keyword">import</span> com.ly.allendemojetpack.viewmodel.factory.RegisterModelFactory</span><br><span class="line"><span class="keyword">import</span> com.ly.allendemojetpack.viewmodel.factory.ShoeModelFactory</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ViewModel提供者</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Liuyang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">object</span> CustomViewModelProvider &#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">providerShoeModel</span><span class="params">(context: <span class="type">Context</span>)</span></span>: ShoeModelFactory &#123;</span><br><span class="line">        <span class="keyword">val</span> repository: ShoeRepository = RepositoryProvider.providerShoeRepository(context)</span><br><span class="line">        <span class="keyword">return</span> ShoeModelFactory(repository)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后就能在<code>ShoeFragemnt</code>中获取<code>ShoeModel</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by viewModels 需要依赖 "androidx.navigation:navigation-ui-ktx:$rootProject.navigationVersion"</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> viewModel: ShoeModel <span class="keyword">by</span> viewModels &#123;</span><br><span class="line">    CustomViewModelProvider.providerShoeModel(requireContext())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-4-步骤4：使用ViewModel"><a href="#2-3-4-步骤4：使用ViewModel" class="headerlink" title="2.3.4 步骤4：使用ViewModel"></a>2.3.4 步骤4：使用ViewModel</h3><p><code>ViewModel</code>的使用需要结合具体的业务，这里的<code>ShoeModel</code>在<code>ShoeFragment</code>中的使用如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ly.allendemojetpack.ui.fragment.main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.view.LayoutInflater</span><br><span class="line"><span class="keyword">import</span> android.view.View</span><br><span class="line"><span class="keyword">import</span> android.view.ViewGroup</span><br><span class="line"><span class="keyword">import</span> androidx.fragment.app.Fragment</span><br><span class="line"><span class="keyword">import</span> androidx.fragment.app.viewModels</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.Observer</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.ViewModelProviders</span><br><span class="line"><span class="keyword">import</span> com.ly.allendemojetpack.databinding.FragmentShoeBinding</span><br><span class="line"><span class="keyword">import</span> com.ly.allendemojetpack.ui.adapter.ShoeAdapter</span><br><span class="line"><span class="keyword">import</span> com.ly.allendemojetpack.viewmodel.CustomViewModelProvider</span><br><span class="line"><span class="keyword">import</span> com.ly.allendemojetpack.viewmodel.ShoeModel</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 鞋子的Fragment</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Liuyang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoeFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line">    <span class="comment">// by viewModels 需要依赖 "androidx.navigation:navigation-ui-ktx:$rootProject.navigationVersion"</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> viewModel: ShoeModel <span class="keyword">by</span> viewModels &#123;</span><br><span class="line">        CustomViewModelProvider.providerShoeModel(requireContext())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(inflater: <span class="type">LayoutInflater</span>, container: <span class="type">ViewGroup</span>?, savedInstanceState: <span class="type">Bundle</span>?)</span></span>: View? &#123;</span><br><span class="line">        <span class="keyword">val</span> binding: FragmentShoeBinding = FragmentShoeBinding.inflate(inflater, container, <span class="literal">false</span>)</span><br><span class="line">        context ?: <span class="keyword">return</span> binding.root</span><br><span class="line"></span><br><span class="line">        ViewModelProviders.of(<span class="keyword">this</span>).<span class="keyword">get</span>(ShoeModel::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 适配器</span></span><br><span class="line">        <span class="keyword">val</span> adapter = ShoeAdapter()</span><br><span class="line">        binding.recycler.adapter = adapter</span><br><span class="line">        onSubscribeUi(adapter)</span><br><span class="line">        <span class="keyword">return</span> binding.root</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 鞋子数据更新的通知</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSubscribeUi</span><span class="params">(adapter: <span class="type">ShoeAdapter</span>)</span></span> &#123;</span><br><span class="line">        viewModel.shoes.observe(viewLifecycleOwner, Observer &#123;</span><br><span class="line">            <span class="keyword">if</span> (it != <span class="literal">null</span>) &#123;</span><br><span class="line">                adapter.submitList(it)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>onSubscribeUi()</code>中，使用<code>ShoeModel</code>的<code>LiveData</code>进行观察通知，当鞋子集合更新数据时，就会更新到当前的适配器中。</p><p>布局文件<code>framgent_shoe.xml</code>很简单，虽然使用了Data Binding，但是没有变量，只有一个<code>RecyclerView</code>。</p><p>Demo地址：<a href="https://gitee.com/QingFengBaiYu/Allen_Demo_Jetpack" target="_blank" rel="noopener">Allen_Demo_Jetpack</a></p><h1 id="3-其他"><a href="#3-其他" class="headerlink" title="3. 其他"></a>3. 其他</h1><h2 id="3-1-LiveData数据变换"><a href="#3-1-LiveData数据变换" class="headerlink" title="3.1 LiveData数据变换"></a>3.1 LiveData数据变换</h2><p><code>LiveData</code>中数据变换方法有<code>map()</code>和<code>switchMap()</code>，<code>switchMap()</code>在上面已经看到了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本地数据仓库</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoeRepository</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> shoeDao: ShoeDao) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getAllShoes</span><span class="params">()</span></span> = shoeDao.getAllShoes()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过品牌查询鞋子，返回LiveData&lt;List&lt;Shoe&gt;&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getShoeByBrand</span><span class="params">(brand: <span class="type">String</span>)</span></span> = shoeDao.findShoeByBrand(brand)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入鞋子的集合，返回LiveData&lt;List&lt;Shoe&gt;&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">insertShoes</span><span class="params">(shoes: <span class="type">List</span>&lt;<span class="type">Shoe</span>&gt;)</span></span> = shoeDao.insertShoe(shoes)</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoeModel</span> <span class="keyword">constructor</span></span>(repository: ShoeRepository) : ViewModel() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> ALL = <span class="string">"所有"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 品牌的观察对象，默认观察所有的品牌</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> brand = MutableLiveData&lt;String&gt;().apply &#123;</span><br><span class="line">        value = ALL</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 鞋子集合的观察类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> shoes: LiveData&lt;List&lt;Shoe&gt;&gt; = brand.switchMap &#123;</span><br><span class="line">        <span class="comment">// Room数据库查询，只要知道返回的是LiveData&lt;List&lt;Shoe&gt;&gt;即可</span></span><br><span class="line">        <span class="keyword">if</span> (it == ALL) &#123;</span><br><span class="line">            repository.getAllShoes()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            repository.getShoeByBrand(it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>map()</code>的使用借用官方的例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> userLiveData: LiveData&lt;User&gt; = UserLiveData()</span><br><span class="line"><span class="keyword">val</span> userName: LiveData&lt;String&gt; = Transformations.map(userLiveData) &#123;</span><br><span class="line">    user -&gt; <span class="string">"<span class="subst">$&#123;user.name&#125;</span> <span class="subst">$&#123;user.lastName&#125;</span>"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>map()</code>也可以实现将A变成B，二者有什么区别呢？</p><ul><li><code>map()</code>中只有一个<code>LiveData&lt;A&gt;</code>，它在<code>LiveData&lt;A&gt;</code>发送数据的时候将A变成B</li><li><code>switchMap()</code>中同时存在<code>LiveData&lt;A&gt;</code>和<code>LiveData&lt;B&gt;</code>，<code>LiveData&lt;A&gt;</code>更新之后，通知<code>LiveData&lt;B&gt;</code>更新。</li></ul><h2 id="3-2-LiveData如何共享数据"><a href="#3-2-LiveData如何共享数据" class="headerlink" title="3.2 LiveData如何共享数据"></a>3.2 LiveData如何共享数据</h2><p>如果有这样的需求：注册页需要记录信息，注册完成跳转到登录页，并将账号和密码显示在登录页。这时，可以定义一个类然后继承<code>LiveData</code>，并使用单例模式即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ly.allendemojetpack.common.livedata</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  登录信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Liuyang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginInfo</span> <span class="keyword">constructor</span></span>(<span class="keyword">val</span> account: String, <span class="keyword">val</span> pwd: String, <span class="keyword">val</span> email: String)</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ly.allendemojetpack.common.livedata</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.<span class="keyword">annotation</span>.MainThread</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.LiveData</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义单例LiveData</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Liuyang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginLiveData</span> : <span class="type">LiveData</span>&lt;<span class="type">LoginInfo</span>&gt;</span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> sInstance: LoginLiveData</span><br><span class="line"></span><br><span class="line">        <span class="meta">@MainThread</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">()</span></span>: LoginLiveData &#123;</span><br><span class="line">            sInstance = <span class="keyword">if</span> (::sInstance.isInitialized) sInstance <span class="keyword">else</span> LoginLiveData()</span><br><span class="line">            <span class="keyword">return</span> sInstance</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-使用ViewModel在同一个Activity中的Fragment之间共享数据"><a href="#3-3-使用ViewModel在同一个Activity中的Fragment之间共享数据" class="headerlink" title="3.3 使用ViewModel在同一个Activity中的Fragment之间共享数据"></a>3.3 使用ViewModel在同一个Activity中的Fragment之间共享数据</h2><p>要想利用<code>ViewModel</code>实现Fragment之间数据共享，前提是<code>Fragment</code>中的<code>FragmentActivity</code>要相同，这里看看官方示例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SharedViewModel</span> : <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line">    <span class="keyword">val</span> selected = MutableLiveData&lt;Item&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">select</span><span class="params">(item: <span class="type">Item</span>)</span></span> &#123;</span><br><span class="line">        selected.value = item</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MasterFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> itemSelector: Selector</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> model: SharedViewModel</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        model = activity?.run &#123;</span><br><span class="line">            ViewModelProviders.of(<span class="keyword">this</span>).<span class="keyword">get</span>(SharedViewModel::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">        &#125; ?: <span class="keyword">throw</span> Exception(<span class="string">"Invalid Activity"</span>)</span><br><span class="line">        itemSelector.setOnClickListener &#123; item -&gt;</span><br><span class="line">            <span class="comment">// Update the UI</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetailFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> model: SharedViewModel</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        model = activity?.run &#123;</span><br><span class="line">            ViewModelProviders.of(<span class="keyword">this</span>).<span class="keyword">get</span>(SharedViewModel::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">        &#125; ?: <span class="keyword">throw</span> Exception(<span class="string">"Invalid Activity"</span>)</span><br><span class="line">        model.selected.observe(<span class="keyword">this</span>, Observer&lt;Item&gt; &#123; item -&gt;</span><br><span class="line">            <span class="comment">// Update the UI</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在&lt;a href=&quot;https://tylerliu.top/2019/07/31/Android-Jetpack-DataBinding/&quot;&gt;Android-Jetpack-DataBinding&lt;/a&gt;中，讨论了MVVM模式和Data Binding组件，这里继续学习跟
      
    
    </summary>
    
      <category term="Android" scheme="https://tylerLiu.top/categories/Android/"/>
    
      <category term="Jetpack" scheme="https://tylerLiu.top/categories/Android/Jetpack/"/>
    
    
      <category term="Jetpack" scheme="https://tylerLiu.top/tags/Jetpack/"/>
    
  </entry>
  
  <entry>
    <title>Android Jetpack：DataBinding</title>
    <link href="https://tylerLiu.top/2019/07/31/Android-Jetpack-DataBinding/"/>
    <id>https://tylerLiu.top/2019/07/31/Android-Jetpack-DataBinding/</id>
    <published>2019-07-31T08:34:26.000Z</published>
    <updated>2019-08-22T03:13:22.417Z</updated>
    
    <content type="html"><![CDATA[<p>Android Jetpack一系类的内容，适合使用MVVM，这里先看看MVVM。</p><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><h2 id="1-1-MVVM介绍"><a href="#1-1-MVVM介绍" class="headerlink" title="1.1 MVVM介绍"></a>1.1 MVVM介绍</h2><p>MVVM，全称Model-View-ViewModel，和MVC和MVP一样，是逻辑分层解耦的模式。</p><h3 id="1-1-1-结构图"><a href="#1-1-1-结构图" class="headerlink" title="1.1.1 结构图"></a>1.1.1 结构图</h3><img src="/2019/07/31/Android-Jetpack-DataBinding/9271486-daf7f3dda87c84ab.webp"><p>MVVM三要素：</p><ul><li>View层：xml、Activity、Framgent、Adapter和View等</li><li>Model层：数据源（包括本地数据和网络数据等）</li><li>ViewModel层：View层处理数据以及逻辑处理</li></ul><h2 id="1-2-Data-Binding介绍"><a href="#1-2-Data-Binding介绍" class="headerlink" title="1.2 Data Binding介绍"></a>1.2 Data Binding介绍</h2><p>MVVM是一种架构模式，Data Binding是一种实现数据和UI绑定的框架，是构建MVVM模式的一个工具。</p><ul><li>官方文档：<a href="https://developer.android.google.cn/topic/libraries/data-binding/" target="_blank" rel="noopener">Data Binding</a></li><li>官方Demo地址：<a href="https://github.com/googlecodelabs/android-databinding" target="_blank" rel="noopener">android-databinding</a></li></ul><h1 id="2-Demo"><a href="#2-Demo" class="headerlink" title="2. Demo"></a>2. Demo</h1><p>这里会在前一篇<a href="https://tylerliu.top/2019/07/29/Android-Jetpack-Navigation/">Android-Jetpack-Navigation</a>的基础上进行扩展，如果要查看之前的可以使用git进行版本回退，本文会在注册和登录模块上进行修改。</p><h2 id="2-1-步骤1：在module的build-gradle中添加如下："><a href="#2-1-步骤1：在module的build-gradle中添加如下：" class="headerlink" title="2.1 步骤1：在module的build.gradle中添加如下："></a>2.1 步骤1：在module的build.gradle中添加如下：</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    dataBinding &#123;</span><br><span class="line">        enabled <span class="keyword">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-步骤2：构建LoginModel"><a href="#2-2-步骤2：构建LoginModel" class="headerlink" title="2.2 步骤2：构建LoginModel"></a>2.2 步骤2：构建LoginModel</h2><p>创建登录的<code>LoginModel</code>，主要负责登录逻辑的处理以及两个输入框内容改变时数据的更新：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ly.allendemojetpack.viewmodel</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> android.content.Intent</span><br><span class="line"><span class="keyword">import</span> android.text.Editable</span><br><span class="line"><span class="keyword">import</span> android.widget.EditText</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast</span><br><span class="line"><span class="keyword">import</span> androidx.databinding.BindingAdapter</span><br><span class="line"><span class="keyword">import</span> androidx.databinding.ObservableField</span><br><span class="line"><span class="keyword">import</span> com.ly.allendemojetpack.MainActivity</span><br><span class="line"><span class="keyword">import</span> com.ly.allendemojetpack.common.Constant</span><br><span class="line"><span class="keyword">import</span> com.ly.allendemojetpack.common.listener.SimpleWatcher</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginModel</span> <span class="keyword">constructor</span></span>(name: String, pwd: String, context: Context) &#123;</span><br><span class="line">    <span class="keyword">val</span> n = ObservableField&lt;String&gt;(name)</span><br><span class="line">    <span class="keyword">val</span> p = ObservableField&lt;String&gt;(pwd)</span><br><span class="line">    <span class="keyword">val</span> context: Context = context</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户名改变时的回调</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onNameChanged</span><span class="params">(s: <span class="type">CharSequence</span>)</span></span> &#123;</span><br><span class="line">        n.<span class="keyword">set</span>(s.toString())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 密码改变时的回调</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onPwdChanged</span><span class="params">(s: <span class="type">CharSequence</span>, start: <span class="type">Int</span>, before: <span class="type">Int</span>, count: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        p.<span class="keyword">set</span>(s.toString())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录的逻辑</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">login</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n.<span class="keyword">get</span>().equals(Constant.USERNAME) &amp;&amp; p.<span class="keyword">get</span>().equals(Constant.PASSWORD)) &#123;</span><br><span class="line">            Toast.makeText(context, <span class="string">"账号密码正确"</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">            <span class="keyword">val</span> intent = Intent(context, MainActivity::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">            context.startActivity(intent)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> nameWatcher = <span class="keyword">object</span> : SimpleWatcher() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">afterTextChanged</span><span class="params">(s: <span class="type">Editable</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.afterTextChanged(s)</span><br><span class="line"></span><br><span class="line">            n.<span class="keyword">set</span>(s.toString())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> pwdWatcher = <span class="keyword">object</span> : SimpleWatcher() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">afterTextChanged</span><span class="params">(s: <span class="type">Editable</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.afterTextChanged(s)</span><br><span class="line"></span><br><span class="line">            p.<span class="keyword">set</span>(s.toString())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BindingAdapter(<span class="meta-string">"addTextChangedListener"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addTextChangedListener</span><span class="params">(editText: <span class="type">EditText</span>, simpleWatcher: <span class="type">SimpleWatcher</span>)</span></span> &#123;</span><br><span class="line">        editText.addTextChangedListener(simpleWatcher)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ObservableField</code>是一个可观察的域，通过泛型来使用，可以使用的方法有三个：</p><ul><li><code>ObservableField(T value)</code>：构造函数，设置可观察的域</li><li><code>T get()</code>：获取可观察的域的内容，可以使用UI控件监测它的值</li><li><code>set(T value)</code>：设置可观察的域，设置成功后，会通知UI控件进行更新</li></ul><p>再来看看<code>LoginModel</code>，里面包含了用来观察<code>name</code>和<code>pws</code>的两个成员变量<code>n</code>和<code>p</code>，以及一个登录的逻辑处理方法。</p><h2 id="2-3-步骤3：创建布局文件"><a href="#2-3-步骤3：创建布局文件" class="headerlink" title="2.3 步骤3：创建布局文件"></a>2.3 步骤3：创建布局文件</h2><p>使用Data Binding之后的布局文件和之前的会有很大不同，里面包含了一些新的标签：</p><ul><li><code>layout</code>：布局根节点，只能包裹一个<code>View</code>标签，且不能包裹<code>merge</code>标签。</li><li><code>data</code>：Data Binding的数据，只能存放一个data标签。</li><li><code>variable</code>：在<code>data</code>标签中使用，数据的变量标签。<code>type</code>属性指明变量的类。<code>name</code>属性指明变量的名字，方便布局中使用。</li><li><code>import</code>：在<code>data</code>标签中使用，需要使用静态方法和静态常量，如果需要使用<code>view.visible</code>属性的时候，需要导入<code>&lt;import type=&quot;android.view.View&quot;/&gt;</code>。<code>type</code>属性指明类的路径，如果两个<code>import</code>标签带入的类名相同，可以使用<code>alias</code>属性声明别名，使用时直接用别名即可。</li></ul><p>来看看<code>LoginFragment</code>的布局文件<code>fragment_login.xml</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--ViewModel，通过mBinding.vm=mViewMode注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"model"</span> <span class="attr">type</span>=<span class="string">"com.ly.allendemojetpack.viewmodel.LoginModel"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"activity"</span> <span class="attr">type</span>=<span class="string">"androidx.fragment.app.FragmentActivity"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/txt_cancel"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:onClick</span>=<span class="string">"@&#123;()-&gt; activity.onBackPressed()&#125;"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">......</span></span></span><br><span class="line"><span class="tag">                /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/txt_title"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">......</span></span></span><br><span class="line"><span class="tag">                /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/et_account"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:text</span>=<span class="string">"@&#123;model.n.get()&#125;"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:onTextChanged</span>=<span class="string">"@&#123;(text, start, before, count)-&gt;model.onNameChanged(text)&#125;"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">......</span></span></span><br><span class="line"><span class="tag">                /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/et_pwd"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:text</span>=<span class="string">"@&#123;model.p.get()&#125;"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:onTextChanged</span>=<span class="string">"@&#123;model::onPwdChanged&#125;"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">......</span></span></span><br><span class="line"><span class="tag">                /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/btn_login"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:onClick</span>=<span class="string">"@&#123;()-&gt; model.login()&#125;"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:enabled</span>=<span class="string">"@&#123;(model.p.get().isEmpty()||model.n.get().isEmpty()) ? false : true&#125;"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">......</span></span></span><br><span class="line"><span class="tag">                /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>variable</code>有了两个：</p><ul><li><code>model</code>：类型为<code>com.ly.allendemojetpack.viewmodel.LoginModel</code>，绑定用户名。</li><li><code>activity</code>：类型为<code>androidx.fragment.app.FragmentActivity</code>，主要用来处理返回按钮事件。</li></ul><p>知识点讲解：</p><ol><li>属性的引用<br>如果想使用<code>ViewModel</code>中成员变量，直接使用<code>model.p</code>即可。</li><li>事件绑定<br>事件绑定包括方法引用和监听绑定：</li></ol><ul><li>方法引用：参数类型和返回类型要一致，参考<code>et_pwd</code>的<code>android:onTextChanged</code>引用</li><li>监听绑定：要求没有方法引用高，可以使用自定义函数，参考<code>et_account</code>的<code>android:onTextChanged</code>引用。</li></ul><ol start="3"><li>表达式<br><code>btn_login</code>按钮在账号或密码为空的时候，是灰色的：</li></ol><img src="/2019/07/31/Android-Jetpack-DataBinding/11843186-4e333c0f092fcdc2.png"><p>这是因为在代码中设置了<code>android:enabled=&quot;@{(model.p.get().isEmpty()||model.n.get().isEmpty()) ? false : true}&quot;</code>，意思是用户名或密码为空时，设置<code>android:enable</code>属性设置为<code>flase</code>，这是一个三元表达式，除了上面的<code>||</code>和三元表达式，Data Binding还支持：</p><ul><li>运算符 + - / * %</li><li>字符串连接 +</li><li>逻辑与或 &amp;&amp; ||</li><li>二进制 &amp; | ^</li><li>一元 + - ! ~</li><li>移位 &gt;&gt; &gt;&gt;&gt; &lt;&lt;</li><li>比较 == &gt; &lt; &gt;= &lt;= (Note that &lt; needs to be escaped as &lt;)</li><li>instanceof</li><li>Grouping ()</li><li>Literals - character, String, numeric, null</li><li>Cast</li><li>方法调用</li><li>域访问</li><li>数组访问</li><li>三元操作符</li></ul><p>除了上述，Data Binding还新增了空合并操作符<code>??</code>，例如<code>androud:text=&quot;@{user.displayName ?? user.lastName}&quot;</code>等价于<code>android:text=&quot;@{user.displayName != null ? user.displayName : user.lastName}&quot;</code></p><h2 id="2-4-生成绑定类"><a href="#2-4-生成绑定类" class="headerlink" title="2.4 生成绑定类"></a>2.4 生成绑定类</h2><p>创建完布局文件之后，点击Make Project按钮，系统会自动生成绑定类：</p><img src="/2019/07/31/Android-Jetpack-DataBinding/11843186-74caa4177dd6e3f7.png"><p>下面只需要在<code>LoginFragment</code>中完成绑定操作即可，既可以使用生成的<code>FragmentLoginBinding</code>，也可以使用自带的<code>BindingUtil</code>。</p><ol><li>使用<code>BindingUtil</code><br><code>BindingUtil</code>常用的API：</li></ol><ul><li><code>setContentView()</code>：进行Activity下面的绑定</li><li><code>inflate</code>：进行Fragment下面的绑定</li><li><code>bind</code>：进行View的绑定</li></ul><p><code>LoginFragemnt</code>绑定代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(inflater: <span class="type">LayoutInflater</span>, container: <span class="type">ViewGroup</span>?, savedInstanceState: <span class="type">Bundle</span>?)</span></span>: View? &#123;</span><br><span class="line">    <span class="keyword">val</span> binding: FragmentLoginBinding = DataBindingUtil.inflate(</span><br><span class="line">        inflater, R.layout.fragment_login, container, <span class="literal">false</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    loginModel = LoginModel(<span class="string">""</span>, <span class="string">""</span>, context!!)</span><br><span class="line">    binding.model = loginModel</span><br><span class="line">    binding.activity = activity</span><br><span class="line">    <span class="keyword">return</span> binding.root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用生产的<code>FragmentLoginBinding</code><br>使用方法与<code>DataBindingUtil</code>类似：<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(inflater: <span class="type">LayoutInflater</span>, container: <span class="type">ViewGroup</span>?, savedInstanceState: <span class="type">Bundle</span>?)</span></span>: View? &#123;</span><br><span class="line">    <span class="keyword">val</span> binding = FragmentLoginBinding.inflate(inflater, container, <span class="literal">false</span>)</span><br><span class="line">    loginModel = LoginModel(<span class="string">""</span>, <span class="string">""</span>, context!!)</span><br><span class="line">    binding.model = loginModel</span><br><span class="line">    binding.activity = activity</span><br><span class="line">    <span class="keyword">return</span> binding.root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="3-Data-Binding的一些其他功能"><a href="#3-Data-Binding的一些其他功能" class="headerlink" title="3. Data Binding的一些其他功能"></a>3. Data Binding的一些其他功能</h1><h2 id="3-1-布局中属性的设置"><a href="#3-1-布局中属性的设置" class="headerlink" title="3.1 布局中属性的设置"></a>3.1 布局中属性的设置</h2><h3 id="3-1-1-有属性有setter"><a href="#3-1-1-有属性有setter" class="headerlink" title="3.1.1 有属性有setter"></a>3.1.1 有属性有setter</h3><p>如果一个XXXView类中有成员变量<code>borderColor</code>，并且XXXView类中有<code>setBorderColor(int color)</code>方法，那么在布局文件中，可以借助Data Binding直接使用<code>app:borderColor</code>属性。</p><h3 id="3-1-2-没有setter，但有相关方法"><a href="#3-1-2-没有setter，但有相关方法" class="headerlink" title="3.1.2 没有setter，但有相关方法"></a>3.1.2 没有setter，但有相关方法</h3><p>以XXXView为例，内有有成员变量<code>borderColor</code>，这次设置<code>borderColor</code>的方法是<code>setBorder()</code>（或者其他，总之不是标准的set方法，<code>setBorderColor()</code>），还使用<code>app:borderColor</code>肯定不行的。这时，可以通过<code>BindingMethods</code>注解实现<code>app:borderColor</code>的使用，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingMethods(value = [</span></span><br><span class="line"><span class="meta">    BindingMethod(</span></span><br><span class="line"><span class="meta">        type = 包名.XXXView::class, </span></span><br><span class="line"><span class="meta">        attribute = <span class="meta-string">"app:borderColor"</span>, </span></span><br><span class="line"><span class="meta">        method = <span class="meta-string">"setBColor"</span>)</span>])</span><br></pre></td></tr></table></figure><h3 id="3-1-3-自定义属性"><a href="#3-1-3-自定义属性" class="headerlink" title="3.1.3 自定义属性"></a>3.1.3 自定义属性</h3><p>现在不仅没有<code>setter</code>方法，甚至成员变量都没有。例如现在要给<code>EditText</code>添加文本监听器，这样，现在<code>LoginModel</code>中自定义个监听器，并使用<code>@BindingAdapter</code>注解：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> nameWatcher = <span class="keyword">object</span> : SimpleWatcher() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">afterTextChanged</span><span class="params">(s: <span class="type">Editable</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.afterTextChanged(s)</span><br><span class="line"></span><br><span class="line">        n.<span class="keyword">set</span>(s.toString())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BindingAdapter(<span class="meta-string">"addTextChangedListener"</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">addTextChangedListener</span><span class="params">(editText: <span class="type">EditText</span>, simpleWatcher: <span class="type">SimpleWatcher</span>)</span></span> &#123;</span><br><span class="line">    editText.addTextChangedListener(simpleWatcher)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以在布局文件中使用<code>app:addTextChangedListener</code>属性了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/et_account"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"@&#123;model.n.get()&#125;"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:addTextChangedListener</span>=<span class="string">"@&#123;model.nameWatcher&#125;"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">...</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br></pre></td></tr></table></figure><p>效果和之前的一样。</p><h2 id="3-2-数据双向绑定"><a href="#3-2-数据双向绑定" class="headerlink" title="3.2 数据双向绑定"></a>3.2 数据双向绑定</h2><p>数据双向绑定可以分为两种情况：数据刷新视图和视图刷新数据。</p><h3 id="3-2-1-数据刷新视图"><a href="#3-2-1-数据刷新视图" class="headerlink" title="3.2.1 数据刷新视图"></a>3.2.1 数据刷新视图</h3><p>需要数据变化时视图也跟着变化。有了两种实现方式：</p><ul><li>自定义继承<code>BaseObservable</code></li><li>使用<code>ObservableField</code></li></ul><ol><li>继承<code>BaseObservable</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ly.allendemojetpack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.databinding.BaseObservable;</span><br><span class="line"><span class="keyword">import</span> androidx.databinding.Bindable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableUser</span> <span class="keyword">extends</span> <span class="title">BaseObservable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注解才会自动在build目录BR类中生成entry, 要求方法名必须以get开头</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bindable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> firstName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bindable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirstName</span><span class="params">(String firstName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">        <span class="comment">// 手动刷新</span></span><br><span class="line">        notifyPropertyChanged(BR.firstName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastName</span><span class="params">(String lastName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">        notifyPropertyChanged(BR.lastName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><code>BaseObservable</code>和<code>Observable</code>的区别：</p><ul><li><code>BaseObservable</code>是实现了<code>Observable</code>的类，帮助实现监听器的线程安全问题；</li><li><code>BaseObservable</code>使用了<code>addPropertyChangeRegistry()</code>来执行<code>OnPropertyChangedCallback()</code>；</li><li>不建议直接实现<code>Observable</code>。</li></ul><ol start="2"><li>使用<code>ObservableField</code><br>Data Binding默认实现了一系列<code>Observable</code>接口的字段：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BaseObservable,</span><br><span class="line">ObservableBoolean,</span><br><span class="line">ObservableByte,</span><br><span class="line">ObservableChar,</span><br><span class="line">ObservableDouble,</span><br><span class="line">ObservableField&lt;T&gt;,</span><br><span class="line">ObservableFloat,</span><br><span class="line">ObservableInt,</span><br><span class="line">ObservableLong,</span><br><span class="line">ObservableParcelable&lt;T extends Parcelable&gt;,</span><br><span class="line">ObservableShort,</span><br><span class="line">ViewDataBinding</span><br></pre></td></tr></table></figure></li></ol><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlainUser</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> ObservableField&lt;String&gt; firstName = <span class="keyword">new</span> ObservableField&lt;&gt;();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> ObservableField&lt;String&gt; lastName = <span class="keyword">new</span> ObservableField&lt;&gt;();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> ObservableInt age = <span class="keyword">new</span> ObservableInt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于集合类型，可以使用<code>ObservableArryMap</code>、<code>ObservableArryList</code>、<code>ObservableMap</code>等集合类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ObservableArrayMap&lt;String, Object&gt; user = <span class="keyword">new</span> ObservableArrayMap&lt;&gt;();</span><br><span class="line">user.put(<span class="string">"firstName"</span>, <span class="string">"Google"</span>);</span><br><span class="line">user.put(<span class="string">"lastName"</span>, <span class="string">"Inc."</span>);</span><br><span class="line">user.put(<span class="string">"age"</span>, <span class="number">17</span>);</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">"android.databinding.ObservableMap"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">type</span>=<span class="string">"ObservableMap&lt;String, Object&gt;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">…</span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:text</span>=<span class="string">'@&#123;user["lastName"]&#125;'</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:text</span>=<span class="string">'@&#123;String.valueOf(1 + (Integer)user["age"])&#125;'</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>还支持<code>ObservableParcelable&lt;Object&gt;</code>序列化数据类型；</li><li><code>ObservableField</code>同样可以使用<code>addPropertyChangedCallback</code>监听属性变化。</li></ul><h3 id="3-2-2-视图刷新数据"><a href="#3-2-2-视图刷新数据" class="headerlink" title="3.2.2 视图刷新数据"></a>3.2.2 视图刷新数据</h3><p>通过使用表达式<code>@=</code>就可以在视图刷新时自动刷新数据，但是要求数据实现以下 两种方式修改才会触发刷新：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:inputType</span>=<span class="string">"textNoSuggestions"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"@=&#123;model.name&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>这种双向绑定会存在一个死循环的问题，即数据变化（回调监听器）触发了视图变化，视图变化又会触发数据变化（再次回调监听），一直循环，设置相同的数据也会视为数据变化。</p><p>所以需要判断当前变化的数据是否等于旧数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ly.allendemojetpack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"><span class="keyword">import</span> androidx.databinding.BindingAdapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomBindingAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@BindingAdapter</span>(<span class="string">"android:text"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setText</span><span class="params">(TextView view, CharSequence text)</span> </span>&#123;</span><br><span class="line">        CharSequence oldText = view.getText();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!haveContentChanged(text, oldText)) &#123;</span><br><span class="line">            <span class="comment">// 数据没有变化时，不进行视图刷新</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        view.setText(text);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 本方法使用的是官方源码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">haveContentChanged</span><span class="params">(CharSequence str1, CharSequence str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((str1 == <span class="keyword">null</span>) != (str2 == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> length = str1.length();</span><br><span class="line">        <span class="keyword">if</span> (length != str2.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str1.charAt(i) != str2.charAt(i)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这种判断是无效的，因为<code>String</code>参数传递属于引用类型变量，不是常量，需要使用<code>equals()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本段截取官方源码，是错误的</span></span><br><span class="line"><span class="keyword">if</span> (text == oldText || (text == <span class="keyword">null</span> &amp;&amp; oldText.length() == <span class="number">0</span>)) &#123;</span><br><span class="line">  <span class="keyword">return</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (text == <span class="keyword">null</span> || text.equals(oldText) || oldText.length() == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到本例，比如上面的<code>EditText</code>在实现双向绑定后，既不需要添加<code>SimpleWatcher</code>，也不需要用方法调用，实现代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/et_account"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"@=&#123;model.n.get()&#125;"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">......</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br></pre></td></tr></table></figure><p>仅仅将<code>@{model.n.get()}</code>换为<code>@={model.n.get()}</code>,需要注意，属性必须是可观察的，即使用上面提到的<code>ObservableField</code>，也可以自定义实现<code>BaseObservable</code>接口。</p><h1 id="4-注解"><a href="#4-注解" class="headerlink" title="4. 注解"></a>4. 注解</h1><h2 id="4-1-Bindable"><a href="#4-1-Bindable" class="headerlink" title="4.1 @Bindable"></a>4.1 @Bindable</h2><p>用于数据更新自动刷新视图。</p><h2 id="4-2-BindingAdapter"><a href="#4-2-BindingAdapter" class="headerlink" title="4.2 BindingAdapter"></a>4.2 BindingAdapter</h2><p>创建一个XML属性和函数，然后在属性中进行设置数据操作会进入该函数。图片加载框架可以使用此方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter</span>(value = &#123; <span class="string">"imageUrl"</span>, <span class="string">"error"</span> &#125;, requireAll = <span class="keyword">false</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadImage</span><span class="params">(ImageView view, String url, Drawable error)</span> </span>&#123;</span><br><span class="line">    Glide.with(view.getContext()).load(url).into(view);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>方法必须是<code>public static</code>；</li><li>第一个参数必须是控件或其父类</li><li>方法名随意</li><li>最后一个<code>boolean</code>类型是可选参数，可以要求是否所有参数都要填写，默认为<code>true</code></li><li>如果<code>requireAll</code>为<code>false</code>，没有填的属性将默认为<code>null</code>，所以需要做非空判断</li></ol><p>使用：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"200dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:error</span>=<span class="string">"@&#123;@drawable/error&#125;"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">allen:imageUrl</span>=<span class="string">"@&#123;imageUrl&#125;"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:onClickListener</span>=<span class="string">"@&#123;activity.avatarClickListener&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>命名空间可以是随意的，但如果在<code>BindingAdapter</code>的数组内定义了命名空间，就必须遵守。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里省略了一个注解参数.   </span></span><br><span class="line"><span class="meta">@BindingAdapter</span>(&#123; <span class="string">"android:imageUrl"</span>, <span class="string">"error"</span> &#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadImage</span><span class="params">(ImageView view, String url, Drawable error)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(url == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">  Glide.with(view.getContext()).load(url).into(view);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果数据初始化在异步，会回调方法，但数据为<code>null</code>（成员默认值），所以要先进行非空判断。</p><p>Kotlin有两种实现方式：</p><ol><li><p>单例 + <code>@JvmStatic</code>注解</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> ProgressAdapter &#123;</span><br><span class="line">    <span class="meta">@JvmStatic</span></span><br><span class="line">    <span class="meta">@BindingAdapter(<span class="meta-string">"android:bindName"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setBindName</span><span class="params">(view: <span class="type">View</span>, name:<span class="type">String</span>)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>顶级函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter(<span class="meta-string">"android:bindName"</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setBindName</span><span class="params">(view: <span class="type">View</span>, name:<span class="type">String</span>)</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于顶级函数太多影响代码补全建议使用顶级扩展函数, 之后也可以在代码中方便使用</span></span><br><span class="line"><span class="meta">@BindingAdapter(<span class="meta-string">"android:bindName"</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> View.<span class="title">setBindName</span><span class="params">( name:<span class="type">String</span>)</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="4-3-BindingMethods"><a href="#4-3-BindingMethods" class="headerlink" title="4.3 @BindingMethods"></a>4.3 @BindingMethods</h2><p>如果想创建一个XML属性并且和View中函数关联（即自动使用属性值作为参数调用该函数），就可以使用<code>@BindingMethods</code>注解这个类（也可以是一个接口）。</p><p>该注解属于一个容器，内部参数是一个<code>@BindingMethods</code>数组，只能用于修饰类或接口。</p><p>官方Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingMethods</span>(&#123;</span><br><span class="line">    <span class="meta">@BindingMethod</span>(type = android.widget.ProgressBar.class, attribute = <span class="string">"android:indeterminateTint"</span>, method = <span class="string">"setIndeterminateTintList"</span>),</span><br><span class="line">    <span class="meta">@BindingMethod</span>(type = android.widget.ProgressBar.class, attribute = <span class="string">"android:progressTint"</span>, method = <span class="string">"setProgressTintList"</span>),</span><br><span class="line">    <span class="meta">@BindingMethod</span>(type = android.widget.ProgressBar.class, attribute = <span class="string">"android:secondaryProgressTint"</span>, method = <span class="string">"setSecondaryProgressTintList"</span>),</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProgressBarBindingAdapter</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@BindingMethods</code>注解参数（必选）：</p><ul><li><code>type</code>：字节码，即控件类型</li><li><code>attribute</code>：XML属性</li><li><code>method</code>：函数名，即控件中的函数名称</li></ul><p>注意：</p><ul><li>如果属性名和<code>@BindingAdapter</code>定义的XML属性相同，会冲突报错</li><li>如果控件类中已经存在一个和定义的属性相关联的函数（例如<code>setName</code>函数和<code>android:name</code>属性就相关联），则会优先执行该函数。</li></ul><h2 id="4-4-BindingConversion"><a href="#4-4-BindingConversion" class="headerlink" title="4.4 @BindingConversion"></a>4.4 @BindingConversion</h2><p>属性值自动进行类型转换。</p><ol><li>只能修饰<code>public static</code>方法</li><li>任意位置任意方法名都不受限制</li><li>Data Binding自动匹配被该注解修饰的方法和参数类型</li><li>返回值类型必须和属性<code>setter</code>方法匹配，且参数只有一个</li><li>要求属性值必须是<code>@{}</code>Data Binding表达式</li></ol><p>官方示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Converters</span> </span>&#123;</span><br><span class="line">    <span class="meta">@BindingConversion</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ColorDrawable <span class="title">convertColorToDrawable</span><span class="params">(<span class="keyword">int</span> color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ColorDrawable(color);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@BindingConversion</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ColorStateList <span class="title">convertColorToColorStateList</span><span class="params">(<span class="keyword">int</span> color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ColorStateList.valueOf(color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kotlin示例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingConversion</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">int2string</span><span class="params">(integer:<span class="type">Int</span>)</span></span>:String&#123;</span><br><span class="line">    Log.d(<span class="string">"日志"</span>, <span class="string">"(CusView.kt:92) int2string ___ integer = [<span class="variable">$integer</span>]"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> integer.toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>XML</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">name</span>=<span class="string">"m"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">"com.example.architecture.Model"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:context</span>=<span class="string">".MainActivity"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">com.example.architecture.CusView</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:bindName</span>=<span class="string">"@=&#123;m.age&#125;"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面这段代码会报错，因为涉及双向数据绑定，<code>@BindingConversion</code>只会在数据设置视图时生效，但是如果是视图设置数据则会走其他函数（如<code>get()</code>），如果该函数返回的类型和Model中的类型不匹配会报异常，除非将函数改为类型匹配，或者去掉<code>=</code>，不使用双向数据绑定。</p><p><code>android:text</code>不能使用int转为String，因为它本身能正常接收int（作为<code>resouceId</code>），会报：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android.content.res.Resources$NotFoundException: String resource ID #0xa</span><br></pre></td></tr></table></figure><h2 id="4-5-InverseMethod"><a href="#4-5-InverseMethod" class="headerlink" title="4.5 @InverseMethod"></a>4.5 @InverseMethod</h2><p>Android Studio 3.0提供了<strong>inverse系列</strong>新的注解，都是针对数据双向绑定的。</p><p>在数据和视图的数据不统一时可以使用该注解<code>@InverseMethod</code>解决数据转换问题。</p><p>例如，数据模型存储的是用户id，但视图不显示id，而是显示用户名（数据和视图类型不一样），就需要进行二者的转换。</p><p>需要两个函数：设置数据到视图的函数<code>set()</code>和设置视图变更到数据的函数<code>get()</code></p><ul><li><code>set()</code>和<code>get()</code>都至少有一个参数</li><li>自身参数必须和另一个函数的返回值对应</li></ul><p>简单示例：在用户id和用户名称之间转换，存储的是id，但显示的是用户名。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ly.allendemojetpack.DataBindingOther</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.databinding.InverseMethod</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"设计师"</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@InverseMethod(<span class="meta-string">"ui2data"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">data2ui</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"设计师1"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">ui2data</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"设计师2"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"model"</span> <span class="attr">type</span>=<span class="string">"com.ly.allendemojetpack.DataBindingOther.Model"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">tools:context</span>=<span class="string">".MainActivity"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">com.ly.allendemojetpack.DataBindingOther.CusView</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:text</span>=<span class="string">"@&#123;model.data2ui(model.name)&#125;"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-6-InverseBindingAdapter"><a href="#4-6-InverseBindingAdapter" class="headerlink" title="4.6 @InverseBindingAdapter"></a>4.6 @InverseBindingAdapter</h2><p>参数：</p><ul><li><code>String attribute</code>：属性值，必填</li><li><code>String event</code>：默认值，非必填，属性值 + <code>AttrChanged</code>后缀</li></ul><p>和<code>@BindingAdapter</code>配合，实现双向绑定。</p><p>完全的双向绑定需要三个函数：</p><ol><li><code>set()</code>：数据到视图</li><li><code>get()</code>：视图到数据</li><li><code>notify()</code>：通知Data Binding视图已经刷新，可以更新数据（Model）了</li></ol><p><code>set()</code>函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter(<span class="meta-string">"android:bindName"</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> TextView.<span class="title">setBindName</span><span class="params">(name:<span class="type">String</span>?)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name.isNullOrEmpty() &amp;&amp; name != text) &#123;</span><br><span class="line">        text = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>get()</code>函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@InverseBindingAdapter(attribute = <span class="meta-string">"android:bindName"</span>, event = <span class="meta-string">"cus_event"</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> TextView.<span class="title">getBindName</span><span class="params">()</span></span>:String&#123;</span><br><span class="line"><span class="comment">// 这里你可以对视图上的数据进行处理最终设置给Model层</span></span><br><span class="line">    <span class="keyword">return</span> text.toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不允许有更多参数</li><li>返回值类型必须是绑定的数据类型</li></ul><p><code>notify()</code>视图变化后要通知Data Binding开始设置Model层，也要用到<code>@BindingAdapter</code>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter(<span class="meta-string">"cus_event"</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> TextView.<span class="title">notifyBindName</span><span class="params">( inverseBindingListener: <span class="type">InverseBindingListener</span>)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 这个函数是监听TextWatch官方源码</span></span><br><span class="line">   doAfterTextChanged &#123;</span><br><span class="line">       inverseBindingListener.onChange() </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>InverseBindingListener</code>是一个接口，里面只有一个函数，它是<code>notify()</code>函数必要的参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InverseBindingListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Notifies the data binding system that the attribute value has changed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onChange</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-7-InverseBindingMethods"><a href="#4-7-InverseBindingMethods" class="headerlink" title="4.7 @InverseBindingMethods"></a>4.7 @InverseBindingMethods</h2><p>和<code>@BindingMethods</code>类似，但是<code>@InverseBindingMethods</code>是视图变更数据（<code>get()</code>函数）,而<code>@BindingMethods</code>是数据到视图（<code>set()</code>函数）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.ANNOTATION_TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> InverseBindingMethod &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 控件的类字节码</span></span><br><span class="line"><span class="comment">     * The View type that is associated with the attribute.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Class <span class="title">type</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义的属性</span></span><br><span class="line"><span class="comment">     * The attribute that supports two-way binding.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">attribute</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * notify函数的名称，即用于通知数据更新的函数</span></span><br><span class="line"><span class="comment">     * The event used to notify the data binding system that the attribute value has changed.</span></span><br><span class="line"><span class="comment">     * Defaults to attribute() + "AttrChanged"</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">event</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 控件自身的函数名称，如果省略，即自动生成为&#123;attribute&#125;AttrChanged</span></span><br><span class="line"><span class="comment">     * The getter method to retrieve the attribute value from the View. The default is</span></span><br><span class="line"><span class="comment">     * the bean method name based on the attribute name.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">method</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果说<code>@BindingMethods</code>是关联<code>setter</code>方法和自定义属性，那么<code>@InverseBindingMethods</code>就是关联<code>getter</code>方法和自定义属性。<br><code>setter</code>是更新视图时使用的，<code>getter</code>是更新数据时使用的。<br>比<code>@BindingMethods</code>只是多了一个用于通知数据更新的<code>notify()</code>。<br>示例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@InverseBindingMethods(</span></span><br><span class="line"><span class="meta">    InverseBindingMethod(</span></span><br><span class="line"><span class="meta">        type = CusView::class,</span></span><br><span class="line"><span class="meta">        attribute = <span class="meta-string">"android:bindName"</span>,</span></span><br><span class="line"><span class="meta">        method = <span class="meta-string">"getName"</span>, event = <span class="meta-string">"cus_event"</span></span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">object</span> Adapter &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看生成类中用于视图更新数据的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> android.databinding.InverseBindingListener ivandroidTextAttr = <span class="keyword">new</span> android.databinding.InverseBindingListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Inverse of data.name</span></span><br><span class="line">        <span class="comment">// is data.setName((java.lang.String) callbackArg_0)</span></span><br><span class="line">        java.lang.String callbackArg_0 = com.liangjingkanji.databinding.MyInverseBindingAdapter.getTextString(iv);  <span class="comment">// 拿到变化的属性</span></span><br><span class="line">        <span class="comment">// localize variables for thread safety</span></span><br><span class="line">        <span class="comment">// data != null</span></span><br><span class="line">        <span class="keyword">boolean</span> dataJavaLangObjectNull = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// data.name</span></span><br><span class="line">        java.lang.String dataName = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// data</span></span><br><span class="line">        com.liangjingkanji.databinding.Bean data = mData; <span class="comment">// 拿到数据</span></span><br><span class="line">        dataJavaLangObjectNull = (data) != (<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (dataJavaLangObjectNull) &#123;</span><br><span class="line">            data.setName(((java.lang.String) (callbackArg_0))); <span class="comment">// 存储到数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果没有重写Inverse的数据变更方法，将无法让视图通知数据更新。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该方法会在绑定布局的时候回调</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">executeBindings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> dirtyFlags = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            dirtyFlags = mDirtyFlags;</span><br><span class="line">            mDirtyFlags = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        java.lang.String dataName = <span class="keyword">null</span>;</span><br><span class="line">        com.liangjingkanji.databinding.Bean data = mData;</span><br><span class="line">        <span class="keyword">if</span> ((dirtyFlags &amp; <span class="number">0x1aL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (data != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// read data.name</span></span><br><span class="line">                    dataName = data.getName();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// batch finished</span></span><br><span class="line">        <span class="keyword">if</span> ((dirtyFlags &amp; <span class="number">0x1aL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// api target 1</span></span><br><span class="line">            com.liangjingkanji.databinding.MyInverseBindingAdapter.setText(<span class="keyword">this</span>.iv, dataName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((dirtyFlags &amp; <span class="number">0x10L</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// api target 1</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">// 重点是这段代码, 将上面创建的监听器传入setTextWatcher方法</span></span><br><span class="line">            com.liangjingkanji.databinding.MyInverseBindingAdapter.setTextWatcher(<span class="keyword">this</span>.iv, (com.liangjingkanji.databinding.MyInverseBindingAdapter.BeforeTextChanged)<span class="keyword">null</span>, (com.liangjingkanji.databinding.MyInverseBindingAdapter.OnTextChanged)<span class="keyword">null</span>, (com.liangjingkanji.databinding.MyInverseBindingAdapter.AfterTextChanged)<span class="keyword">null</span>, ivandroidTextAttr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="4-8-总结"><a href="#4-8-总结" class="headerlink" title="4.8 总结"></a>4.8 总结</h2><p><code>@BindingBuildInfo</code>和<code>Untaggable</code>两个注解是Data Binding自动生成Java类时使用的。</p><ul><li><code>@Bindable</code>：设置数据刷新视图，自动生成BR的id</li><li><code>@BindingAdapter</code>：设置自定义属性，可以覆盖系统原有属性</li><li><code>@BindingMethod/BindingMethods</code>：关联自定义属性到控件原有的<code>setter</code>方法</li><li><code>@BindingConversion</code>：如果属性不能匹配类型，参数将自动根据类型参数匹配该注解修饰的方法来转换。</li><li><code>@InverseMethod</code>：负责实现视图和数据之间的转换</li><li><code>@InverseBindingAdapter</code>：视图通知数据刷新</li><li><code>@InverseBindingMethod/InverseBindingMethods</code>：视图通知数据刷新（如果存在已有<code>getter()</code>方法可用的情况下）</li><li>BindingMethods系统优先级高于BindingAdapter系列</li><li>所有注解的功能都是基于XML属性值为Data Binding表达式才生效（即<code>@{}</code>）</li></ul><h1 id="5-表达式"><a href="#5-表达式" class="headerlink" title="5. 表达式"></a>5. 表达式</h1><p>前面也列举了，这里着重讲几个。</p><h2 id="5-1-避免空指针"><a href="#5-1-避免空指针" class="headerlink" title="5.1 避免空指针"></a>5.1 避免空指针</h2><p><code>variable</code>的值即使设置<code>null</code>，或者没有设置，也不会报空指针异常。因为谷歌已经用Data Binding的<code>@BindingAdapter</code>注解重写了很多属性，并且在里面进行了判空处理。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag"><span class="attr">name</span>=<span class="string">"userName"</span></span></span><br><span class="line"><span class="tag"><span class="attr">type</span>=<span class="string">"String"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line">android:text="@&#123;userName&#125;"</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataBinding.setUserName(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>不会报空指针，并且还支持特有的非空多元表达式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:text="@&#123;user.displayName ?? user.lastName&#125;"</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:text="@&#123;user.displayName !=null user.displayName :: user.lastName&#125;"</span><br></pre></td></tr></table></figure><p>但是要注意数组越界。</p><h2 id="5-2-集合"><a href="#5-2-集合" class="headerlink" title="5.2 集合"></a>5.2 集合</h2><p>集合不属于<code>java.lang.*</code>下的，需要导入全路径</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">    <span class="attr">name</span>=<span class="string">"list"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">type</span>=<span class="string">"java.util.List&amp;lt;String&amp;gt;"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">    <span class="attr">name</span>=<span class="string">"map"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">type</span>=<span class="string">"java.util.Map&lt;String, String&gt;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>上面的写法是错误的：Error:与元素类型 “variable” 相关联的 “type” 属性值不能包含 ‘&lt;’ 字符。<br>因为<code>&lt;</code>符号需要转义。</p><p>常用的转义符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    空格   &amp;nbsp    或 &amp;#160；</span><br><span class="line">&lt;小于号&amp;lt;     或 &amp;#60;</span><br><span class="line">&gt;大于号&amp;gt;     或 &amp;#62;</span><br><span class="line">&amp;与号 &amp;amp;    或 &amp;#38;</span><br><span class="line">&quot;引号 &amp;quot;   或 &amp;#34;</span><br><span class="line">‘撇号 &amp;apos;   或 &amp;#39;</span><br><span class="line">×乘号 &amp;times;  或 &amp;#215;</span><br><span class="line">÷除号 &amp;divide; 或 &amp;#247;</span><br></pre></td></tr></table></figure><p>正确写法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">    <span class="attr">name</span>=<span class="string">"list"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">type</span>=<span class="string">"java.util.List&amp;lt;String&amp;gt;"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">    <span class="attr">name</span>=<span class="string">"map"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">type</span>=<span class="string">"java.util.Map&amp;lt;String, String&amp;gt;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>集合数组都可以用<code>[]</code>来得到元素：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:text="@&#123;map["firstName"]&#125;"</span><br></pre></td></tr></table></figure><h2 id="5-3-字符串"><a href="#5-3-字符串" class="headerlink" title="5.3 字符串"></a>5.3 字符串</h2><p>如果要在<code>@{}</code>中使用字符串，有三种方式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 方式1：</span><br><span class="line">android:text="@&#123;"XXX"&#125;"</span><br><span class="line"></span><br><span class="line">// 方式2：</span><br><span class="line">android:text="@&#123;'XXX'&#125;"</span><br><span class="line"></span><br><span class="line">// 方式3：</span><br><span class="line">android:text="@&#123;@string/name&#125;"</span><br></pre></td></tr></table></figure><p>同样也支持<code>@color</code>和<code>@drawable</code>。</p><h2 id="5-4-格式化字符串"><a href="#5-4-格式化字符串" class="headerlink" title="5.4 格式化字符串"></a>5.4 格式化字符串</h2><p>首先在stirngs文件中定义<code>&lt;string&gt;</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"string_format"</span>&gt;</span>名字：%s 性别：%s<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后就可以使用Data Binding表达式了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:text="@&#123;@string/string_format('XXX', '男')&#125;"</span><br></pre></td></tr></table></figure><p>输出内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">名字：XXX 性别：男</span><br></pre></td></tr></table></figure><h2 id="5-5-默认值"><a href="#5-5-默认值" class="headerlink" title="5.5 默认值"></a>5.5 默认值</h2><p>如果<code>variable</code>还没有赋值，就会先使用默认值。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:text="@&#123;user.integral, default=`30`&#125;"</span><br></pre></td></tr></table></figure><h2 id="5-6-上下文"><a href="#5-6-上下文" class="headerlink" title="5.6 上下文"></a>5.6 上下文</h2><p>Data Binding提供了一个名为<code>context</code>的<code>variable</code>，可以直接使用。等价于<code>View</code>的<code>getContext()</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:color="@&#123;context.getApplication().toString()&#125;"</span><br></pre></td></tr></table></figure><h2 id="5-7-引用其他控件"><a href="#5-7-引用其他控件" class="headerlink" title="5.7 引用其他控件"></a>5.7 引用其他控件</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/datingName"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_centerVertical</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginLeft</span>=<span class="string">"8dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_toRightOf</span>=<span class="string">"@id/iv_dating"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"活动"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_centerVertical</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginLeft</span>=<span class="string">"8dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_toRightOf</span>=<span class="string">"@id/iv_order"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"@&#123;datingName.text&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>引用包含<code>_</code>的控件id，可以直接忽略该符号，如<code>tv_name</code>直接写<code>tvName</code>。</p></blockquote><h2 id="5-8-使用Class"><a href="#5-8-使用Class" class="headerlink" title="5.8  使用Class"></a>5.8  使用Class</h2><p>如果想使用Class作为参数，那么该Class不能直接通过静态导入来使用，需要作为字段常量来使用。</p><h1 id="6-Data-Binding组件"><a href="#6-Data-Binding组件" class="headerlink" title="6. Data Binding组件"></a>6. Data Binding组件</h1><h2 id="6-1-ViewDataBinding"><a href="#6-1-ViewDataBinding" class="headerlink" title="6.1 ViewDataBinding"></a>6.1 ViewDataBinding</h2><p>自动生成的Data Binding类都继承自该类，里面的主要方法有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加绑定监听器, 可以在Variable被设置的时候回调</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addOnRebindCallback</span><span class="params">(OnRebindCallback listener)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 删除绑定监听器</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeOnRebindCallback</span><span class="params">(OnRebindCallback listener)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 返回被绑定的视图对象</span></span></span><br><span class="line"><span class="function">View <span class="title">getRoot</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 使所有的表达式无效并且立刻重新设置表达式. 会重新触发OnRebindCallback回调(可以看做重置)</span></span></span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">invalidateAll</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 可以根据字段id来设置变量</span></span></span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">setVariable</span><span class="params">(<span class="keyword">int</span> variableId, Object value)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 解绑布局, ui不会根据数据来变化, 但是监听器还是会触发的</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unbind</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 当ui需要根据当前数据变化时就会返回true(数据变化后有一瞬间)</span></span></span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">hasPendingBindings</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 强制ui立刻刷新数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">executePendingBindings</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>当改变数据以后（在设置了<code>Observable</code>观察者的情况下）会马上刷新UI，但是会在下一帧才会刷新UI，存在一定的延迟。在这段时间内，<code>hasPendingBindings()</code>会返回<code>true</code>。 如果想要同步刷新UI，可以调用<code>executePendingBindings()</code>。<br><strong><code>OnRebindCallback()</code>：</strong>该监听器可以监听布局绑定的生命周期。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">OnRebindCallback</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">ViewDataBinding</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定前</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> binding</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果返回true，就会绑定布局，；返回fasle，则取消绑定</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onPreBind</span><span class="params">(T binding)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果取消绑定则回调该方法，取决于onPreBind()的返回值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> binding</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCanceled</span><span class="params">(T binding)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定完成</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> binding</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBound</span><span class="params">(T binding)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Data Binding也有一个数据变更监听器，可以监听<code>variable</code>的设置事件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mDataBinding.addOnPropertyChangedCallback(<span class="keyword">new</span> Observable.OnPropertyChangedCallback() &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 会在DataBinding设置数据的时候回调</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> sender DataBinding生成的类</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> propertyId Variable的id</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPropertyChanged</span><span class="params">(Observable sender, <span class="keyword">int</span> propertyId)</span> </span>&#123;</span><br><span class="line">        ActivityMainBinding databinding = (ActivityMainBinding) sender;</span><br><span class="line">        <span class="keyword">switch</span> (propertyId) &#123;</span><br><span class="line">          <span class="keyword">case</span> BR.data:</span><br><span class="line">            Log.d(<span class="string">"日志"</span>, <span class="string">"(MainActivity.java:54) ___ Result = "</span> + databinding.getData().getName());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> BR.dataSecond:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="6-2-DataBindingUtil"><a href="#6-2-DataBindingUtil" class="headerlink" title="6.2 DataBindingUtil"></a>6.2 DataBindingUtil</h2><p>Data Binding不仅可以绑定Activity，还可以绑定视图内容（<code>View</code>）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 视图</span></span><br><span class="line"><span class="keyword">static</span> &lt;T extends ViewDataBinding&gt; <span class="function">T <span class="title">bind</span><span class="params">(View root)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;T extends ViewDataBinding&gt; T <span class="title">bind</span><span class="params">(View root, DataBindingComponent bindingComponent)</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="comment">// 布局</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;T extends ViewDataBinding&gt; T <span class="title">inflate</span><span class="params">(LayoutInflater inflater, <span class="keyword">int</span> layoutId, ViewGroup parent, <span class="keyword">boolean</span> attachToParent, DataBindingComponent bindingComponent)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 组件</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;T extends ViewDataBinding&gt; T <span class="title">inflate</span><span class="params">(LayoutInflater inflater, <span class="keyword">int</span> layoutId, ViewGroup parent, <span class="keyword">boolean</span> attachToParent)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// activity</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;T extends ViewDataBinding&gt; T <span class="title">setContentView</span><span class="params">(Activity activity, <span class="keyword">int</span> layoutId)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;T extends ViewDataBinding&gt; T <span class="title">setContentView</span><span class="params">(Activity activity, <span class="keyword">int</span> layoutId, DataBindingComponent bindingComponent)</span></span></span><br></pre></td></tr></table></figure><p>还有两个不常用的方法，用于检索糊涂是否被绑定，如果没有绑定，返回<code>null</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T extends ViewDataBinding&gt; <span class="function">T <span class="title">getBinding</span><span class="params">(View view)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 和getBinding不同的是如果视图没有绑定会去检查父容器是否被绑定</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;T extends ViewDataBinding&gt; T <span class="title">findBinding</span><span class="params">(View view)</span></span></span><br></pre></td></tr></table></figure><p>其他方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据传的BR的id来返回字符串类型. 可能用于日志输出</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">convertBrIdToString</span><span class="params">(<span class="keyword">int</span> id)</span></span></span><br></pre></td></tr></table></figure><h2 id="6-3-DataBindingComponent"><a href="#6-3-DataBindingComponent" class="headerlink" title="6.3 DataBindingComponent"></a>6.3 DataBindingComponent</h2><p>每个Data Binding都可以拥有一个组件或者说设置一个默认的全局组件。<br>创建<code>DataBindingComponent</code>的步骤：</p><ol><li>创建一个类，类中写入<code>@BindingAdapter</code>注解（需设置静态），这时Android Studio会扫描自动生成对应的<code>DataBindingComponent</code>接口；</li><li>创建一个类实现<code>DataBindingComponent</code>，这时会提示有方法需要覆写，如果省略第一步，则不会有。</li></ol><p>第一步：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ly.allendemojetpack.databindingother</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.widget.TextView</span><br><span class="line"><span class="keyword">import</span> androidx.databinding.BindingAdapter</span><br><span class="line"><span class="keyword">import</span> androidx.databinding.InverseBindingAdapter</span><br><span class="line"><span class="keyword">import</span> androidx.databinding.InverseBindingListener</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PinkComponent</span> </span>&#123;</span><br><span class="line">    <span class="meta">@BindingAdapter(<span class="meta-string">"android:bindName"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> TextView.<span class="title">setBindName</span><span class="params">(name: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name.isNotEmpty() &amp;&amp; name != text) &#123;</span><br><span class="line">            text = <span class="string">"数据体"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BindingAdapter(<span class="meta-string">"android:bindNameAttrChanged"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> TextView.<span class="title">notifyBindName</span><span class="params">(inverseBindingListener: <span class="type">InverseBindingListener</span>)</span></span> &#123;</span><br><span class="line">        doAfterTextChanged &#123;</span><br><span class="line">            inverseBindingListener.onChange()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InverseBindingAdapter(attribute = <span class="meta-string">"android:bindName"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> TextView.<span class="title">getBindName</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> text.toString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ly.allendemojetpack.databindingother</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CusComponent</span> : <span class="type">androidx.databinding.DataBindingComponent &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getPinkComponent</span><span class="params">()</span></span>: PinkComponent &#123;</span><br><span class="line">        <span class="comment">// 此处不能返回null</span></span><br><span class="line">        <span class="keyword">return</span> PinkComponent()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置默认组件都是由<code>DataBindingUtil</code>设置，但是方法有所不同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span><span class="title">setDefaultComponent</span><span class="params">(DataBindingComponent bindingComponent)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> DataBindingComponent<span class="title">getDefaultComponent</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>以上这种设置必须在绑定视图之前设置，并且默认全局的，只需要设置一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T extends ViewDataBinding&gt; <span class="function">T <span class="title">setContentView</span><span class="params">(Activity activity, <span class="keyword">int</span> layoutId, DataBindingComponent bindingComponent)</span></span></span><br></pre></td></tr></table></figure><p>如果没有执行<code>setDefaultComponent()</code>，则选择通过函数单独传入，则每次都要传入，否则报错。或者可以将<code>@BindingAdapter</code>注解的方法变为<code>static</code>修饰。<code>DataBindingComponent</code>只能使用<code>@BindingAdapter</code>注解。</p><h1 id="7-注意"><a href="#7-注意" class="headerlink" title="7. 注意"></a>7. 注意</h1><ol><li>可以使用<code>include</code>，但是不能作为<code>root</code>布局，<code>merge</code>不能使用；</li><li>如果没有自动生成<code>DataBinding</code>类，可以先写一个<code>variable</code>（或者make module一下）；</li><li>即使没有绑定数据（可能会等到网络请求成功之后再去绑定数据），但是只要视图创建完成，就会自动绑定数据，这是数据是一个空对象。空对象的字段也有默认值（<code>String</code>的默认值是<code>null</code>，<code>TextView</code>就会显示<code>null</code>）；并且，如果用了三元表达式，空对象的三元表达式都为<code>fasle</code>，所以建议不考虑空对象的情况；</li><li>如果给一个要求值是<code>bolean</code>类型的值自定义属性（<code>@BindingAdapter</code>）赋值一个函数，空指针的情况会返回<code>false</code>。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Android Jetpack一系类的内容，适合使用MVVM，这里先看看MVVM。&lt;/p&gt;
&lt;h1 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1. 介绍&quot;&gt;&lt;/a&gt;1. 介绍&lt;/h1&gt;&lt;h2 id=&quot;1-1-MV
      
    
    </summary>
    
      <category term="Android" scheme="https://tylerLiu.top/categories/Android/"/>
    
      <category term="Jetpack" scheme="https://tylerLiu.top/categories/Android/Jetpack/"/>
    
    
      <category term="Jetpack" scheme="https://tylerLiu.top/tags/Jetpack/"/>
    
  </entry>
  
  <entry>
    <title>Android Jetpack：Navigation</title>
    <link href="https://tylerLiu.top/2019/07/29/Android-Jetpack-Navigation/"/>
    <id>https://tylerLiu.top/2019/07/29/Android-Jetpack-Navigation/</id>
    <published>2019-07-29T08:10:39.000Z</published>
    <updated>2019-08-22T03:13:27.082Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Android Jetpack是谷歌在2018年的I/O大会上发布的，<a href="https://developer.android.google.cn/jetpack" target="_blank" rel="noopener">官网</a>,主要包含一下模块，系列文章主要介绍架构部分的内容：</p><img src="/2019/07/29/Android-Jetpack-Navigation/11843186-36d663863dacbbd5.png"><p>这里先学习<code>Navigation</code>。</p><p>官方Demo：<a href="https://github.com/googlesamples/android-architecture-components" target="_blank" rel="noopener">android-architecture-components</a>。</p><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h2><p><code>Navigation</code>是一个可简化Android导航和库的插件。更确切来说，<code>Navigation</code>是用来管理<code>Fragment</code>切换的，并且可以通过可视化的方式，看见App的交互流程。</p><h2 id="1-2-优点"><a href="#1-2-优点" class="headerlink" title="1.2 优点"></a>1.2 优点</h2><ul><li>处理<code>Fragment</code>的切换</li><li>默认情况下正确处理<code>Fragment</code>的前进和后退</li><li>为过渡和动画提供标准化的资源</li><li>实现和处理深层连接</li><li>可以绑定<code>Toolbar</code>、<code>BottomNavigationView</code>和<code>ActionBar</code>等</li><li><code>SafeArgs</code>（Gradle插件）数据传递时提供类型安全性</li><li><code>ViewModel</code>的支持</li></ul><h1 id="2-具体学习"><a href="#2-具体学习" class="headerlink" title="2. 具体学习"></a>2. 具体学习</h1><p><code>Navigation</code>三个关键组成部分：</p><ul><li>Navigation Graph：导航图，一个XML资源，包含集中在一个位置的所有和导航相关的信息。包括应用程序中所有单独的内容区域（也成目的地），以及用户可以通过应用程序访问的可能路径。</li><li><code>NavHost</code>：一个存储前面目的地的容器，<code>Navigation</code>组件包含了一个默认的实现了<a href="https://developer.android.google.cn/reference/androidx/navigation/fragment/NavHostFragment.html" target="_blank" rel="noopener"><code>NavHostFragment</code></a>的<code>NavHost</code>，用来显示<code>Fragment</code>的目的地。</li><li><code>NavController</code>：导航控制者，在<code>NavHost</code>中，管理应用程序导航的对象。当用户在app中进行切换页面等操作时，<code>NavController</code>在<code>NavHost</code>中协调目标内容的切换。</li></ul><h2 id="2-1-步骤1：添加依赖"><a href="#2-1-步骤1：添加依赖" class="headerlink" title="2.1 步骤1：添加依赖"></a>2.1 步骤1：添加依赖</h2><p>在module的<code>build.gradle</code>中添加依赖：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    implementation <span class="string">'androidx.fragment:fragment-ktx:1.2.0-alpha01'</span></span><br><span class="line">    implementation <span class="string">'androidx.navigation:navigation-fragment-ktx:2.1.0-beta02'</span></span><br><span class="line">    implementation <span class="string">'androidx.navigation:navigation-ui-ktx:2.1.0-beta02'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要加上<code>kotlin</code>依赖，在项目的<code>build.gradle</code>：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">buildscript</span> &#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">dependencies</span> &#123;</span><br><span class="line">        <span class="keyword">classpath</span> <span class="string">'com.android.tools.build:gradle:3.4.0'</span></span><br><span class="line">        <span class="keyword">classpath</span> <span class="string">'org.jetbrains.kotlin:kotlin-gradle-plugin:1.3.31'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要使用<code>SafeArgs</code>插件，可以在项目的<code>build.gradle</code>中添加：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">buildscript</span> &#123;</span><br><span class="line">    <span class="keyword">dependencies</span> &#123;</span><br><span class="line">        <span class="keyword">classpath</span> <span class="string">'androidx.navigation:navigation-safe-args-gradle-plugin:2.0.0'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及module下的<code>build.gradle</code>中添加：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">'kotlin-android-extensions'</span></span><br><span class="line">apply plugin: <span class="string">'androidx.navigation.safeargs'</span></span><br></pre></td></tr></table></figure><h2 id="2-2-步骤2：创建Navigation导航"><a href="#2-2-步骤2：创建Navigation导航" class="headerlink" title="2.2 步骤2：创建Navigation导航"></a>2.2 步骤2：创建Navigation导航</h2><ol><li>创建基础目录：资源文件<code>res</code>目录下创建<code>navigation</code>目录；</li><li>创建一个<code>Destination</code>，如果说<code>navigation</code>是导航工具，<code>Destination</code>就是目的地，在此之前已经写好了需要用到的<code>Fragment</code>——<code>SplashFragment</code>、<code>LoginFragment</code>和<code>RegisterFragment</code>，添加<code>Desination</code>，如下示图：<img src="/2019/07/29/Android-Jetpack-Navigation/11843186-834d85cff1b6769d.png"></li></ol><p>除了上面的可视化界面，也能通过代码进行编辑，<code>login_navigation.xml</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">navigation</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/login_navigation"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:startDestination</span>=<span class="string">"@id/splash"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:ignore</span>=<span class="string">"UnusedNavigation"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/login"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">"com.ly.allendemojetpack.ui.fragment.login.LoginFragment"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:label</span>=<span class="string">"LoginFragment"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">tools:layout</span>=<span class="string">"@layout/fragment_login"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/splash"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">"com.ly.allendemojetpack.ui.fragment.login.SplashFragment"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:label</span>=<span class="string">"LoginFragment"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">tools:layout</span>=<span class="string">"@layout/fragment_splash"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/action_welcome_to_login"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:destination</span>=<span class="string">"@id/login"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/action_welcome_to_register"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:enterAnim</span>=<span class="string">"@anim/common_fade_in"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:exitAnim</span>=<span class="string">"@anim/common_slide_out_left"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:popEnterAnim</span>=<span class="string">"@anim/common_slide_in_left"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:popExitAnim</span>=<span class="string">"@anim/common_slide_out_right"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:destination</span>=<span class="string">"@id/register"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">fragment</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/register"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">"com.ly.allendemojetpack.ui.fragment.login.RegisterFragment"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:label</span>=<span class="string">"LoginFragment"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">tools:layout</span>=<span class="string">"@layout/fragment_register"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">argument</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:name</span>=<span class="string">"EMAIL"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:defaultValue</span>=<span class="string">"2019"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:argType</span>=<span class="string">"string"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">fragment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里看看<code>navigation</code>标签的属性，<code>app:startDestination</code>，即默认的起始位置。</p><h2 id="2-3-步骤3：创建NavHostFragment"><a href="#2-3-步骤3：创建NavHostFragment" class="headerlink" title="2.3 步骤3：创建NavHostFragment"></a>2.3 步骤3：创建NavHostFragment</h2><p>这里创建一个新的<code>LoginActivity</code>作为<code>NavHostFragment</code>，在<code>activity_login.xml</code>中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:context</span>=<span class="string">".ui.activity.LoginActivity"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/my_nav_host_fragment"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">"androidx.navigation.fragment.NavHostFragment"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:navGraph</span>=<span class="string">"@navigation/login_navigation"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:defaultNavHost</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>android:name</code>：值必须是<code>androidx.navigation.fragment.NavHostFragment</code>，声明这是一个<code>NavHostFragemnt</code>。</li><li><code>app:navGraph</code>：存放导航的资源文件，确定<code>Navgation Graph</code>。</li><li><code>app:defaultNavHost</code>：关联系统的返回按钮 。</li></ul><h2 id="2-4-步骤4：界面跳转、参数传递和动画"><a href="#2-4-步骤4：界面跳转、参数传递和动画" class="headerlink" title="2.4 步骤4：界面跳转、参数传递和动画"></a>2.4 步骤4：界面跳转、参数传递和动画</h2><p>在<code>SplashFragment</code>中，点击登录按钮和注册按钮可以分别跳转到<code>LoginFragment</code>和<code>RegisterFragment</code>。</p><img src="/2019/07/29/Android-Jetpack-Navigation/11843186-b88ceedefecf627c.png"><p>有两种实现方式：</p><h3 id="2-4-1-方式1：利用ID导航"><a href="#2-4-1-方式1：利用ID导航" class="headerlink" title="2.4.1 方式1：利用ID导航"></a>2.4.1 方式1：利用ID导航</h3><p>目标：<code>SplashFragment</code>携带<code>key</code>为<code>name</code>的数据跳转到<code>LoginFragment</code>，<code>LoginFragment</code>接收后显示。</p><p>登录按钮的点击事件如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">btnLogin.setOnClickListener &#123;</span><br><span class="line">    <span class="comment">// 设置动画参数</span></span><br><span class="line">    <span class="keyword">val</span> navOption = navOptions &#123;</span><br><span class="line">        anim &#123;</span><br><span class="line">            enter = R.anim.common_slide_in_right</span><br><span class="line">            exit = R.anim.common_slide_out_left</span><br><span class="line">            popEnter = R.anim.common_slide_in_left</span><br><span class="line">            popExit = R.anim.common_slide_out_right</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 参数设置</span></span><br><span class="line">    <span class="keyword">val</span> bundle = Bundle()</span><br><span class="line">    bundle.putString(<span class="string">"name"</span>, <span class="string">"TeaOf"</span>)</span><br><span class="line">    findNavController().navigate(R.id.login, bundle, navOption)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>LoginFragment</code>中就可以通过<code>Fragment</code>的<code>Bundle</code>直接获取传来的参数。代码如下：<br><code>LoginFragment.kt</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ly.allendemojetpack.ui.fragment.login</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Intent</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.view.LayoutInflater</span><br><span class="line"><span class="keyword">import</span> android.view.View</span><br><span class="line"><span class="keyword">import</span> android.view.ViewGroup</span><br><span class="line"><span class="keyword">import</span> android.widget.Button</span><br><span class="line"><span class="keyword">import</span> android.widget.EditText</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView</span><br><span class="line"><span class="keyword">import</span> androidx.fragment.app.Fragment</span><br><span class="line"><span class="keyword">import</span> com.ly.allendemojetpack.MainActivity</span><br><span class="line"><span class="keyword">import</span> com.ly.allendemojetpack.R</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(inflater: <span class="type">LayoutInflater</span>, container: <span class="type">ViewGroup</span>?, savedInstanceState: <span class="type">Bundle</span>?)</span></span>: View? &#123;</span><br><span class="line">        <span class="keyword">return</span> inflater.inflate(R.layout.fragment_login, container, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> cancel: TextView</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> login: Button</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> account: EditText</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class="line"></span><br><span class="line">        cancel = view.findViewById(R.id.txt_cancel)</span><br><span class="line">        login = view.findViewById(R.id.btn_login)</span><br><span class="line">        account = view.findViewById(R.id.et_account)</span><br><span class="line"></span><br><span class="line">        login.setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">val</span> intent = Intent(context, MainActivity::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">            context!!.startActivity(intent)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cancel.setOnClickListener &#123;</span><br><span class="line">            activity?.onBackPressed()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> name = arguments?.getString(<span class="string">"name"</span>)</span><br><span class="line">        account.setText(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果图：</p><img src="/2019/07/29/Android-Jetpack-Navigation/11843186-874008f63561036b.png"><h3 id="2-4-2-利用Safe-Args"><a href="#2-4-2-利用Safe-Args" class="headerlink" title="2.4.2 利用Safe Args"></a>2.4.2 利用Safe Args</h3><p>目标：<code>SplashFragment</code>通过<code>Safe Args</code>将数据传到<code>RegisterFragment</code>，<code>RegisterFragment</code>接收后显示。</p><p>在前面的<code>login_navigation.xml</code>中可以看到里面还有<code>action</code>标签和<code>argument</code>标签。</p><ol><li><code>action</code>标签里面的属性</li></ol><ul><li><code>app:destination</code>：跳转完成到达的<code>fragment</code>的<code>id</code></li><li><code>app:popUpTo</code>：将<code>fragment</code>从栈中弹出，直到某个<code>id</code>的<code>fragment</code></li></ul><ol start="2"><li><code>argument</code>标签里面的属性</li></ol><ul><li><code>android:name</code>：标签名字</li><li><code>app:argType</code>：标签的类型</li><li><code>android:defaultValue</code>：默认值</li></ul><p>点击Make Project按钮，Android Studio会自动生成两个类：</p><img src="/2019/07/29/Android-Jetpack-Navigation/11843186-e1e32f87e41fc83a.png"><p><code>SplashFragment</code>的注册按钮点击事件：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">btnRegister.setOnClickListener &#123;</span><br><span class="line">    <span class="keyword">val</span> action = SplashFragmentDirections</span><br><span class="line">        .actionWelcomeToRegister()</span><br><span class="line">        .setEMAIL(<span class="string">"TeaOf1995@Gamil.com"</span>)</span><br><span class="line">    findNavController().navigate(action)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RegisterFragment</code>中的接收：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ly.allendemojetpack.ui.fragment.login</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.view.LayoutInflater</span><br><span class="line"><span class="keyword">import</span> android.view.View</span><br><span class="line"><span class="keyword">import</span> android.view.ViewGroup</span><br><span class="line"><span class="keyword">import</span> android.widget.Button</span><br><span class="line"><span class="keyword">import</span> android.widget.EditText</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast</span><br><span class="line"><span class="keyword">import</span> androidx.fragment.app.Fragment</span><br><span class="line"><span class="keyword">import</span> androidx.navigation.fragment.navArgs</span><br><span class="line"><span class="keyword">import</span> com.ly.allendemojetpack.R</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegisterFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(inflater: <span class="type">LayoutInflater</span>, container: <span class="type">ViewGroup</span>?, savedInstanceState: <span class="type">Bundle</span>?)</span></span>: View? &#123;</span><br><span class="line">        <span class="keyword">return</span> inflater.inflate(R.layout.fragment_register, container, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> cancel: TextView</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> register: Button</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> emailEt: EditText</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class="line"></span><br><span class="line">        cancel = view.findViewById(R.id.txt_cancel)</span><br><span class="line">        register = view.findViewById(R.id.btn_register)</span><br><span class="line">        emailEt = view.findViewById(R.id.et_email)</span><br><span class="line"></span><br><span class="line">        register.setOnClickListener &#123;</span><br><span class="line">            Toast.makeText(context, <span class="string">"Register"</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cancel.setOnClickListener &#123;</span><br><span class="line">            activity?.onBackPressed()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> safeArgs: RegisterFragmentArgs <span class="keyword">by</span> navArgs()</span><br><span class="line">        <span class="keyword">val</span> email = safeArgs.email</span><br><span class="line">        emailEt.setText(email)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里的<code>navArgs()</code>必须在JVM 1.8 以上，低于此版本会报错，<code>Cannot inline bytecode built with JVM target 1.8 into bytecode that is being built with JVM target 1.6</code>，在Android Studio中，Settings -&gt; Other Settings -&gt; Kotlin Compiler -&gt; Target JVM version，选择1.8及以上，同时在module的<code>build.gradle</code>添加以下：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 这里也要添加，否则报错  Error: Invoke-customs are only supported starting with Android O (--min-api</span></span><br><span class="line">    compileOptions &#123;</span><br><span class="line">        <span class="keyword">sourceCompatibility</span> JavaVersion.VERSION_1_8</span><br><span class="line">        <span class="keyword">targetCompatibility</span> JavaVersion.VERSION_1_8</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).all &#123;</span><br><span class="line">    kotlinOptions &#123;</span><br><span class="line">        jvmTarget = <span class="string">"1.8"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果图：</p><img src="/2019/07/29/Android-Jetpack-Navigation/11843186-14a0286c7f881a7f.png"><h1 id="3-其他"><a href="#3-其他" class="headerlink" title="3. 其他"></a>3. 其他</h1><p><code>Navigation</code>还可以绑定其他，如<code>menu</code>、<code>drawables</code>和<code>bottom navigation</code>，这里以<code>bototm navigation</code>为例，先在<code>navigation</code>目录下创建<code>main_navigation.xml</code>，用之前的<code>MainActivity</code>，修改<code>activity_main.xml</code>如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:context</span>=<span class="string">".MainActivity"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/my_nav_host_fragment"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">"androidx.navigation.fragment.NavHostFragment"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:navGraph</span>=<span class="string">"@navigation/main_navigation"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:defaultNavHost</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_weight</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.google.android.material.bottomnavigation.BottomNavigationView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/navigation_view"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:background</span>=<span class="string">"@android:color/white"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:itemIconTint</span>=<span class="string">"@color/colorAccent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:itemTextColor</span>=<span class="string">"@color/colorPrimary"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:menu</span>=<span class="string">"@menu/menu_main"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>MainActivity</code>中的处理也很简单：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ly.allendemojetpack</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> androidx.navigation.NavController</span><br><span class="line"><span class="keyword">import</span> androidx.navigation.fragment.NavHostFragment</span><br><span class="line"><span class="keyword">import</span> androidx.navigation.ui.setupWithNavController</span><br><span class="line"><span class="keyword">import</span> com.google.android.material.bottomnavigation.BottomNavigationView</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> bottomNavigationView: BottomNavigationView</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> host: NavHostFragment =</span><br><span class="line">            supportFragmentManager.findFragmentById(R.id.my_nav_host_fragment) <span class="keyword">as</span> NavHostFragment</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> navController = host.navController</span><br><span class="line"></span><br><span class="line">        initWidget()</span><br><span class="line"></span><br><span class="line">        initBottomNavigationView(bottomNavigationView, navController)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">initBottomNavigationView</span><span class="params">(bottomNavigationView: <span class="type">BottomNavigationView</span>, navController: <span class="type">NavController</span>)</span></span> &#123;</span><br><span class="line">        bottomNavigationView.setupWithNavController(navController)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">initWidget</span><span class="params">()</span></span> &#123;</span><br><span class="line">        bottomNavigationView = findViewById(R.id.navigation_view)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果图：</p><img src="/2019/07/29/Android-Jetpack-Navigation/11843186-8d77debcffc93404.png"><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><ol><li>定义：可简化Android导航的库和插件</li><li>功能：</li></ol><ul><li>处理Fragment的切换</li><li>实现和处理深层连接</li><li>绑定<code>Toolbar</code>、<code>BottomNavigationView</code>和<code>DrawableLayout</code></li><li>支持ViewModel</li><li>Safe Args</li></ul><ol start="3"><li>准备：Android Studio 3.2及以上</li><li>三要素</li></ol><ul><li>Navigation Graph<ul><li>地图</li><li>关键标签：<ul><li><code>navigation</code></li><li><code>fragment</code></li><li><code>action</code>：可以设置动画</li><li><code>argument</code></li></ul></li></ul></li><li>NavHostFragment：容器</li><li>NavController：控制器</li></ul><ol start="5"><li>跳转</li></ol><ul><li>通过<code>fragment id</code>实现跳转</li><li><code>action</code>实现跳转</li></ul><ol start="6"><li>传参</li></ol><ul><li><code>fragment</code>自带的<code>Bundle</code></li><li>Safe Args：类型安全</li></ul><ol start="7"><li>绑定View：<code>Toolbar</code>、<code>BottomNavigationView</code>和<code>DrawableLayout</code></li><li>深层连接（本文未涉及）</li></ol><p>Demo地址：<a href="https://gitee.com/QingFengBaiYu/Allen_Demo_Jetpack" target="_blank" rel="noopener">Allen_Demo_WebService</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Android Jetpack是谷歌在2018年的I/O大会上发布的，&lt;a href=&quot;https://developer.android.
      
    
    </summary>
    
      <category term="Android" scheme="https://tylerLiu.top/categories/Android/"/>
    
      <category term="Jetpack" scheme="https://tylerLiu.top/categories/Android/Jetpack/"/>
    
    
      <category term="Jetpack" scheme="https://tylerLiu.top/tags/Jetpack/"/>
    
  </entry>
  
  <entry>
    <title>Android热修复 Tinker接入与源码浅析（有问题）</title>
    <link href="https://tylerLiu.top/2019/07/29/Android%E7%83%AD%E4%BF%AE%E5%A4%8D-Tinker%E6%8E%A5%E5%85%A5%E4%B8%8E%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/"/>
    <id>https://tylerLiu.top/2019/07/29/Android热修复-Tinker接入与源码浅析/</id>
    <published>2019-07-29T02:26:54.000Z</published>
    <updated>2019-07-31T08:17:45.392Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>现在主流热修复：阿里的AndFix、腾讯的QZone的方案、美团的Robust和腾讯的Tinker。</p><img src="/2019/07/29/Android热修复-Tinker接入与源码浅析/11843186-7e23a8bb78d2af25.png"><p>其中AndFix接入是最简单的，不过兼容性还是问题；QZone对性能有一定影响，在在Art模式下出现内存错乱的问题；美团的Robust是基于Instant Run原理的，兼容性好；Tinker就是用在微信上面的热修复，性能和兼容性不用多说。</p><p>这里主要学习腾讯的Tinker和美团的Robust。</p><p>本文主要学习Tinker的接入以及对Tinker大致原理的分析。</p><h1 id="2-Tinker的接入"><a href="#2-Tinker的接入" class="headerlink" title="2. Tinker的接入"></a>2. Tinker的接入</h1><p>接入前提（开启混淆模式）：</p><ul><li>对于API，一般来说，接入热修复，会在<code>Application</code>的<code>onCreate()</code>中进行一些初始化操，然后在某个地方去调用类似<code>loadPatch</code>这样的API去加载patch文件。</li><li>对于patch最简单的生成方式就是通过对比两个APK然后生成；注意，两个APK做对比，需要的前提是，第二次打包混淆使用的<code>mapping.txt</code>文件应该和线上的APK是一致的。</li></ul><p>最后看看该项目有没有需要配置混淆的。</p><p><a href="http://www.tinkerpatch.com/Docs/SDK" target="_blank" rel="noopener">Tinker官方文档</a></p><h2 id="2-1-步骤1：添加gradle插件依赖"><a href="#2-1-步骤1：添加gradle插件依赖" class="headerlink" title="2.1 步骤1：添加gradle插件依赖"></a>2.1 步骤1：添加gradle插件依赖</h2><p>gradle远程仓库依赖jcenter：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">buildscript</span> &#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">dependencies</span> &#123;</span><br><span class="line">        <span class="comment">// TinkerPatch 插件</span></span><br><span class="line">        <span class="keyword">classpath</span> <span class="string">"com.tinkerpatch.sdk:tinkerpatch-gradle-plugin:1.2.13.3"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意，在这里SDK使用了fat打包模式，不能再引用任何Tinker的相关 依赖，否则会造成版本冲突。</strong></p><h2 id="2-2-步骤2：集成TinkerPatch-SDK"><a href="#2-2-步骤2：集成TinkerPatch-SDK" class="headerlink" title="2.2 步骤2：集成TinkerPatch SDK"></a>2.2 步骤2：集成TinkerPatch SDK</h2><p>添加TinkerPatch SDK库的依赖，可以参考Sample中的<a href="https://github.com/TinkerPatch/tinkerpatch-sample/blob/master/app/build.gradle" target="_blank" rel="noopener">app/build.gradle</a>：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//若使用annotation需要单独引用,对于tinker的其他库都无需再引用</span></span><br><span class="line">    <span class="comment">// 可选，用于生成application类</span></span><br><span class="line">    compileOnly(<span class="string">"com.tinkerpatch.tinker:tinker-android-anno:1.9.13.3"</span>) &#123; changing = <span class="keyword">true</span> &#125;</span><br><span class="line">    annotationProcessor(<span class="string">"com.tinkerpatch.tinker:tinker-android-anno:1.9.13.3"</span>) &#123; changing = <span class="keyword">true</span> &#125;</span><br><span class="line">    implementation(<span class="string">"com.tinkerpatch.sdk:tinkerpatch-android-sdk:1.2.13.3"</span>) &#123; changing = <span class="keyword">true</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>若使用annotation自动生成Application，需要单独引入Tinker的tiner-android-anno库。除此之外，不需要单独引入tinker的其他库。</strong></p><p>为了方便，已经将TinkerPatch相关的配置放到了<a href="https://github.com/TinkerPatch/tinkerpatch-sample/blob/master/app/tinkerpatch.gradle" target="_blank" rel="noopener">tinkerpatch.gradle</a>中，所以需要引用：（注释：这块内容还需要整理，有报错！！）</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="keyword">from</span>: <span class="string">'tinkerpatch.gradle'</span></span><br></pre></td></tr></table></figure><h2 id="2-3-步骤3：配置tinkerpatchSupport参数：（可以不配置，使用默认的）"><a href="#2-3-步骤3：配置tinkerpatchSupport参数：（可以不配置，使用默认的）" class="headerlink" title="2.3 步骤3：配置tinkerpatchSupport参数：（可以不配置，使用默认的）"></a>2.3 步骤3：配置tinkerpatchSupport参数：（可以不配置，使用默认的）</h2><p>打开前面的<code>tinkerpatcch.gradle</code>文件可以看到如下参数：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">tinkerpatchSupport &#123;</span><br><span class="line">    <span class="comment">/** 可以在debug的时候关闭 tinkerPatch **/</span></span><br><span class="line">    tinkerEnable = <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 是否使用一键接入功能  **/</span></span><br><span class="line">    reflectApplication = <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 是否开启加固模式，只有在使用加固时才能开启此开关 **/</span></span><br><span class="line">    protectedApp = <span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 补丁是否支持新增 Activity (新增Activity的exported属性必须为false)**/</span></span><br><span class="line">    supportComponent = <span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">    autoBackupApkPath = <span class="string">"$&#123;bakPath&#125;"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 在tinkerpatch.com得到的appKey **/</span></span><br><span class="line">    appKey = <span class="string">"yourAppKey"</span></span><br><span class="line">    <span class="comment">/** 注意: 若发布新的全量包, appVersion一定要更新 **/</span></span><br><span class="line">    appVersion = <span class="string">"1.0.0"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> pathPrefix = <span class="string">"$&#123;bakPath&#125;/$&#123;baseInfo&#125;/$&#123;variantName&#125;/"</span></span><br><span class="line">    <span class="keyword">def</span> name = <span class="string">"$&#123;project.name&#125;-$&#123;variantName&#125;"</span></span><br><span class="line"></span><br><span class="line">    baseApkFile = <span class="string">"$&#123;pathPrefix&#125;/$&#123;name&#125;.apk"</span></span><br><span class="line">    baseProguardMappingFile = <span class="string">"$&#123;pathPrefix&#125;/$&#123;name&#125;-mapping.txt"</span></span><br><span class="line">    baseResourceRFile = <span class="string">"$&#123;pathPrefix&#125;/$&#123;name&#125;-R.txt"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体含义如下：</p><table><thead><tr><th align="center">参数</th><th align="center">默认值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">tinkerEnable</td><td align="center">true</td><td align="center">是否开启tinkerpatchSupport插件功能</td></tr><tr><td align="center">appKey</td><td align="center">“”</td><td align="center">在TinkerPatch平台申请的appKey</td></tr><tr><td align="center">appVersion</td><td align="center">“”</td><td align="center">在TinkerPatch平台输入的版本号。<strong>注意：使用appVerison作为TinkerId，需要保证每个发布出去的基础安装包的appVersion都不一样。</strong></td></tr><tr><td align="center">reflectApplication</td><td align="center">false</td><td align="center">是否反射Application</td></tr><tr><td align="center">autoBackupAppPath</td><td align="center">“”</td><td align="center">将每次编译产生的apk/mapping.txt/R.txt归档存储的位置</td></tr><tr><td align="center">baseApkFile</td><td align="center">“”</td><td align="center"><strong>基准包的文件路径，对应tinker插件中的oldApk参数</strong>；编译补丁包时，必须指定基准版本的apk，默认值为空，表示不进行补丁包的编译</td></tr><tr><td align="center">baseProguardMappingFile</td><td align="center">“”</td><td align="center"><strong>基准包的Proguard mapping.txt文件路径，对应tinker插件appliMapping参数</strong>；在编译新的apk时，希望通过基准apk的proguard混淆方式，从而减小补丁包的大小。编译补丁包时，推荐输入基准apk生成的mapping.txt文件</td></tr><tr><td align="center">baseResourceRFile</td><td align="center">“”</td><td align="center"><strong>基准包的资源R.txt文件路径，对应tinker插件applyResourceMapping参数</strong>；在编译新的apk时，希望通过基准apk的R.txt文件来保存Resource Id的分配，这样不仅可以减少补丁包的大小，同时也能避免由于Resource Id改变导致remote view异常</td></tr><tr><td align="center">protectedApp</td><td align="center">false</td><td align="center">是否开启加固支持，<strong>注意：只有在使用加固支持时才能开启此开关</strong></td></tr><tr><td align="center">supportComponent</td><td align="center">false</td><td align="center">是否开启支持在补丁包中动态增加Activity，<strong>注意：新增Activity的exported属性必须设置为false</strong></td></tr><tr><td align="center">backupFileNameFormat</td><td align="center">‘${appName}-${variantName}’</td><td align="center">格式化命名备份文件，这里要使用单引号</td></tr></tbody></table><p><strong>一般来说，不需要修改引用Android的编译配置，也不用修改tinker插件原来的配置</strong>。对于需要特殊配置，参考<a href="https://github.com/Tencent/tinker/wiki/Tinker-%E6%8E%A5%E5%85%A5%E6%8C%87%E5%8D%97" target="_blank" rel="noopener">接入指南</a></p><h2 id="2-4-初始化TinkerPatch-SDK"><a href="#2-4-初始化TinkerPatch-SDK" class="headerlink" title="2.4 初始化TinkerPatch SDK"></a>2.4 初始化TinkerPatch SDK</h2><ol><li><code>reflectApplication = true</code>：<br>这时，无需为Tinker而改造Application。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        <span class="comment">// 我们可以从这里获得Tinker加载过程的信息</span></span><br><span class="line">        tinkerApplicationLike = TinkerPatchApplicationLike.getTinkerPatchApplicationLike();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化TinkerPatch SDK, 更多配置可参照API章节中的,初始化SDK</span></span><br><span class="line">        TinkerPatch.init(tinkerApplicationLike)</span><br><span class="line">            .reflectPatchLibrary()</span><br><span class="line">            .setPatchRollbackOnScreenOff(<span class="keyword">true</span>)</span><br><span class="line">            .setPatchRestartOnSrceenOff(<span class="keyword">true</span>)</span><br><span class="line">            .setFetchPatchIntervalByHours(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每隔3个小时(通过setFetchPatchIntervalByHours设置)去访问后台时候有更新,通过handler实现轮训的效果</span></span><br><span class="line">        TinkerPatch.with().fetchPatchUpdateAndPollWithInterval();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></li></ol><p>将Tinker加载补丁过程的结果放在<code>TinkerPatchApplicationLike</code>中。</p><ol start="2"><li><code>reflectApplication = false</code>（一般使用）：<br>API主要就是初始化和<code>loadPatch()</code>。</li></ol><p>通常情况下，会考虑在<code>Application</code>的<code>onCreate()</code>中初始化，但Tinker推荐下面的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ly.allendemotinker;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Application;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.tencent.tinker.anno.DefaultLifeCycle;</span><br><span class="line"><span class="keyword">import</span> com.tencent.tinker.entry.DefaultApplicationLike;</span><br><span class="line"><span class="keyword">import</span> com.tencent.tinker.lib.tinker.TinkerInstaller;</span><br><span class="line"><span class="keyword">import</span> com.tencent.tinker.loader.shareutil.ShareConstants;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化TinkerPatch SDK</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Liuyang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/7/29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@DefaultLifeCycle</span>(application = <span class="string">".SampleApplication"</span>,</span><br><span class="line">        flags = ShareConstants.TINKER_ENABLE_ALL,</span><br><span class="line">        loadVerifyFlag = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleApplicationLike</span> <span class="keyword">extends</span> <span class="title">DefaultApplicationLike</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SampleApplicationLike</span><span class="params">(Application application, <span class="keyword">int</span> tinkerFlags, <span class="keyword">boolean</span> tinkerLoadVerifyFlag,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">long</span> applicationStartElapsedTime, <span class="keyword">long</span> applicationStartMillisTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 Intent tinkerResultIntent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(application, tinkerFlags, tinkerLoadVerifyFlag, applicationStartElapsedTime, applicationStartMillisTime</span><br><span class="line">                , tinkerResultIntent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBaseContextAttached</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onBaseContextAttached(base);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        TinkerManager.installedTinker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tinker建议编写一个<code>ApplicationLike</code>的子类，可以当成<code>Application</code>去使用，顶部的注解<code>@DefaultLifeCycle</code>，其中<code>application</code>属性，会在编译期生成一个<code>SimpleTinkerInApplication</code>类。</p><p>所以，实际上<code>Application</code>会在编译期生成，所以<code>AndroidManifest.xml</code>中是这样的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">".SampleApplication"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">...</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>编译报红，build一下就可以。</p><p>实际上，注解的背后有一个Annotation Processor的处理，具体原理可以查看<a href="https://blog.csdn.net/lmj623565791/article/details/51931859" target="_blank" rel="noopener">Android 如何编写基于编译时注解的项目</a>。</p><h2 id="2-5-创建一个ApplicationLike代理类："><a href="#2-5-创建一个ApplicationLike代理类：" class="headerlink" title="2.5 创建一个ApplicationLike代理类："></a>2.5 创建一个<code>ApplicationLike</code>代理类：</h2><p>实现对Tinker的管理，<code>TinkerManager</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ly.allendemotinker;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.tencent.tinker.lib.tinker.Tinker;</span><br><span class="line"><span class="keyword">import</span> com.tencent.tinker.lib.tinker.TinkerInstaller;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tinker管理类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Liuyang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/7/29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TinkerManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> mIsInstalled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ApplicationLike mApplicationLike;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 完成Tinker初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">installedTinker</span><span class="params">(ApplicationLike applicationLike)</span> </span>&#123;</span><br><span class="line">        mApplicationLike = applicationLike;</span><br><span class="line">        <span class="keyword">if</span> (mIsInstalled) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TinkerInstaller.install(mApplicationLike);</span><br><span class="line">        mIsInstalled = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 完成patch文件的加载</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path 补丁文件路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadPatch</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 是否已经安装过</span></span><br><span class="line">        <span class="keyword">if</span> (Tinker.isTinkerInstalled()) &#123;</span><br><span class="line">            TinkerInstaller.onReceiveUpgradePatch(getApplicationContext(), path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 利用Tinker代理Application 获取应用全局的上下文</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 全局的上下文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Context <span class="title">getApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mApplicationLike != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> mApplicationLike.getApplication().getApplicationContext();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-6-AndroidManifest-xml配置"><a href="#2-6-AndroidManifest-xml配置" class="headerlink" title="2.6 AndroidManifest.xml配置"></a>2.6 AndroidManifest.xml配置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">"com.ly.allendemotinker"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.READ_EXTERNAL_STORAGE"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">".Application"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:allowBackup</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">"@mipmap/ic_launcher"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:roundIcon</span>=<span class="string">"@mipmap/ic_launcher_round"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:supportsRtl</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">"@style/AppTheme"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:ignore</span>=<span class="string">"GoogleAppIndexingWarning"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".MainActivity"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 这个标签开判断我们生成的patch的.apk文件中的tinker_id_XXX</span></span><br><span class="line"><span class="comment">       与我们的版本号tinker_id_XXX比较。相同合法，不同则不会进行更新 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">"TINKER_ID"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:value</span>=<span class="string">"tinker_id_6235657"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这里加上必要的权限，然后设置<code>andorid:name = &quot;.Application&quot;</code>，最后配置<code>TINKER_ID</code>属性，里面的数字部分一般是<code>versionCode</code>。</p><h2 id="2-7-生成差异apk文件"><a href="#2-7-生成差异apk文件" class="headerlink" title="2.7 生成差异apk文件"></a>2.7 生成差异apk文件</h2><p>首先生成old.apk。<br>布局文件：<code>activity_main.xml</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">android.support.constraint.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">".MainActivity"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:onClick</span>=<span class="string">"loadPatch"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"热修复"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintLeft_toLeftOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintRight_toRightOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">"parent"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">android.support.constraint.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>代码文件：<code>MainActivity.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ly.allendemotinker;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Liuyang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/7/29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件后缀</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FILE_END = <span class="string">".apk"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String mFileDir;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// /storage/emulated/0/Android/data/com.ly.allendemotinker/cache/demo_patch/</span></span><br><span class="line">        mFileDir = getExternalCacheDir().getAbsolutePath() + <span class="string">"/demo_patch/"</span>;</span><br><span class="line">        <span class="comment">// 创建路径对应的文件夹</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(mFileDir);</span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">            file.mkdir();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadPatch</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        TinkerManager.loadPatch(getPatchName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPatchName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mFileDir.concat(<span class="string">"tinker"</span>).concat(FILE_END);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打包成old.apk，然后修改布局代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">android.support.constraint.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">".MainActivity"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/button"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:onClick</span>=<span class="string">"loadPatch"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"热修复"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintLeft_toLeftOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintRight_toRightOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">"parent"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"测试"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintLeft_toLeftOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintRight_toRightOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">"@+id/button"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">android.support.constraint.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其他不用修改，打包成new.apk。</p><h2 id="2-8-命令行生成补丁文件"><a href="#2-8-命令行生成补丁文件" class="headerlink" title="2.8 命令行生成补丁文件"></a>2.8 命令行生成补丁文件</h2><p>Tinker官方提供了<a href="https://github.com/Tencent/tinker/tree/master/tinker-build/tinker-patch-cli/tool_output" target="_blank" rel="noopener">命令行工具</a>：</p><img src="/2019/07/29/Android热修复-Tinker接入与源码浅析/11843186-538332d422151c1b.png"><p>将前面生成的两个apk文件和签名文件复制到该目录下（.keystore是eclipse的签名文件，.jks是Andorid Studio的签名文件，可以直接修改后缀，不影响使用），然后输入下面的命令：</p><p>参考：</p><ol><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650821993&amp;idx=1&amp;sn=550a90e30a398bbb652ecd65209b62e2&amp;chksm=80b781f7b7c008e17d9f5a59542f46329d28cbcd2ec075d4c2d44784f789135166a4e1949303&amp;scene=38#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650821993&amp;idx=1&amp;sn=550a90e30a398bbb652ecd65209b62e2&amp;chksm=80b781f7b7c008e17d9f5a59542f46329d28cbcd2ec075d4c2d44784f789135166a4e1949303&amp;scene=38#wechat_redirect</a></li><li><a href="https://www.jianshu.com/p/d649fc014919" target="_blank" rel="noopener">https://www.jianshu.com/p/d649fc014919</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h1&gt;&lt;p&gt;现在主流热修复：阿里的AndFix、腾讯的QZone的方案、美团的Robust和腾讯的Tinker。&lt;/p&gt;
&lt;img 
      
    
    </summary>
    
      <category term="Android" scheme="https://tylerLiu.top/categories/Android/"/>
    
      <category term="热修复" scheme="https://tylerLiu.top/categories/Android/%E7%83%AD%E4%BF%AE%E5%A4%8D/"/>
    
    
      <category term="热修复" scheme="https://tylerLiu.top/tags/%E7%83%AD%E4%BF%AE%E5%A4%8D/"/>
    
  </entry>
  
  <entry>
    <title>Android代码混淆</title>
    <link href="https://tylerLiu.top/2019/07/27/Android%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/"/>
    <id>https://tylerLiu.top/2019/07/27/Android代码混淆/</id>
    <published>2019-07-27T06:32:49.000Z</published>
    <updated>2019-07-31T08:08:16.462Z</updated>
    
    <content type="html"><![CDATA[<p>在Android日常开发中，<strong>混淆</strong>是必不可少的。</p><h1 id="1-混淆简介"><a href="#1-混淆简介" class="headerlink" title="1. 混淆简介"></a>1. 混淆简介</h1><p>代码混淆：Obfuscated code，是将程序中的代码以某种规则转换为难以阅读和理解的代码的一种行为。</p><h2 id="1-1-混淆的好处"><a href="#1-1-混淆的好处" class="headerlink" title="1.1 混淆的好处"></a>1.1 混淆的好处</h2><p>好处就是目的：令APK难以被逆向工程，即很大程度上增加反编译的成本。此外，Android中的“混淆”还能在打包时移除没用的资源，显著减小APK的体积。最后，还能以变通方式避免Anddroid中常见的64k方法数引用的限制。</p><p>先看看APK混淆前后的结构对比：</p><img src="/2019/07/27/Android代码混淆/5256969-397ea710d0cd14a5.webp"><img src="/2019/07/27/Android代码混淆/5256969-ba43f52c9a913b4a.webp"><p>从上面两张图可以看出：经过混淆后，APK中的包名、类名、成员名等都被替换为随机、无意义的名称，增加了代码阅读和理解的难度，提高反编译的成本。混淆前后APK的大小也从2.7M下降到1.4M。</p><h1 id="2-Android中的混淆"><a href="#2-Android中的混淆" class="headerlink" title="2. Android中的混淆"></a>2. Android中的混淆</h1><p>在Android中，平时说的“混淆”其实包含两层意思，一是<strong>Java代码的混淆</strong>，二是<strong>资源的压缩</strong>。</p><h2 id="2-1-开启混淆"><a href="#2-1-开启混淆" class="headerlink" title="2.1 开启混淆"></a>2.1 开启混淆</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">android &#123;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="keyword">true</span></span><br><span class="line">            shrinkResources <span class="keyword">true</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是开启混淆的基本操作，通过<code>minifyEnabled</code>设置为<code>true</code>来开启混淆。同时，可以设置<code>shrinkResources</code>为<code>true</code>来开启资源的压缩。一般在打release包时才会开启混淆，因为混淆会增加额外的编译时间，所以不建议在debug下启用。<strong>此外，需要注意：只有在开启混淆的前提下开启资源压缩才有效果。</strong>以上代码中的<code>proguard-android.txt</code>表示Android系统提供的默认混淆规则文件，而<code>proguard-rules.pro</code>是我们自定义的混淆规则。下面讲解如何自定义混淆规则。</p><h2 id="2-2-代码混淆"><a href="#2-2-代码混淆" class="headerlink" title="2.2 代码混淆"></a>2.2 代码混淆</h2><p>Java平台提供了Proguard工具来帮助我们快速地对代码进行混淆。根据Java官方介绍，Proguard对应的具体中文定义如下：</p><ul><li>它是一个包含代码文件压缩、优化、混淆和校验等功能的工具；</li><li>它能检测并删除无用的类、变量、方法和属性；</li><li>它能优化字节码并删除未使用的指令；</li><li>它能将类、变量和方法的名字重命名为无意义的名称从而达到混淆效果；</li><li>它会校验处理后的代码，只有针对Java 6及以上的版本和Java ME。</li></ul><h2 id="2-3-资源压缩"><a href="#2-3-资源压缩" class="headerlink" title="2.3 资源压缩"></a>2.3 资源压缩</h2><p>在Android中，编译提供了另一个功能：<strong>资源压缩</strong>。资源压缩能帮助移除项目和仓库中未使用到的资源，有效降低APK的大小，。由于资源压缩与代码混淆是协同工作，所以，<strong>如果要开启资源压缩，一定要先开启代码混淆</strong>，否则会报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR: Removing unused resources requires unused code shrinking to be turned on. See http://d.android.com/r/tools/shrink-resources.html for more information.</span><br><span class="line">Affected Modules: app</span><br></pre></td></tr></table></figure><h2 id="2-4-自定义要保留的资源"><a href="#2-4-自定义要保留的资源" class="headerlink" title="2.4 自定义要保留的资源"></a>2.4 自定义要保留的资源</h2><p>开启资源压缩后，系统默认会移除所有未使用的资源，如果要保留特定的资源，可以在项目中创建一个被<code>&lt;resources&gt;</code>标记的XML文件（如，<code>res/raw/keep.xml</code>），并在<code>tools:keep</code>属性中指定每个要保留的资源，在<code>tools:discard</code>属性中指定每个要舍弃的资源。这两个属性都接受逗号分隔的资源名称列表。同样，可以使用<code>*</code>作为通配符。如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span> <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:keep</span>=<span class="string">"@layout/activity_video*,@layout/dialog_update_v2"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:discard</span>=<span class="string">"@layout/unused_layout,@drawable/unused_selector"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-5-启用严格检查模式"><a href="#2-5-启用严格检查模式" class="headerlink" title="2.5 启用严格检查模式"></a>2.5 启用严格检查模式</h2><p>通常， 资源压缩器可以准确判定系统是否使用了资源。但，如果代码（包含库）调用了<code>Resources.getIdentifier()</code>，这就表示代码将根据动态生成的字符串查询名称。这时，资源压缩器会采取防御性行为，将所有具有匹配名称格式的资源标记为可能已使用，无法移除。如，以下代码会使所有带<code>img_</code>前缀的资源标记为已使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String name = String.format(<span class="string">"img_%1d"</span>, angle + <span class="number">1</span>);</span><br><span class="line">res = getResources().getIdentifier(name, <span class="string">"drawable"</span>, getPackageName());</span><br></pre></td></tr></table></figure><p>这时，可以启用严格检查模式，只会保留确定已经使用的资源。</p><h2 id="2-6-移除备用资源"><a href="#2-6-移除备用资源" class="headerlink" title="2.6 移除备用资源"></a>2.6 移除备用资源</h2><p>Gradle资源压缩器只会移除未被应用引用的资源，意味着它不会移除用于不同设备配置的<a href="https://developer.android.google.cn/guide/topics/resources/providing-resources.html#AlternativeResources" target="_blank" rel="noopener">备用资源</a>。必要时，可以使用Android Gradle插件的<code>resCOnfigs</code>属性来移除应用中不需要的备用资源文件（常见的有用于国际化支持的<code>strings.xml</code>，适配用的<code>layout.xml</code>等）。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//保留中文和英文国际化支持</span></span><br><span class="line">        resConfigs <span class="string">"en"</span>, <span class="string">"zh"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-自定义混淆规则"><a href="#3-自定义混淆规则" class="headerlink" title="3. 自定义混淆规则"></a>3. 自定义混淆规则</h1><p>先了解常用的混淆命令：</p><h2 id="3-1-keep命令"><a href="#3-1-keep命令" class="headerlink" title="3.1 keep命令"></a>3.1 keep命令</h2><p>指一系列以<code>-keep</code>开头的命令，主要是用来保留Java中不需要进行混淆的元素。以下是常见的<code>-keep</code>命令：</p><ul><li><p><code>-keep</code>：<br>作用：保留指定的类和成员，防止被混淆处理。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 保留包：com.moos.media.entity 下面的类以及类成员</span><br><span class="line">-keep public class com.moos.media.entity.**</span><br><span class="line"></span><br><span class="line"># 保留类：NumberProgressBar</span><br><span class="line">-keep public class com.moos.media.widget.NumberProgressBar &#123;*;&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>-keepclassmembers</code>：<br>作用：保留指定的类的成员（变量/方法），它们将不会被混淆。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 保留类的成员：MediaUtils类中的特定成员方法</span><br><span class="line">-keepclassmembers class com.moos.media.MediaUtils &#123;</span><br><span class="line">    public static *** getLocalVideos(android.content.Context);</span><br><span class="line">    public static *** getLocalPictures(android.content.Context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>-keepclasseswithmembers</code>：<br>作用：保留指定的类及其成员（变量/方法），前提是它们在压缩阶段没有被删除。与<code>-keep</code>使用方式类似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 保留类：BaseMediaEntity 的子类</span><br><span class="line">-keepclasseswithmembers public class * extends com.moos.media.entity.BaseMediaEntity&#123;*;&#125;</span><br><span class="line"></span><br><span class="line"># 保留类：OnProgressBarListener接口的实现类</span><br><span class="line">-keep public class * implements com.moos.media.widget.OnProgressBarListener &#123;*;&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>@keep</code>：<br>除了以上的方式，还可以使用<code>@keep</code>注解来保留代码，防止它们被混淆处理。比如，通过<code>@keep</code>来修饰一个类来保留它不被混淆：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Keep</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">CloudMusicBean</span></span>(<span class="keyword">var</span> createDate: String,</span><br><span class="line">                          <span class="keyword">var</span> id: <span class="built_in">Long</span>,</span><br><span class="line">                          <span class="keyword">var</span> name: String,</span><br><span class="line">                          <span class="keyword">var</span> url: String,</span><br><span class="line">                          <span class="keyword">val</span> imgUrl: String)</span><br></pre></td></tr></table></figure></li></ul><p>也可以修饰方法或字段进行保留。</p><h2 id="3-2-其他命令"><a href="#3-2-其他命令" class="headerlink" title="3.2 其他命令"></a>3.2 其他命令</h2><ol><li><p>dontwarn<br><code>-dontwarn</code>命令一般在引入新的library时会用到，常用于处理library中无法解决的警告。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-keep class twitter4j.** &#123; *; &#125;</span><br><span class="line"></span><br><span class="line">-dontwarn twitter4j.**</span><br></pre></td></tr></table></figure></li><li><p>其他命令用法可以参考Android系统提供的默认混淆规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">#混淆时不生成大小写混合的类名</span><br><span class="line">-dontusemixedcaseclassnames</span><br><span class="line"></span><br><span class="line">#不跳过非公共的库的类</span><br><span class="line">-dontskipnonpubliclibraryclasses</span><br><span class="line"></span><br><span class="line">#混淆过程中记录日志</span><br><span class="line">-verbose</span><br><span class="line"></span><br><span class="line">#关闭预校验</span><br><span class="line">-dontpreverify</span><br><span class="line"></span><br><span class="line">#关闭优化</span><br><span class="line">-dontoptimize</span><br><span class="line"></span><br><span class="line">#保留注解</span><br><span class="line">-keepattributes *Annotation*</span><br><span class="line"></span><br><span class="line">#保留所有拥有本地方法的类名及本地方法名</span><br><span class="line">-keepclasseswithmembernames class * &#123;</span><br><span class="line">    native &lt;methods&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#保留自定义View的get和set方法</span><br><span class="line">-keepclassmembers public class * extends android.view.View &#123;</span><br><span class="line">   void set*(***);</span><br><span class="line">   *** get*();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#保留Activity中View及其子类入参的方法，如: onClick(android.view.View)</span><br><span class="line">-keepclassmembers class * extends android.app.Activity &#123;</span><br><span class="line">   public void *(android.view.View);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#保留枚举</span><br><span class="line">-keepclassmembers enum * &#123;</span><br><span class="line">    **[] $VALUES;</span><br><span class="line">    public *;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#保留序列化的类</span><br><span class="line">-keepclassmembers class * implements android.os.Parcelable &#123;</span><br><span class="line">  public static final android.os.Parcelable$Creator CREATOR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#保留R文件的静态成员</span><br><span class="line">-keepclassmembers class **.R$* &#123;</span><br><span class="line">    public static &lt;fields&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-dontwarn android.support.**</span><br><span class="line"></span><br><span class="line">-keep class android.support.annotation.Keep</span><br><span class="line"></span><br><span class="line">-keep @android.support.annotation.Keep class * &#123;*;&#125;</span><br><span class="line"></span><br><span class="line">-keepclasseswithmembers class * &#123;</span><br><span class="line">    @android.support.annotation.Keep &lt;methods&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-keepclasseswithmembers class * &#123;</span><br><span class="line">    @android.support.annotation.Keep &lt;fields&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-keepclasseswithmembers class * &#123;</span><br><span class="line">    @android.support.annotation.Keep &lt;init&gt;(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>更多混淆命令可以参考文章：<a href="https://juejin.im/entry/58f6d2a10ce463006bc9e6af" target="_blank" rel="noopener">ProGuard 最全混淆规则说明</a></p><h1 id="4-不能混淆的部分"><a href="#4-不能混淆的部分" class="headerlink" title="4. 不能混淆的部分"></a>4. 不能混淆的部分</h1><p>哪些内容应该混淆？其实，在使用代码混淆时，ProGuard对项目大部分代码进行了混淆操作，为防止编译出错，应该通过<code>-keep</code>命令保留一些元素不被混淆。所以需要知道<strong>哪些元素不应该被混淆</strong>：</p><h2 id="4-1-枚举"><a href="#4-1-枚举" class="headerlink" title="4.1 枚举"></a>4.1 枚举</h2><p>枚举不能参与到混淆中，原因是：枚举内部存在<code>values</code>方法，混淆后该方法会被重新命名，并抛出<code>NoSuchMethodException</code>。Android系统默认的混淆规则中已经添加了对枚举类的处理，无需额外进行处理。</p><h2 id="4-2-被反射的元素"><a href="#4-2-被反射的元素" class="headerlink" title="4.2 被反射的元素"></a>4.2 被反射的元素</h2><p>被反射使用的类、方法、变量、包名等不能被混淆，原因是：代码混淆过程中，被反射的元素会被重命名，而反射依旧按照先前的名称去查找元素，会发生<code>NoSuchMethodException</code>和<code>NoSuchFieldException</code>。</p><h2 id="4-3-实体类"><a href="#4-3-实体类" class="headerlink" title="4.3 实体类"></a>4.3 实体类</h2><p>实体类通常会伴随着<strong>序列化</strong>和<strong>反序列化</strong>操作。混合是将原本有特定含义的“元素”转成无意义的名称，所以，经过混淆之后，序列化之后的<code>value</code>对应的<code>key</code>已经变成没有意义的字段。同时，反序列化的过程创建对象从根本上还是借助反射，混淆后<code>key</code>会被改变，所以实体类通常也不能混淆。</p><h2 id="4-4-四大组件"><a href="#4-4-四大组件" class="headerlink" title="4.4 四大组件"></a>4.4 四大组件</h2><p>Android中的四大组件也不能被混淆，原因是：</p><ol><li>四大组件使用前都需要在<code>AndroidManifest.xml</code>文件中进行注册声明，然而混淆处理后，四大组件的类名就会被更改，实际使用的类与<code>AndroidMainifest.xml</code>中注册的类不匹配，会报错。</li><li>其他应用程序访问组件时，可能会用到类的包名和类名，经过混淆，可能会找不到对应的组件而产生异常。</li></ol><h2 id="4-5-JNI调用的Java方法"><a href="#4-5-JNI调用的Java方法" class="headerlink" title="4.5 JNI调用的Java方法"></a>4.5 JNI调用的Java方法</h2><p>当JNI调用的Java方法被混淆后，方法名会变成无意义的名称，这就与C++中原本的Java方法名不匹配，因而无法找到所调用的方法。</p><h2 id="4-6-其他不应被混淆的"><a href="#4-6-其他不应被混淆的" class="headerlink" title="4.6 其他不应被混淆的"></a>4.6 其他不应被混淆的</h2><ul><li>自定义控件不能被混淆</li><li>JavaScript调用Java的方法不应被混淆</li><li>Java的native方法不应被混淆</li><li>项目中引用的第三方库不建议混淆</li></ul><h1 id="5-混淆后的堆栈跟踪"><a href="#5-混淆后的堆栈跟踪" class="headerlink" title="5. 混淆后的堆栈跟踪"></a>5. 混淆后的堆栈跟踪</h1><p>代码经过ProGuard混淆处理后，想要读取<code>StackTrace</code>（堆栈追踪）信息就会变得困难。由于方法名和类名都经过混淆处理，即使程序崩溃，也很难定位问题。但是，ProGuard提供了补救的措施，先来看看ProGuard每次构建后生成哪些内容。</p><h2 id="5-1-混淆输出结果"><a href="#5-1-混淆输出结果" class="headerlink" title="5.1 混淆输出结果"></a>5.1 混淆输出结果</h2><p>混淆构建完成之后，会在<code>&lt;module-name&gt;/build/outputs/mapping/release/</code>目录下生成以下文件：</p><ul><li>dump.txt：说明APK内所有类文件的内部结构。</li><li>mapping.txt：提供混淆前后的内容对照表，内容主要包括类、方法和类的成员变量。</li><li>seeds.txt：罗列出未进行混淆处理的类和成员。</li><li>usage.txt：罗列出从APK移除的代码。</li></ul><h2 id="5-2-恢复堆栈跟踪"><a href="#5-2-恢复堆栈跟踪" class="headerlink" title="5.2 恢复堆栈跟踪"></a>5.2 恢复堆栈跟踪</h2><p>前面的遗留问题：混淆处理后，StackTrace定位困难。如何恢复StackTrace的定位能力？系统提供了retrace工具，结合上面定义的<code>mapping.txt</code>文件，就可以将混淆后的<strong>崩溃堆栈追踪器信息</strong>还原成正常情况下的StackTrace信息。主要有两种方式来恢复SrackTrace，为了方便理解，以下面的崩溃信息为例，协助两种方式分别进行还原：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.lang.RuntimeException: Unable to start activity </span><br><span class="line">     Caused by: kotlin.KotlinNullPointerException</span><br><span class="line">        at com.moos.media.ui.ImageSelectActivity.k(ImageSelectActivity.kt:71)</span><br><span class="line">        at com.moos.media.ui.ImageSelectActivity.onCreate(ImageSelectActivity.kt:58)</span><br><span class="line">        at android.app.Activity.performCreate(Activity.java:6237)</span><br><span class="line">        at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1107)</span><br></pre></td></tr></table></figure><ol><li><strong>通过retrace脚本工具</strong><br> 首先进入Android SDK路径的<code>tools/proguard/bin</code>中：</li></ol><img src="/2019/07/27/Android代码混淆/11843186-07e12471ad07a914.png"><p>可以看到里面有三个文件，而<code>proguardgui.bat</code>就是需要的retrace脚本。双加该脚本文件，运行，即可看到：</p><img src="/2019/07/27/Android代码混淆/11843186-fd56ca5694c9dc61.png"><p>选择Retrace栏，添加项目中混淆生成的<code>mapping.txt</code>文件所在位置，然后将混淆后的崩溃信息复制到Obfuscated stack trace一栏，点击Retrace，即可还原出崩溃日志信息。</p><ol start="2"><li>通过retrace命令行<br>首先将崩溃信息复制到<code>.txt</code>文件中，然后执行下面命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">retrace.bat -verbose mapping.txt proguard_stacktrace.txt</span><br></pre></td></tr></table></figure></li></ol><p>最终还原结果和之前效果相同：</p><img src="/2019/07/27/Android代码混淆/11843186-0d431cd96bcb8e2f.png"><p>在对stackTrace进行恢复时，发现<code>unknown Source</code>问题：</p><img src="/2019/07/27/Android代码混淆/11843186-bc3c5030553ad703.png"><p>在混淆规则上添加如下配置来提升StackSource查找效率，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 保留源文件名和具体代码行号</span><br><span class="line">-keepattributes SourceFile,LineNumberTable</span><br></pre></td></tr></table></figure><p>此外，每次使用ProGuard创建发布构建时都会覆盖之前版本的<code>mapping.txt</code>文件，因此，每次发布一个新版本时，建议保存一个副本。通过为每个发布构建保留一个<code>mapping.txt</code>文件副本，就可以在用户提交的已混淆的StackTrace来对旧版本应用的问题进行调试和修复。</p><h1 id="6-其他操作"><a href="#6-其他操作" class="headerlink" title="6. 其他操作"></a>6. 其他操作</h1><p>前面介绍到，APK在经过代码混淆处理后，包名、类名、成员名被转化为无意义、难以理解的名称，增加反编译的成本。Android ProGuard提供了默认的“混淆字典”，即将元素名称转为英文小写字母的形式。那么，可以定义自己的混淆字典吗？先看一张效果图：</p><img src="/2019/07/27/Android代码混淆/11843186-fc80135d648c0ff6.png"><p>只要生成一套自己的<code>.txt</code>格式的混淆字典，然后在混淆规则<code>Proguard-rules.pro</code>中应用下即可：</p><img src="/2019/07/27/Android代码混淆/11843186-c7d89bb491c6687a.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Android日常开发中，&lt;strong&gt;混淆&lt;/strong&gt;是必不可少的。&lt;/p&gt;
&lt;h1 id=&quot;1-混淆简介&quot;&gt;&lt;a href=&quot;#1-混淆简介&quot; class=&quot;headerlink&quot; title=&quot;1. 混淆简介&quot;&gt;&lt;/a&gt;1. 混淆简介&lt;/h1&gt;&lt;p&gt;代码混淆
      
    
    </summary>
    
      <category term="Android" scheme="https://tylerLiu.top/categories/Android/"/>
    
      <category term="其他" scheme="https://tylerLiu.top/categories/Android/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="代码混淆" scheme="https://tylerLiu.top/tags/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/"/>
    
  </entry>
  
  <entry>
    <title>Android-RecyclerView自动滚动</title>
    <link href="https://tylerLiu.top/2019/07/27/Android-RecyclerView%E8%87%AA%E5%8A%A8%E6%BB%9A%E5%8A%A8/"/>
    <id>https://tylerLiu.top/2019/07/27/Android-RecyclerView自动滚动/</id>
    <published>2019-07-27T05:03:29.000Z</published>
    <updated>2020-05-16T05:54:30.726Z</updated>
    
    <content type="html"><![CDATA[<p>实现功能：使用<code>RecyclerView</code>实现垂直滚动效果。</p><h1 id="1-自定义RecyclerView实现滚动效果"><a href="#1-自定义RecyclerView实现滚动效果" class="headerlink" title="1. 自定义RecyclerView实现滚动效果"></a>1. 自定义RecyclerView实现滚动效果</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ly.allendemoautopollrecyclerview;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.annotation.SuppressLint;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.support.annotation.NonNull;</span><br><span class="line"><span class="keyword">import</span> android.support.annotation.Nullable;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.widget.RecyclerView;</span><br><span class="line"><span class="keyword">import</span> android.util.AttributeSet;</span><br><span class="line"><span class="keyword">import</span> android.view.MotionEvent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.ref.WeakReference;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义垂直滚动RecyclerView</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Liuyang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/7/27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoPollRecyclerView</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TIME_AUTO_POLL = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">private</span> AutoPollTask mAutoPollTask;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标示是否正在自动轮询</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mRunning;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标示是否可以自动轮询，可在不需要的是否置false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mCanRun;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AutoPollRecyclerView</span><span class="params">(@NonNull Context context, @Nullable AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">        mAutoPollTask = <span class="keyword">new</span> AutoPollTask(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoPollTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> WeakReference&lt;AutoPollRecyclerView&gt; mReference;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 使用弱引用持有外部引用，放置内存泄露</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        AutoPollTask(AutoPollRecyclerView reference) &#123;</span><br><span class="line">            mReference = <span class="keyword">new</span> WeakReference&lt;&gt;(reference);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            AutoPollRecyclerView recyclerView = mReference.get();</span><br><span class="line">            <span class="keyword">if</span> (recyclerView != <span class="keyword">null</span> &amp;&amp; recyclerView.mRunning &amp;&amp; recyclerView.mCanRun) &#123;</span><br><span class="line">                recyclerView.scrollBy(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">                recyclerView.postDelayed(recyclerView.mAutoPollTask, TIME_AUTO_POLL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开启：如果正在运行，则先停止，再开始</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mRunning) &#123;</span><br><span class="line">            stop();</span><br><span class="line">        &#125;</span><br><span class="line">        mCanRun = <span class="keyword">true</span>;</span><br><span class="line">        mRunning = <span class="keyword">true</span>;</span><br><span class="line">        postDelayed(mAutoPollTask, TIME_AUTO_POLL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 停止</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mRunning = <span class="keyword">false</span>;</span><br><span class="line">        removeCallbacks(mAutoPollTask);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressLint</span>(<span class="string">"ClickableViewAccessibility"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (e.getAction()) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                <span class="keyword">if</span> (mRunning) &#123;</span><br><span class="line">                    stop();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_OUTSIDE:</span><br><span class="line">                <span class="keyword">if</span> (mCanRun) &#123;</span><br><span class="line">                    start();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-实现Adapter"><a href="#2-实现Adapter" class="headerlink" title="2. 实现Adapter"></a>2. 实现Adapter</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ly.allendemoautopollrecyclerview;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.annotation.SuppressLint;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.support.annotation.NonNull;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.widget.RecyclerView;</span><br><span class="line"><span class="keyword">import</span> android.view.LayoutInflater;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.view.ViewGroup;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoPollAdapter</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">Adapter</span>&lt;<span class="title">AutoPollAdapter</span>.<span class="title">BaseViewHolder</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Context mContext;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;AutoScrollLuckyListReq.DatasBean&gt; mData;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AutoPollAdapter</span><span class="params">(Context context, List&lt;AutoScrollLuckyListReq.DatasBean&gt; data)</span> </span>&#123;</span><br><span class="line">        mContext = context;</span><br><span class="line">        mData = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BaseViewHolder <span class="title">onCreateViewHolder</span><span class="params">(@NonNull ViewGroup viewGroup, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        View view = LayoutInflater.from(mContext).inflate(R.layout.auto_list_item, viewGroup, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BaseViewHolder(view);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressLint</span>(<span class="string">"SetTextI18n"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(@NonNull BaseViewHolder baseViewHolder, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        AutoScrollLuckyListReq.DatasBean datasBean = mData.get(position % mData.size());</span><br><span class="line">        baseViewHolder.content.setText(datasBean.getPhone() + <span class="string">" 获得 "</span> + datasBean.getGiftName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">BaseViewHolder</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">ViewHolder</span> </span>&#123;</span><br><span class="line">        TextView content;</span><br><span class="line"></span><br><span class="line">        BaseViewHolder(View itemView) &#123;</span><br><span class="line">            <span class="keyword">super</span>(itemView);</span><br><span class="line">            content = itemView.findViewById(R.id.content);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-适配器布局文件"><a href="#3-适配器布局文件" class="headerlink" title="3. 适配器布局文件"></a>3. 适配器布局文件</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">"#fffcf5"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">"8dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginBottom</span>=<span class="string">"8dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"135xxxx8888 获得 8积分"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">"#797762"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">"14sp"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">View</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"1dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">"#797762"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="4-调用"><a href="#4-调用" class="headerlink" title="4. 调用"></a>4. 调用</h1><p>布局文件：<code>activity_main.xml</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">".MainActivity"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"150dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_centerInParent</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginLeft</span>=<span class="string">"15dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">"15dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginRight</span>=<span class="string">"15dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">"@drawable/luckyer_bg"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">RelativeLayout</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"40dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginStart</span>=<span class="string">"23dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginTop</span>=<span class="string">"1dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginBottom</span>=<span class="string">"1dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:background</span>=<span class="string">"#fff6ea"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_centerInParent</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:padding</span>=<span class="string">"10dp"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:src</span>=<span class="string">"@drawable/zhongjiangzhemingdan"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">com.ly.allendemoautopollrecyclerview.AutoPollRecyclerView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/recyclerview"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_margin</span>=<span class="string">"20dp"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Java文件：<code>MainActivity.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ly.allendemoautopollrecyclerview;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.widget.LinearLayoutManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Liuyang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/7/27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AutoPollRecyclerView mRecyclerView;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        initView();</span><br><span class="line">        initData();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mRecyclerView = findViewById(R.id.recyclerview);</span><br><span class="line">        mRecyclerView.setLayoutManager(<span class="keyword">new</span> LinearLayoutManager(<span class="keyword">this</span>, LinearLayoutManager.VERTICAL, <span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String response = <span class="string">"&#123;\n"</span> +</span><br><span class="line">                <span class="string">"    \"datas\": [\n"</span> +</span><br><span class="line">                <span class="string">"        &#123;\n"</span> +</span><br><span class="line">                <span class="string">"            \"giftName\": \"20个积分\",\n"</span> +</span><br><span class="line">                <span class="string">"            \"phone\": \"****\"\n"</span> +</span><br><span class="line">                <span class="string">"        &#125;,\n"</span> +</span><br><span class="line">                <span class="string">"        &#123;\n"</span> +</span><br><span class="line">                <span class="string">"            \"giftName\": \"20个积分\",\n"</span> +</span><br><span class="line">                <span class="string">"            \"phone\": \"****\"\n"</span> +</span><br><span class="line">                <span class="string">"        &#125;,\n"</span> +</span><br><span class="line">                <span class="string">"        &#123;\n"</span> +</span><br><span class="line">                <span class="string">"            \"giftName\": \"满10减1元\",\n"</span> +</span><br><span class="line">                <span class="string">"            \"phone\": \"****\"\n"</span> +</span><br><span class="line">                <span class="string">"        &#125;,\n"</span> +</span><br><span class="line">                <span class="string">"        &#123;\n"</span> +</span><br><span class="line">                <span class="string">"            \"giftName\": \"20个积分\",\n"</span> +</span><br><span class="line">                <span class="string">"            \"phone\": \"****\"\n"</span> +</span><br><span class="line">                <span class="string">"        &#125;,\n"</span> +</span><br><span class="line">                <span class="string">"        &#123;\n"</span> +</span><br><span class="line">                <span class="string">"            \"giftName\": \"20个积分\",\n"</span> +</span><br><span class="line">                <span class="string">"            \"phone\": \"****\"\n"</span> +</span><br><span class="line">                <span class="string">"        &#125;,\n"</span> +</span><br><span class="line">                <span class="string">"        &#123;\n"</span> +</span><br><span class="line">                <span class="string">"            \"giftName\": \"满10减1元\",\n"</span> +</span><br><span class="line">                <span class="string">"            \"phone\": \"****\"\n"</span> +</span><br><span class="line">                <span class="string">"        &#125;,\n"</span> +</span><br><span class="line">                <span class="string">"        &#123;\n"</span> +</span><br><span class="line">                <span class="string">"            \"giftName\": \"20个积分\",\n"</span> +</span><br><span class="line">                <span class="string">"            \"phone\": \"****\"\n"</span> +</span><br><span class="line">                <span class="string">"        &#125;,\n"</span> +</span><br><span class="line">                <span class="string">"        &#123;\n"</span> +</span><br><span class="line">                <span class="string">"            \"giftName\": \"满10减1元\",\n"</span> +</span><br><span class="line">                <span class="string">"            \"phone\": \"****\"\n"</span> +</span><br><span class="line">                <span class="string">"        &#125;,\n"</span> +</span><br><span class="line">                <span class="string">"        &#123;\n"</span> +</span><br><span class="line">                <span class="string">"            \"giftName\": \"满10减1元\",\n"</span> +</span><br><span class="line">                <span class="string">"            \"phone\": \"****\"\n"</span> +</span><br><span class="line">                <span class="string">"        &#125;,\n"</span> +</span><br><span class="line">                <span class="string">"        &#123;\n"</span> +</span><br><span class="line">                <span class="string">"            \"giftName\": \"三花便签（20枚）\",\n"</span> +</span><br><span class="line">                <span class="string">"            \"phone\": \"****\"\n"</span> +</span><br><span class="line">                <span class="string">"        &#125;,\n"</span> +</span><br><span class="line">                <span class="string">"        &#123;\n"</span> +</span><br><span class="line">                <span class="string">"            \"giftName\": \"三花便签（20枚）\",\n"</span> +</span><br><span class="line">                <span class="string">"            \"phone\": \"****\"\n"</span> +</span><br><span class="line">                <span class="string">"        &#125;,\n"</span> +</span><br><span class="line">                <span class="string">"        &#123;\n"</span> +</span><br><span class="line">                <span class="string">"            \"giftName\": \"满10减1元\",\n"</span> +</span><br><span class="line">                <span class="string">"            \"phone\": \"****\"\n"</span> +</span><br><span class="line">                <span class="string">"        &#125;,\n"</span> +</span><br><span class="line">                <span class="string">"        &#123;\n"</span> +</span><br><span class="line">                <span class="string">"            \"giftName\": \"20个积分\",\n"</span> +</span><br><span class="line">                <span class="string">"            \"phone\": \"****\"\n"</span> +</span><br><span class="line">                <span class="string">"        &#125;,\n"</span> +</span><br><span class="line">                <span class="string">"        &#123;\n"</span> +</span><br><span class="line">                <span class="string">"            \"giftName\": \"满10减1元\",\n"</span> +</span><br><span class="line">                <span class="string">"            \"phone\": \"****\"\n"</span> +</span><br><span class="line">                <span class="string">"        &#125;,\n"</span> +</span><br><span class="line">                <span class="string">"        &#123;\n"</span> +</span><br><span class="line">                <span class="string">"            \"giftName\": \"20个积分\",\n"</span> +</span><br><span class="line">                <span class="string">"            \"phone\": \"****\"\n"</span> +</span><br><span class="line">                <span class="string">"        &#125;,\n"</span> +</span><br><span class="line">                <span class="string">"        &#123;\n"</span> +</span><br><span class="line">                <span class="string">"            \"giftName\": \"三花便签（20枚）\",\n"</span> +</span><br><span class="line">                <span class="string">"            \"phone\": \"****\"\n"</span> +</span><br><span class="line">                <span class="string">"        &#125;,\n"</span> +</span><br><span class="line">                <span class="string">"        &#123;\n"</span> +</span><br><span class="line">                <span class="string">"            \"giftName\": \"三花便签（20枚）\",\n"</span> +</span><br><span class="line">                <span class="string">"            \"phone\": \"****\"\n"</span> +</span><br><span class="line">                <span class="string">"        &#125;,\n"</span> +</span><br><span class="line">                <span class="string">"        &#123;\n"</span> +</span><br><span class="line">                <span class="string">"            \"giftName\": \"满10减1元\",\n"</span> +</span><br><span class="line">                <span class="string">"            \"phone\": \"****\"\n"</span> +</span><br><span class="line">                <span class="string">"        &#125;,\n"</span> +</span><br><span class="line">                <span class="string">"        &#123;\n"</span> +</span><br><span class="line">                <span class="string">"            \"giftName\": \"20个积分\",\n"</span> +</span><br><span class="line">                <span class="string">"            \"phone\": \"****\"\n"</span> +</span><br><span class="line">                <span class="string">"        &#125;,\n"</span> +</span><br><span class="line">                <span class="string">"        &#123;\n"</span> +</span><br><span class="line">                <span class="string">"            \"giftName\": \"20个积分\",\n"</span> +</span><br><span class="line">                <span class="string">"            \"phone\": \"****\"\n"</span> +</span><br><span class="line">                <span class="string">"        &#125;\n"</span> +</span><br><span class="line">                <span class="string">"    ],\n"</span> +</span><br><span class="line">                <span class="string">"    \"msg\": \"success\",\n"</span> +</span><br><span class="line">                <span class="string">"    \"ret\": 0\n"</span> +</span><br><span class="line">                <span class="string">"&#125;"</span>;</span><br><span class="line"></span><br><span class="line">        AutoScrollLuckyListReq autoScrollLuckyListReq = JSON.parseObject(response, AutoScrollLuckyListReq.class);</span><br><span class="line">        <span class="comment">// 0为请求成功</span></span><br><span class="line">        <span class="keyword">if</span> (autoScrollLuckyListReq.getRet() == <span class="number">0</span>) &#123;</span><br><span class="line">            AutoPollAdapter autoPollAdapter = <span class="keyword">new</span> AutoPollAdapter(getApplicationContext(),</span><br><span class="line">                    autoScrollLuckyListReq.getDatas());</span><br><span class="line">            mRecyclerView.setAdapter(autoPollAdapter);</span><br><span class="line">            <span class="comment">// 启动滚动</span></span><br><span class="line">            mRecyclerView.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-效果和Demo地址"><a href="#5-效果和Demo地址" class="headerlink" title="5. 效果和Demo地址"></a>5. 效果和Demo地址</h1><img src="/2019/07/27/Android-RecyclerView自动滚动/11843186-e97d2347865f08c0.gif"><p>Demo地址：<a href="https://gitee.com/QingFengBaiYu/Allen_Demo_AutoPollRecyclerView" target="_blank" rel="noopener">Allen_Demo_AutoPollRecyclerView</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;实现功能：使用&lt;code&gt;RecyclerView&lt;/code&gt;实现垂直滚动效果。&lt;/p&gt;
&lt;h1 id=&quot;1-自定义RecyclerView实现滚动效果&quot;&gt;&lt;a href=&quot;#1-自定义RecyclerView实现滚动效果&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="Android" scheme="https://tylerLiu.top/categories/Android/"/>
    
      <category term="View" scheme="https://tylerLiu.top/categories/Android/View/"/>
    
    
      <category term="RecyclerView" scheme="https://tylerLiu.top/tags/RecyclerView/"/>
    
  </entry>
  
  <entry>
    <title>蘸水牛肉</title>
    <link href="https://tylerLiu.top/2019/07/27/%E8%98%B8%E6%B0%B4%E7%89%9B%E8%82%89/"/>
    <id>https://tylerLiu.top/2019/07/27/蘸水牛肉/</id>
    <published>2019-07-27T03:25:47.000Z</published>
    <updated>2019-07-31T07:35:20.295Z</updated>
    
    <content type="html"><![CDATA[<p>【食材】：牛腱子两斤，老姜一大块，花椒四五十粒， 食盐适量，大蒜泥适量、调味盐、味精适量，红油辣子一大勺，花椒面适量，藤椒油适量，芝麻油适量，香葱花适量。</p><p>流程：</p><ol><li>牛腱子用洗水浸泡两三个小时，尽量泡出肉的的血水，因为肉中血水多，肉的腥味就比较重，不好吃；</li><li>浸泡好的牛肉入冷水锅，中火煮开后，再煮两分钟；</li><li>经过稍稍煮过的牛肉会紧缩一团，我们从锅中取出肉，再用温水冲洗干净牛肉表面的血污，再控干水分，以上几个步骤的目的都是尽量去除肉中的血污，让肉的味道更鲜美，而没有腥味；</li><li>砂锅中放入前面处理好的牛肉，再加入纯净水或矿泉水，再加入一块用刀拍破的老姜和花椒粒，以及适量的食盐，开 大火烧开后，转小火盖上锅盖煮，大约一个小时左右；</li><li>煮一个小时左右，我们用一根筷子插肉，如果可以轻松插入牛肉肉中就差不多了；</li><li>我们再把牛肉从锅中取出，彻底晾凉后再切成薄片备用；</li><li>取一个碗，碗中加入大蒜泥，红油辣子（最好是近期制作的在，时间长了不香），适量的花面和藤椒油卡 ，还要加上适量的调味盐（虽然前面煮肉时加过盐，但比较淡，这里还是需要加少量的调味盐），最后我们还要加入，适量的味精、芝麻油、香葱花，再搅拌匀就可以蘸牛肉了。</li></ol><img src="/2019/07/27/蘸水牛肉/13033741-0b5b682c021e4590.webp">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;【食材】：牛腱子两斤，老姜一大块，花椒四五十粒， 食盐适量，大蒜泥适量、调味盐、味精适量，红油辣子一大勺，花椒面适量，藤椒油适量，芝麻油适量，香葱花适量。&lt;/p&gt;
&lt;p&gt;流程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;牛腱子用洗水浸泡两三个小时，尽量泡出肉的的血水，因为肉中血水多，肉的腥
      
    
    </summary>
    
      <category term="美食" scheme="https://tylerLiu.top/categories/%E7%BE%8E%E9%A3%9F/"/>
    
    
      <category term="美食" scheme="https://tylerLiu.top/tags/%E7%BE%8E%E9%A3%9F/"/>
    
  </entry>
  
  <entry>
    <title>豆角焖面</title>
    <link href="https://tylerLiu.top/2019/07/27/%E8%B1%86%E8%A7%92%E7%84%96%E9%9D%A2/"/>
    <id>https://tylerLiu.top/2019/07/27/豆角焖面/</id>
    <published>2019-07-27T03:19:40.000Z</published>
    <updated>2019-07-27T03:22:40.402Z</updated>
    
    <content type="html"><![CDATA[<p>主料：圆滚豆角一小把切成丁，五花肉适量切成末，细刀切面适量</p><p>配料：泡发好的香菇4、5朵切丁，胡萝卜一小段切丁，葱末、姜米、蒜米，香菜碎，八角一朵，干红辣椒4、5只</p><p>酱汁：另准备4、5瓣大蒜切米放入碗中，加适量青葱碎，里面放入两匙酱油，一匙陈醋，1\3匙白糖 调成酱汁备用</p><p>流程：</p><ol><li>热锅凉油，油温7、8层热时放入八角爆香，下肉末煸炒，肉末变色断生后放入干红辣椒翻炒几下，依次加入姜末、葱末、蒜末，翻炒出香味后加入适量酱油和少许盐，加稍多些水，烧开后慢火炖煮10分钟；</li><li>冲调酱汁：10分钟后将锅里面的汤一勺一勺舀出，冲倒在酱汁碗中；</li><li>锅内留少许汤汁，以不没过豆角为限，将刀切面疏散的铺在豆角上面，尽量不要贴在锅壁上，防粘和糊；</li><li>将冲调好的酱汁分三次均匀淋在面条上，每次间隔3分钟；</li><li>9分钟后关火，在面条上淋少许香油，撒上香菜碎，用筷子轻轻将面条拨散拌匀，装盘上桌。</li></ol><p>搭配上橄榄油沙拉和花生米，营养很均衡。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;主料：圆滚豆角一小把切成丁，五花肉适量切成末，细刀切面适量&lt;/p&gt;
&lt;p&gt;配料：泡发好的香菇4、5朵切丁，胡萝卜一小段切丁，葱末、姜米、蒜米，香菜碎，八角一朵，干红辣椒4、5只&lt;/p&gt;
&lt;p&gt;酱汁：另准备4、5瓣大蒜切米放入碗中，加适量青葱碎，里面放入两匙酱油，一匙陈醋，1
      
    
    </summary>
    
      <category term="美食" scheme="https://tylerLiu.top/categories/%E7%BE%8E%E9%A3%9F/"/>
    
    
      <category term="美食" scheme="https://tylerLiu.top/tags/%E7%BE%8E%E9%A3%9F/"/>
    
  </entry>
  
  <entry>
    <title>二、Android XML数据解析</title>
    <link href="https://tylerLiu.top/2019/07/26/%E4%BA%8C%E3%80%81Android-XML%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/"/>
    <id>https://tylerLiu.top/2019/07/26/二、Android-XML数据解析/</id>
    <published>2019-07-26T08:27:11.000Z</published>
    <updated>2019-07-29T02:32:02.644Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-XML数据要点介绍"><a href="#1-XML数据要点介绍" class="headerlink" title="1. XML数据要点介绍"></a>1. XML数据要点介绍</h1><p>XML，可扩展标记语言。可以用来存储数据，可以看做是一个小型的数据库，<code>SharedPreference</code>就是使用XML文件存储数据的，<code>SQLite</code>底层也是一个XML文件，而在网络应用方面，通常作为信息的载体，通常把数据包装成XML来传递。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>      -----文档开始</span><br><span class="line"><span class="tag">&lt;<span class="name">persons</span>&gt;</span>                                   -----开始元素(persons)</span><br><span class="line">    <span class="tag">&lt;<span class="name">person</span> <span class="attr">id</span> = <span class="string">"11"</span>&gt;</span>                      -----文本节点（空白文本） 开始元素(person)属性</span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Coder-pig<span class="tag">&lt;/<span class="name">name</span>&gt;</span>              -----文本节点（空白文本） 开始元素(name)属性 结束元素</span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>18<span class="tag">&lt;/<span class="name">age</span>&gt;</span>          -----文本节点（空白文本） 开始元素(age)属性 结束元素</span><br><span class="line">    <span class="tag">&lt;/<span class="name">person</span>&gt;</span>         -----文本节点（空白文本） 结束元素</span><br><span class="line">    <span class="tag">&lt;<span class="name">person</span> <span class="attr">id</span> = <span class="string">"13"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Jay<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>20<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">persons</span>&gt;</span>        -----结束元素(persons)</span><br><span class="line">                     -----文档结束</span><br></pre></td></tr></table></figure><p>上面就简单的定义了一个存储person对象的xml文件的编码，注意，外面的空白区域也是文本节点。</p><h1 id="2-三种解析XML方法的比较"><a href="#2-三种解析XML方法的比较" class="headerlink" title="2. 三种解析XML方法的比较"></a>2. 三种解析XML方法的比较</h1><h2 id="2-1-SAX解析XML"><a href="#2-1-SAX解析XML" class="headerlink" title="2.1 SAX解析XML"></a>2.1 SAX解析XML</h2><p>对文档进行顺序扫描，当扫描到文档(doucument)开始与结束、元素(element)开始与结束等地方时，通知事件处理函数，由事件处理函数做相对应动作，然后继续进行同样的扫描，直至文档结束。解释速度快，占用内存小，，每需要解析一类XML，就需要编写新的适合该类的XML处理类，比较麻烦。采用的是流式解析，解析是同步的，读到哪就处理到哪。</p><h2 id="2-2-Dom解析XML"><a href="#2-2-Dom解析XML" class="headerlink" title="2.2 Dom解析XML"></a>2.2 Dom解析XML</h2><p>先把XML文档读取到内存中，然后再用DOM API来访问树形结构，并获取数据。这个写起来很简单，但是很消耗内存，假如读取的数据量大，手机内存不够的话，可能导致手机死机。不建议在Android设备中使用，解析简单的XML可以。常用的五个接口与类：<code>Docculem</code>、<code>Element</code>、<code>Node</code>、<code>NodeList</code>、<code>DOMParser</code>，Don是整个文件解析到内存中，供用户需要的节点信息，支持随机访问。</p><h2 id="2-3-pull解析XML"><a href="#2-3-pull解析XML" class="headerlink" title="2.3 pull解析XML"></a>2.3 pull解析XML</h2><p>XML pull提供了开始元素和结束元素。当某个元素开始时，可以调用<code>parser</code>、<code>nextText</code>从XML文档中提取所有字符数据。当解析到文档结束时，自动生成<code>EndDocument</code>。常用接口和类：<code>XmlPullParser</code>、<code>XmlSerializer</code>、<code>XmlPullParserFactory</code>。和SAX差不多，代码实现比较简单，非常适合移动设备，Android系统内置pull解析器，而且Android系统内部默认使用pull来解析XML文件。</p><h1 id="3-SAX解析XML"><a href="#3-SAX解析XML" class="headerlink" title="3. SAX解析XML"></a>3. SAX解析XML</h1><p>SAX是一个解析速度快且占用内存少的XML解析器，非常适合用于Android等移动设备；SAX解析XML文件采用的是事件驱动，也就是说不需要解析整个文档，而是在解析过程中，判断读取的字符是否符合XML语法的某部分（文档开头，文档结束，或者标签开头和标签结束），符合的话就会触发事件（回调方法），而这些方法都定义在<code>ContentHandler</code>接口中，而<code>ContentHandler</code>是一个接口， 使用起来不方便，所以Android准备了一个帮助类<code>DefaultHandler</code>，只需要继承这个类，重写里面对应的方法即可。</p><p>可以重写的方法：</p><ul><li><code>startDocument()</code>：当读取到文文档开始标志时触发，通常在这里完成一些初始化操作。</li><li><code>endDocument()</code>：文档结束部分，在这里完成一些善后工作。</li><li><code>startElement(names, paceURI, localName, qName, atts)</code>：参数依次问命名空间，不带命名空间的前缀标签名，带命名空间的前缀标签名，通过<code>atts</code>可以得到所有的属性名和相应的值；SAX中一个重要的特点就是它的流式处理，当遇到一个标签时，它并不会记录下以前遇到的标签，就是说，在<code>startElement()</code>中，所有知道的信息就是标签的名字和属性，至于标签的嵌套结构，上层标签的名字，是否有子元素等其他与结构相关的信息，都不知道，需要程序来完成，这使得SAX在编程处理上没有DOM方便。</li><li><code>endElement(uri, localName, name)</code>：在遇到结束标签的时候，调用该方法。</li><li><code>characters(ch, start, length)</code>：这个方法用来处理在XML文件中读到的内容，第一个参数用于存放文件的内容，后面两个参数是读到的字符串在这个数组中的起始位置和长度，使用<code>new String(ch, start, length)</code>就可以获取内容。</li></ul><p><strong>核心代码：SAX解析类——<code>SaxHelper.java</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ly.allendemowebservice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.xml.sax.Attributes;</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.SAXException;</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.helpers.DefaultHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SAX解析XML</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Liuyang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/7/26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaxHelper</span> <span class="keyword">extends</span> <span class="title">DefaultHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"SaxHelper"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Person mPerson;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Person&gt; mPersons;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前解析的元素标签</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String mTagName = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当读取到文档开始标志时触发，通常在里面完成一些初始化操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startDocument</span><span class="params">()</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mPersons = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Log.i(TAG, <span class="string">"读取到文档头,开始解析xml"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ELEMENT = <span class="string">"person"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读到一个开始标签时触发，第二个参数为标签名，最后一个参数为属性数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startElement</span><span class="params">(String uri, String localName, String qName, Attributes attributes)</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ELEMENT.equals(localName)) &#123;</span><br><span class="line">            mPerson = <span class="keyword">new</span> Person();</span><br><span class="line">            mPerson.setId(Integer.parseInt(attributes.getValue(<span class="string">"id"</span>)));</span><br><span class="line">            Log.i(TAG, <span class="string">"开始处理person元素~"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mTagName = localName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG_NAME1 = <span class="string">"name"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG_NAME2 = <span class="string">"age"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取标签里面的内容，第一个参数为字符串内容，后面依次为起始位置和长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">characters</span><span class="params">(<span class="keyword">char</span>[] ch, <span class="keyword">int</span> start, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">        <span class="comment">// 判断当前标签是否有效</span></span><br><span class="line">        <span class="keyword">if</span> (mTagName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String data = <span class="keyword">new</span> String(ch, start, length);</span><br><span class="line">            <span class="comment">// 读取标签内容</span></span><br><span class="line">            <span class="keyword">if</span> (TAG_NAME1.equals(mTagName)) &#123;</span><br><span class="line">                mPerson.setName(data);</span><br><span class="line">                Log.i(TAG, <span class="string">"处理name元素内容"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (TAG_NAME2.equals(mTagName)) &#123;</span><br><span class="line">                mPerson.setAge(Integer.parseInt(data));</span><br><span class="line">                Log.i(TAG, <span class="string">"处理age元素内容"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取到元素结束时触发，这里将对象添加到集合中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endElement</span><span class="params">(String uri, String localName, String qName)</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ELEMENT.equals(localName)) &#123;</span><br><span class="line">            mPersons.add(mPerson);</span><br><span class="line">            mPerson = <span class="keyword">null</span>;</span><br><span class="line">            Log.i(TAG, <span class="string">"处理person元素结束~"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mTagName = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取到文档结束时触发，</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endDocument</span><span class="params">()</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.endDocument();</span><br><span class="line">        Log.i(TAG, <span class="string">"处理person元素结束~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取persons集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Person&gt; <span class="title">getPersons</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mPersons;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ArrayList&lt;Person&gt; <span class="title">readXmlForSax</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ParserConfigurationException, SAXException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取文件资源建立输入流对象，可能是从网络获取</span></span><br><span class="line">    InputStream inputStream = getAssets().open(<span class="string">"person1.xml"</span>);</span><br><span class="line">    <span class="comment">// 创建XML解析器</span></span><br><span class="line">    SaxHelper helper = <span class="keyword">new</span> SaxHelper();</span><br><span class="line">    <span class="comment">// 得到SAX解析工厂</span></span><br><span class="line">    SAXParserFactory factory = SAXParserFactory.newInstance();</span><br><span class="line">    <span class="comment">// 创建SAX解析器</span></span><br><span class="line">    SAXParser parser = factory.newSAXParser();</span><br><span class="line">    <span class="comment">// 将XML解析器分配给解析器，对文档进行解析，将事件发送给处理器</span></span><br><span class="line">    parser.parse(inputStream, helper);</span><br><span class="line">    inputStream.close();</span><br><span class="line">    <span class="keyword">return</span> helper.getPersons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在项目assets目录下有一个文件<code>person1.xml</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">persons</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">person</span> <span class="attr">id</span> = <span class="string">"11"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>SAX解析<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>18<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">person</span> <span class="attr">id</span> = <span class="string">"13"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>XML1<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>43<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">persons</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Demo地址：<a href="https://gitee.com/QingFengBaiYu/Allen_Demo_WebService" target="_blank" rel="noopener">Allen_Demo_WebService</a></p><h1 id="4-DOM解析XML数据"><a href="#4-DOM解析XML数据" class="headerlink" title="4. DOM解析XML数据"></a>4. DOM解析XML数据</h1><p>DOM解析XML文件时会将文件所有的内容以文档树的形式存放在内存中，可以使用DOM API遍历XML树，检索到需要的数据。使用DOM操作XML的代码比较直观，并且在编码方面比基于SAX的实现更加简单。但是DOM需要将XML文件的所有内容存放到内存中，所以内存消耗大，特别是对于Android设备而言，内存资源有限，因此建议使用前面的SAX解析。如果解析的内容比较小，也可以使用DOM来解析。</p><p>DOM API：</p><ul><li><p><code>DocumentBuilderFactory</code>（解析器工厂类）：创建方法<code>DoucmentBuilderFactory factory = DoucmentBuilderFactory.newInstance();</code></p></li><li><p><code>DocumentBuilder</code>（解析器类）：创建方法：通过解析器工厂类来获得<code>DocumentBuidler builder = factory.newDocumentBuilder();</code></p></li><li><p><code>Document</code>（文档树模型）：将需要解析的XML文件读入DOM解析器：<code>Document doc = builder.parse(context.getAssets().open(&quot;person2.xml&quot;));</code></p><p><strong><code>Document</code>对象代表了一个XML文档的模型，所有的其他<code>Node</code>都以一定的顺序包含在<code>Document</code>对象内，排列成树状，以后对XML文档的所有操作都与解析器无关。</strong></p></li><li><p><code>NodeList</code>（列表类）：代表一个包含一个或多个<code>Node</code>的列表，有以下两个方法：</p><ul><li><code>item(index)</code>：返回集合的第<code>index</code>个<code>Node</code>项；</li><li><code>getLength()</code>：列表的节点数</li></ul></li><li><p><code>Node</code>（节点类）：DOM中最基本的对象，代表文档树中的抽象节点，很少会直接使用；通常调用其子对象的<code>Element</code>、<code>Attr</code>、<code>Text</code>等。</p></li><li><p><code>Element</code>（元素类）：<code>Node</code>最主要的子对象，在元素中可以包含属性，因此有获取属性的方法：</p><ul><li><code>getAttrbute()</code>：获取属性值</li><li><code>getTagName()</code>：获取元素名称</li></ul></li><li><p><code>Attr</code>（属性类）：代表某个元素的属性，虽然<code>Attr</code>继承自<code>Node</code>接口，但因为<code>Attr</code>是包含在<code>Element</code>中的，但并不能将其看做是<code>Element</code>的子对象，因为<code>Attr</code>并不是DOM树的一部分。</p></li></ul><p><strong>核心代码：DOM解析类——<code>DomHelper.java</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ly.allendemowebservice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.Document;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.Element;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.Node;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.NodeList;</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.SAXException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.DocumentBuilder;</span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.DocumentBuilderFactory;</span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.ParserConfigurationException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DOM解析XML</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Liuyang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/7/26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DomHelper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"DomHelper"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG_NAME = <span class="string">"name"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG_AGE = <span class="string">"age"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Person&gt; <span class="title">queryXML</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Person&gt; persons = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 获取DOM解析器工厂</span></span><br><span class="line">            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();</span><br><span class="line">            <span class="comment">// 2. 获取DOM解析器</span></span><br><span class="line">            DocumentBuilder builder = factory.newDocumentBuilder();</span><br><span class="line">            <span class="comment">// 3. 将要解析的XML文件读入DOM解析器</span></span><br><span class="line">            Document document = builder.parse(context.getAssets().open(<span class="string">"person2.xml"</span>));</span><br><span class="line"></span><br><span class="line">            Log.i(TAG, <span class="string">"处理该文档的DomImplementation对象 = "</span> + document.getImplementation());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 得到文档中名称为person的元素的节点元素</span></span><br><span class="line">            NodeList nodeList = document.getElementsByTagName(<span class="string">"person"</span>);</span><br><span class="line">            <span class="comment">// 5. 遍历集合，显示集合中的元素以及子元素的名字</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodeList.getLength(); i++) &#123;</span><br><span class="line">                <span class="comment">// 先从person元素开始解析</span></span><br><span class="line">                Element personElement = (Element) nodeList.item(i);</span><br><span class="line">                Person person = <span class="keyword">new</span> Person();</span><br><span class="line">                person.setId(Integer.valueOf(personElement.getAttribute(<span class="string">"id"</span>)));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取person下的name和age的Note集合</span></span><br><span class="line">                NodeList childNodeList = personElement.getChildNodes();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; childNodeList.getLength(); j++) &#123;</span><br><span class="line">                    Node childNode = childNodeList.item(j);</span><br><span class="line">                    <span class="comment">// 判断子Node类型是否为元素的Node</span></span><br><span class="line">                    <span class="keyword">if</span> (childNode.getNodeType() == Node.ELEMENT_NODE) &#123;</span><br><span class="line">                        Element childElement = (Element) childNode;</span><br><span class="line">                        <span class="keyword">if</span> (TAG_NAME.equals(childElement.getNodeName())) &#123;</span><br><span class="line">                            person.setName(childElement.getFirstChild().getNodeValue());</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (TAG_AGE.equals(childElement.getNodeName())) &#123;</span><br><span class="line">                            person.setAge(Integer.valueOf(childElement.getFirstChild().getNodeValue()));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                persons.add(person);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParserConfigurationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SAXException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> persons;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-PULL解析XML数据"><a href="#5-PULL解析XML数据" class="headerlink" title="5. PULL解析XML数据"></a>5. PULL解析XML数据</h1><p>除了SAX和DOM解析XML之外，Android系统内置了Pull解析器用来解析XML，比如<code>SharedPreference</code>就是使用内置的pull解析配置文件的。它的使用和SAX类似，都是采用事件驱动来完成XML的解析，而pull代码比较简单，只需处理开始和结束的事件，通常使用<code>switch</code>语句，根据事件不同的类型，匹配不同的处理方式，有五种事件：<code>START_DOCUMENT</code>、<code>START_TAG</code>、<code>TEXT</code>、<code>END_TAG</code>、<code>END_DUCOMENT</code>。</p><p>XML pull 提供了开始元素和结束元素。当某个元素开始的时候，可以调用<code>paser.nextText</code>从XML文档中提取所有字符数据。当解析到一个文档结束时，自动生成<code>EndDocument</code>事件。在PULL解析过程中返回的是数字，且需要自己获取产生事件然后做出相应的操作，而不像SAX那样由处理器触发一种事件的方法，执行我们的代码：读取到XML的声明返回<code>START_DOCUMENT</code>；结束返回<code>END_DOCUMENT</code>；开始标签返回<code>START_TAG</code>；结束标签返回<code>END_TAG</code>；文本返回<code>TEXT</code>。<br>使用PULL解析XML的流程：</p><ol><li><p>获取一个<code>XmlPullPaser</code>类的引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1：通过xml解析工厂获得实体类</span></span><br><span class="line">XmlPullPaserFactory factory = XmlPullPaserFactory.newInstance(); XmlPullPaser paser = factory.newPullPaser();</span><br><span class="line"><span class="comment">// 方式2：直接获得实体类</span></span><br><span class="line">XmlPullPaser paser = Xml.newPullPaser();</span><br></pre></td></tr></table></figure></li><li><p>为<code>paser</code>解析器对象提供xml流与编码格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paser.setInput(xml, <span class="string">"UTF-8"</span>);</span><br></pre></td></tr></table></figure></li><li><p>获得事件的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> eventType = paser.getEventType();</span><br></pre></td></tr></table></figure></li><li><p>用<code>switch</code>对不同的事件类型进行不同的处理：</p></li></ol><ul><li><code>START_DUCUMENT</code>：开始读文档时触发，在这里完成初始化操作；</li><li><code>START_TAG</code>:开始读标签，通过<code>paser</code>的<code>getName()</code>方法获得标签名信息比较，使用<code>getAttributeValue(index)</code>获取属性值；</li><li>对于文字节点<code>TEXT</code>可以使用<code>paser.nextText()</code>获得节点内容；</li><li><code>END_TAG</code>：标签结束；</li><li><code>paser.next()</code>：循环解析下一个元素。</li></ul><p><strong>核心代码：PULL解析XML——<code>PullHelper.java</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ly.allendemowebservice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.xmlpull.v1.XmlPullParser;</span><br><span class="line"><span class="keyword">import</span> org.xmlpull.v1.XmlPullParserException;</span><br><span class="line"><span class="keyword">import</span> org.xmlpull.v1.XmlPullParserFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * PULL解析XML</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Liuyang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/7/27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PullHelper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Person&gt; <span class="title">getPersons</span><span class="params">(InputStream xml)</span> <span class="keyword">throws</span> XmlPullParserException, IOException </span>&#123;</span><br><span class="line">        ArrayList&lt;Person&gt; persons = <span class="keyword">null</span>;</span><br><span class="line">        Person person = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 创建一个XML解析工厂</span></span><br><span class="line">        XmlPullParserFactory factory = XmlPullParserFactory.newInstance();</span><br><span class="line">        <span class="comment">// 获得XML解析类的引用</span></span><br><span class="line">        XmlPullParser parser = factory.newPullParser();</span><br><span class="line">        parser.setInput(xml, <span class="string">"UTF_8"</span>);</span><br><span class="line">        <span class="comment">// 获得事件类型</span></span><br><span class="line">        <span class="keyword">int</span> eventType = parser.getEventType();</span><br><span class="line">        <span class="keyword">while</span> (eventType != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (eventType) &#123;</span><br><span class="line">                <span class="keyword">case</span> XmlPullParser.START_DOCUMENT:</span><br><span class="line">                    persons = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> XmlPullParser.START_TAG:</span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">"person"</span>.equals(parser.getName())) &#123;</span><br><span class="line">                        person = <span class="keyword">new</span> Person();</span><br><span class="line">                        <span class="comment">// 取出属性值</span></span><br><span class="line">                        <span class="keyword">int</span> id = Integer.parseInt(parser.getAttributeValue(<span class="number">0</span>));</span><br><span class="line">                        person.setId(id);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"name"</span>.equals(parser.getName())) &#123;</span><br><span class="line">                        <span class="comment">// 获取该节点的内容</span></span><br><span class="line">                        String name = parser.nextText();</span><br><span class="line">                        <span class="keyword">assert</span> person != <span class="keyword">null</span>;</span><br><span class="line">                        person.setName(name);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"age"</span>.equals(parser.getName())) &#123;</span><br><span class="line">                        <span class="keyword">int</span> age = Integer.parseInt(parser.nextText());</span><br><span class="line">                        <span class="keyword">assert</span> person != <span class="keyword">null</span>;</span><br><span class="line">                        person.setAge(age);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> XmlPullParser.END_TAG:</span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">"person"</span>.equals(parser.getName())) &#123;</span><br><span class="line">                        <span class="keyword">assert</span> persons != <span class="keyword">null</span>;</span><br><span class="line">                        persons.add(person);</span><br><span class="line">                        person = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            eventType = parser.next();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> persons;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    InputStream inputStream = getAssets().open(<span class="string">"person3.xml"</span>);</span><br><span class="line">    ArrayList&lt;Person&gt; persons = PullHelper.getPersons(inputStream);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; persons.size(); i++) &#123;</span><br><span class="line">        Log.i(TAG, i + <span class="string">" == "</span> + persons.get(i).toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (XmlPullParserException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用PULL生成XML数据的流程：</p><ol><li><p>创建<code>XMlSerializer</code>（XML序列化类）的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XmlSerializer serializer = Xml.newSerializer();</span><br></pre></td></tr></table></figure></li><li><p>为<code>XmlSerializer</code>设置输出流与编码格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serializersetOutput(out, <span class="string">"UTF-8"</span>);</span><br></pre></td></tr></table></figure></li><li><p>为<code>XMlSerializer</code>设置XML的编码格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serializer.startDocument(<span class="string">"UTF-8"</span>, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></li><li><p>设置根元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serializer.startTag(<span class="keyword">null</span>, <span class="string">"person"</span>);</span><br></pre></td></tr></table></figure></li><li><p>使用<code>foreach</code>循环遍历<code>persons</code>集合中所有的元素，同时依次写入标签与属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Person p: persons)&#123;</span><br><span class="line">serializer.startTag(<span class="keyword">null</span>, <span class="string">"person"</span>);</span><br><span class="line">serializer.attribute(<span class="keyword">null</span>, <span class="string">"id"</span>, p.getId() + <span class="string">""</span>);</span><br><span class="line">serializer.startTag(<span class="keyword">null</span>, <span class="string">"name"</span>);</span><br><span class="line">serializer.text(p.getName());</span><br><span class="line">serializer.endTag(<span class="keyword">null</span>, <span class="string">"name"</span>);</span><br><span class="line">serializer.startTag(<span class="keyword">null</span>, <span class="string">"age"</span>);</span><br><span class="line">serializer.text(p.getAge() + <span class="string">""</span>);</span><br><span class="line">serializer.endTag(<span class="keyword">null</span>, <span class="string">"age"</span>);</span><br><span class="line">serializer.endTag(<span class="keyword">null</span>, <span class="string">"person"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>设置跟踪完结元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serializer.endTag(<span class="keyword">null</span>, <span class="string">"persons"</span>);</span><br></pre></td></tr></table></figure></li><li><p>结束文档编写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serializer.endDocument();</span><br></pre></td></tr></table></figure></li><li><p>调用<code>flush()</code>，将内存中的数据写入文件中并关闭输出流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">out.flush();</span><br><span class="line">out.close();</span><br></pre></td></tr></table></figure></li></ol><p>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(List&lt;Person&gt; persons, OutputStream out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    XmlSerializer serializer = Xml.newSerializer();</span><br><span class="line">    serializer.setOutput(out, <span class="string">"UTF-8"</span>);</span><br><span class="line">    serializer.startDocument(<span class="string">"UTF-8"</span>, <span class="keyword">true</span>);</span><br><span class="line">    serializer.startTag(<span class="keyword">null</span>, <span class="string">"persons"</span>);</span><br><span class="line">    <span class="keyword">for</span> (Person p : persons) &#123;</span><br><span class="line">        serializer.startTag(<span class="keyword">null</span>, <span class="string">"person"</span>);</span><br><span class="line">        serializer.attribute(<span class="keyword">null</span>, <span class="string">"id"</span>, p.getId() + <span class="string">""</span>);</span><br><span class="line">        serializer.startTag(<span class="keyword">null</span>, <span class="string">"name"</span>);</span><br><span class="line">        serializer.text(p.getName());</span><br><span class="line">        serializer.endTag(<span class="keyword">null</span>, <span class="string">"name"</span>);</span><br><span class="line">        serializer.startTag(<span class="keyword">null</span>, <span class="string">"age"</span>);</span><br><span class="line">        serializer.text(p.getAge() + <span class="string">""</span>);</span><br><span class="line">        serializer.endTag(<span class="keyword">null</span>, <span class="string">"age"</span>);</span><br><span class="line">        serializer.endTag(<span class="keyword">null</span>, <span class="string">"person"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serializer.endTag(<span class="keyword">null</span>, <span class="string">"persons"</span>);</span><br><span class="line">    serializer.endDocument();</span><br><span class="line">    out.flush();</span><br><span class="line">    out.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Demo地址：<a href="https://gitee.com/QingFengBaiYu/Allen_Demo_WebService" target="_blank" rel="noopener">Allen_Demo_WebService</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-XML数据要点介绍&quot;&gt;&lt;a href=&quot;#1-XML数据要点介绍&quot; class=&quot;headerlink&quot; title=&quot;1. XML数据要点介绍&quot;&gt;&lt;/a&gt;1. XML数据要点介绍&lt;/h1&gt;&lt;p&gt;XML，可扩展标记语言。可以用来存储数据，可以看做是一个小型的数
      
    
    </summary>
    
      <category term="Android" scheme="https://tylerLiu.top/categories/Android/"/>
    
      <category term="网络" scheme="https://tylerLiu.top/categories/Android/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="WebService" scheme="https://tylerLiu.top/tags/WebService/"/>
    
  </entry>
  
  <entry>
    <title>一、Android调用WebService</title>
    <link href="https://tylerLiu.top/2019/07/26/%E4%B8%80%E3%80%81Android%E8%B0%83%E7%94%A8WebService/"/>
    <id>https://tylerLiu.top/2019/07/26/一、Android调用WebService/</id>
    <published>2019-07-26T08:12:57.000Z</published>
    <updated>2019-07-31T08:07:13.078Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Android调用WebService类似于一些给我们提供了原始数据API服务的数据平台，比如聚合数据。而WebService则用到了XML和SOAP，通过HTTP协议即可完成与远程机器的交互。</p></blockquote><h1 id="1-WebService简介"><a href="#1-WebService简介" class="headerlink" title="1. WebService简介"></a>1. WebService简介</h1><h2 id="1-1-WebService的引入"><a href="#1-1-WebService的引入" class="headerlink" title="1.1 WebService的引入"></a>1.1 WebService的引入</h2><p>手机硬件资源是有限的，对于一些复杂的数据处理和计算，通常都是部署在远程服务器上，然后安卓手机作为对应的客户端。为了让Android APP与远程服务器进行交互，肯定需要一些技术，这里使用WebService就可以了。</p><p>什么是WebService？</p><p>简单来说，就是某些站点开放出来的服务，当然也可以自己开发一个service，也就是一些方法，通过URI，指定某一个方法名，发出请求，站点的这个服务（方法），接收请求后，根据传入的参数进行一些处理，然后将处理的结果以XML的形式返回。客户端收到这些XML并进行解析，然后显示或者进行其他操作。</p><p>例如，很多大的站点提供天气预报的WebSwevice、查询某网站的数据的WebService，只要发送请求，它就返回天气预报、某网站的数据，然后在客户端就能显示出来。</p><h2 id="1-2-主要采用的四个技术"><a href="#1-2-主要采用的四个技术" class="headerlink" title="1.2 主要采用的四个技术"></a>1.2 主要采用的四个技术</h2><h3 id="1-2-1-XML"><a href="#1-2-1-XML" class="headerlink" title="1.2.1 XML"></a>1.2.1 XML</h3><p>可扩展的标记语言。同时采用XML Schema。正式因为WebWervice采用了XML，才使得它可以跨越各种编程语言。</p><h3 id="1-2-2-SOAP"><a href="#1-2-2-SOAP" class="headerlink" title="1.2.2 SOAP"></a>1.2.2 SOAP</h3><p>简单对象访问协议。提供了标准的RPC（Remote Procedure Call，远程调用过程）方法来调用WebService。SOAP规范中定义了SOAP消息格式，以及怎样通过HTTP协议来使用SOAP。SOAP是基于XML语言和XSD标准的，其中XML是SOAP的数据编码方式。</p><h3 id="1-2-3-WSDL"><a href="#1-2-3-WSDL" class="headerlink" title="1.2.3 WSDL"></a>1.2.3 WSDL</h3><p>WSDL是一种基于XML的用于描述WenService及其操作、参数和返回值的语言。因为是基于XML，一些IDE可以根据WenService来生成WSDL文档，又能通过导入WSDL文档 ，生成调用相应WebWervice的代码。</p><h3 id="1-2-4-UDDI"><a href="#1-2-4-UDDI" class="headerlink" title="1.2.4 UDDI"></a>1.2.4 UDDI</h3><p>用于在网上自动查找WebService，一旦WebService注册到UDDI，客户就可以很方便的查找和定位所需要的WebService。   </p><h2 id="1-3-WebService模型"><a href="#1-3-WebService模型" class="headerlink" title="1.3 WebService模型"></a>1.3 WebService模型</h2><ul><li>服务提供者：把自己的服务注册到“服务注册中心”。</li><li>服务请求者：到“服务注册中心”查找相应的服务，然后定位到“服务提供者”。</li><li>服务提供者：开始为“服务请求者”提供相应的服务。</li></ul><h1 id="2-去哪里获取WebService"><a href="#2-去哪里获取WebService" class="headerlink" title="2. 去哪里获取WebService"></a>2. 去哪里获取WebService</h1><p>网上有很多WebService的站点，这里选取了WebXmlu为例。</p><p>WebXml：<a href="http://www.webxml.com.cn/zh_cn/index.aspx" target="_blank" rel="noopener">http://www.webxml.com.cn/zh_cn/index.aspx</a></p><img src="/2019/07/26/一、Android调用WebService/11843186-85a70b9dc88caa11.png"><img src="/2019/07/26/一、Android调用WebService/11843186-5ba756df7190bd3e.png"><h1 id="3-第三方jar包准备"><a href="#3-第三方jar包准备" class="headerlink" title="3. 第三方jar包准备"></a>3. 第三方jar包准备</h1><p>首先如果想在Android平台上调用WebService，需要依赖第三方库ksoap2，而在Android平台上使用的是ksoap2-android-releases，一个高效、轻量级的SOAP开发包。</p><ol><li>ksoap2-Android项目网站：<br><a href="https://simpligility.github.io/ksoap2-android/index.html" target="_blank" rel="noopener">https://simpligility.github.io/ksoap2-android/index.html</a></li><li>ksoap2-android-assembly发布版本列表(包含所有可用版本jar包)：<br><a href="https://oss.sonatype.org/content/repositories/ksoap2-android-releases/com/google/code/ksoap2-android/ksoap2-android-assembly/" target="_blank" rel="noopener">https://oss.sonatype.org/content/repositories/ksoap2-android-releases/com/google/code/ksoap2-android/ksoap2-android-assembly/</a></li></ol><h1 id="4-获取相关参数"><a href="#4-获取相关参数" class="headerlink" title="4. 获取相关参数"></a>4. 获取相关参数</h1><p>首先找到需要获取的服务，然后记录相关的参数：<code>NameSpace</code>（命名空间）、<code>SoapAction</code>以及<code>URL</code>。</p><img src="/2019/07/26/一、Android调用WebService/11843186-70ebd2865bece62b.png"><img src="/2019/07/26/一、Android调用WebService/11843186-1e89b8be4f8b6d2d.png"><p>比如这里查找天气的查询参数，点击去可以看到一个参数文档：</p><img src="/2019/07/26/一、Android调用WebService/11843186-18783eb0756adcbd.png"><p>假设这里需要的是天气查询部分的功能：</p><img src="/2019/07/26/一、Android调用WebService/11843186-97490ce74afa498f.png"><p>这里可以拿到<code>SoapAction</code>和<code>NameSpace</code>。</p><p>这是一个测试页，可以不用填id信息，点击查询，可以看到这样一个页面：</p><img src="/2019/07/26/一、Android调用WebService/11843186-5a91a680272bb756.png"><p>这就是返回的XML文件，下面就需要去解析这个文件，这里的.gif表示天气的图标。</p><p>上面的查询号码归属地也是同理操作。</p><h1 id="5-注册"><a href="#5-注册" class="headerlink" title="5. 注册"></a>5. 注册</h1><img src="/2019/07/26/一、Android调用WebService/11843186-2ca8fd15f9c2dbeb.png"><img src="/2019/07/26/一、Android调用WebService/11843186-5f37902ccf47d8aa.png"><h1 id="6-Demo"><a href="#6-Demo" class="headerlink" title="6. Demo"></a>6. Demo</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ly.allendemowebservice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.annotation.SuppressLint;</span><br><span class="line"><span class="keyword">import</span> android.os.Handler;</span><br><span class="line"><span class="keyword">import</span> android.os.Message;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.EditText;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.ksoap2.SoapEnvelope;</span><br><span class="line"><span class="keyword">import</span> org.ksoap2.serialization.SoapObject;</span><br><span class="line"><span class="keyword">import</span> org.ksoap2.serialization.SoapPrimitive;</span><br><span class="line"><span class="keyword">import</span> org.ksoap2.serialization.SoapSerializationEnvelope;</span><br><span class="line"><span class="keyword">import</span> org.ksoap2.transport.HttpTransportSE;</span><br><span class="line"><span class="keyword">import</span> org.xmlpull.v1.XmlPullParserException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * WebService demo</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Liuyang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/7/24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MainActivity"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EditText mEtParam;</span><br><span class="line">    <span class="keyword">private</span> TextView mTvResult;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String mResult;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String USER_ID = <span class="string">"1e3c36a0f18b4da4affa98cdd26ab0b4"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义获取手机信息的SoapAction与命名空间,作为常量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME_SPACE = <span class="string">"http://WebXml.com.cn/"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 天气查询相关参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String WEATHER_URL = <span class="string">"http://ws.webxml.com.cn/WebServices/WeatherWS.asmx"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String WEATHER_METHOD = <span class="string">"getWeather"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String WEATHER_SOAP_ACTION = <span class="string">"http://WebXml.com.cn/getWeather"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 号码归属地查询相关参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ADDRESS_URL = <span class="string">"http://ws.webxml.com.cn/WebServices/MobileCodeWS.asmx"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ADDRESS_METHOD = <span class="string">"getMobileCodeInfo"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ADDRESS_SOAP_ACTION = <span class="string">"http://WebXml.com.cn/getMobileCodeInfo"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个Handler用来更新页面</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressLint</span>(<span class="string">"HandlerLeak"</span>)</span><br><span class="line">    <span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0x001</span>:</span><br><span class="line">                    mTvResult.setText(mResult);</span><br><span class="line">                    Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"获取天气信息成功"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0x002</span>:</span><br><span class="line">                    mTvResult.setText(mResult);</span><br><span class="line">                    Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"号码归属地查询成功"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        bindViews();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bindViews</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mEtParam = findViewById(R.id.et_param);</span><br><span class="line">        Button btnAttribution = findViewById(R.id.btn_attribution);</span><br><span class="line">        Button btnWeather = findViewById(R.id.btn_weather);</span><br><span class="line">        mTvResult = findViewById(R.id.tv_result);</span><br><span class="line"></span><br><span class="line">        btnAttribution.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">        btnWeather.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (v.getId()) &#123;</span><br><span class="line">            <span class="keyword">case</span> R.id.btn_attribution:</span><br><span class="line">                <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        getLand();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;.start();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> R.id.btn_weather:</span><br><span class="line">                <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        getWeather();</span><br><span class="line"><span class="comment">//                        getWeather1();</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;.start();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取某个号码的归属地信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getLand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mResult = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">// 根据命名空间和方法得到SoapObject对象</span></span><br><span class="line">        SoapObject soapObject = <span class="keyword">new</span> SoapObject(NAME_SPACE, ADDRESS_METHOD);</span><br><span class="line">        soapObject.addProperty(<span class="string">"mobileCode"</span>, mEtParam.getText().toString());</span><br><span class="line">        soapObject.addProperty(<span class="string">"userID"</span>, USER_ID);</span><br><span class="line">        <span class="comment">// 通过SOAP1.1协议得到envelop对象</span></span><br><span class="line">        SoapSerializationEnvelope envelope = <span class="keyword">new</span> SoapSerializationEnvelope(SoapEnvelope.VER11);</span><br><span class="line">        <span class="comment">// 将soapObject对象设置为envelop对象，传出消息</span></span><br><span class="line">        envelope.bodyOut = soapObject;</span><br><span class="line">        <span class="comment">// 设置是否调用的是dotNet开发的WebService</span></span><br><span class="line">        <span class="comment">// 指定webservice的类型的（java，PHP，dotNet）</span></span><br><span class="line">        envelope.dotNet = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 等价于envelop.bodyOut = soapObject;</span></span><br><span class="line">        envelope.setOutputSoapObject(soapObject);</span><br><span class="line">        HttpTransportSE httpTransportSe = <span class="keyword">new</span> HttpTransportSE(ADDRESS_URL);</span><br><span class="line"></span><br><span class="line">        Log.i(TAG, <span class="string">"号码服务设置完毕,准备开启服务"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始调用远程方法</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 得到远程方法返回的SOAP对象</span></span><br><span class="line">            httpTransportSe.call(ADDRESS_SOAP_ACTION, envelope);</span><br><span class="line">            Log.i(TAG, <span class="string">"调用号码归属地查询WebService服务成功"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            Log.i(TAG, <span class="string">"调用号码归属地查询WebService服务失败 = IOException"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (XmlPullParserException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            Log.i(TAG, <span class="string">"调用号码归属地查询WebService服务失败 = XmlPullParserException"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取返回的数据，并开始解析</span></span><br><span class="line">        SoapObject object = (SoapObject) envelope.bodyIn;</span><br><span class="line">        mResult = object.getProperty(<span class="number">0</span>).toString();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = object.getPropertyCount();</span><br><span class="line">        Log.i(TAG, <span class="string">"count = "</span> + count);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            Log.i(TAG, i + <span class="string">" === "</span> + object.getProperty(i).toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mHandler.sendEmptyMessage(<span class="number">0x002</span>);</span><br><span class="line">        Log.i(TAG, <span class="string">"发送号码归属地数据完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取某个城市的天气信息，使用封装的工具类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getWeather1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        SoapNetUtils.getInstance().doSoapRequest();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取某个城市的天气信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getWeather</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mResult = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">// 根据命名空间和方法得到SoapObject对象</span></span><br><span class="line">        SoapObject soapObject = <span class="keyword">new</span> SoapObject(NAME_SPACE, WEATHER_METHOD);</span><br><span class="line">        soapObject.addProperty(<span class="string">"theCityCode"</span>, mEtParam.getText().toString());</span><br><span class="line">        soapObject.addProperty(<span class="string">"theUserID"</span>, USER_ID);</span><br><span class="line">        <span class="comment">// 通过SOAP1.1协议得到envelop对象</span></span><br><span class="line">        SoapSerializationEnvelope envelope = <span class="keyword">new</span> SoapSerializationEnvelope(SoapEnvelope.VER11);</span><br><span class="line">        <span class="comment">// 将soapObject对象设置为envelop对象，传出消息</span></span><br><span class="line">        envelope.bodyOut = soapObject;</span><br><span class="line">        <span class="comment">// 设置是否调用的是dotNet开发的WebService</span></span><br><span class="line">        <span class="comment">// 指定webservice的类型的（java，PHP，dotNet）</span></span><br><span class="line">        envelope.dotNet = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 等价于envelop.bodyOut = soapObject;</span></span><br><span class="line">        envelope.setOutputSoapObject(soapObject);</span><br><span class="line">        HttpTransportSE httpTransportSe = <span class="keyword">new</span> HttpTransportSE(WEATHER_URL);</span><br><span class="line"></span><br><span class="line">        Log.i(TAG, <span class="string">"天气服务设置完毕,准备开启服务"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始调用远程方法</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 得到远程方法返回的SOAP对象</span></span><br><span class="line">            httpTransportSe.call(WEATHER_SOAP_ACTION, envelope);</span><br><span class="line">            Log.i(TAG, <span class="string">"调用天气查询WebService服务成功"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            Log.i(TAG, <span class="string">"调用天气查询WebService服务失败 = IOException"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (XmlPullParserException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            Log.i(TAG, <span class="string">"调用天气查询WebService服务失败 = XmlPullParserException"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取返回的数据，并开始解析，以下都通过getClass()直到数据的类型，才去进行强制类型转换的</span></span><br><span class="line">        SoapObject object = (SoapObject) envelope.bodyIn;</span><br><span class="line">        SoapPrimitive primitive;</span><br><span class="line">        <span class="keyword">int</span> count = object.getPropertyCount();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            SoapObject object1 = (SoapObject) object.getProperty(i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; object1.getPropertyCount(); j++) &#123;</span><br><span class="line">                primitive = (SoapPrimitive) object1.getProperty(j);</span><br><span class="line">                Log.i(TAG, <span class="string">"第"</span> + j + <span class="string">"个数据为："</span> + primitive.getName() + <span class="string">" = "</span> + primitive.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        primitive = (SoapPrimitive) ((SoapObject) object.getProperty(<span class="number">0</span>)).getProperty(<span class="number">37</span>);</span><br><span class="line"></span><br><span class="line">        mResult = (String) primitive.getValue();</span><br><span class="line">        mHandler.sendEmptyMessage(<span class="number">0x001</span>);</span><br><span class="line">        Log.i(TAG, <span class="string">"发送天气数据完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Demo地址：<a href="https://gitee.com/QingFengBaiYu/Allen_Demo_WebService" target="_blank" rel="noopener">Allen_Demo_WebService</a></p><img src="/2019/07/26/一、Android调用WebService/11843186-c31a93ae4bc7daf3.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Android调用WebService类似于一些给我们提供了原始数据API服务的数据平台，比如聚合数据。而WebService则用到了XML和SOAP，通过HTTP协议即可完成与远程机器的交互。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;
      
    
    </summary>
    
      <category term="Android" scheme="https://tylerLiu.top/categories/Android/"/>
    
      <category term="网络" scheme="https://tylerLiu.top/categories/Android/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="WebService" scheme="https://tylerLiu.top/tags/WebService/"/>
    
  </entry>
  
</feed>
