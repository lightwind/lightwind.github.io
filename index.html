<!DOCTYPE html>


<html lang="zh-Hans">


<head>
  <meta charset="utf-8" />
    
  <meta name="description" content="人生是一场难得的修行，不要轻易交白卷" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     Tyler的博客
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  <link rel="stylesheet" href="/dist/main.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">
  <link rel="stylesheet" href="/css/custom.css">
  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

</head>

</html>

<body>
  
  <div id="app">
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Tyler的博客</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-慕课网《编程必备基础-计算机组成原理-操作系统-计算机网络》-01" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/22/慕课网《编程必备基础-计算机组成原理-操作系统-计算机网络》-01/"
    >慕课网《编程必备基础 计算机组成原理+操作系统+计算机网络》-01</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/22/慕课网《编程必备基础-计算机组成原理-操作系统-计算机网络》-01/" class="article-date">
  <time datetime="2020-05-22T02:03:00.000Z" itemprop="datePublished">2020-05-22</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/计算机基础/">计算机基础</a> / <a class="article-category-link" href="/categories/计算机基础/计算机组成原理/">计算机组成原理</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/计算机组成原理/">计算机组成原理</a></li></ul>


    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-HashMap解析-02：手写HashMap" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/21/HashMap解析-02：手写HashMap/"
    >HashMap解析-02：手写HashMap（基于JDK1.7，只写数组+链表）</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/21/HashMap解析-02：手写HashMap/" class="article-date">
  <time datetime="2020-05-21T08:55:29.000Z" itemprop="datePublished">2020-05-21</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a> / <a class="article-category-link" href="/categories/Java/源码/">源码</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p><code>HashMap</code>的存储结构为散列表，解决哈希冲突是用过链表法解决的，结构如下：</p>
<img src="/2020/05/21/HashMap解析-02：手写HashMap/微信图片_20200521170634.png">

<p>下面主要实现这个结构。</p>
<h1 id="1、定义接口"><a href="#1、定义接口" class="headerlink" title="1、定义接口"></a>1、定义接口</h1><p><code>HashMap</code>是实现了<code>Map</code>接口的，这里也需要定义个类似的接口，主要包括存取数据，以及存取数据结构的接口（包括取键和取值）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(K k)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">put</span><span class="params">(K k, V v)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 内部接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 取值</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function">V <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 取键</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> 键</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function">K <span class="title">getKey</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2、自定义HashMap实现自定义的Map接口"><a href="#2、自定义HashMap实现自定义的Map接口" class="headerlink" title="2、自定义HashMap实现自定义的Map接口"></a>2、自定义HashMap实现自定义的Map接口</h1><p>实现自定义的接口，并且定义默认的容量，默认加载因子（0.75），以及数组使用长度，存储的数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">MyMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> DEFAULT_LENGTH = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认加载因子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> LOADER = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Map使用数组长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> useSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Entry&lt;K, V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">16</span>, <span class="number">0.75f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHashMap</span><span class="params">(<span class="keyword">int</span> defaultLength, <span class="keyword">float</span> loader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (defaultLength &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"数组异常"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (loader &lt;= <span class="number">0</span> || Float.isNaN(loader)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"加载因子异常"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.DEFAULT_LENGTH = defaultLength;</span><br><span class="line">        <span class="keyword">this</span>.LOADER = loader;</span><br><span class="line">        table = <span class="keyword">new</span> Entry[DEFAULT_LENGTH];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K k, V v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3、HashMap存储结构"><a href="#3、HashMap存储结构" class="headerlink" title="3、HashMap存储结构"></a>3、HashMap存储结构</h1><p>下面实现内部接口，来自定义每个点的存储结构，需要有键，值，及指向下一节点的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存储结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">MyMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> K key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> V value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表指向下一个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Entry&lt;K, V&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Entry</span><span class="params">(K key, V value, Entry&lt;K, V&gt; next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4、实现HashMap的HashCode来计算下标"><a href="#4、实现HashMap的HashCode来计算下标" class="headerlink" title="4、实现HashMap的HashCode来计算下标"></a>4、实现HashMap的HashCode来计算下标</h1><p>实现<code>HashCode</code>来自定义确定key所对应的下标。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用每个object的hashCode计算hashCode</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> hashCode)</span> </span>&#123;</span><br><span class="line">    hashCode = hashCode ^ ((hashCode &gt;&gt;&gt; <span class="number">20</span>) ^ (hashCode &gt;&gt;&gt; <span class="number">12</span>));</span><br><span class="line">    <span class="keyword">return</span> hashCode ^ ((hashCode &gt;&gt;&gt; <span class="number">7</span>) ^ hashCode &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取下标</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k      键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length 数组长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(K k, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index = hash(k.hashCode()) &amp; m;</span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> ? index : -index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5、实现HashMap的put方法"><a href="#5、实现HashMap的put方法" class="headerlink" title="5、实现HashMap的put方法"></a>5、实现HashMap的put方法</h1><p>通过key确定对于数组的下标，再确定有没有哈希冲突，有则往后追加，没有则直接存放。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> v 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K k, V v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 扩容</span></span><br><span class="line">    <span class="keyword">if</span> (useSize &gt;= DEFAULT_LENGTH * LOADER) &#123;</span><br><span class="line">        resize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算下标</span></span><br><span class="line">    <span class="keyword">int</span> index = getIndex(k, table.length);</span><br><span class="line">    Entry&lt;K, V&gt; entry = table[index];</span><br><span class="line">    Entry&lt;K, V&gt; newEntry = <span class="keyword">new</span> Entry&lt;K, V&gt;(k, v, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == entry) &#123;</span><br><span class="line">        <span class="comment">// 直接插入第一个</span></span><br><span class="line">        table[index] = newEntry;</span><br><span class="line">        useSize++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Entry&lt;K, V&gt; t = entry;</span><br><span class="line">        <span class="keyword">if</span> (t.getKey() == k || (t.getKey() != <span class="keyword">null</span> &amp;&amp; t.getKey().equals(k))) &#123;</span><br><span class="line">            <span class="comment">// 已经存在，替换</span></span><br><span class="line">            t.value = v;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (t.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t.getKey() == k || (t.getKey() != <span class="keyword">null</span> &amp;&amp; t.getKey().equals(k))) &#123;</span><br><span class="line">                    <span class="comment">// 已经存在，替换</span></span><br><span class="line">                    t.value = v;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    t = t.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (t.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 不存在，追加在链表后面</span></span><br><span class="line">                t.next = newEntry;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newEntry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6、HashMap的扩容方法resize"><a href="#6、HashMap的扩容方法resize" class="headerlink" title="6、HashMap的扩容方法resize"></a>6、HashMap的扩容方法resize</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry&lt;K, V&gt;[] newTable = <span class="keyword">new</span> Entry[DEFAULT_LENGTH * <span class="number">2</span>];</span><br><span class="line">    List&lt;Entry&lt;K, V&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 循环遍历取出就数组的数据</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K, V&gt; kvEntry : table) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == kvEntry) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Entry&lt;K, V&gt; entry = kvEntry;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != entry) &#123;</span><br><span class="line">            list.add(entry);</span><br><span class="line">            entry = entry.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新放回数组</span></span><br><span class="line">    <span class="keyword">if</span> (list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        useSize = <span class="number">0</span>;</span><br><span class="line">        DEFAULT_LENGTH = DEFAULT_LENGTH * <span class="number">2</span>;</span><br><span class="line">        table = newTable;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K, V&gt; entry : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                entry.next = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            put(entry.getKey(), entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7、实现HashMap的get方法"><a href="#7、实现HashMap的get方法" class="headerlink" title="7、实现HashMap的get方法"></a>7、实现HashMap的get方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = getIndex(k, table.length);</span><br><span class="line">    Entry&lt;K, V&gt; entry = table[index];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != entry) &#123;</span><br><span class="line">        <span class="keyword">while</span> (entry.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.getKey() == k || (entry.getKey() != <span class="keyword">null</span> &amp;&amp; entry.getKey().equals(k))) &#123;</span><br><span class="line">                <span class="keyword">return</span> entry.getValue();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                entry = entry.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (entry.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.getKey() == k || (entry.getKey() != <span class="keyword">null</span> &amp;&amp; entry.getKey().equals(k))) &#123;</span><br><span class="line">                <span class="keyword">return</span> entry.getValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码地址：<a href="https://gitee.com/QingFengBaiYu/HandWriteHashMap" target="_blank" rel="noopener">HandWriteHashMap</a></p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码/">源码</a></li></ul>


    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-HashMap解析-01：HashMap源码解析" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/16/HashMap解析-01：HashMap源码解析/"
    >HashMap解析-01：HashMap源码解析（基于JDK1.8）</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/16/HashMap解析-01：HashMap源码解析/" class="article-date">
  <time datetime="2020-05-16T05:58:48.000Z" itemprop="datePublished">2020-05-16</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a> / <a class="article-category-link" href="/categories/Java/源码/">源码</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p><a href="https://www.cnblogs.com/biehongli/p/11672380.html" target="_blank" rel="noopener">时间复杂度O(1), O(n), O(logn), O(nlogn)</a></p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和元素，时间复杂度为O(n)，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n)。</p>
<h2 id="线性列表"><a href="#线性列表" class="headerlink" title="线性列表"></a>线性列表</h2><p>对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理节点间的引用即可，时间复杂度为O(1)，而查找操作需要遍历链表逐一进行对比，复杂度为O(n)。</p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p><strong>红黑树（Red Black Tree）是一种自平衡二叉查找树</strong>，其典型的用途是实现关联数组。除了二叉树强制的一般要求外，红黑树还需要：</p>
<ul>
<li>1、节点是红色或黑色；</li>
<li>2、根节点是黑色；</li>
<li>3、每个叶节点（NIL节点，空节点）是黑色；</li>
<li>4、每个红色节点的两个子节点都是黑色。（从每个叶子到根的所有路径上不能有两个连续的红色节点）</li>
<li>5、从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</li>
</ul>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p><strong>散列表</strong>（Hash Table，也成哈希表），是根据关键码值（key value）而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中的一个位置来访问记录，以加快查找速度。这个映射函数叫做散列函数，存放记录的数组叫散列表。</p>
<p>给定表M，存在函数f(key)，对任意给定的关键字key，带入函数后如果能包含该关键字的记录在表中的地址，则成表M为哈希（Hash）表，函数f(key)为哈希（Hash）函数。</p>
<h2 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h2><p>如果两个不同的元素，通过哈希函数得出的实际存储地址相同怎么办？也就是说，当对某个元素进行哈希运算，得到一个存储地址，然后要进行插入时，发现已经被其他元素占用了，这就是哈希冲突，也叫哈希碰撞。前面提到，哈希函数的设计至关重要，好的哈希函数会尽可能保证计算简单和散列地址分布均匀，但是，需要清楚的是，数组是一块连续的固定长度的内存空间，再好的哈希函数也不能保证得到的存储地址绝不发生冲突。那么哈希冲突如何解决呢？哈希冲突的解决方案有多种：开放定址法（发生冲突，继续寻找下一块未被占用的存储地址）、再散列函数法、链地址法，HashMap采用的是再散列函数法，即<strong>数组+链表</strong>的方式。</p>
<h1 id="HashMap在JDK1-8中的源码"><a href="#HashMap在JDK1-8中的源码" class="headerlink" title="HashMap在JDK1.8中的源码"></a>HashMap在JDK1.8中的源码</h1><p>源码注释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、哈希表基于map接口的实现，这个实现提供了map所有的操作，并且提供了key和value可以为null，(HashMap和HashTable大致上市一样的除了hashmap是异步的和允许key和value为null)，这个类不确定map中元素的位置，特别要提的是，这个类也不确定元素的位置随着时间会不会保持不变。</span></span><br><span class="line">Hash table based implementation of the Map <span class="class"><span class="keyword">interface</span>. <span class="title">This</span> <span class="title">implementation</span> <span class="title">provides</span> <span class="title">all</span> <span class="title">of</span> <span class="title">the</span> <span class="title">optional</span> <span class="title">map</span> <span class="title">operations</span>, <span class="title">and</span> <span class="title">permits</span> <span class="title">null</span> <span class="title">values</span> <span class="title">and</span> <span class="title">the</span> <span class="title">null</span> <span class="title">key</span>. </span></span><br><span class="line"><span class="class">(<span class="title">The</span> <span class="title">HashMap</span> <span class="title">class</span> <span class="title">is</span> <span class="title">roughly</span> <span class="title">equivalent</span> <span class="title">to</span> <span class="title">Hashtable</span>, <span class="title">except</span> <span class="title">that</span> <span class="title">it</span> <span class="title">is</span> <span class="title">unsynchronized</span> <span class="title">and</span> <span class="title">permits</span> <span class="title">nulls</span>.) <span class="title">This</span> <span class="title">class</span> <span class="title">makes</span> <span class="title">no</span> <span class="title">guarantees</span> <span class="title">as</span> <span class="title">to</span> <span class="title">the</span> <span class="title">order</span> <span class="title">of</span> <span class="title">the</span> <span class="title">map</span></span>;</span><br><span class="line"> in particular, it does not guarantee that the order will remain constant over time. </span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设哈希函数将元素合适的分到了每个桶(其实就是指的数组中位置上的链表)中，则这个实现为基本的操作(get、put)提供了稳定的性能，迭代这个集合视图需要的时间跟hashMap实例(key-value映射的数量)的容量(在桶中)</span></span><br><span class="line">成正比，因此，如果迭代的性能很重要的话，就不要将初始容量设置的太高或者loadfactor设置的太低，【这里的桶，相当于在数组中每个位置上放一个桶装元素】</span><br><span class="line">This implementation provides constant-<span class="function">time performance <span class="keyword">for</span> the basic <span class="title">operations</span> <span class="params">(get and put)</span>, assuming the hash function disperses the elements properly among the buckets.</span></span><br><span class="line"><span class="function"> Iteration over collection views <span class="keyword">requires</span> time proportional to the "capacity" of the HashMap <span class="title">instance</span> <span class="params">(the number of buckets)</span> plus its <span class="title">size</span> <span class="params">(the number of key-value mappings</span></span></span><br><span class="line"><span class="function"><span class="params">)</span>. Thus, it's very important not to set the initial capacity too <span class="title">high</span> <span class="params">(or the load factor too low)</span> <span class="keyword">if</span> iteration performance is important.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// HashMap的实例有两个参数影响性能，初始化容量(initialCapacity)和loadFactor加载因子，在哈希表中这个容量是桶的数量【也就是数组的长度】，一个初始化容量仅仅是在哈希表被创建时容量，在</span></span></span><br><span class="line"><span class="function">容量自动增长之前加载因子是衡量哈希表被允许达到的多少的。当entry的数量在哈希表中超过了加载因子乘以当前的容量，那么哈希表被修改<span class="params">(内部的数据结构会被重新建立)</span>所以哈希表有大约两倍的桶的数量</span></span><br><span class="line"><span class="function">An instance of HashMap has two parameters that affect its performance: initial capacity and load factor. The capacity is the number of buckets in the hash table, </span></span><br><span class="line"><span class="function">and the initial capacity is simply the capacity at the time the hash table is created. The load factor is a measure of how full the hash table is allowed to get before</span></span><br><span class="line"><span class="function"> its capacity is automatically increased. When the number of entries in the hash table exceeds the product of the load factor and the current capacity, the hash table </span></span><br><span class="line"><span class="function">is <span class="title">rehashed</span> <span class="params">(that is, internal data structures are rebuilt)</span> so that the hash table has approximately twice the number of buckets.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 通常来讲，默认的加载因子(0.75)能够在时间和空间上提供一个好的平衡，更高的值会减少空间上的开支但是会增加查询花费的时间（体现在HashMap类中get、put方法上），当设置初始化容量时，应该考虑到map中会存放</span></span></span><br><span class="line"><span class="function">entry的数量和加载因子，以便最少次数的进行rehash操作，如果初始容量大于最大条目数除以加载因子，则不会发生 rehash 操作。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">As a general rule, the <span class="keyword">default</span> load <span class="title">factor</span> <span class="params">(<span class="number">.75</span>)</span> offers a good tradeoff between time and space costs. Higher values decrease the space overhead but increase the lookup</span></span><br><span class="line"><span class="function"> <span class="title">cost</span> <span class="params">(reflected in most of the operations of the HashMap class, including get and put)</span>. The expected number of entries in the map and its load factor should be taken </span></span><br><span class="line"><span class="function">into account when setting its initial capacity, so as to minimize the number of rehash operations. If the initial capacity is greater than the maximum number of</span></span><br><span class="line"><span class="function"> entries divided by the load factor, no rehash operations will ever occur.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 如果很多映射关系要存储在 HashMap 实例中，则相对于按需执行自动的 rehash 操作以增大表的容量来说，使用足够大的初始容量创建它将使得映射关系能更有效地存储。</span></span></span><br><span class="line"><span class="function">If many mappings are to be stored in a HashMap instance, creating it with a sufficiently large capacity will allow the mappings to be stored more efficiently than letting </span></span><br><span class="line"><span class="function">it perform automatic rehashing as needed to grow the table</span></span><br></pre></td></tr></table></figure>

<h1 id="HashMap的继承关系"><a href="#HashMap的继承关系" class="headerlink" title="HashMap的继承关系"></a>HashMap的继承关系</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"> <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/****省略代码****/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HashMap继承了<code>AbstractMap</code>实现了<code>Map</code>、<code>Cloneable</code>、<code>Serializable</code>接口。</p>
<h1 id="HashMap的属性"><a href="#HashMap的属性" class="headerlink" title="HashMap的属性"></a>HashMap的属性</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"> <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 序列号，序列化的时候使用。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;</span><br><span class="line">    <span class="comment">/**默认容量，1向左移位4个，00000001变成00010000，也就是2的4次方为16，使用移位是因为移位是计算机基础运算，效率比加减乘除快。**/</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 最大容量，2的30次方。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// 加载因子，用于扩容使用。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line">    <span class="comment">// 当某个桶节点数量大于8时，会转换为红黑树。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 当某个桶节点数量小于6时，会转换为链表，前提是它当前是红黑树结构。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 当整个hashMap中元素数量大于64时，也会进行转为红黑树结构。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line">    <span class="comment">// 存储元素的数组，transient关键字表示该属性不能被序列化</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line">    <span class="comment">// 将数据转换成set的另一种存储形式，这个变量主要用于迭代功能。</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line">    <span class="comment">// 元素数量</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">// 统计该map修改的次数</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line">    <span class="comment">// 临界值，也就是元素数量达到临界值时，会进行扩容。</span></span><br><span class="line">    <span class="keyword">int</span> threshold;</span><br><span class="line">    <span class="comment">// 也是加载因子，只不过这个是变量。</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/****省略代码****/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认容量16，默认加载因子0.75。</p>
<h1 id="HashMap构造方法"><a href="#HashMap构造方法" class="headerlink" title="HashMap构造方法"></a>HashMap构造方法</h1><img src="/2020/05/16/HashMap解析-01：HashMap源码解析/微信图片_20200516163444.png">

<p>HashMap有四个构造方法：</p>
<ul>
<li>1、空参构造方法，使用默认的负载因子0.75；</li>
<li>2、设置初始容量并使用默认加载因子；</li>
<li>3、设置容量和加载因子，第二个构造方法最终还是调用了第三个构造方法；</li>
<li>4、将一个Map转换为HashMap。</li>
</ul>
<p>第四个构造方法源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取该map的实际长度</span></span><br><span class="line">    <span class="keyword">int</span> s = m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断table是否初始化，如果没有初始化</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="comment">/**求出需要的容量，因为实际使用的长度=容量*0.75得来的，+1是因为小数相除，基本都不会是整数，容量大小不能为小数的，后面转换为int，多余的小数就要被丢掉，所以+1，例如，map实际长度22，22/0.75=29.3,所需要的容量肯定为30，有人会问如果刚刚好除得整数呢，除得整数的话，容量大小多1也没什么影响**/</span></span><br><span class="line">            <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="comment">//判断该容量大小是否超出上限。</span></span><br><span class="line">            <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="comment">/**对临界值进行初始化，tableSizeFor(t)这个方法会返回大于t值的，且离其最近的2次幂，例如t为29，则返回的值是32**/</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果table已经初始化，则进行扩容操作，resize()就是扩容。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">// 遍历，把map中的数据转到hashMap中。</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造函数中传入了一个Map，然后把这个Map转换为HashMap，这里还调用了<code>resize()</code>进行扩容。</p>
<p>在上面的<code>entrySet()</code>中返回一个<code>Set&lt;Map.Entry&lt;K, V&gt;&gt;</code>，泛型为<code>Map</code>的内部类<code>Entry</code>，它是一个存放key-value的实例，因为hash表的遍历，插入效率高。</p>
<p>构造函数就到这里，下面重点看看<code>HashMap</code>是如何将key和value存储的。下面看看<code>HashMap</code>的<code>put(K key,V value)</code>方法。</p>
<h1 id="HashMap的put方法"><a href="#HashMap的put方法" class="headerlink" title="HashMap的put方法"></a>HashMap的put方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**四个参数，第一个hash值，第四个参数表示如果该key存在值，如果为null的话，则插入新的value，最后一个参数，在hashMap中没有用，可以不用管，使用默认的即可**/</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里调用了<code>putVal</code>之前调用了hash方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里将键值的<code>hashCode</code>做异或运算，目的是为了减少哈希冲突。</p>
<p>下面看看<code>putVal</code>的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// tab:哈希数组，p:该哈希桶的首节点，n:hashMap的长度，i:计算出的数组下标</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 获取长度并进行扩容，使用的是懒加载，table一开始是没有加载的，等put后才开始加载</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">/**如果计算出的该哈希桶的位置没有值，则把新插入的key-value放到此处，此处就算没有插入成功，也就是发生哈希冲突时也会把哈希桶的首节点赋予p**/</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 发生哈希冲突的几种情况</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// e:临时节点的作用，k:存放该当前节点的key </span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 第一种，插入的key-value的hash值，key都与当前节点的相等，e = p，则表示为首节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 第二种，hash值不等于首节点，判断该p是否属于红黑树的节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">/**为红黑树的节点，则在红黑树中进行添加，如果该节点已经存在，则返回该节点（不为null），该值很重要，用来判断put操作是否成功，如果添加成功返回null**/</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 第三种，hash值不等于首节点，不为红黑树的节点，则为链表的节点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 遍历该链表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 如果找到尾部，则表明添加的key-value没有重复，在尾部进行添加</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 判断是否要转换为红黑树结构</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果链表中有重复的key，e则为当前重复的节点，结束循环</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有重复的key，则用待插入值进行覆盖，返回旧值。</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; </span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 到了此步骤，则表明待插入的key-value是没有key的重复，因为插入成功e节点的值为null</span></span><br><span class="line">    <span class="comment">// 修改次数+1</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 实际长度+1，判断是否大于临界值，大于则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="comment">// 添加成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要有以下几个步骤：</p>
<ul>
<li>1、根据key计算处在数组中存储的下标；</li>
<li>2、根据使用的大小，判断是否需要扩容；</li>
<li>3、根据数组下标判断是否当前下标已存储数据，如果没有，则直接插入；</li>
<li>4、如果存储了，则存在哈希冲突，判断当前entry的key是否相等，如果相等则替换，否则判断下一个节点是否为空，为空则直接插入，否则取下一节点重复上述步骤；</li>
<li>5、判断链表长度是否大于8，当达到8时，转换为红黑树。</li>
</ul>
<h1 id="HashMap的扩容函数resize"><a href="#HashMap的扩容函数resize" class="headerlink" title="HashMap的扩容函数resize()"></a>HashMap的扩容函数resize()</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">// 把没插入之前的哈希数组作为oldTal</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">// old的长度</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">// old的临界值</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="comment">// 初始化new的长度和临界值</span></span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// oldCap &gt; 0也就是说不是首次初始化，因为hashMap用的是懒加载</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 大于最大值</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">// 临界值为整数的最大值</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 标记##，其它情况，扩容两倍，并且扩容后的长度要小于最大值，old长度也要大于16</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">// 临界值也扩容为old的临界值2倍</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**如果oldCap&lt;0，但是已经初始化了，像把元素删除完之后的情况，那么它的临界值肯定还存在，        </span></span><br><span class="line"><span class="comment">       如果是首次初始化，它的临界值则为0</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) </span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">// 首次初始化，给与默认的值</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               </span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        <span class="comment">// 临界值等于容量*加载因子</span></span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此处的if为上面标记##的补充，也就是初始化时容量小于默认值16的，此时newThr没有赋值</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// new的临界值</span></span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        <span class="comment">// 判断是否new容量是否大于最大值，临界值是否大于最大值</span></span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把上面各种情况分析出的临界值，在此处真正进行改变，也就是容量和临界值都改变了。</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="comment">// 表示忽略该警告</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    <span class="comment">// 赋予当前的table</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">// 此处自然是把old中的元素，遍历到new中</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            <span class="comment">// 临时变量</span></span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="comment">// 当前哈希桶的位置值不为null，也就是数组下标处有值，因为有值表示可能会发生冲突</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 把已经赋值之后的变量置位null，当然是为了好回收，释放内存</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 如果下标处的节点没有下一个元素</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// 把该变量的值存入newCap中，e.hash &amp; (newCap - 1)并不等于j</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 该节点为红黑树结构，也就是存在哈希冲突，该哈希桶中有多个元素</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// ✨✨✨把此树进行转移到newCap中✨✨✨</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">/**此处表示为链表结构，同样把链表转移到newCap中，就是把链表遍历后，把值转过去，在置位null**/</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回扩容后的hashMap</span></span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>HashMap</code>的结构为数组+链表（红黑树）。</p>
<p>逻辑：</p>
<ul>
<li>1、对数组进行扩容；</li>
<li>2、扩容后重新计算<code>hashCode</code>，即key的下标，将原始数据放入扩容后的数据结构中；</li>
<li>3、当存在哈希冲突时，在数组后面以链表的形式追加到后面，当链表长度达到8时，就会将链表转换为红黑树。</li>
</ul>
<p>对于红黑树新增节点，需要考虑前面所说的红黑树性质。就需要对红黑树做调整，使红黑树达到平衡。这种平衡就是红黑树的旋转。</p>
<h1 id="红黑树的旋转"><a href="#红黑树的旋转" class="headerlink" title="红黑树的旋转"></a>红黑树的旋转</h1><p>分为左旋和右旋，以某个节点为圆心向左或向右旋转。<a href="https://www.cnblogs.com/CarpenterLee/p/5503882.html" target="_blank" rel="noopener">史上最清晰的红黑树讲解</a></p>
<h2 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h2><img src="/2020/05/16/HashMap解析-01：HashMap源码解析/微信图片_20200521094557.png">

<p>上图中各子树可以是多个节点构成的子树，也可以是一个具体的节点，也可以是null。</p>
<img src="/2020/05/16/HashMap解析-01：HashMap源码解析/微信图片_20200521093955.png">

<h2 id="HashMap中红黑树的左旋"><a href="#HashMap中红黑树的左旋" class="headerlink" title="HashMap中红黑树的左旋"></a>HashMap中红黑树的左旋</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateLeft</span><span class="params">(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; r, pp, rl;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (r = p.right) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((rl = p.right = r.left) != <span class="keyword">null</span>)</span><br><span class="line">            rl.parent = p;</span><br><span class="line">        <span class="keyword">if</span> ((pp = r.parent = p.parent) == <span class="keyword">null</span>)</span><br><span class="line">            (root = r).red = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p)</span><br><span class="line">            pp.left = r;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = r;</span><br><span class="line">        r.left = p;</span><br><span class="line">        p.parent = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/05/16/HashMap解析-01：HashMap源码解析/微信图片_20200521101422.png">

<p>上图中各子树可以是多个节点构成的子树，也可以是一个具体的节点，也可以是null。</p>
<h2 id="HashMap中红黑树的右旋"><a href="#HashMap中红黑树的右旋" class="headerlink" title="HashMap中红黑树的右旋"></a>HashMap中红黑树的右旋</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateRight</span><span class="params">(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; l, pp, lr;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (l = p.left) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((lr = p.left = l.right) != <span class="keyword">null</span>)</span><br><span class="line">            lr.parent = p;</span><br><span class="line">        <span class="keyword">if</span> ((pp = l.parent = p.parent) == <span class="keyword">null</span>)</span><br><span class="line">            (root = l).red = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pp.right == p)</span><br><span class="line">            pp.right = l;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.left = l;</span><br><span class="line">        l.right = p;</span><br><span class="line">        p.parent = l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="红黑树新增节点的例子"><a href="#红黑树新增节点的例子" class="headerlink" title="红黑树新增节点的例子"></a>红黑树新增节点的例子</h2><p><code>TreeMap</code>的结构也是红黑树，它新增节点的过程如下：这里跟<code>HashMap</code>的红黑树的新增原理一样:</p>
<img src="/2020/05/16/HashMap解析-01：HashMap源码解析/微信图片_20200521155212.png">

<p>现在回到<code>resize()</code>，里面有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ✨✨✨把此树进行转移到newCap中✨✨✨</span></span><br><span class="line">((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br></pre></td></tr></table></figure>

<h2 id="HashMap中TreeNode-split"><a href="#HashMap中TreeNode-split" class="headerlink" title="HashMap中TreeNode.split"></a>HashMap中TreeNode.split</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; b = <span class="keyword">this</span>;	<span class="comment">// 拿到调用此方法的节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>; <span class="comment">// 存储跟原索引位置相同的节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>; <span class="comment">// 存储索引位置为:原索引+oldCap的节点</span></span><br><span class="line">    <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123;	<span class="comment">// 从b节点开始遍历</span></span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)e.next;   <span class="comment">// next赋值为e的下个节点</span></span><br><span class="line">        e.next = <span class="keyword">null</span>;  <span class="comment">// 同时将老表的节点设置为空，以便垃圾收集器回收</span></span><br><span class="line">        <span class="comment">//如果e的hash值与老表的容量进行与运算为0,则扩容后的索引位置跟老表的索引位置一样</span></span><br><span class="line">        <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)  <span class="comment">// 如果loTail为空, 代表该节点为第一个节点</span></span><br><span class="line">                loHead = e; <span class="comment">// 则将loHead赋值为第一个节点</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;    <span class="comment">// 否则将节点添加在loTail后面</span></span><br><span class="line">            loTail = e; <span class="comment">// 并将loTail赋值为新增的节点</span></span><br><span class="line">            ++lc;   <span class="comment">// 统计原索引位置的节点个数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果e的hash值与老表的容量进行与运算为1,则扩容后的索引位置为:老表的索引位置＋oldCap</span></span><br><span class="line">        <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)  <span class="comment">// 如果hiHead为空, 代表该节点为第一个节点</span></span><br><span class="line">                hiHead = e; <span class="comment">// 则将hiHead赋值为第一个节点</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;    <span class="comment">// 否则将节点添加在hiTail后面</span></span><br><span class="line">            hiTail = e; <span class="comment">// 并将hiTail赋值为新增的节点</span></span><br><span class="line">            ++hc;   <span class="comment">// 统计索引位置为原索引+oldCap的节点个数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;   <span class="comment">// 原索引位置的节点不为空</span></span><br><span class="line">        <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)  <span class="comment">// 节点个数少于6个则将红黑树转为链表结构</span></span><br><span class="line">            tab[index] = loHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index] = loHead;    <span class="comment">// 将原索引位置的节点设置为对应的头结点</span></span><br><span class="line">            <span class="comment">// hiHead不为空则代表原来的红黑树(老表的红黑树由于节点被分到两个位置)</span></span><br><span class="line">            <span class="comment">// 已经被改变, 需要重新构建新的红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) </span><br><span class="line">                loHead.treeify(tab);    <span class="comment">// 以loHead为根结点, 构建新的红黑树</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;   <span class="comment">// 索引位置为原索引+oldCap的节点不为空</span></span><br><span class="line">        <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)  <span class="comment">// 节点个数少于6个则将红黑树转为链表结构</span></span><br><span class="line">            tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index + bit] = hiHead;  <span class="comment">// 将索引位置为原索引+oldCap的节点设置为对应的头结点</span></span><br><span class="line">            <span class="comment">// loHead不为空则代表原来的红黑树(老表的红黑树由于节点被分到两个位置)</span></span><br><span class="line">            <span class="comment">// 已经被改变, 需要重新构建新的红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) </span><br><span class="line">                hiHead.treeify(tab);    <span class="comment">// 以hiHead为根结点, 构建新的红黑树</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面看看<code>treeify()</code></p>
<h2 id="HashMap中的treeify"><a href="#HashMap中的treeify" class="headerlink" title="HashMap中的treeify()"></a>HashMap中的treeify()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;   <span class="comment">// 构建红黑树</span></span><br><span class="line">    TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;<span class="comment">// this即为调用此方法的TreeNode</span></span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)x.next;   <span class="comment">// next赋值为x的下个节点</span></span><br><span class="line">        x.left = x.right = <span class="keyword">null</span>;    <span class="comment">// 将x的左右节点设置为空</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="comment">// 如果还没有根结点, 则将x设置为根结点</span></span><br><span class="line">            x.parent = <span class="keyword">null</span>;    <span class="comment">// 根结点没有父节点</span></span><br><span class="line">            x.red = <span class="keyword">false</span>;  <span class="comment">// 根结点必须为黑色</span></span><br><span class="line">            root = x;   <span class="comment">// 将x设置为根结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            K k = x.key;	<span class="comment">// k赋值为x的key</span></span><br><span class="line">            <span class="keyword">int</span> h = x.hash;	<span class="comment">// h赋值为x的hash值</span></span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 如果当前节点x不是根结点, 则从根节点开始查找属于该节点的位置</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;	</span><br><span class="line">                <span class="keyword">int</span> dir, ph;</span><br><span class="line">                K pk = p.key;   </span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)  <span class="comment">// 如果x节点的hash值小于p节点的hash值</span></span><br><span class="line">                    dir = -<span class="number">1</span>;   <span class="comment">// 则将dir赋值为-1, 代表向p的左边查找</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)    <span class="comment">// 与上面相反, 如果x节点的hash值大于p节点的hash值</span></span><br><span class="line">                    dir = <span class="number">1</span>;    <span class="comment">// 则将dir赋值为1, 代表向p的右边查找</span></span><br><span class="line">                <span class="comment">// 走到这代表x的hash值和p的hash值相等，则比较key值</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp; <span class="comment">// 如果k没有实现Comparable接口 或者 x节点的key和p节点的key相等</span></span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                	<span class="comment">// 使用定义的一套规则来比较x节点和p节点的大小，用来决定向左还是向右查找</span></span><br><span class="line">                    dir = tieBreakOrder(k, pk); </span><br><span class="line"> </span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;   <span class="comment">// xp赋值为x的父节点,中间变量用于下面给x的父节点赋值</span></span><br><span class="line">                <span class="comment">// dir&lt;=0则向p左边查找,否则向p右边查找,如果为null,则代表该位置即为x的目标位置</span></span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123; </span><br><span class="line">                    x.parent = xp;  <span class="comment">// x的父节点即为最后一次遍历的p节点</span></span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)   <span class="comment">// 如果时dir &lt;= 0, 则代表x节点为父节点的左节点</span></span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span>    <span class="comment">// 如果时dir &gt; 0, 则代表x节点为父节点的右节点</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    <span class="comment">// 进行红黑树的插入平衡(通过左旋、右旋和改变节点颜色来保证当前树符合红黑树的要求)</span></span><br><span class="line">                    root = balanceInsertion(root, x);   </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    moveRootToFront(tab, root); <span class="comment">// 如果root节点不在table索引位置的头结点, 则将其调整为头结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>balanceInsertion()</code>使红黑树达到平衡。要平衡红黑树，就要进行左旋或右旋。</p>
<h2 id="HashMap中的balanceInsertion"><a href="#HashMap中的balanceInsertion" class="headerlink" title="HashMap中的balanceInsertion()"></a>HashMap中的balanceInsertion()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">     x.red = <span class="keyword">true</span>;</span><br><span class="line">     <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">         <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">             x.red = <span class="keyword">false</span>;</span><br><span class="line">             <span class="keyword">return</span> x;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="keyword">null</span>)</span><br><span class="line">             <span class="keyword">return</span> root;</span><br><span class="line">         <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class="line">             <span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123;</span><br><span class="line">                 xppr.red = <span class="keyword">false</span>;</span><br><span class="line">                 xp.red = <span class="keyword">false</span>;</span><br><span class="line">                 xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                 x = xpp;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="keyword">if</span> (x == xp.right) &#123;</span><br><span class="line">                     root = rotateLeft(root, x = xp);<span class="comment">//对红黑树进行左旋</span></span><br><span class="line">                     xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                     xp.red = <span class="keyword">false</span>;</span><br><span class="line">                     <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                         xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                         root = rotateRight(root, xpp);<span class="comment">//对红黑树进行右旋</span></span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">if</span> (xppl != <span class="keyword">null</span> &amp;&amp; xppl.red) &#123;</span><br><span class="line">                 xppl.red = <span class="keyword">false</span>;</span><br><span class="line">                 xp.red = <span class="keyword">false</span>;</span><br><span class="line">                 xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                 x = xpp;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="keyword">if</span> (x == xp.left) &#123;</span><br><span class="line">                     root = rotateRight(root, x = xp);<span class="comment">//对红黑树进行右旋</span></span><br><span class="line">                     xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                     xp.red = <span class="keyword">false</span>;</span><br><span class="line">                     <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                         xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                         root = rotateLeft(root, xpp);<span class="comment">//对红黑树进行左旋</span></span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="HashMap的存储结构"><a href="#HashMap的存储结构" class="headerlink" title="HashMap的存储结构"></a>HashMap的存储结构</h2><p>数组+链表+红黑树</p>
<img src="/2020/05/16/HashMap解析-01：HashMap源码解析/微信图片_20200521162526.png">

<h2 id="HashMap扩容"><a href="#HashMap扩容" class="headerlink" title="HashMap扩容"></a>HashMap扩容</h2><p>扩容过程:</p>
<img src="/2020/05/16/HashMap解析-01：HashMap源码解析/微信图片_20200521165320.png">
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码/">源码</a></li></ul>


    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-Android-RecyclerView的缓存机制" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/15/Android-RecyclerView的缓存机制/"
    >Android-RecyclerView的缓存机制</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/15/Android-RecyclerView的缓存机制/" class="article-date">
  <time datetime="2020-05-15T01:43:45.000Z" itemprop="datePublished">2020-05-15</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a> / <a class="article-category-link" href="/categories/Android/View/">View</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p>使用<code>ScrollView</code>时，它的所有子<code>View</code>会一次性加载出来。<code>RecyclerView</code>可以做到按需加载、按需绑定，并实现复用。这里主要分析<code>RecyclerView</code>缓存复用的原理。</p>
<h1 id="从缓存获取ViewHolder流程概览"><a href="#从缓存获取ViewHolder流程概览" class="headerlink" title="从缓存获取ViewHolder流程概览"></a>从缓存获取ViewHolder流程概览</h1><img src="/2020/05/15/Android-RecyclerView的缓存机制/微信图片_20200515155023.png">

<p>说明：</p>
<p>在创建<code>ViewHolder</code>之前，<code>RecyclerView</code>会先从缓存中尝试获取是否有符合要求的<code>ViewHolder</code>，详见<code>RecyclerView#tryGetViewHolderForPositionByDeadline</code>方法。</p>
<ul>
<li>第一次，尝试从<code>mChangedScrap</code>中获取。<ul>
<li>只有在<code>mState.isPreLayout()</code>为<code>true</code>时，也就是预布局阶段，才做这次尝试。</li>
</ul>
</li>
<li>第二次，<code>getScrapOrHiddenOrCachedHolderForPosition()</code>获得<code>ViewHolder</code>。<ul>
<li>尝试从<code>mAttachedScrap</code>、<code>mHiddenViews</code>或<code>mCachedViews</code>中查找<code>ViewHolder</code>。<ul>
<li>其中<code>mAttachedScrap</code>和<code>mCachedViews</code>都是<code>Recycler</code>的成员变量。</li>
<li>如果成功获得<code>ViewHolder</code>则检验其有效性，<ul>
<li>若<strong>检验失败则将其收回</strong>到<code>RecyclerViewPool</code>中</li>
<li>检验成功，则可以正常使用</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>第三次，如果给<code>Adapter</code>设置了<code>stableld</code>，调用<code>getScrappOrCachedViewForld</code>尝试获取<code>ViewHolder</code>。<ul>
<li>和第二次的区别在于，之前是根据<code>position</code>查找，现在是根据<code>id</code>查找</li>
</ul>
</li>
<li>第四次，<code>mViewCahceExtension</code>不为空的话，则调用<code>ViewCacheExtension#getViewForPositionAndType</code>方法尝试获取<code>View</code>。<ul>
<li>注，<code>ViewCacheExtension</code>是由开发者设置的，默认情况下为空，一般不会设置。这层缓存大部分情况下可以忽略。</li>
</ul>
</li>
<li>第五次，尝试从<code>RecyclerViewPool</code>中获取，相较于<code>mCacheViews</code>，从<code>RecyclerViewPool</code>中成功获取<code>ViewHolder</code>对象后并没有做合法性和<code>item</code>的位置校验，只检验<code>viewtype</code>是否一致。<ul>
<li>从<code>RecyclerViewPool</code>中取出来的<code>ViewHodler</code>需要重新执行<code>bind</code>才能使用。</li>
</ul>
</li>
<li>如果上面的五次尝试都失败了，就调用<code>RecyclerView.Adapter#createViewHolder</code>新建一个<code>ViewHolder</code>。</li>
<li>最后根据<code>ViewHodler</code>的状态，确定是否需要调用<code>bindViewHolder</code>进行数据绑定。</li>
</ul>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="预布局、预测动画是什么？"><a href="#预布局、预测动画是什么？" class="headerlink" title="预布局、预测动画是什么？"></a>预布局、预测动画是什么？</h2><p>理解“预布局”就需要理解“预测动画”。例如：</p>
<p>用户有A、B、C三个item，A、B正好显示在屏幕中，这时，用户把B删除了，最终C会显示在原先B的位置。</p>
<img src="/2020/05/15/Android-RecyclerView的缓存机制/微信图片_20200515132105.png">

<p>如果C从底部平滑地滑动到B的位置会更加合适，但是要想实现，并不简单。因为知道C的最终位置，但是不知道C的起始位置，就无法确定C应该从哪里滑动过来。有可能是底部，也可能是侧边。</p>
<p>根据原状态和最终状态之间的差异，是无法得出应该执行怎样的动画的。</p>
<p>设计<code>RecyclerView</code>的工程师是这样解决的。当<code>Adapter</code>发生变化时，<code>RecyclerView</code>会让<code>LayoutManager</code>进行两次布局。</p>
<ul>
<li>第一次是<strong>预布局</strong>，将之前原状态下的item都布局出来。并且根据<code>Adapter</code>的<code>notify</code>信息，知道哪些item即将变化，所以可以<strong>加载出另外的View</strong>。上述例子中，因为知道B已经被删除，所以可以<strong>把屏幕之外的C也加载进来</strong>。</li>
<li>第二，最终的布局。</li>
</ul>
<img src="/2020/05/15/Android-RecyclerView的缓存机制/微信图片_20200515143312.png">

<p>这样只要比较前后布局的变化，就能得出应该执行什么动画了。</p>
<p>这种负责执行动画的View在原布局或新布局中不存在的动画，就是<strong>预测动画</strong>。</p>
<p><strong>预布局</strong>是实现预测动画的一个步骤。</p>
<p>下面两个动图展示了普通动画和预测动画的区别。</p>
<p>普通动画：</p>
<img src="/2020/05/15/Android-RecyclerView的缓存机制/171d8db8bf70b9ce">

<p>预测动画：</p>
<img src="/2020/05/15/Android-RecyclerView的缓存机制/171d8e01b6b0ba6c">

<p>关于预测动画，可以阅读<a href="http://frogermcs.github.io/recyclerview-animations-androiddevsummit-write-up/" target="_blank" rel="noopener">文章</a>。</p>
<h1 id="关于Scrap"><a href="#关于Scrap" class="headerlink" title="关于Scrap"></a>关于Scrap</h1><p><code>Scrap</code>，缓存列表（<code>mChangedScrap</code>、<code>mAttachedScrap</code>）是<code>RecyclerView</code>最先查找<code>ViewHolder</code>的地方，它跟<code>RecyclerViewPool</code>或者<code>ViewCache</code>有很大的区别。</p>
<p><code>mChangedScrap</code>和<code>mAttchedScrap</code>只在布局阶段使用。其他时候它们为空。布局完成之后，这两个缓存中的<code>ViewHolder</code>，会移到<code>mCacheView</code>和<code>RecyclerViewPool</code>中。</p>
<p>当<code>LayoutManage</code>开始布局的时候（预布局或者是最终布局），当前布局中的所有view，都会被dump到scrap中（具体可见<code>LinearLayoutManage#onLayoutChildren</code>中调用的了<code>detachAndScrap</code>），然后<code>LayoutManager</code>挨个取回view，除非view发生了什么变化，否则它会马上从scrap中回到原来的位置。</p>
<img src="/2020/05/15/Android-RecyclerView的缓存机制/微信图片_20200515155901.png">

<p>以上图为例，删除B，调用<code>notifyItemRemove()</code>方法，触发重新布局，这时，A、B、C都会被dump到scrap中，然后<code>LayoutManager</code>会从scrap中取回A和C。</p>
<p>此时，B去哪里了？<code>RecyclerView</code>看到B没有出现在最终布局中，会unscrap它，让他它执行一个消失的动画，然后隐藏。动画执行结束后，B会放到<code>RecyclerViewPool</code>中。</p>
<p>为什么<code>LayoutManager</code>需要先执行<code>detach</code>，然后再重新<code>attach</code>这些view，而不是只移除那些变化的子view呢？Scrap缓存列表的存在，是为了隔离<code>LayoutManager</code>和<code>RecyclerView.Recycler</code>之间的关注点/职责。<code>LayoutManager</code>不需要知道哪些子view需要保留或者被回收到<code>RecyclerViewPool</code>或者其他地方。这是<code>Recycler</code>的职责。</p>
<p>除了在布局时不为空之外，还有另外一个与scrap有关的规律：所有scrap的view都会跟<code>RecyclerView</code>分离。<code>ViewGroup</code>中的<code>attachView</code>和<code>detachView</code>方法跟<code>addView</code>和<code>removeView</code>很像，但是不会触发请求布局重绘的事件。它们只是从<code>ViewGroup</code>的子view列表中删除对应的子view。，并将该子view的parent设置为null。<code>detached</code>状态必须是临时的，后面紧随着<code>attach</code>或<code>remove</code>事件。</p>
<p>如果在计算一个新布局的时候，已经添加了一堆子view，可以放心的将它们<code>detach</code>，<code>RecyclerView</code>也是这么做的。</p>
<h1 id="Attached-VS-Changed-scrap"><a href="#Attached-VS-Changed-scrap" class="headerlink" title="Attached VS Changed scrap"></a>Attached VS Changed scrap</h1><p><code>Recycler</code>中，可以看到两个单独的scrap容器：<code>mAttachedScrap</code>和<code>mChangedScrap</code>。为什么需要两个呢？</p>
<p><code>ViewHolder</code>只有在满足下面情况才会被添加到<code>mChangedScrap</code>：当它关联的item发生变化（<code>notifyItemChanged</code>或<code>notifyItemRangeChanged</code>被调用），并且<code>ItemAnimator</code>调用<code>ViewHolder#canReuseUpdatedViewHolder</code>方法时，返回<code>false</code>。否则，<code>ViewHolder</code>会被添加到<code>AttachScrap</code>中。</p>
<p><code>canReuseUpdatedViewHolder</code>返回<code>false</code>表示要执行用一个view替换另一个view的动画，<code>true</code>表示动画在内部发生。</p>
<p><code>mAttachedScrap</code>在整个布局过程中都能使用，但是changed scrap只能在预布局阶段使用。</p>
<p>原因：在布局后，新的<code>ViewHolder</code>应该替换调“改变了的”视图，因此<code>AttachedScrap</code>在布局后是没有用的。更改动画执行完成后，changed scrop将按照预期方式转存到pool中。</p>
<p>默认的<code>ItemAnimator</code>可以在3种情况下重用更新的<code>ViewHolder</code>：</p>
<ul>
<li>调用<code>setSupportsChangeAnimation(false)</code></li>
<li>调用<code>notifyDataSetChanged()</code>而不是<code>notifyItemChanged()</code>或<code>notifyItemRangeChanged()</code></li>
<li>提供这样的更改playload: <code>adapter.notifyItemChanged(index, anyObject)</code></li>
</ul>
<p>最后一种显示了一种很好的方法，当只想更改一些内部元素时，可以避免创建/绑定新的<code>ViewHolder</code>。</p>
<h1 id="Hidden-View-是什么？"><a href="#Hidden-View-是什么？" class="headerlink" title="Hidden View 是什么？"></a>Hidden View 是什么？</h1><p>前面说的第二次尝试获取<code>ViewHodler</code>时，有一个子步骤会从hidden view中搜索。hidden view指的是那些正在从<code>RecyclerView</code>边界中脱离的view。为了让这些view正确的执行对应的分离动画，它们仍然作为<code>RecyclerView</code>的子view被保留下来。</p>
<p>站在<code>LayoutManager</code>的角度，这些view已经不存在了，因此不应该被包含在计算里面。比如在部分view正在执行消失动画过程中，调用<code>LayoutManager#getChildAt</code>方法，这些view不算在下标里面。来自<code>LayoutManager</code>的所有对<code>getChild()</code>、<code>getChildCount()</code>、<code>addView()</code>等的方法调用在应用到实际的可回收view之前，都要通过<code>ChildHelper</code>处理，<code>ChildHelper</code>的职责是重新计算非隐藏的子view列表和完整的子view列表之间的索引。</p>
<p>注意，正在搜索要提供给<code>LayoutManager</code>的视图，<strong>但是<code>LayoutManager</code>不应了解隐藏View</strong>。</p>
<p>举一个实际的例子：这种“从隐藏的view弹跳”（bounching from hidden views）机制对于处理下面这种情况很有必要。现在要插入一个item，然后在插入动画完成之前，马上删除该item：</p>
<img src="/2020/05/15/Android-RecyclerView的缓存机制/微信图片_20200515174940.png">

<p>想要看到B从C移除的位置开始向上平移。但是在那个时候，B是一个隐藏的view。如果忽略它（”隐藏“的B），那么会导致在现有B下面创建一个新的B。更糟糕的是，这两个view会重叠，因为新的B会往上，旧的B会往下。为了避免这种错误，在搜索<code>ViewHolder</code>的较早步骤中，<code>RecyclerView</code>会询问<code>ChildHelper</code>是否具有合适的hidden view。所谓”合适“，表示这个view和需要的位置相关联，并具有正确的view type，并且这个view的被隐藏的原因不是为了移除它。</p>
<p>如果有这样的view，<code>RecyclerView</code>会将其返回到<code>LayoutManger</code>并将其添加到<code>preLayout</code>中以标记应从其进行动画处理的位置（详见<code>recordAnimationInfoIfBouncedHiddenView()</code>方法）。</p>
<p>在布局前后添加内容的不应该是<code>LayoutManager</code>的职责吗？怎么现在<code>RecyclerView</code>也往<code>preLayout</code>中添加view？这有必要了解。</p>
<h1 id="Stable-Id的作用？"><a href="#Stable-Id的作用？" class="headerlink" title="Stable Id的作用？"></a>Stable Id的作用？</h1><p>Stable Id只会在调用<code>notifyDataSetChanged()</code>方法之后，影响<code>RecyclerView</code>的行为。</p>
<p>如果调用<code>notifyDataSetChanged()</code>的时候，<code>Adapter</code>并没有设置<code>hasStableId</code>，<code>RecyclerView</code>不知道发生了什么，哪一些东西变化了，所以，它假设所有东西都变了，每一个<code>ViewHolder</code>都是无效的，因此应该把它们放到<code>RecyclerViewPool</code>而不是scrap中。</p>
<img src="/2020/05/15/Android-RecyclerView的缓存机制/微信图片_20200515194333.png">

<p>如果有Stable Id，就会如下：</p>
<img src="/2020/05/15/Android-RecyclerView的缓存机制/微信图片_20200515194749.png">

<p><code>ViewHolder</code>会进入scrap而不是pool中。然后会通过特定的Id（<code>Adapter</code>中的<code>getItemId()</code>获取到的<code>id</code>），而不是<code>position</code>到scrap中查找<code>ViewHodler</code>。</p>
<p>好处：</p>
<ul>
<li>1、不会导致<code>RecyclerViewPool</code>溢出，因此非必须情况下，不需要创建新的<code>ViewHoler</code>。之前的<code>ViewHolder</code>会重新绑定，因为Id没有变化不代表内容没有变化</li>
<li>2、最大的好处是支持动画。上面移动item4到item6的位置。通常，需要调用<code>notifyItemMoved(4, 6)</code>才能得到一个移动动画。但是通过stable id，调用<code>notifyDataSetChanged()</code>也可以实现。因为<code>RecyclerView</code>可以看到特定id的view在新旧布局的位置。<ul>
<li>注意，这里的动画只支持简单的动画，预测动画无法支持。如果在新布局中看到一些id，而旧布局中没有，那么如何知道它是新插入的item还是从某处移入的item，后一种情况item究竟是从哪来的？通常，这些问题的答案在预布局中可以找到，根据适配器的更改，该布局已经超出<code>RecyclerView</code>的范围，但现在这种情况下，不知道聚义更改了什么。</li>
</ul>
</li>
</ul>
<p>总之，stable id的使用场景比较有限，不过，还是有一个使用场景：如果是从<code>ListView</code>迁移到<code>RecyclerView</code>，将所有<code>notifyDataSetChanged()</code>调用，都转换为特定更改的通知可能会很麻烦，这时，stable id可以提供简单的<code>RecyclerView</code>动画。</p>
<h1 id="缓存优化实践"><a href="#缓存优化实践" class="headerlink" title="缓存优化实践"></a>缓存优化实践</h1><ul>
<li><p>尽量使用<code>notifyItemXxx</code>方法进行通知更新，而不是<code>notifyDataSetChanged()</code></p>
<ul>
<li>如果变更前后是两个数据集，无法确定具体哪一些数据项变化了，可以考虑使用<a href="https://developer.android.google.cn/reference/androidx/recyclerview/widget/DiffUtil" target="_blank" rel="noopener">DiffUtil</a></li>
<li>如果数据集较大，建议结合使用<a href="https://developer.android.google.cn/reference/androidx/recyclerview/widget/AsyncListDiffer" target="_blank" rel="noopener">AsyncListDiffer</a>在子线程做diff运算。</li>
</ul>
</li>
<li><p>如果特定viewType的item只有一个，可以通过<code>RecyclerView#getRecycledViewPool()#setMaxRecycledViews(viewType, 1);</code>来调整缓存区的大小，减少内存占用</p>
</li>
<li><p>如果特定viewType的item特别多，但是不得不通过<code>notifyDataSetChanged()</code>方法更新数据，可以通过下面这种方式，在变更前调大缓存，变更完成后，调小缓存。这样布局变化也可以最大程度地复用已有的<code>ViewHolder</code>。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mRecyclerView.getRecycledViewPool().setMaxRecycledViews(<span class="number">0</span>, 屏幕显示的item总数 + <span class="number">7</span>);</span><br><span class="line">mAdapter.notifyDataSetChanged();</span><br><span class="line"><span class="keyword">new</span> Handler().post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mRecyclerView.getRecycledViewPool().setMaxRecycledViews(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果<code>RecyclerView</code>中每个item都是一个<code>RecycleyView</code>，并且子<code>RecyclerView</code>的item type相同可以通过<code>RecyclerView#setRecycledViewPool()</code>方法，实现缓存池复用。</p>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://www.programmersought.com/article/4558924504/" target="_blank" rel="noopener">RecyclerView caching mechanism ( multiplexing?)</a></p>
<p><a href="https://juejin.im/post/5b79a0b851882542b13d204b" target="_blank" rel="noopener">RecyclerView缓存原理，有图有真相</a></p>
<p><a href="https://juejin.im/post/5c696ba9e51d457f136d24ff" target="_blank" rel="noopener">RecyclerView缓存机制（咋复用？）</a></p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RecyclerView/">RecyclerView</a></li></ul>


    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-Binder原理-04：ServiceManager的启动过程" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/12/09/Binder原理-04：ServiceManager的启动过程/"
    >Binder原理 04：ServiceManager的启动过程（基于Android 9.0/goldfish3.4）</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2019/12/09/Binder原理-04：ServiceManager的启动过程/" class="article-date">
  <time datetime="2019-12-09T01:38:18.000Z" itemprop="datePublished">2019-12-09</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android进阶/">Android进阶</a> / <a class="article-category-link" href="/categories/Android进阶/框架层/">框架层</a> / <a class="article-category-link" href="/categories/Android进阶/框架层/Binder原理/">Binder原理</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面以<code>MediaPlayerService</code>为例，讲解了系统服务是如何注册的（<code>addService()</code>），既然有注册，就会有获取，但是在获取服务之前，需要先了解<code>ServiceManager</code>的启动过程，有助于理解系统服务的注册和获取的过程。<br>另外，想要了解<code>ServiceManager</code>的启动过程，需要查看Kernel Binder部分的源码，这部分源码包含在内核源码中，AOSP不包含内核源码，需要单独下载。</p>
<h1 id="1-ServiceManager的入口函数"><a href="#1-ServiceManager的入口函数" class="headerlink" title="1. ServiceManager的入口函数"></a>1. ServiceManager的入口函数</h1><p><code>ServiceManager</code>是init进程负责启动的，具体在解析init.rc配置文件时启动的，init进程是在系统启动时启动的，因此<code>ServiceManager</code>也是。<br>rc文件内部由Android初始化语言（Android Init Language）编写的脚本，主要包含五种类型语句：Action、Commands、Servcies、Options和Import。<br>在Android 7.0中对init.rc文件进行了拆分，每个服务一个rc文件。<code>ServiceManager</code>的启动脚本在servicemanager.rc中：frameworks/native/cmds/servicemanager/servicemanager.rc</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">service servicemanager /system/bin/servicemanager</span><br><span class="line">    class core animation</span><br><span class="line">    user system  // 1</span><br><span class="line">    group system readproc</span><br><span class="line">    critical // 2</span><br><span class="line">    onrestart restart healthd  </span><br><span class="line">    onrestart restart zygote</span><br><span class="line">    onrestart restart audioserver</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart surfaceflinger</span><br><span class="line">    onrestart restart inputflinger</span><br><span class="line">    onrestart restart drm</span><br><span class="line">    onrestart restart cameraserver</span><br><span class="line">    onrestart restart keystore</span><br><span class="line">    onrestart restart gatekeeperd</span><br><span class="line">    writepid /dev/cpuset/system-background/tasks</span><br><span class="line">    shutdown critical</span><br></pre></td></tr></table></figure>

<p><code>service</code>用于通知init进程创建名为servicemanager的进程，这个servicemanager进程执行程序的路径为/system/bin/servicemanager。<br>注释1，关键字<code>user</code>说明servicemanager是以用户systemdd的身份运行的。<br>注释2，<code>critical</code>说明servicemanager是系统中的关键服务，关键服务是不会退出的，如果退出了，系统就会重启，当系统重启时，就会启动onrestart关键字修饰的进程，比如，zygote、media、surfaceflinger等。<br>servicemanager的入口函数在service_manager.c中：frameworks/native/cmds/servicemanager/service_manager.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_state</span> *<span class="title">bs</span>;</span> <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">union</span> selinux_callback cb;</span><br><span class="line">    <span class="keyword">char</span> *driver;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        driver = argv[<span class="number">1</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        driver = <span class="string">"/dev/binder"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bs = binder_open(driver, <span class="number">128</span>*<span class="number">1024</span>); <span class="comment">// 2</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (binder_become_context_manager(bs)) &#123; <span class="comment">// 3</span></span><br><span class="line">        ALOGE(<span class="string">"cannot become context manager (%s)\n"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (getcon(&amp;service_manager_context) != <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"SELinux: Failed to acquire service_manager context. Aborting.\n"</span>);</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    binder_loop(bs, svcmgr_handler); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释1，<code>binder_state</code>结构体用来存储<code>binder</code>的三个信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd; <span class="comment">// binder设备的文件描述符</span></span><br><span class="line">    <span class="keyword">void</span> *mapped; <span class="comment">// binder设备文件映射到进程的地址空间</span></span><br><span class="line">    <span class="keyword">size_t</span> mapsize; <span class="comment">// 内存映射后，系统分配的地址空间的大小，默认为128KB</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>main()</code>函数主要做了三件事：</p>
<ol>
<li>注释2调用<code>binder</code>设备文件，并申请了128KB字节大小的内存空间。</li>
<li>注释3调用<code>binder_become_context_manager()</code>函数，将servicemanager注册成Binder机制的上下文管理者。</li>
<li>注释4调用<code>binder_loop()</code>函数，循环等待和处理client端发来的请求。</li>
</ol>
<p>下面详细讲解。</p>
<h2 id="1-1-打开binder设备"><a href="#1-1-打开binder设备" class="headerlink" title="1.1 打开binder设备"></a>1.1 打开binder设备</h2><p><code>binder_open()</code>函数用于打开binder设备文件，并将它映射到进程的地址空间，如下。frameworks/native/cmds/servicemanager/binder.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct binder_state *<span class="title">binder_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* driver, <span class="keyword">size_t</span> mapsize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_state</span> *<span class="title">bs</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_version</span> <span class="title">vers</span>;</span></span><br><span class="line"></span><br><span class="line">    bs = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*bs));</span><br><span class="line">    <span class="keyword">if</span> (!bs) &#123;</span><br><span class="line">        errno = ENOMEM;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bs-&gt;fd = open(driver, O_RDWR | O_CLOEXEC); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> (bs-&gt;fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"binder: cannot open %s (%s)\n"</span>,</span><br><span class="line">                driver, strerror(errno));</span><br><span class="line">        <span class="keyword">goto</span> fail_open;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取Binder的version</span></span><br><span class="line">    <span class="keyword">if</span> ((ioctl(bs-&gt;fd, BINDER_VERSION, &amp;vers) == <span class="number">-1</span>) ||</span><br><span class="line">        (vers.protocol_version != BINDER_CURRENT_PROTOCOL_VERSION)) &#123; <span class="comment">// 2</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,</span><br><span class="line">                <span class="string">"binder: kernel driver version (%d) differs from user space version (%d)\n"</span>,</span><br><span class="line">                vers.protocol_version, BINDER_CURRENT_PROTOCOL_VERSION);</span><br><span class="line">        <span class="keyword">goto</span> fail_open;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bs-&gt;mapsize = mapsize;</span><br><span class="line">    bs-&gt;mapped = mmap(<span class="literal">NULL</span>, mapsize, PROT_READ, MAP_PRIVATE, bs-&gt;fd, <span class="number">0</span>); <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">if</span> (bs-&gt;mapped == MAP_FAILED) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"binder: cannot map device (%s)\n"</span>,</span><br><span class="line">                strerror(errno));</span><br><span class="line">        <span class="keyword">goto</span> fail_map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bs;</span><br><span class="line"></span><br><span class="line">fail_map:</span><br><span class="line">    close(bs-&gt;fd);</span><br><span class="line">fail_open:</span><br><span class="line">    <span class="built_in">free</span>(bs);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释1，打开binder设备文件，后面会进行分析。<br>注释2，<code>ioct()</code>函数用于获取Binder的版本，如果获取不到或者内核空间和用户空间的binder不是同一个版本，就会直接<code>goto</code>到<code>fail_open</code>标签，释放binder的内存空间。<br>注释3，调用<code>mmap()</code>函数进行内存映射，通俗来讲就是将binder设备文件映射到进程的地址空间，地址空间的大小为<code>mapsize</code>，即128K。映射完毕后会将地址空间的起始地址和大小保存在<code>binder_state</code>结构体中的<code>mmaped</code>和<code>mapsize</code>变量中。</p>
<p>这里说明一下<code>open()</code>函数，它会调用Kernel Binder部分的<code>binder_open()</code>函数，这部分的源码在内核源码中，这里展示的代码版本为goldfish 3.4。</p>
<h4 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h4><p>Intel的X86架构的CPU提供了0~3四个特权级别，数字越小，权限越高，Linux系统主要采用了0和3两个特权级别，分别对应内核态和用户态。用户态的特权级别低，因此进程在用户态下不经过系统调用是无法主动访问到内核空间中的数据的，这样用户无法随意进入所有进程共享的内核空间，起到保护作用。<br>当一个进程在执行用户自己的代码时处于用户态，比如<code>open()</code>函数，它运行在用户空间，当前的进程处于用户态。<br>当一个进程因为系统调用进入内核代码中执行时，就处于内核态，比如<code>open()</code>函数通过系统调用（<code>_open()</code>函数），查找到了<code>open()</code>函数在Kernel Binder对应的函数为<code>binder_open()</code>，这是<code>binder_open()</code>运行在内核空间，当前的进程由用户态切换到内核态。<br>kernel/goldfish/drivers/staging/android/binder.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_open</span><span class="params">(struct inode *nodp, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">// 代表Binder进程</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span>;</span> <span class="comment">// 1</span></span><br><span class="line">	binder_debug(BINDER_DEBUG_OPEN_CLOSE, <span class="string">"binder_open: %d:%d\n"</span>,</span><br><span class="line">		     current-&gt;group_leader-&gt;pid, current-&gt;pid);</span><br><span class="line">    <span class="comment">// 分配内存空间</span></span><br><span class="line">	proc = kzalloc(<span class="keyword">sizeof</span>(*proc), GFP_KERNEL); <span class="comment">// 2</span></span><br><span class="line">	<span class="keyword">if</span> (proc == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	get_task_struct(current);</span><br><span class="line">	proc-&gt;tsk = current;</span><br><span class="line">	INIT_LIST_HEAD(&amp;proc-&gt;todo);</span><br><span class="line">	init_waitqueue_head(&amp;proc-&gt;wait);</span><br><span class="line">	proc-&gt;default_priority = task_nice(current);</span><br><span class="line">    <span class="comment">// binder同步锁</span></span><br><span class="line">	binder_lock(__func__);</span><br><span class="line"></span><br><span class="line">	binder_stats_created(BINDER_STAT_PROC);</span><br><span class="line">	hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs);</span><br><span class="line">	proc-&gt;pid = current-&gt;group_leader-&gt;pid;</span><br><span class="line">	INIT_LIST_HEAD(&amp;proc-&gt;delivered_death);</span><br><span class="line">	filp-&gt;private_data = proc; <span class="comment">// 3</span></span><br><span class="line">    <span class="comment">// binder同步锁释放</span></span><br><span class="line">	binder_unlock(__func__);</span><br><span class="line">	......</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释1，<code>binder_proc</code>结构体代表binder进程，用于管理binder的各种信息。<br>注释2，用于为<code>binder_proc</code>分配内存空间。<br>注释3，将<code>binder_proc</code>赋值给<code>file</code>指针的<code>private_data</code>变量，下一小节会再次提到变量<code>private_data</code>。</p>
<h2 id="1-2-注册称为Binder机制的上下文管理者"><a href="#1-2-注册称为Binder机制的上下文管理者" class="headerlink" title="1.2 注册称为Binder机制的上下文管理者"></a>1.2 注册称为Binder机制的上下文管理者</h2><p><code>binder_become_context_manager()</code>函数用于将servicemanager注册成为Binder机制的上下文管理者，这个管理者在整个系统只有一个，代码如下。frameworks/native/cmds/servicemanager/binder.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_become_context_manager</span><span class="params">(struct binder_state *bs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ioctl(bs-&gt;fd, BINDER_SET_CONTEXT_MGR, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Binder/">Binder</a></li></ul>


    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-Binder原理-03：系统服务的注册过程" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/11/15/Binder原理-03：系统服务的注册过程/"
    >Binder原理 03：系统服务的注册过程（基于Android 9.0）</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2019/11/15/Binder原理-03：系统服务的注册过程/" class="article-date">
  <time datetime="2019-11-15T07:39:27.000Z" itemprop="datePublished">2019-11-15</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android进阶/">Android进阶</a> / <a class="article-category-link" href="/categories/Android进阶/框架层/">框架层</a> / <a class="article-category-link" href="/categories/Android进阶/框架层/Binder原理/">Binder原理</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面学习了<code>ServiceManager</code>中的<code>Binder</code>机制，但是并没有看到<code>MediaPlayerService</code>是如何注册的。下面通过了解<code>MediaPlayerService</code>的注册，看看系统服务的注册过程。</p>
<h1 id="1-从调用链角度说明MediaPlayerService是如何注册的"><a href="#1-从调用链角度说明MediaPlayerService是如何注册的" class="headerlink" title="1. 从调用链角度说明MediaPlayerService是如何注册的"></a>1. 从调用链角度说明MediaPlayerService是如何注册的</h1><p><code>MediaServer</code>的入口函数。frameworks/av/media/mediaserver/main_mediaserver.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc __unused, <span class="keyword">char</span> **argv __unused)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    signal(SIGPIPE, SIG_IGN);</span><br><span class="line">    <span class="comment">// 获取ProcessState实例</span></span><br><span class="line">    sp&lt;ProcessState&gt; proc(ProcessState::self());</span><br><span class="line">    sp&lt;IServiceManager&gt; sm(defaultServiceManager());</span><br><span class="line">    ALOGI(<span class="string">"ServiceManager: %p"</span>, sm.get());</span><br><span class="line">    InitializeIcuOrDie();</span><br><span class="line">    <span class="comment">// 注册MediaPlayerService</span></span><br><span class="line">    MediaPlayerService::instantiate(); <span class="comment">// 1</span></span><br><span class="line">    ResourceManagerService::instantiate();</span><br><span class="line">    registerExtensions();</span><br><span class="line">    <span class="comment">// 启动Binder线程池</span></span><br><span class="line">    ProcessState::self()-&gt;startThreadPool();</span><br><span class="line">    <span class="comment">// 当前线程加入到线程池</span></span><br><span class="line">    IPCThreadState::self()-&gt;joinThreadPool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在注释1处注册了<code>MediaPlayerService</code>。frameworks/av/media/libmediaplayerservice/MediaPlayerService.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MediaPlayerService::instantiate() &#123;</span><br><span class="line">    defaultServiceManager()-&gt;addService(</span><br><span class="line">            String16(<span class="string">"media.player"</span>), <span class="keyword">new</span> MediaPlayerService，());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>defaultServiceManager()</code>返回的是<code>BpServiceManager</code>。参数是字符串和<code>MediaPlayerService</code>，就像key/value的形式来完成注册，接着看<code>addService()</code>。frameworks/native/libs/binder/IServiceManager.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> status_t <span class="title">addService</span><span class="params">(<span class="keyword">const</span> String16&amp; name, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; service,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">bool</span> allowIsolated, <span class="keyword">int</span> dumpsysPriority)</span> </span>&#123;</span><br><span class="line">    Parcel data, reply; <span class="comment">// 数据包</span></span><br><span class="line">    data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor());</span><br><span class="line">    data.writeString16(name); <span class="comment">// name值为"media.player"</span></span><br><span class="line">    data.writeStrongBinder(service); <span class="comment">// service值为MediaPlayerService</span></span><br><span class="line">    data.writeInt32(allowIsolated ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    data.writeInt32(dumpsysPriority);</span><br><span class="line">    <span class="keyword">status_t</span> err = remote()-&gt;transact(ADD_SERVICE_TRANSACTION, data, &amp;reply); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> err == NO_ERROR ? reply.readExceptionCode() : err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>data</code>是一个数据包，后面会不断的将数据写入<code>data</code>中。<br>注释1，<code>remote()</code>指的是<code>mRemote</code>，也就是<code>BpBinder</code>。<br><code>addService()</code>函数的作用就是将请求数据打包成<code>data</code>，然后传给<code>BpBinder</code>的<code>transact()</code>函数。frameworks/native/libs/binder/BpBinder.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> BpBinder::transact(</span><br><span class="line">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mAlive) &#123;</span><br><span class="line">        <span class="keyword">status_t</span> status = IPCThreadState::self()-&gt;transact(</span><br><span class="line">            mHandle, code, data, reply, flags);</span><br><span class="line">        <span class="keyword">if</span> (status == DEAD_OBJECT) mAlive = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DEAD_OBJECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>BpBinder</code>将逻辑处理交给了<code>IPCThreadState</code>，先来看看<code>IPCThreadState::self()</code>。frameworks/native/libs/binder/IPCThreadState.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">IPCThreadState* IPCThreadState::self()</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">// 首次进来gHaveTLS的值为false</span></span><br><span class="line">    <span class="keyword">if</span> (gHaveTLS) &#123;</span><br><span class="line">restart:</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">pthread_key_t</span> k = gTLS; <span class="comment">// 1</span></span><br><span class="line">        IPCThreadState* st = (IPCThreadState*)pthread_getspecific(k); <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">if</span> (st) <span class="keyword">return</span> st;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IPCThreadState; <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    pthread_mutex_unlock(&amp;gTLSMutex);</span><br><span class="line">    <span class="keyword">goto</span> restart;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释1，TLS的全称为Thread local storge，线程本地存储空间，在每个线程中都有TLS，并且线程间不共享。<br>注释2，获取TLS中的内容并赋值给<code>IPCThreadState</code>指针。<br>注释3，新建一个<code>IPCThreadState</code>，这里可以得知<code>IPCThreadState::self()</code>实际上是为了创建<code>IPCThreadState</code>，它的构造函数如下。frameworks/native/libs/binder/IPCThreadState.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">IPCThreadState::IPCThreadState()</span><br><span class="line">    : mProcess(ProcessState::self()),</span><br><span class="line">      mStrictModePolicy(<span class="number">0</span>),</span><br><span class="line">      mLastTransactionBinderFlags(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    pthread_setspecific(gTLS, <span class="keyword">this</span>); <span class="comment">// 1</span></span><br><span class="line">    clearCaller();</span><br><span class="line">    mIn.setDataCapacity(<span class="number">256</span>);</span><br><span class="line">    mOut.setDataCapacity(<span class="number">256</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释1，<code>pthread_setspecific()</code>函数用于设置TLS，将<code>IPCThreadState::self()</code>获得的TLS和自身传进去。<code>IPCThreadState</code>还包含一个<code>mIn</code>和一个<code>mOut</code>，<code>mIn</code>用来接收来自<code>Binder</code>驱动的数据，<code>mOut</code>用来存储发往<code>Binder</code>驱动的数据，默认大小都是256字节。再来看看<code>IPCThreadState</code>的<code>transact()</code>函数。frameworks/native/libs/binder/IPCThreadState.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::transact(<span class="keyword">int32_t</span> handle,</span><br><span class="line">                                  <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data,</span><br><span class="line">                                  Parcel* reply, <span class="keyword">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    flags |= TF_ACCEPT_FDS;</span><br><span class="line">    ......</span><br><span class="line">    err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, <span class="literal">NULL</span>); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (reply) reply-&gt;setError(err);</span><br><span class="line">        <span class="keyword">return</span> (mLastError = err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">            err = waitForResponse(reply); <span class="comment">// 2</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Parcel fakeReply;</span><br><span class="line">            err = waitForResponse(&amp;fakeReply);</span><br><span class="line">        &#125;</span><br><span class="line">       ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 不需要等待reply的分支</span></span><br><span class="line">        err = waitForResponse(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>BpBinder</code>的<code>transact()</code>函数实际上就是调用<code>IPCThreadState</code>的<code>transact()</code>函数。<br>注释1，<code>writeTransactionData()</code>函数用于传输数据，其中第一个参数<code>BC_TRANSACTION</code>代表向Binder驱动发送命令协议，向Binder设备发送的命令协议都以<code>BC_</code>开头，而Binder驱动返回的命令都以<code>BR_</code>开头。<br>现在来分别分析注释1的<code>writeTransactionData()</code>和注释2的<code>waitForResponse()</code>函数。</p>
<h2 id="1-1-writeTransactionData"><a href="#1-1-writeTransactionData" class="headerlink" title="1.1 writeTransactionData()"></a>1.1 writeTransactionData()</h2><p>frameworks/native/libs/binder/IPCThreadState.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::writeTransactionData(<span class="keyword">int32_t</span> cmd, <span class="keyword">uint32_t</span> binderFlags,</span><br><span class="line">    <span class="keyword">int32_t</span> handle, <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, <span class="keyword">status_t</span>* statusBuffer)</span><br><span class="line">&#123;</span><br><span class="line">    binder_transaction_data tr; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    tr.target.ptr = <span class="number">0</span>; </span><br><span class="line">    tr.target.handle = handle; <span class="comment">// 2</span></span><br><span class="line">    tr.code = code; <span class="comment">// code=ADD_SERVICE_TRANSACTION</span></span><br><span class="line">    tr.flags = binderFlags;</span><br><span class="line">    tr.cookie = <span class="number">0</span>;</span><br><span class="line">    tr.sender_pid = <span class="number">0</span>;</span><br><span class="line">    tr.sender_euid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">status_t</span> err = data.errorCheck(); <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        tr.data_size = data.ipcDataSize();</span><br><span class="line">        tr.data.ptr.buffer = data.ipcData();</span><br><span class="line">        tr.offsets_size = data.ipcObjectsCount()*<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>);</span><br><span class="line">        tr.data.ptr.offsets = data.ipcObjects();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (statusBuffer) &#123;</span><br><span class="line">        tr.flags |= TF_STATUS_CODE;</span><br><span class="line">        *statusBuffer = err;</span><br><span class="line">        tr.data_size = <span class="keyword">sizeof</span>(<span class="keyword">status_t</span>);</span><br><span class="line">        tr.data.ptr.buffer = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(statusBuffer);</span><br><span class="line">        tr.offsets_size = <span class="number">0</span>;</span><br><span class="line">        tr.data.ptr.offsets = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (mLastError = err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mOut.writeInt32(cmd); <span class="comment">// cmd=BC_TRANSACTION</span></span><br><span class="line">    mOut.write(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释1，<code>binder_transaction_data</code>结构体（tr结构体）是向Binder驱动通信的数据结构。<br>注释2，将<code>handle</code>传递给<code>target</code>的<code>handle</code>，用于标识目标，这里的<code>handle</code>的值为0，代表了<code>ServiceManager</code>。<br>注释3，对数据<code>data</code>进行错误检查，如果没有错误，就将数据赋值给对应的tr结构体。最后会将<code>BC_TRANSACTION</code>和tr结构体写入到<code>mOut</code>中。</p>
<img src="/2019/11/15/Binder原理-03：系统服务的注册过程/1575253205.jpg">

<h2 id="1-2-waitForResponse函数分析"><a href="#1-2-waitForResponse函数分析" class="headerlink" title="1.2 waitForResponse函数分析"></a>1.2 waitForResponse函数分析</h2><p><code>waitForResponse()</code>中有很多<code>case</code>语句，这里截取部分。frameworks/native/libs/binder/IPCThreadState.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::waitForResponse(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">    <span class="keyword">int32_t</span> err;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="keyword">break</span>; <span class="comment">// 1</span></span><br><span class="line">        err = mIn.errorCheck();</span><br><span class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (mIn.dataAvail() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        cmd = (<span class="keyword">uint32_t</span>)mIn.readInt32();</span><br><span class="line">        IF_LOG_COMMANDS() &#123;</span><br><span class="line">            alog &lt;&lt; <span class="string">"Processing waitForResponse Command: "</span></span><br><span class="line">                &lt;&lt; getReturnString(cmd) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION_COMPLETE:</span><br><span class="line">            <span class="keyword">if</span> (!reply &amp;&amp; !acquireResult) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BR_DEAD_REPLY:</span><br><span class="line">            err = DEAD_OBJECT;</span><br><span class="line">            <span class="keyword">goto</span> finish;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// 处理各种命令协议</span></span><br><span class="line">            err = executeCommand(cmd);</span><br><span class="line">            <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">finish:</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释1，<code>talkWithDriver()</code>内部通过<code>ioctl</code>与<code>Binder</code>驱动进行通信。frameworks/native/libs/binder/IPCThreadState.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::talkWithDriver(<span class="keyword">bool</span> doReceive)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mProcess-&gt;mDriverFD &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -EBADF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 和Binder驱动通信的结构体</span></span><br><span class="line">    binder_write_read bwr; <span class="comment">// 1</span></span><br><span class="line">    <span class="comment">// mIn是否有可读的数据，接收的数据存储在mIn</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> needRead = mIn.dataPosition() &gt;= mIn.dataSize();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> outAvail = (!doReceive || needRead) ? mOut.dataSize() : <span class="number">0</span>;</span><br><span class="line">    bwr.write_size = outAvail;</span><br><span class="line">    bwr.write_buffer = (<span class="keyword">uintptr_t</span>)mOut.data(); <span class="comment">// 2</span></span><br><span class="line">    <span class="comment">// 这时doReceive的值为true</span></span><br><span class="line">    <span class="keyword">if</span> (doReceive &amp;&amp; needRead) &#123;</span><br><span class="line">        bwr.read_size = mIn.dataCapacity();</span><br><span class="line">        bwr.read_buffer = (<span class="keyword">uintptr_t</span>)mIn.data(); <span class="comment">// 3</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bwr.read_size = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> ((bwr.write_size == <span class="number">0</span>) &amp;&amp; (bwr.read_size == <span class="number">0</span>)) <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        IF_LOG_COMMANDS() &#123;</span><br><span class="line">            alog &lt;&lt; <span class="string">"About to read/write, write size = "</span> &lt;&lt; mOut.dataSize() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> defined(__ANDROID__)</span></span><br><span class="line">        <span class="keyword">if</span> (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="number">0</span>) <span class="comment">// 4</span></span><br><span class="line">            err = NO_ERROR;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            err = -errno;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        err = INVALID_OPERATION;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">while</span> (err == -EINTR);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释1，<code>binder_write_read</code>是与<code>Binder</code>驱动通信的结构体，在注释2和3处将<code>mOut</code>、<code>mIn</code>赋值给<code>binder_write_read</code>的相应字段，最终通过注释4的<code>ioctl()</code>函数和<code>Binder</code>驱动进行通信，这部分涉及Kernel Binder的内容，在Kernel Binder中会记录服务名和handle，用于后续的服务查询。</p>
<h2 id="1-3-小结"><a href="#1-3-小结" class="headerlink" title="1.3 小结"></a>1.3 小结</h2><p>从调用链的角度来看，<code>MediaPlayerService</code>注册并不复杂，这里只是简单介绍了一个调用链的分支，可以简单总结为以下步骤：</p>
<ol>
<li><code>addService()</code>函数将数据打包发送给<code>BpBinder</code>来进行处理。</li>
<li><code>BpBinder</code>新建一个<code>IPCThreadState</code>对象，并将通信的任务交给<code>IPCThreadState</code>。</li>
<li><code>IPCThreadState</code>的<code>writeTransactionData()</code>函数用于将命令协议和数据写入到<code>mOut</code>中。</li>
<li><code>IPCThreadState</code>的<code>waitForResponse()</code>函数主要做两件事，一是通过<code>ioctl()</code>函数操作<code>mOut</code>和<code>mIn</code>来与Binder驱动进行数据交互，二是处理各种命令协议。</li>
</ol>
<h1 id="2-从进程角度说明MediaPlayerService是如何注册的"><a href="#2-从进程角度说明MediaPlayerService是如何注册的" class="headerlink" title="2. 从进程角度说明MediaPlayerService是如何注册的"></a>2. 从进程角度说明MediaPlayerService是如何注册的</h1><img src="/2019/11/15/Binder原理-03：系统服务的注册过程/1575446811.jpg">

<p>从图中可以看出是以C/S架构为基础的，<code>addService()</code>是在<code>MediaPlayerService</code>进行的，它是Client端，用于请求添加系统服务。而Server端则指的是<code>ServiceManager</code>，用于完成系统服务的添加。<br>Client端和Server端分别运行在两个进程中，通过Binder驱动来进行通信。两端通过向Binder驱动发送命令协议来完成系统服务的添加。其中命令协议非常多，过程比较复杂，这里对命令协议进行了简化，只涉及四个命令协议，其中<code>BC_TRANSACTION</code>和<code>BR_TRANSACTION</code>过程是一个完整的事务，<code>BC_REPLAY</code>和<code>BR_REPLAY</code>过程是一个完整的事务。<br>Client端和Server端向Binder驱动发送命令协议以BC开头，而Binder驱动向Client端和Server端返回的命令协议以BR开头。<br>步骤如下：</p>
<ol>
<li>Client端向Binder驱动发送<code>BC_TRANSACTION</code>命令。</li>
<li>Binder驱动接收请求后生成<code>BR_TRANSACTION</code>命令，唤醒Server端的线程后将<code>BR_TRANSACTION</code>命令发送给<code>ServiceManager</code>。</li>
<li>Server端中的服务注册完成后，生成<code>BC_REPLAY</code>命令发动给Binder驱动。</li>
<li>Binder驱动生成<code>BR_REPLAY</code>命令，唤醒Client端的线程后将<code>BR_REPLAY</code>命令发送给Client端。</li>
</ol>
<p>通过这些协议命令来完成系统服务的注册。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Binder/">Binder</a></li></ul>


    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-Binder原理-02：ServiceManager中的Binder机制" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/11/12/Binder原理-02：ServiceManager中的Binder机制/"
    >Binder原理 02：ServiceManager中的Binder机制（基于Android 9.0）</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2019/11/12/Binder原理-02：ServiceManager中的Binder机制/" class="article-date">
  <time datetime="2019-11-12T07:41:04.000Z" itemprop="datePublished">2019-11-12</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android进阶/">Android进阶</a> / <a class="article-category-link" href="/categories/Android进阶/框架层/">框架层</a> / <a class="article-category-link" href="/categories/Android进阶/框架层/Binder原理/">Binder原理</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面说到<code>Binder</code>机制分成三个部分：Java Binder、Native Binder、Kernel Binder，其中Java Binder和Native Binder都是应用开发需要掌握的的。Java Binder是需要借助Native Binder来工作的，因此需要先了解Native Binder，Native Binder架构的原型就是基于Binder通信的C/S架构。</p>
<h1 id="1-基于Binder通信的C-S架构"><a href="#1-基于Binder通信的C-S架构" class="headerlink" title="1. 基于Binder通信的C/S架构"></a>1. 基于Binder通信的C/S架构</h1><p>在Android系统中，<code>Binder</code>进程间的通信的使用很普遍，在MadiaPlayer框架中，就是基于C/S架构，并采用了<code>Binder</code>来进行进程间通信的。</p>
<img src="/2019/11/12/Binder原理-02：ServiceManager中的Binder机制/1573615014.jpg">

<p>从上图可以看出，除了常规C/S架构的Client端和Server端，还包括了<code>ServiceManager</code>，用于管理系统中的服务。<br>首先，Server进程会注册一些Service到<code>ServiceManager</code>中，Client要使用某个Service，则需要先到<code>ServiceManager</code>查询Service的相关信息，然后根据Service的相关信息与Service所在的Server进程建立通信通路，这样Client就可以使用Service了。</p>
<h1 id="2-MediaServer的main函数"><a href="#2-MediaServer的main函数" class="headerlink" title="2. MediaServer的main函数"></a>2. MediaServer的main函数</h1><p>Client、Server、ServiceManager三者的交互都是基于<code>Binder</code>通信的，可以说Native Binder的原理的核心就是<code>ServiceManager</code>的原理，为了更好了解<code>ServiceManager</code>，这里拿<code>MediaPlayer</code>框架为例。</p>
<img src="/2019/11/12/Binder原理-02：ServiceManager中的Binder机制/1573693782.jpg">

<p>可以看到，<code>MediaPlayer</code>和<code>MediaPlayerService</code>是通过<code>Binder</code>通信的，<code>MediaPlayer</code>是Client端，<code>MediaPlayerService</code>是Server端，<code>MediaPlayerService</code>是系统多媒体服务的一种，系统多媒体服务是由一个叫<code>MediaServer</code>的服务进程提供的，它是一个可执行程序，在Android系统启动时，<code>MediaServer</code>也被启动，它的函数入口如下。frameworks/av/media/mediaserver/main_mediaserver.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc __unused, <span class="keyword">char</span> **argv __unused)</span></span>&#123;</span><br><span class="line">    signal(SIGPIPE, SIG_IGN);</span><br><span class="line">    <span class="comment">// 获取ProcessState实例</span></span><br><span class="line">    sp&lt;ProcessState&gt; proc(ProcessState::self()); <span class="comment">// 1</span></span><br><span class="line">    sp&lt;IServiceManager&gt; sm(defaultServiceManager()); <span class="comment">// 2</span></span><br><span class="line">    ALOGI(<span class="string">"ServiceManager: %p"</span>, sm.get());</span><br><span class="line">    InitializeIcuOrDie();</span><br><span class="line">    <span class="comment">// 注册MediaPlayerService</span></span><br><span class="line">    MediaPlayerService::instantiate(); <span class="comment">// 3</span></span><br><span class="line">    ResourceManagerService::instantiate();</span><br><span class="line">    registerExtensions();</span><br><span class="line">    <span class="comment">// 启动Binder线程池</span></span><br><span class="line">    ProcessState::self()-&gt;startThreadPool();</span><br><span class="line">    <span class="comment">// 当前线程加入到线程池</span></span><br><span class="line">    IPCThreadState::self()-&gt;joinThreadPool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释1，用于获取<code>ProcessState</code>实例，在这一过程中会打开/dev/binder设备，并使用mmap为Binder驱动分配一个虚拟地址空间来接收数据。<br>注释2，获取一个<code>IServiceManager</code>，通过这个<code>IServiceManager</code>，其他进程就可以和当前的<code>ServiceManager</code>进行交互，这里就用到<code>Binder</code>通信。<br>注释3，注册<code>MediaPlayerService</code>。</p>
<h1 id="3-每个进程唯一的ProcessState"><a href="#3-每个进程唯一的ProcessState" class="headerlink" title="3. 每个进程唯一的ProcessState"></a>3. 每个进程唯一的ProcessState</h1><p><code>ProcessState</code>用于表示进程的状态，先从<code>ProcessState</code>的<code>self()</code>函数开始。frameworks/native/libs/binder/ProcessState.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;ProcessState&gt; ProcessState::self()&#123;</span><br><span class="line">    Mutex::Autolock _l(gProcessMutex);</span><br><span class="line">    <span class="keyword">if</span> (gProcess != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> gProcess;</span><br><span class="line">    &#125;</span><br><span class="line">    gProcess = <span class="keyword">new</span> ProcessState(<span class="string">"/dev/binder"</span>); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> gProcess;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>采用了单例模式，确保每个进程只有一个<code>ProcessState</code>。注释1，创建一个<code>ProcessState</code>实例，参数为<code>&quot;/dev/Binder&quot;</code>。接着查看<code>ProcessState</code>的构造函数。frameworks/native/libs/binder/ProcessState.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ProcessState::ProcessState(<span class="keyword">const</span> <span class="keyword">char</span> *driver)</span><br><span class="line">    : mDriverName(String8(driver))</span><br><span class="line">    , mDriverFD(open_driver(driver)) <span class="comment">// 1</span></span><br><span class="line">    , mVMStart(MAP_FAILED)</span><br><span class="line">    , mThreadCountLock(PTHREAD_MUTEX_INITIALIZER)</span><br><span class="line">    , mThreadCountDecrement(PTHREAD_COND_INITIALIZER)</span><br><span class="line">    , mExecutingThreadsCount(<span class="number">0</span>)</span><br><span class="line">    , mMaxThreads(DEFAULT_MAX_BINDER_THREADS)</span><br><span class="line">    , mStarvationStartTimeMs(<span class="number">0</span>)</span><br><span class="line">    , mManagesContexts(<span class="literal">false</span>)</span><br><span class="line">    , mBinderContextCheckFunc(<span class="literal">NULL</span>)</span><br><span class="line">    , mBinderContextUserData(<span class="literal">NULL</span>)</span><br><span class="line">    , mThreadPoolStarted(<span class="literal">false</span>)</span><br><span class="line">    , mThreadPoolSeq(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDriverFD &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        mVMStart = mmap(<span class="number">0</span>, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, <span class="number">0</span>); <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">if</span> (mVMStart == MAP_FAILED) &#123;</span><br><span class="line">            <span class="comment">// *sigh*</span></span><br><span class="line">            ALOGE(<span class="string">"Using %s failed: unable to mmap transaction memory.\n"</span>, mDriverName.c_str());</span><br><span class="line">            close(mDriverFD);</span><br><span class="line">            mDriverFD = <span class="number">-1</span>;</span><br><span class="line">            mDriverName.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(mDriverFD &lt; <span class="number">0</span>, <span class="string">"Binder driver could not be opened.  Terminating."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释1，打开/dev/Binder设备。<br>注释2，<code>mmap()</code>函数会在内核虚拟地址空间中申请一块与用户虚拟内存相同大小的内存，然后再申请物理内存，将同一块物理内存分别映射到内核虚拟地址空间和用户虚拟内存空间，实现内核虚拟地址空间和用户虚拟内存空间的数据同步操作，即内存映射。<br><code>mmap()</code>函数用于对Binder设备进行内存映射，除了它还有<code>open()</code>、<code>ioct()</code>函数，下面来看看它们实现了什么。<br><code>open_driver()</code>。frameworks/native/libs/binder/ProcessState.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">open_driver</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *driver)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(driver, O_RDWR | O_CLOEXEC); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">size_t</span> maxThreads = DEFAULT_MAX_BINDER_THREADS;</span><br><span class="line">        result = ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads); <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">"Binder ioctl to set max threads failed: %s"</span>, strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ALOGW(<span class="string">"Opening '%s' failed: %s\n"</span>, driver, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释1，打开/dev/Binder设备并返回文件操作符<code>fd</code>，这样就可以操作内核的Binder驱动了。<br>注释2，<code>ioct()</code>函数的作用就是和Binder设备进行参数的传递，这里的<code>ioct()</code>函数用于设定<code>binder</code>支持的最大线程数为15（<code>maxThreads</code>的值为15）。最终<code>open_driver()</code>函数返回文件操作符<code>fd</code>。</p>
<p><code>ProcessState</code>主要做了两件事：</p>
<ol>
<li>打开/dev/Binder设备并设定<code>Binder</code>最大的支持线程数。</li>
<li>通过<code>mmap()</code>为<code>binder</code>分配一块虚拟地址空间，达到内存映射的目的。</li>
</ol>
<h1 id="4-ServiceManager中的Binder机制"><a href="#4-ServiceManager中的Binder机制" class="headerlink" title="4. ServiceManager中的Binder机制"></a>4. ServiceManager中的Binder机制</h1><p>回到<code>MediaServer</code>的入口函数，在注释2调用了<code>defaultServiceManager()</code>函数。frameworks/native/libs/binder/IServiceManager.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IServiceManager&gt; defaultServiceManager()&#123;</span><br><span class="line">    <span class="keyword">if</span> (gDefaultServiceManager != <span class="literal">NULL</span>) <span class="keyword">return</span> gDefaultServiceManager;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        AutoMutex _l(gDefaultServiceManagerLock);</span><br><span class="line">        <span class="keyword">while</span> (gDefaultServiceManager == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;(</span><br><span class="line">                ProcessState::self()-&gt;getContextObject(<span class="literal">NULL</span>)); <span class="comment">// 1</span></span><br><span class="line">            <span class="keyword">if</span> (gDefaultServiceManager == <span class="literal">NULL</span>)</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> gDefaultServiceManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从<code>IServiceManager</code>所在文件路径就可以知道，<code>ServiceManager</code>中不仅仅使用了<code>Binder</code>通信，它自身也属于<code>Binder</code>体系。<code>defaultServiceManager()</code>中同样使用了单例。<br>注释1，<code>interface_cast()</code>函数生成了<code>gDefaultServiceManager</code>，其内部调用了<code>ProcessState</code>的<code>getContextObject()</code>函数。frameworks/native/libs/binder/ProcessState.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IBinder&gt; ProcessState::getContextObject(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; <span class="comment">/*caller*/</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> getStrongProxyForHandle(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(<span class="keyword">int32_t</span> handle)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;IBinder&gt; result;</span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line">    handle_entry* e = lookupHandleLocked(handle); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        IBinder* b = e-&gt;binder;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">NULL</span> || !e-&gt;refs-&gt;attemptIncWeak(<span class="keyword">this</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (handle == <span class="number">0</span>) &#123;</span><br><span class="line">                Parcel data;</span><br><span class="line">                <span class="keyword">status_t</span> status = IPCThreadState::self()-&gt;transact(</span><br><span class="line">                        <span class="number">0</span>, IBinder::PING_TRANSACTION, data, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (status == DEAD_OBJECT)</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            b = BpBinder::create(handle); <span class="comment">// 2</span></span><br><span class="line">            e-&gt;binder = b;</span><br><span class="line">            <span class="keyword">if</span> (b) e-&gt;refs = b-&gt;getWeakRefs();</span><br><span class="line">            result = b;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.force_set(b);</span><br><span class="line">            e-&gt;refs-&gt;decWeak(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getContextObject()</code>函数中直接调用了<code>getStrongProxyForHandle()</code>函数，传入的参数的值为0，即<code>handle</code>的值就是0，<code>handle</code>是一个资源标识。<br>注释1，查询这个资源标识对应的资源<code>handle_entry</code>是否存在，如果不存在就会在注释2处新建<code>BpBinder</code>，并在注释3赋值给<code>handle_entry</code>的<code>binder</code>。最终返回的<code>result</code>的值为<code>BpBinder</code>。</p>
<h2 id="4-1-BpBinder和BBinder"><a href="#4-1-BpBinder和BBinder" class="headerlink" title="4.1 BpBinder和BBinder"></a>4.1 BpBinder和BBinder</h2><p>它们都继承了<code>IBinder</code>。<br><code>BpBinder</code>是Client端与Server交互的代理类，<code>BBinder</code>代表了Server端。<code>BpBinder</code>和<code>BBinder</code>是一一对应的，<code>BpBinder</code>会通过<code>handle</code>来找到对应的<code>BpBinder</code>。<br>在<code>ServiceManager</code>中创建<code>BpBinder</code>，通过<code>handle</code>（值为0）可以找到对应的<code>BBinder</code>。</p>
<p>分析完<code>ProcessState</code>的<code>getContextObject()</code>函数，回到<code>interface_cast()</code>函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;(ProcessState::self()-&gt;getContextObject(<span class="literal">NULL</span>));</span><br></pre></td></tr></table></figure>

<p><code>interface_cast()</code>函数的具体实现如下。frameworks/native/libs/binder/include/binder/IInterface.h</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> INTERFACE&gt;</span><br><span class="line"><span class="keyword">inline</span> sp&lt;INTERFACE&gt; interface_cast(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> INTERFACE::asInterface(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当前场景中，<code>INTERFACE</code>的值为<code>IServiceManager</code>，那么替换后代码如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> sp&lt;IServiceManager&gt; interface_cast(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> IServiceManager::asInterface(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面来分析<code>IServiceManager</code>。</p>
<h2 id="4-2-IServiceManager"><a href="#4-2-IServiceManager" class="headerlink" title="4.2 IServiceManager"></a>4.2 IServiceManager</h2><p><code>BpBinder</code>和<code>BBinder</code>负责<code>Binder</code>通信，而<code>IServiceManager</code>用于处理<code>ServiceManager</code>的业务，<code>IServiceManager</code>是C++代码，因此它被定义在<code>IServiceManager.h</code>中。frameworks/native/libs/binder/include/binder/IServiceManager.h</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IServiceManager</span> :</span> <span class="keyword">public</span> IInterface</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DECLARE_META_INTERFACE(ServiceManager) <span class="comment">// 1</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 一些操作Service的函数</span></span><br><span class="line">    <span class="keyword">virtual</span> sp&lt;IBinder&gt;    getService( <span class="keyword">const</span> String16&amp; name) <span class="keyword">const</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> sp&lt;IBinder&gt;    checkService( <span class="keyword">const</span> String16&amp; name) <span class="keyword">const</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">addService</span><span class="params">(<span class="keyword">const</span> String16&amp; name, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; service,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">bool</span> allowIsolated = <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> dumpsysFlags = DUMP_FLAG_PRIORITY_DEFAULT)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> Vector&lt;String16&gt; listServices(<span class="keyword">int</span> dumpsysFlags = DUMP_FLAG_PRIORITY_ALL) = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        GET_SERVICE_TRANSACTION = IBinder::FIRST_CALL_TRANSACTION,</span><br><span class="line">        CHECK_SERVICE_TRANSACTION,</span><br><span class="line">        ADD_SERVICE_TRANSACTION,</span><br><span class="line">        LIST_SERVICES_TRANSACTION,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>IServiceManager</code>继承了<code>IInterface</code>，其内部定义了一些常量和一些操作Service的函数，在注释1调用了<code>DECLARE_META_INTERFACE()</code>宏，它的定义在<code>IInterface.h</code>中。frameworks/native/libs/binder/include/binder/IInterface.h</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_META_INTERFACE(INTERFACE)                               \</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> ::android::String16 descriptor;                        \</span><br><span class="line">    <span class="keyword">static</span> ::android::sp&lt;I##INTERFACE&gt; asInterface(                     \</span><br><span class="line">            <span class="keyword">const</span> ::android::sp&lt;::android::IBinder&gt;&amp; obj);              \</span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">const</span> ::android::<span class="function">String16&amp; <span class="title">getInterfaceDescriptor</span><span class="params">()</span> <span class="keyword">const</span></span>;  \</span><br><span class="line">    I##INTERFACE();                                                     \</span><br><span class="line">    <span class="keyword">virtual</span> ~I##INTERFACE();     </span><br><span class="line">```    </span><br><span class="line">其中`INTERFACE`的值为`ServiceManager`，那么经过替换后的代码如下所示。</span><br><span class="line">```cpp               </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> ::android::String16 descriptor;</span><br><span class="line">    <span class="comment">// 定义asInterface函数</span></span><br><span class="line">    <span class="keyword">static</span> ::android::sp&lt;IServiceManager&gt; asInterface(                    </span><br><span class="line">            <span class="keyword">const</span> ::android::sp&lt;::android::IBinder&gt;&amp; obj);</span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">const</span> ::android::<span class="function">String16&amp; <span class="title">getInterfaceDescriptor</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">// 定义IServiceManager构造函数</span></span><br><span class="line">    IServiceManager();</span><br><span class="line">    <span class="comment">// 定义IServiceManager析构函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~IServiceManager();</span><br></pre></td></tr></table></figure>

<p>从<code>DECLARE_META_INTERFACE</code>宏的名称和上面的代码中，可以发现它主要声明了一些函数和一个变量。那么这些函数和变量的实现在哪呢？答案还是在IInterface.h中，叫做<code>IMPLEMENT_META_INTERFACE</code>宏，代码如下所示.frameworks/native/libs/binder/include/binder/IInterface.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPLEMENT_META_INTERFACE(INTERFACE, NAME)                   \</span></span><br><span class="line"><span class="keyword">const</span> ::android::String16 I##INTERFACE::descriptor(NAME);           \</span><br><span class="line"><span class="keyword">const</span> ::android::String16&amp;                                          \</span><br><span class="line">        I##INTERFACE::getInterfaceDescriptor() <span class="keyword">const</span> &#123;              \</span><br><span class="line">    <span class="keyword">return</span> I##INTERFACE::descriptor;                                \</span><br><span class="line">&#125;                                                                   \</span><br><span class="line">::android::sp&lt;I##INTERFACE&gt; I##INTERFACE::asInterface(              \</span><br><span class="line">        <span class="keyword">const</span> ::android::sp&lt;::android::IBinder&gt;&amp; obj)               \</span><br><span class="line">&#123;                                                                   \</span><br><span class="line">    ::android::sp&lt;I##INTERFACE&gt; intr;                               \</span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="literal">NULL</span>) &#123;                                              \</span><br><span class="line">        intr = <span class="keyword">static_cast</span>&lt;I##INTERFACE*&gt;(                          \</span><br><span class="line">            obj-&gt;queryLocalInterface(                               \</span><br><span class="line">                    I##INTERFACE::descriptor).get());               \</span><br><span class="line">        <span class="keyword">if</span> (intr == <span class="literal">NULL</span>) &#123;                                         \</span><br><span class="line">            intr = <span class="keyword">new</span> Bp##INTERFACE(obj);                          \</span><br><span class="line">        &#125;                                                           \</span><br><span class="line">    &#125;                                                               \</span><br><span class="line">    <span class="keyword">return</span> intr;                                                    \</span><br><span class="line">&#125;                                                                   \</span><br><span class="line">I##INTERFACE::I##INTERFACE() &#123; &#125;                                    \</span><br><span class="line">I##INTERFACE::~I##INTERFACE() &#123; &#125;                                   \</span><br></pre></td></tr></table></figure>

<p><code>DECLARE_META_INTERFACE()</code>和<code>IMPLEMENT_META_INTERFACE()</code>宏是配合使用的，很多系统服务都使用它们，<code>IServiceManager</code>使用<code>IMPLEMENT_META_INTERFACE()</code>宏只有一行代码，如下。frameworks/native/libs/binder/IServiceManager.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IMPLEMENT_META_INTERFACE(ServiceManager, <span class="string">"android.os.IServiceManager"</span>);</span><br></pre></td></tr></table></figure>

<p><code>IMPLEMENT_META_INTERFACE()</code>宏的<code>INTERFACE</code>值为<code>ServiceManager</code>，<code>NAME</code>值为<code>&quot;android.os.IServiceManager&quot;</code>，进行替换后，代码如下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ::android::String16 IServiceManager::descriptor(<span class="string">"android.os.IServiceManager"</span>);          </span><br><span class="line"><span class="keyword">const</span> ::android::String16&amp;                                          </span><br><span class="line">        IServiceManager::getInterfaceDescriptor() <span class="keyword">const</span> &#123;              </span><br><span class="line">    <span class="keyword">return</span> IServiceManager::descriptor;                                </span><br><span class="line">&#125; </span><br><span class="line"> <span class="comment">// 实现了asInterface函数</span></span><br><span class="line">::android::sp&lt;IServiceManager&gt; IServiceManager::asInterface(              </span><br><span class="line">        <span class="keyword">const</span> ::android::sp&lt;::android::IBinder&gt;&amp; obj)               </span><br><span class="line">&#123;                                                                   </span><br><span class="line">    ::android::sp&lt;IServiceManager&gt; intr;                               </span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="literal">NULL</span>) &#123;                                              </span><br><span class="line">        intr = <span class="keyword">static_cast</span>&lt;IServiceManager&gt;(                          </span><br><span class="line">            obj-&gt;queryLocalInterface(                               </span><br><span class="line">                    IServiceManager::descriptor).get());               </span><br><span class="line">        <span class="keyword">if</span> (intr == <span class="literal">NULL</span>) &#123;                                         </span><br><span class="line">            intr = <span class="keyword">new</span> BpServiceManager(obj); <span class="comment">// 1                        </span></span><br><span class="line">        &#125;                                                           </span><br><span class="line">    &#125;                                                               </span><br><span class="line">    <span class="keyword">return</span> intr;                                                    </span><br><span class="line">&#125;                                                                   </span><br><span class="line">IServiceManager::IServiceManager() &#123; &#125;                                    </span><br><span class="line">IServiceManager::~IServiceManager() &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>关键在于注释1，新建一个<code>BpServiceManager</code>，传入的参数<code>obj</code>的值为<code>BpBinder</code>。所以，<code>asInterface()</code>函数就是用<code>BpBinder</code>为参数创建<code>BpServiceManager</code>，从而推断出<code>interface_cast()</code>函数创建了<code>BpServiceManager</code>，再往上推断，<code>IServiceManager</code>的<code>defaultServiceManaher()</code>函数返回的就是<code>BpServiceManager</code>。<br><code>BpServiceManager</code>有什么作用？先来看看它的构造函数。frameworks/native/libs/binder/IServiceManager.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BpServiceManager</span> :</span> <span class="keyword">public</span> BpInterface&lt;IServiceManager&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">BpServiceManager</span><span class="params">(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; impl)</span></span></span><br><span class="line">        : BpInterface&lt;IServiceManager&gt;(impl)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>impl</code>的值就是<code>BpBinder</code>，<code>BpServiceManager</code>的构造函数调用了基类<code>BpInterface</code>的构造函数。frameworks/native/libs/binder/include/binder/IInterface.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> INTERFACE&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BpInterface</span> :</span> <span class="keyword">public</span> INTERFACE, <span class="keyword">public</span> BpRefBase</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>BpInterface</code>又继承了<code>BpRefBase</code>。<code>BpRefBase</code>的实现如下。frameworks/native/libs/binder/Binder.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BpRefBase::BpRefBase(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; o)</span><br><span class="line">    : mRemote(o.get()), mRefs(<span class="literal">NULL</span>), mState(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    extendObjectLifetime(OBJECT_LIFETIME_WEAK);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mRemote) &#123;</span><br><span class="line">        mRemote-&gt;incStrong(<span class="keyword">this</span>);           </span><br><span class="line">        mRefs = mRemote-&gt;createWeak(<span class="keyword">this</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>mRemote</code>是一个<code>IBinder*</code>指针，它的最终指向为<code>BpBinder</code>，即<code>BpServiceManager</code>的<code>mRemote</code>指向了<code>BpBinder</code>。那么<code>BpServiceManager</code>的作用就是实现了<code>IServiceManager</code>，并通过<code>BpBinder</code>实现通信。</p>
<h2 id="4-3-IServiceManager关系图"><a href="#4-3-IServiceManager关系图" class="headerlink" title="4.3 IServiceManager关系图"></a>4.3 IServiceManager关系图</h2><img src="/2019/11/12/Binder原理-02：ServiceManager中的Binder机制/1573802832.jpg">

<ol>
<li><code>BpBinder</code>和<code>BBinder</code>都和通信有关，它们都继承了<code>IBinder</code>。</li>
<li><code>BpServiceManager</code>派生自<code>IServiceManager</code>，它们都和业务有关。</li>
<li><code>BpRefBase</code>包含了<code>mRemote</code>，通过不断地派生，<code>BpServiceManager</code>也同样包含<code>mRemote</code>，它指向了<code>BpBidner</code>，通过<code>BpBinder</code>来实现通信。</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Binder/">Binder</a></li></ul>


    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-Binder原理-01：基础知识" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/11/05/Binder原理-01：基础知识/"
    >Binder原理 01：基础知识（基于Android 9.0）</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2019/11/05/Binder原理-01：基础知识/" class="article-date">
  <time datetime="2019-11-05T06:53:09.000Z" itemprop="datePublished">2019-11-05</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android进阶/">Android进阶</a> / <a class="article-category-link" href="/categories/Android进阶/框架层/">框架层</a> / <a class="article-category-link" href="/categories/Android进阶/框架层/Binder原理/">Binder原理</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="1-Linux和Android的IPC机制种类"><a href="#1-Linux和Android的IPC机制种类" class="headerlink" title="1. Linux和Android的IPC机制种类"></a>1. Linux和Android的IPC机制种类</h1><p>IPC全称Inter-Process Communication，进程间通信，指两个进程间进行数据交换的过程。Android和Linux各有各的IPC机制。</p>
<h2 id="1-1-Linux中IPC机制种类"><a href="#1-1-Linux中IPC机制种类" class="headerlink" title="1.1 Linux中IPC机制种类"></a>1.1 Linux中IPC机制种类</h2><ul>
<li>管道（pipe）</li>
<li>信号（sinal）</li>
<li>信号量（semophore）</li>
<li>消息队列（Message）</li>
<li>内存共享（Share  Memory）</li>
<li>套接字（Socket）</li>
<li>……等</li>
</ul>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>管道是Linux从Unix继承过来的，它是Unix早期的一个重要通信机制。管道的主要思想是，在内存中创建一个共享文件，从而使通信双方利用这个共享文件来传递信息。这个共享文件比较特殊，它不属于系统文件并且只存在于内存中。另外，管道采用的是半双工通信方式，数据只能在一个方向上流动。</p>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>信号是软件层次上对中断机制的一种模拟，是一种异步通信方式，进程不必通过任何操作来等待信号的到达。信号可以在用户空间进程和内核之间直接交互，内核可以利用信号来通知用户空间的进程发生了哪些系统事件。信号不适用于信息交换，比较适用于进程中断控制。</p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量是一个计数器，用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程访问该资源。主要作为进程间以及同一进程内不用线程之间的同步手段。</p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>消息队列是消息的链表，具有特定的格式，存放在内存中并由消息队列标识符标识，并且允许一个或多个进程向它写入和读取消息。信息会复制两次，因此对于频繁或信息量大的通信不宜使用消息队列。</p>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>多个进程可以直接读写的一块内存空间，是针对其他通信机制运行效率较低而设计的。为了在多个进程间交换信息，内核专门留了一块内存区域，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这块内存而不需要进行数据的拷贝，从而提高效率。</p>
<h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><p>更为基础的进程间通信机制，与其他的方式不同的是，套接字可用于不同机器之间的进程间通信。</p>
<h2 id="1-2-Android中的IPC机制"><a href="#1-2-Android中的IPC机制" class="headerlink" title="1.2 Android中的IPC机制"></a>1.2 Android中的IPC机制</h2><p>Android系统是基于Linux内核的，在Linux内核的基础上，拓展了一些IPC的机制。Android系统除了支持套接字，还支持序列化、Messenger、AIDL、Bundle、文件共享、ContentProvider、Binder等。</p>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>指的是<code>Serializable</code>/<code>Parcelable</code>，<code>Serializable</code>是Java提供的一个序列化接口，是一个空接口，为对象提供标准的序列化和反序列化操作。<code>Parcelable</code>接口是Android中的序列化方式，用起来比较麻烦，但效率更高。</p>
<h3 id="Messenger"><a href="#Messenger" class="headerlink" title="Messenger"></a>Messenger</h3><p>在Android应用开发中使用率不高，可以在不同进程中传递Message对象，在Message中加入想要传递的数据就可以在进程间进行数据传递了。Messenger是轻量级的IPC方案，并对AIDL进行了封装。</p>
<h3 id="AIDL"><a href="#AIDL" class="headerlink" title="AIDL"></a>AIDL</h3><p>全称Android interface definition Language，即Android接口定义语言。Messenger是以串行的方式来处理客户端发来的信息，如果有大量的消息发送到服务端，服务端仍然是一个一个的处理，再响应客户端，显然是不合适的。另外，Messenger用来进行进程间的数据传递，但是不能满足跨进程的方法调用，这时就需要使用AIDL。</p>
<h3 id="Bundle"><a href="#Bundle" class="headerlink" title="Bundle"></a>Bundle</h3><p>实现了<code>Parcelable</code>接口，可以方便的在不同的进程间传输。Activity、Service、Receiver都在<code>Intent</code>中通过<code>Bundle</code>来传递数据。</p>
<h3 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h3><p>两个进程通过读写一个文件来进行数据共享，共享的文件可以是文本、XML、Json。文件共享适用于对数据同步要求不高的进程间通信。</p>
<h3 id="ContentProvier"><a href="#ContentProvier" class="headerlink" title="ContentProvier"></a>ContentProvier</h3><p><code>ContentProvier</code>为存储和获取数据提供了统一的接口，它可以在不同的应用程序间共享数据，本身就适合进程间通信。<code>ContentProvier</code>底层实现也是<code>Binder</code>，但是使用要比AIDL容易。系统很多操作都采用了<code>ContentProvider</code>，如通讯录、音频等，这些操作本身就是跨进程进行通信。</p>
<h1 id="2-Linux和Binder的IPC通信原理"><a href="#2-Linux和Binder的IPC通信原理" class="headerlink" title="2. Linux和Binder的IPC通信原理"></a>2. Linux和Binder的IPC通信原理</h1><img src="/2019/11/05/Binder原理-01：基础知识/1573103888.jpg">

<p>先看看几个基本概念：</p>
<h3 id="内核空间（Kernel-space）和用户空间（User-space）"><a href="#内核空间（Kernel-space）和用户空间（User-space）" class="headerlink" title="内核空间（Kernel space）和用户空间（User space）"></a>内核空间（Kernel space）和用户空间（User space）</h3><p>为了确保用户进程不能直接操作内核，保证内核的安全，操作系统从逻辑上将虚拟空间划分为用户空间和内核空间。Linux操作系统将最高的1GB字节供内核使用，称为内核空间，较低的3GB字节供进程使用，称为用户空间。<br>内核空间是Linux内核运行的空间，用户空间是用户程序的运行空间。为了安全，它们是隔离的，即使用户的程序崩溃了，内核也不受影响。内核空间的数据是可以进程间共享的，而用户空间则不可以。</p>
<h3 id="进程隔离"><a href="#进程隔离" class="headerlink" title="进程隔离"></a>进程隔离</h3><p>一个进程不能直接操作或访问另一个进程。</p>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>用户空间需要访问内核空间，就需要借助系统调用来实现。系统调用是用户空间访问内核空间的唯一方式，保证了所有的资源访问都是在内核的控制下进行的，避免用户程序对系统资源的越权访问，提升系统安全性和稳定性。<br>进程A和进程B的用户空间可以通过如下系统函数与内核空间进行交互。</p>
<ul>
<li>copy_from_user：将用户空间数据拷贝到内核空间</li>
<li>copy_to_user：将内核空间的数据拷贝到用户空间</li>
</ul>
<h3 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h3><p>由于应用程序不能直接操作设备硬件地址，所以操作系统提供了一种机制：内存映射，把设备地址映射到进程虚拟内存区。</p>
<img src="/2019/11/05/Binder原理-01：基础知识/1573116084.jpg">

<p>由于新建虚拟内存区域，磁盘文件和虚拟内存区域就可以直接映射，少了一次拷贝。<br>内存映射全称Memory Map，在Linux中通过系统调用函数<code>mmap()</code>来实现内存映射。将用户空间的一块内存区域映射到内核空间。映射关系建立之后，用户对这块内存区域的修改可以直接反映到内核空间，反之也是。内u才能映射能减少数据拷贝的次数，实现用户空间和内核空间的高效互动。</p>
<h2 id="2-1-Linux的IPC通信原理"><a href="#2-1-Linux的IPC通信原理" class="headerlink" title="2.1 Linux的IPC通信原理"></a>2.1 Linux的IPC通信原理</h2><img src="/2019/11/05/Binder原理-01：基础知识/1573196083.jpg">

<p>内核程序在内核空间分配内存并开辟一块内核缓存区，发送进程通过<code>copy_from_user()</code>函数将数据拷贝到内核空间的缓存区中。同样的，接收进程在接收数据时在自己的用户空间开辟一块内存缓存区，然后内核程序调用<code>copy_to_user()</code>函数将数据从内核缓存区拷贝到接收进程。这样数据发送进程和数据接收进程完成一次数据传输，即一次进程间通信。<br>Linux的IPC通信原理有两个问题：</p>
<ol>
<li>一次数据传递需要经历：用户空间 -&gt; 内核缓存区 -&gt; 用户空间，需要2次数据拷贝，效率不高。</li>
<li>接收数据的缓存区由数据接收进程提供，但是接收进程并不知道需要多大的空间来存放将要传递过来的数据，因此只能开辟尽可能大的内存空间或者先调用API接收消息头来获取消息体的大小，这样就会浪费空间或时间。</li>
</ol>
<h2 id="2-2-Binder通信原理"><a href="#2-2-Binder通信原理" class="headerlink" title="2.2 Binder通信原理"></a>2.2 Binder通信原理</h2><p><code>Binder</code>是基于开源的OpenBinder实现的，OpenBinder最早并不是Google开发的，而是BeInc开发的，接着由Palm, Inc.负责开发。后来OpenBinder作者加入了Google，并负责Android平台的开发，也就将<code>Binder</code>带到了Android。<br><code>Binder</code>是基于内存映射来实现的，内存映射通常是用在物理介质的文件系统上的，<code>Binder</code>没有物理介质，它使用内存映射是为了跨进程传递数据。</p>
<img src="/2019/11/05/Binder原理-01：基础知识/1573204355.jpg">

<p><code>Binder</code>通信步骤：</p>
<ol>
<li><code>Binder</code>驱动在内核空间创建一个数据接收缓存区。</li>
<li>在内核空间开辟一块内存缓存区，建立内存缓存区和数据接收缓存区的映射关系，以及数据接收缓存区和接收进程用户空间地址的映射关系。</li>
<li>发送进程通过<code>copy_to_user()</code>函数将数据拷贝到内核中的内核缓存区，由于内核缓存区和接收的用户空间存在内存映射，因此就相当于把数据发送到了接收进程的用户空间，这样就完成了一次进程间通信。</li>
</ol>
<p>整个过程只使用一次拷贝，不会因为不知道数据的大小而浪费空间和时间，效率更高。</p>
<h1 id="3-为什么要使用Binder"><a href="#3-为什么要使用Binder" class="headerlink" title="3. 为什么要使用Binder"></a>3. 为什么要使用Binder</h1><p>Android是基于Linux内核的，Linux提供了很多IPC机制，而Android自己设计了<code>Binder</code>来进行通信，主要有以下几点原因。</p>
<h3 id="性能方面"><a href="#性能方面" class="headerlink" title="性能方面"></a>性能方面</h3><p>性能方面的主要影响因素是拷贝次数，管道、消息队列、Socket的拷贝次数都是两次，性能不是很好，共享内存不需要拷贝，性能最好，<code>Binder</code>的拷贝次数为一次，性能仅次于内存拷贝。</p>
<h3 id="稳定性方面"><a href="#稳定性方面" class="headerlink" title="稳定性方面"></a>稳定性方面</h3><p><code>Binder</code>是基于C/S架构的，这个架构通常采用两层结构，技术上已经很成熟。共享内存没有分层，难以控制，并发同步访问临界资源时，可能会产生死锁。从稳定性角度来看，<code>Binder</code>优于共享内存。</p>
<h3 id="安全方面"><a href="#安全方面" class="headerlink" title="安全方面"></a>安全方面</h3><p>Android是一个开源系统，并且拥有开放的平台，因此安全性对于Android平台很重要。<br>传统的IPC接收方法无法获得对方可靠的进程用户ID/进程ID（UID/PID），无法鉴别对方的身份。<br>Android为每个安装好的APP分配了自己的UID，通过进程的UID来鉴别进程身份。另外，Android系统中的Server端会判断UID/PID是否满足访问权限，而对外只暴露Client端，加强了系统的安全性。</p>
<h3 id="语言方面"><a href="#语言方面" class="headerlink" title="语言方面"></a>语言方面</h3><p>Linux是基于C语言的，C语言是面向过程的，Android应用层和Java Framework是基于Java语言的，是面向对象的。<code>Binder</code>本身符合面向对象的思想，因此作为Android的通信机制更加合适。</p>
<blockquote>
<p>从以上四个方面来看，Linux提供的大部分IPC机制无法和<code>Binder</code>相比较，而共享内存只在性能方面优于<code>Binder</code>，这就是为什么Android使用<code>Binder</code>进行进程间通信。当然系统中并不是所有的进程间通信都使用<code>Bidner</code>，也要结合不同场景，如Zygote进程与AMS通信使用的是Socket，Kill Process使用的是信号。</p>
</blockquote>
<h1 id="4-为什么要学习Binder？"><a href="#4-为什么要学习Binder？" class="headerlink" title="4. 为什么要学习Binder？"></a>4. 为什么要学习Binder？</h1><p><code>Binder</code>机制在Android中很重要，许多需要掌握的原理都和<code>Binder</code>有关：</p>
<ul>
<li>系统中各个进程是如何通信的？</li>
<li>Android系统启动过程</li>
<li>AMS、PMS的原理</li>
<li>四大组件的原理，比如Activity是如何启动的？</li>
<li>插件化原理</li>
<li>系统服务的Client端和Server端如何进行通信？（比如<code>MediaPlayer</code>和<code>MediaPlayerService</code>）</li>
<li>……</li>
</ul>
<p>上面只是列出一小部分，简单来说，比如在系统启动过程时，<code>SystemServer</code>进程启动过程后会创建<code>Binder</code>线程池，目的是通过<code>Binder</code>，使得在<code>SystemServer</code>进程中的服务可以和其他进程进行通信。再比如常说的AMS、PMS都是基于<code>Binder</code>来实现的，拿PMS来说，PMS运行在<code>SystemServer</code>进程，如果它想要和<code>DefaultContainerService</code>通信（是用于检查和复制可移动文件的系统服务），就需要通过<code>Binder</code>，因为<code>DefaultContainerService</code>运行在<code>com.android.defcontainer</code>进程。<br>还有一个比较常见的C/S架构间通信的问题，Client端的<code>MediaPlayer</code>和Server端的<code>MediaPlayerService</code>不是运行在一个进程中的，同样需要<code>Binder</code>来实现通信。<br>可以说<code>Binder</code>机制是掌握系统底层原理的基石。根据Android系统的分层，<code>Binder</code>机制主要分为以下几个部分。</p>
<img src="/2019/11/05/Binder原理-01：基础知识/1573543084.jpg">

<p>根据Android系统的分层，将<code>Binder</code>机制分为Java Binder、Native Binder和Kernel Binder，后面会主要讲解Java Binder和Native Binder。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Binder/">Binder</a></li></ul>


    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-Android解析WindowManagerService-03：Window的删除过程" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/11/04/Android解析WindowManagerService-03：Window的删除过程/"
    >Android解析WindowManagerService 03：Window的删除过程（基于Android 8.0）</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2019/11/04/Android解析WindowManagerService-03：Window的删除过程/" class="article-date">
  <time datetime="2019-11-04T02:14:59.000Z" itemprop="datePublished">2019-11-04</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android进阶/">Android进阶</a> / <a class="article-category-link" href="/categories/Android进阶/框架层/">框架层</a> / <a class="article-category-link" href="/categories/Android进阶/框架层/解析WindowManagerService/">解析WindowManagerService</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p>和<a href="https://tylerliu.top/2019/10/29/Android解析WindowManagerService-02%EF%BC%9AWMS的重要成员和Window的添加过程/">Android解析WindowManagerService 02：WMS的重要成员和Window的添加过程（基于Android 8.0）</a>中Window的创建和更新过程类似，要删除Window需要先调用<code>WindowManagerImpl</code>的<code>removeView()</code>方法，<code>removeView()</code>方法中调用<code>WindowManagerGlobal</code>的<code>removeView()</code>方法。frameworks/base/core/java/android/view/WindowManagerGlobal.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeView</span><span class="params">(View view, <span class="keyword">boolean</span> immediate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"view must not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = findViewLocked(view, <span class="keyword">true</span>); <span class="comment">// 1</span></span><br><span class="line">        View curView = mRoots.get(index).getView();</span><br><span class="line">        removeViewLocked(index, immediate); <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">if</span> (curView == view) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Calling with view "</span> + view</span><br><span class="line">                + <span class="string">" but the ViewAncestor is attached to "</span> + curView);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释1，找到要删除的View在<code>view</code>列表中的索引。注释2，调用<code>removeViewLocked()</code>将该索引传入。frameworks/base/core/java/android/view/WindowManagerGlobal.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeViewLocked</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">boolean</span> immediate)</span> </span>&#123;</span><br><span class="line">    ViewRootImpl root = mRoots.get(index); <span class="comment">// 1</span></span><br><span class="line">    View view = root.getView();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">        InputMethodManager imm = InputMethodManager.getInstance(); <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">if</span> (imm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            imm.windowDismissed(mViews.get(index).getWindowToken()); <span class="comment">// 3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> deferred = root.die(immediate); <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">        view.assignParent(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (deferred) &#123;</span><br><span class="line">            mDyingViews.add(view);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释1，根据传入的索引在<code>ViewRootImpl</code>列表中获得需要删除的Window的<code>ViewRootImpl</code>。<br>注释2，获取<code>InputMethodManager</code>实例，如果<code>InputMethodManager</code>实例不为空，则在注释3调用<code>InputMethodManager</code>的<code>windowDismissed()</code>来结束需要删除的Window的输入法相关的逻辑。<br>注释4，调用<code>ViewRootImpl</code>的<code>die()</code>方法。frameworks/base/core/java/android/view/ViewRootImpl.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">die</span><span class="params">(<span class="keyword">boolean</span> immediate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Make sure we do execute immediately if we are in the middle of a traversal or the damage</span></span><br><span class="line">    <span class="comment">// done by dispatchDetachedFromWindow will cause havoc on return.</span></span><br><span class="line">    <span class="comment">// die()方法需要立即被执行并且此时ViewRootImpl不在执行performTraversals()方法</span></span><br><span class="line">    <span class="keyword">if</span> (immediate &amp;&amp; !mIsInTraversal) &#123; <span class="number">1</span><span class="comment">// </span></span><br><span class="line">        doDie(); <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mIsDrawing) &#123;</span><br><span class="line">        destroyHardwareRenderer();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    mHandler.sendEmptyMessage(MSG_DIE);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释1的<code>immediate</code>如果为<code>true</code>（需要立即执行），并且<code>mIsTraversal</code>为<code>false</code>则执行注释2的代码，<code>mIsTraverrsal</code>在执行<code>ViewRootImpl</code>的<code>performTraversals()</code>方法时被设置为<code>true</code>，在<code>performTraversals()</code>方法执行结束时被设置为<code>false</code>，因此注释1可以理解为<code>die()</code>方法需要立即执行并且此时<code>ViewRootImpl</code>不在执行<code>performTraversals()</code>方法。<br>注释2，<code>doDie()</code>。frameworks/base/core/java/android/view/ViewRootImpl.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doDie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查执行方法线程的正确性</span></span><br><span class="line">    checkThread(); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> (LOCAL_LOGV) Log.v(mTag, <span class="string">"DIE in "</span> + <span class="keyword">this</span> + <span class="string">" of "</span> + mSurface);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mRemoved) &#123; <span class="comment">// 2</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mRemoved = <span class="keyword">true</span>; <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">if</span> (mAdded) &#123; <span class="comment">// 4</span></span><br><span class="line">            dispatchDetachedFromWindow(); <span class="comment">// 5</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mAdded &amp;&amp; !mFirst) &#123; <span class="comment">// 6</span></span><br><span class="line">            destroyHardwareRenderer();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mView != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> viewVisibility = mView.getVisibility();</span><br><span class="line">                <span class="keyword">boolean</span> viewVisibilityChanged = mViewVisibility != viewVisibility;</span><br><span class="line">                <span class="keyword">if</span> (mWindowAttributesChanged || viewVisibilityChanged) &#123;</span><br><span class="line">                    <span class="comment">// If layout params have been changed, first give them</span></span><br><span class="line">                    <span class="comment">// to the window manager to make sure it has the correct</span></span><br><span class="line">                    <span class="comment">// animation info.</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((relayoutWindow(mWindowAttributes, viewVisibility, <span class="keyword">false</span>)</span><br><span class="line">                                &amp; WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != <span class="number">0</span>) &#123;</span><br><span class="line">                            mWindowSession.finishDrawing(mWindow);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                mSurface.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mAdded = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    WindowManagerGlobal.getInstance().doRemoveView(<span class="keyword">this</span>); <span class="comment">// 7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释1，检查执行<code>duDie()</code>方法的线程的正确性，<code>checkThread()</code>内部会判断执行<code>duDie()</code>方法线程是否是创建需要删除的Window的原始线程，如果不是，就抛出异常，因为只有创建需要删除的Window的原始线程才能操作该Window。<br>注释2、3，用于防止<code>doDie()</code>方法被重复调用。<br>注释4，需要删除的Window有子<code>View</code>，就会调用<code>dispatchDetachedFromWindow()</code>方法来销毁<code>View</code>。<br>注释6，如果需要删除的Window有子<code>View</code>并且不是第一次被添加，就会执行后面的代码。<br>注释7，<code>WindowManagerGlobal</code>的<code>doRemoveView()</code>方法。frameworks/base/core/java/android/view/WindowManagerGlobal.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doRemoveView</span><span class="params">(ViewRootImpl root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> index = mRoots.indexOf(root); <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            mRoots.remove(index);</span><br><span class="line">            mParams.remove(index);</span><br><span class="line">            <span class="keyword">final</span> View view = mViews.remove(index);</span><br><span class="line">            mDyingViews.remove(view);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ThreadedRenderer.sTrimForeground &amp;&amp; ThreadedRenderer.isAvailable()) &#123;</span><br><span class="line">        doTrimForeground();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>WindowManagerGlobal</code>中维护了和<code>Window</code>操作相关的三个列表，<code>doRemoveView()</code>方法会从这三个列表中清除需要删除的Window对应的元素。<br>注释1，找到需要删除的Window对应的<code>ViewRootImpl</code>在<code>ViewRootImpl</code>列表中的索引，接着根据这个索引从<code>ViewRootImpl</code>列表、布局参数列表和<code>View</code>列表中删除与需要删除的Window对应的元素。<br>再回到<code>doDie()</code>方法，注释5，<code>dispatchDetachedFromWindow()</code>。<br>frameworks/base/core/java/android/view/ViewRootImpl.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchDetachedFromWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mWindowSession.remove(mWindow);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用了<code>IWindowSession</code>的<code>remove()</code>方法，<code>IWindowSession</code>在Server端的实现为<code>Session</code>，<code>Session</code>的<code>remove()</code>方法如下：<br>frameworks/base/services/core/java/com/android/server/wm/Session.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(IWindow window)</span> </span>&#123;</span><br><span class="line">    mService.removeWindow(<span class="keyword">this</span>, window);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来查看WMS的<code>removeWindow()</code>。frameworks/base/services/core/java/com/android/server/wm/WindowManagerService .java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeWindow</span><span class="params">(Session session, IWindow client)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(mWindowMap) &#123;</span><br><span class="line">        WindowState win = windowForClientLocked(session, client, <span class="keyword">false</span>); <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">if</span> (win == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        win.removeIfPossible(); <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释1，用于获取<code>Window</code>对应的<code>WindowState</code>，<code>WindowState</code>用于保存窗口的信息，在WMS中它用来描述一个窗口。<br>注释2，调用<code>WindowState</code>的<code>removeIfPossible()</code>方法。frameworks/base/services/core/java/com/android/server/wm/WindowState.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeIfPossible</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.removeIfPossible();</span><br><span class="line">    removeIfPossible(<span class="keyword">false</span> <span class="comment">/*keepVisibleDeadWindow*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeIfPossible</span><span class="params">(<span class="keyword">boolean</span> keepVisibleDeadWindow)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 条件判断过滤，满足其中一个条件就会return，推迟删除操作</span></span><br><span class="line">    ......</span><br><span class="line">    removeImmediately();</span><br><span class="line">    <span class="comment">// Removing a visible window will effect the computed orientation</span></span><br><span class="line">    <span class="comment">// So just update orientation if needed.</span></span><br><span class="line">    <span class="keyword">if</span> (wasVisible &amp;&amp; mService.updateOrientationFromAppTokensLocked(<span class="keyword">false</span>, displayId)) &#123;</span><br><span class="line">        mService.mH.obtainMessage(SEND_NEW_CONFIGURATION, displayId).sendToTarget();</span><br><span class="line">    &#125;</span><br><span class="line">    mService.updateFocusedWindowLocked(UPDATE_FOCUS_NORMAL, <span class="keyword">true</span> <span class="comment">/*updateInputWindows*/</span>);</span><br><span class="line">    Binder.restoreCallingIdentity(origId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>removeIfPossible()</code>不会立即执行删除操作，而是进行了多个条件过滤，只要其中一个条件，就会<code>return</code>，推迟删除操作。<br>条件判断都通过的话，就会调用<code>removeImmediately()</code>。frameworks/base/services/core/java/com/android/server/wm/WindowState.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeImmediately</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.removeImmediately();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mRemoved) &#123; <span class="comment">// 1</span></span><br><span class="line">        <span class="comment">// Nothing to do.</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mRemoved = <span class="keyword">true</span>; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    mPolicy.removeWindowLw(<span class="keyword">this</span>); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    disposeInputChannel();</span><br><span class="line"></span><br><span class="line">    mWinAnimator.destroyDeferredSurfaceLocked();</span><br><span class="line">    mWinAnimator.destroySurfaceLocked();</span><br><span class="line">    mSession.windowRemovedLocked(); <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mClient.asBinder().unlinkToDeath(mDeathRecipient, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mService.postWindowRemoveCleanupLocked(<span class="keyword">this</span>); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释1，<code>mRemoved</code>为<code>true</code>意味着正在执行删除Window操作，注释1到注释2之间的代码用于防止重复删除操作。<br>注释3，如果当前要删除的Window是<code>StatusBar</code>或者<code>NavigationBar</code>就会将这个Window从对应的控制器中删除。<br>注释4，将需要删除的Window对应的<code>Session</code>从WMS的<code>ArraySet&lt;Session&gt; mSession</code>中删除并清除<code>Session</code>对应的<code>SurfaceSession</code>资源（<code>SurfaceSession</code>是<code>SurfaceFlinger</code>的一个连接，通过这个连接可以创建一个或多个<code>Surface</code>并渲染到屏幕上）。<br>注释5，调用WMS的<code>postWindowRemoveCleanupLocked()</code>方法用于对需要删除的Window进行一些集中的清理工作。<br>删除的逻辑总结如下：</p>
<ol>
<li>检查删除线程的正确性，如果不正确则抛出异常；</li>
<li>从<code>ViewRootImpl</code>列表、布局参数列表和<code>View</code>列表中删除与需要删除的Window对应的元素；</li>
<li>判断是否可以直接执行删除操作，如果不能，就推迟删除操作；</li>
<li>执行删除操作，清理和释放与需要删除的Window相关的资源。</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/WindowManagerService/">WindowManagerService</a></li></ul>


    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-Android解析WindowManagerService-02：WMS的重要成员和Window的添加过程" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/10/29/Android解析WindowManagerService-02：WMS的重要成员和Window的添加过程/"
    >Android解析WindowManagerService 02：WMS的重要成员和Window的添加过程（基于Android 8.0）</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2019/10/29/Android解析WindowManagerService-02：WMS的重要成员和Window的添加过程/" class="article-date">
  <time datetime="2019-10-29T05:35:02.000Z" itemprop="datePublished">2019-10-29</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android进阶/">Android进阶</a> / <a class="article-category-link" href="/categories/Android进阶/框架层/">框架层</a> / <a class="article-category-link" href="/categories/Android进阶/框架层/解析WindowManagerService/">解析WindowManagerService</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>WMS在创建之后，它的重要成员有哪些？Window添加过程的WMS部分做了什么？</p>
<h1 id="1-WMS的重要成员"><a href="#1-WMS的重要成员" class="headerlink" title="1. WMS的重要成员"></a>1. WMS的重要成员</h1><p>即WMS的重要成员变量，如下：frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> WindowManagerPolicy mPolicy;</span><br><span class="line"><span class="keyword">final</span> IActivityManager mActivityManager;</span><br><span class="line"><span class="keyword">final</span> ActivityManagerInternal mAmInternal;</span><br><span class="line"><span class="keyword">final</span> AppOpsManager mAppOps;</span><br><span class="line"><span class="keyword">final</span> DisplaySettings mDisplaySettings;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">final</span> ArraySet&lt;Session&gt; mSessions = <span class="keyword">new</span> ArraySet&lt;&gt;();</span><br><span class="line"><span class="keyword">final</span> WindowHashMap mWindowMap = <span class="keyword">new</span> WindowHashMap();</span><br><span class="line"><span class="keyword">final</span> ArrayList&lt;AppWindowToken&gt; mFinishedStarting = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">final</span> ArrayList&lt;AppWindowToken&gt; mFinishedEarlyAnim = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">final</span> ArrayList&lt;AppWindowToken&gt; mWindowReplacementTimeouts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">final</span> ArrayList&lt;WindowState&gt; mResizingWindows = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">final</span> ArrayList&lt;WindowState&gt; mPendingRemove = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">WindowState[] mPendingRemoveTmp = <span class="keyword">new</span> WindowState[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">final</span> ArrayList&lt;WindowState&gt; mDestroySurface = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">final</span> ArrayList&lt;WindowState&gt; mDestroyPreservedSurface = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">......</span><br><span class="line"><span class="keyword">final</span> H mH = <span class="keyword">new</span> H();</span><br><span class="line">......</span><br><span class="line"><span class="keyword">final</span> WindowAnimator mAnimator;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">final</span> InputManagerService mInputManager</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>WindowManagerPolicy mPolicy</code>：<code>WindowManagerPolicy</code>是窗口管理策略的接口类，用来定义一个窗口策略所要遵循的通用规范，并提供了<code>WindowManager</code>所有的特定的UI行为。其具体实现类为<code>PhoneWindowManager</code>，这个实现类在WMS创建时被创建。WMP允许定制窗口层级和特殊窗口类型以及关键的调度和布局。</p>
</li>
<li><p><code>ArraySet mSessions</code>：在<a href="https://tylerliu.top/2019/10/24/Android解析WindowManager-03%EF%BC%9AWindow的添加过程/">Android解析WindowManager 03：Window的添加过程</a>这篇文章中提到过<code>Session</code>，它主要用于进程间通信，其他的应用程序进程想要和WMS进程进行通信就需要经过<code>Session</code>，并且每个应用程序进程都会对应一个<code>Session</code>，WMS保存这些<code>Session</code>用来记录所有向WMS提出窗口管理服务的客户端。</p>
</li>
<li><p><code>WindowHashMap mWindowMap</code>：<code>WindowHashMap</code>继承了<code>HashMap</code>，它限制了<code>HashMap</code>的<code>key</code>值的类型为<code>IBinder</code>，<code>value</code>值的类型为<code>WindowState</code>。<code>WindowState</code>用户保存窗口的信息，在WMS中，它用来描述一个窗口。综上，<code>mWindowMap</code>就是用来保存WMS中各种窗口的集合。</p>
</li>
<li><p><code>ArrayList mFinishedStarting</code>：<code>AppWindowToken</code>的集合，<code>AppWindowToken</code>是<code>WindowToken</code>的子类。要想理解<code>mFinishedStarting</code>的意义，需要先理解<code>WindowToken</code>。<code>WindowToken</code>主要有两个作用：</p>
<ul>
<li><p>可以理解为窗口令牌，当应用程序想要向WMS申请新创建一个窗口，则需要向WMS出示有效的的<code>WindowToken</code>。<code>AppWindowToken</code>作为<code>WindowToken</code>的子类，主要用来描述应用程序的<code>WindowToken</code>结构。<br>应用程序中每个Activity都对应一个<code>AppWindowToken</code>。</p>
</li>
<li><p><code>WindowToken</code>会将相同组件（比如Activity）的窗口（<code>WindowState</code>）集合在一起，方便管理。</p>
<p><code>mFinishedStarting</code>就是用于存储已经完成启动的应用程序窗口（比如Activity）的<code>AppWindowToken</code>的列表。<br>除了<code>mFinishedStarting</code>，还有类似的<code>mFinishedEarlyAnim</code>和<code>mWindowReplacementTimeouts</code>，其中<code>mFinishedEarlyAnim</code>用于存储已经完成绘制并且不需要任何已保存<code>surface</code>的应用程序窗口的<code>AppWindowToken</code>。<code>mWindowReplacementTimeouts</code>存储了等待更换的应用程序窗口的<code>AppWindowToken</code>，如果更换不及时，旧窗口就需要被处理。</p>
</li>
</ul>
</li>
<li><p><code>ArrayList mResizingWindows</code>：类型为<code>WindowState</code>。用来存储正在调整大小的窗口的列表。与<code>mResizingWindows</code>类似的还有<code>mPendingRemove</code>、<code>mDestoryPreservedSurface</code>等等。其中<code>mPendingRemove</code>是在内存耗尽时设置的，里面存着需要强制删除的窗口。<code>mDestorySurface</code>里面存有需要被<code>Destory</code>的<code>Surface</code>。<code>mDestoryPreservedSurface</code>里面存着窗口需要保存的等待销毁的<code>Surface</code>，因为当窗口经历<code>Surface</code>变化时，窗口需要一直保持旧<code>Surface</code>，直到新<code>Surface</code>的第一帧绘制完成。</p>
</li>
<li><p><code>WindowAnimator mAnimator</code>：用于管理窗口的动画以及特效动画。</p>
</li>
<li><p><code>H mH</code>：系统的<code>Handler</code>类，用于将任务加入到主线程的消息队列中，这样代码逻辑就会在主线程中执行。</p>
</li>
<li><p><code>InputManagerService mInputManager</code>：输入系统管理者。IMS会对触摸事件进行处理，它会寻找一个最合适的窗口来处理触摸反馈信息，WMS是窗口管理者，因此WMS就是输入系统的中转站，WMS包含IMS的引用。</p>
</li>
</ul>
<h1 id="2-Window的添加过程（WMS部分）"><a href="#2-Window的添加过程（WMS部分）" class="headerlink" title="2. Window的添加过程（WMS部分）"></a>2. Window的添加过程（WMS部分）</h1><p>Window的操作分为两大部分，WindowManager处理部分和WMS处理部分。</p>
<p>在<a href="https://tylerliu.top/2019/10/24/Android解析WindowManager-03%EF%BC%9AWindow的添加过程/">Android解析WindowManager 03：Window的添加过程</a>中，讲解了<code>Window</code>的添加过程的<code>WindowManager</code>处理部分，这里再来看看WMS部分。<br>无论是系统窗口还是Activity，它们的<code>Window</code>的添加过程都会调用WMS的<code>addWindow()</code>方法。frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java这段代码分成三个部分来看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addWindow</span><span class="params">(Session session, IWindow client, <span class="keyword">int</span> seq,</span></span></span><br><span class="line"><span class="function"><span class="params">        WindowManager.LayoutParams attrs, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> displayId,</span></span></span><br><span class="line"><span class="function"><span class="params">        Rect outContentInsets, Rect outStableInsets, Rect outOutsets,</span></span></span><br><span class="line"><span class="function"><span class="params">        InputChannel outInputChannel)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] appOp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> res = mPolicy.checkAddPermission(attrs, appOp); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> (res != WindowManagerGlobal.ADD_OKAY) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">synchronized</span>(mWindowMap) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mDisplayReady) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Display has not been initialialized"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> DisplayContent displayContent = mRoot.getDisplayContentOrCreate(displayId); <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">if</span> (displayContent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">return</span> WindowManagerGlobal.ADD_INVALID_DISPLAY;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (type &gt;= FIRST_SUB_WINDOW &amp;&amp; type &lt;= LAST_SUB_WINDOW) &#123; <span class="comment">// 3</span></span><br><span class="line">            parentWindow = windowForClientLocked(<span class="keyword">null</span>, attrs.token, <span class="keyword">false</span>); <span class="comment">// 4</span></span><br><span class="line">            <span class="keyword">if</span> (parentWindow == <span class="keyword">null</span>) &#123;</span><br><span class="line">               ......</span><br><span class="line">                <span class="keyword">return</span> WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (parentWindow.mAttrs.type &gt;= FIRST_SUB_WINDOW &amp;&amp; parentWindow.mAttrs.type &lt;= LAST_SUB_WINDOW) &#123;</span><br><span class="line">                ......</span><br><span class="line">                <span class="keyword">return</span> WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WMS的<code>addWindow()</code>方法返回的是各种状态值，比如，添加<code>Window</code>成功，无效的<code>display</code>等，这些状态被定义在<code>WindowManagerGlobal</code>中。<br>注释1，根据<code>Window</code>的属性，调用WMP的<code>checkAddPermission()</code>方法来检查权限，具体的实现在<code>PhoneWindowManager</code>的<code>checkAddPermission()</code>中，如果没有权限则不会执行后面的代码。<br>注释2，通过<code>display</code>来获得窗口要添加到哪个<code>DisplayContent</code>上，如果没没有找到<code>DisplayContent</code>，则返回<code>WindowManagerGlobal.ADD_INVALID_DISPLAY</code>状态，其中<code>DisplayContent</code>是用来描述一块屏幕的。<br>注释3，<code>type</code>表示窗口的类型，其数值介于<code>FIRST_SUB_WINDOW</code>和<code>LAST_SUB_WINDOW</code>（1000-1999），该数值定义在<code>WindowManager</code>中，说明这个窗口是一个子窗口。<br>注释4，<code>attrs.token</code>是<code>IBinder</code>类型的对象，<code>windowForClientLocked()</code>方法内部会根据<code>attrs.token</code>作为key值，从<code>mWindowMap</code>中得到该子窗口的父窗口。接着对父窗口进行判断，如果父窗口为空或者<code>type</code>的取值范围不正确，就返回错误的状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">AppWindowToken atoken = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> hasParent = parentWindow != <span class="keyword">null</span>;</span><br><span class="line">WindowToken token = displayContent.getWindowToken(hasParent ? parentWindow.mAttrs.token : attrs.token); <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> rootType = hasParent ? parentWindow.mAttrs.type : type; <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">boolean</span> addToastWindowRequiresToken = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (token == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (rootType &gt;= FIRST_APPLICATION_WINDOW &amp;&amp; rootType &lt;= LAST_APPLICATION_WINDOW) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> WindowManagerGlobal.ADD_BAD_APP_TOKEN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rootType == TYPE_INPUT_METHOD) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> WindowManagerGlobal.ADD_BAD_APP_TOKEN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rootType == TYPE_VOICE_INTERACTION) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> WindowManagerGlobal.ADD_BAD_APP_TOKEN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rootType == TYPE_WALLPAPER) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> WindowManagerGlobal.ADD_BAD_APP_TOKEN;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (type == TYPE_TOAST) &#123;</span><br><span class="line">        <span class="comment">// Apps targeting SDK above N MR1 cannot arbitrary add toast windows.</span></span><br><span class="line">        <span class="keyword">if</span> (doesAddToastWindowRequireToken(attrs.packageName, callingUid, parentWindow)) &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">return</span> WindowManagerGlobal.ADD_BAD_APP_TOKEN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> IBinder binder = attrs.token != <span class="keyword">null</span> ? attrs.token : client.asBinder();</span><br><span class="line">    token = <span class="keyword">new</span> WindowToken(<span class="keyword">this</span>, binder, type, <span class="keyword">false</span>, displayContent, session.mCanAddInternalSystemWindow); <span class="comment">// 3</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rootType &gt;= FIRST_APPLICATION_WINDOW &amp;&amp; rootType &lt;= LAST_APPLICATION_WINDOW) &#123; <span class="comment">// 4</span></span><br><span class="line">    atoken = token.asAppWindowToken(); <span class="comment">// 5</span></span><br><span class="line">    <span class="keyword">if</span> (atoken == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> WindowManagerGlobal.ADD_NOT_APP_TOKEN;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (atoken.removed) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> WindowManagerGlobal.ADD_APP_EXITING;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rootType == TYPE_INPUT_METHOD) &#123;</span><br><span class="line">    <span class="keyword">if</span> (token.windowType != TYPE_INPUT_METHOD) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> WindowManagerGlobal.ADD_BAD_APP_TOKEN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>注释1，通过<code>displayContent</code>的<code>getWindowToken()</code>得到<code>WindowToken</code>。<br>注释2，如果有父窗口就将父窗口的<code>type</code>值赋值给<code>rootType</code>，如果没有就将当前窗口的<code>type</code>值赋值给<code>rootType</code>。如果<code>WindowToken</code>为空，则根据<code>rootType</code>或者<code>type</code>的值进行区分判断，如果<code>rootType</code>值等于<code>TYPE_INPUT_METHOD</code>、<code>TYPE_WALLPAPER</code>等值时，则返回状态值<code>WindowManagerGlobal.ADD_BAD_APP_TOKEN</code>，说明<code>rootType</code>值等于<code>TYPE_INPUT_METHOD</code>、<code>TYPE_WALLPAPER</code>等值时不允许<code>WindowToken</code>为空。<br>注释3，隐式创建<code>WindowToken</code>，说明当添加窗口时可以不向WMS提供<code>WindowToken</code>，前提是<code>rootTtpe</code>或<code>type</code>的值不为前面条件筛选的值。<code>WindowToken</code>隐式和显示的创建需要加以区分，注释3的第4个参数为<code>false</code>就表示是隐式创建。<br>下面就是<code>WindowToken</code>不为空的情况，根据<code>rootType</code>和<code>type</code>的值进行判断，如在注释4，如果窗口为应用程序窗口，在注释5会将<code>WindowToken</code>转换为专门针对应用程序窗口的<code>AppWindowToken</code>，然后根据<code>AppWindowToken</code>的值进行后续的判断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="keyword">final</span> WindowState win = <span class="keyword">new</span> WindowState(<span class="keyword">this</span>, session, client, token, parentWindow, appOp[<span class="number">0</span>], seq, attrs, viewVisibility, session.mUid, session.mCanAddInternalSystemWindow); <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">if</span> (win.mDeathRecipient == <span class="keyword">null</span>) &#123; <span class="comment">// 2</span></span><br><span class="line">      ......</span><br><span class="line">      <span class="keyword">return</span> WindowManagerGlobal.ADD_APP_EXITING;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (win.getDisplayContent() == <span class="keyword">null</span>) &#123; <span class="comment">// 3</span></span><br><span class="line">      ......</span><br><span class="line">      <span class="keyword">return</span> WindowManagerGlobal.ADD_INVALID_DISPLAY;</span><br><span class="line">&#125;</span><br><span class="line">mPolicy.adjustWindowParamsLw(win.mAttrs); <span class="comment">// 4</span></span><br><span class="line">win.setShowToOwnerOnlyLocked(mPolicy.checkShowToOwnerOnly(attrs));</span><br><span class="line">res = mPolicy.prepareAddWindowLw(win, attrs); <span class="comment">// 5</span></span><br><span class="line">......</span><br><span class="line">win.attach();</span><br><span class="line">mWindowMap.put(client.asBinder(), win); <span class="comment">// 6</span></span><br><span class="line"><span class="keyword">if</span> (win.mAppOp != AppOpsManager.OP_NONE) &#123;</span><br><span class="line">    <span class="keyword">int</span> startOpResult = mAppOps.startOpNoThrow(win.mAppOp, win.getOwningUid(), win.getOwningPackage());</span><br><span class="line">    <span class="keyword">if</span> ((startOpResult != AppOpsManager.MODE_ALLOWED) &amp;&amp; (startOpResult != AppOpsManager.MODE_DEFAULT)) &#123;</span><br><span class="line">        win.setAppOpVisibilityLw(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> AppWindowToken aToken = token.asAppWindowToken();</span><br><span class="line"><span class="keyword">if</span> (type == TYPE_APPLICATION_STARTING &amp;&amp; aToken != <span class="keyword">null</span>) &#123;</span><br><span class="line">    aToken.startingWindow = win;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">boolean</span> imMayMove = <span class="keyword">true</span>;</span><br><span class="line">win.mToken.addWindow(win); <span class="comment">// 7</span></span><br><span class="line"><span class="keyword">if</span> (type == TYPE_INPUT_METHOD) &#123;</span><br><span class="line">    win.mGivenInsetsPending = <span class="keyword">true</span>;</span><br><span class="line">    setInputMethodWindowLocked(win);</span><br><span class="line">    imMayMove = <span class="keyword">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == TYPE_INPUT_METHOD_DIALOG) &#123;</span><br><span class="line">    displayContent.computeImeTarget(<span class="keyword">true</span> <span class="comment">/* updateImeTarget */</span>);</span><br><span class="line">    imMayMove = <span class="keyword">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (type == TYPE_WALLPAPER) &#123;</span><br><span class="line">        displayContent.mWallpaperController.clearLastWallpaperTimeoutTime();</span><br><span class="line">        displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((attrs.flags&amp;FLAG_SHOW_WALLPAPER) != <span class="number">0</span>) &#123;</span><br><span class="line">        displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (displayContent.mWallpaperController.isBelowWallpaperTarget(win)) &#123;</span><br><span class="line">        displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>注释1，创建<code>WindowState</code>，它存有窗口的所有的状态信息，在WMS中它代表一个窗口。从<code>WindowState</code>传入的参数，可以发现<code>WindowState</code>中包含了WMS、<code>Session</code>、<code>WindowToken</code>、父类的<code>WindowState</code>、<code>LayoutParams</code>等信息。<br>注释2、3，分别判断请求添加窗口的客户端是否已经死亡、窗口的<code>DisplayContent</code>是否为空，如果是，则不会再执行后面的代码。<br>注释4，调用WMP的<code>adjustWindowParamsLw()</code>方法，该方法的实现在<code>PhoneWindowManager</code>中，会根据窗口的<code>type</code>对窗口的<code>LayoutParams</code>的一些成员变量进行修改。<br>注释5，调用WMP的<code>prepareAddWindowLw()</code>方法，用于准备将窗口添加到系统中。<br>注释6，将<code>WindowState</code>添加到<code>mWindowMap</code>中。<br>注释7，将<code>WindowState</code>添加到该<code>WindowState</code>对应的<code>WindowToken</code>中（实际是保存在<code>WindowToken</code>的父类<code>WindowContainer</code>中），这样<code>WindowToken</code>就包含了相同组件的<code>WindowToken</code>。</p>
<p><strong><code>addWindow()</code>方法总结：</strong>主要做了下面4件事</p>
<ol>
<li>对所要添加的窗口进行检查，如果窗口不满足一些条件，就不会再执行后面的代码；</li>
<li><code>WindowToken</code>相关的处理，比如有的窗口类型需要提供<code>WindowToken</code>，没有提供的话就不会执行后面的代码，有的窗口类型则需要由WMS隐式创建<code>WindowToken</code>；</li>
<li><code>WindowState</code>的创建和相关处理，将<code>WindowToken</code>与<code>WindowState</code>相关联；</li>
<li>创建和配置<code>DisplayContent</code>，完成窗口添加到系统前的准备工作。</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/WindowManagerService/">WindowManagerService</a></li></ul>


    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2019-2020
        <i class="ri-heart-fill heart_icon"></i> Tyler Liu
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
        <span class="division">|</span>
        Theme - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Tyler的博客"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<!-- Subtitle -->

<script>
  try {
    var typed = new Typed("#subtitle", {
      strings: ['人生是一场难得的修行，不要轻易交白卷', '', ''],
      startDelay: 0,
      typeSpeed: 200,
      loop: true,
      backSpeed: 100,
      showCursor: true
    });
  } catch (err) {
    console.log(err)
  }
</script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>
<script src="/dist/main.js"></script>
<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom -->

<!-- CodeCopy -->

<link rel="stylesheet" href="/css/clipboard.css">
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>



    
  </div>
</body>

</html>